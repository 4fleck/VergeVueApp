function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
import{_ as Z0,a as Dv,b as Nv}from"./MarkdownRender-DHmb5Krb.js";import{_ as rf,o as $n,c as ui,b as Rs,p as Ov,a as Fv,d as $i,r as Uv,n as J0,e as zv,f as Vv}from"./index-DhVquT42.js";import{_ as ro}from"./_plugin-vue_export-helper-DlAUqK2U.js";const pr="4.6.0",rr={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Gv={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},$0=0,Nd=1,eg=2,kv=3,na=0,Io=1,Po=2,Vn=4,ar=5,sr=6,kn=0,nn=1,Tn=2,Od=3,En=0,lr=1,os=2,Fd=3,Ud=4,no=5,tn=100,Ch=101,Sh=102,zd=103,Vd=104,Ls=200,ei=201,Mh=202,Eh=203,xr=204,Ri=205,wh=206,Th=207,Ih=208,Rh=209,Lh=210,tg=0,ng=1,ig=2,Sc=3,og=4,rg=5,ag=6,sg=7,Ps=0,lg=1,cg=2,ci=0,Gc=1,ug=2,dg=3,hg=4,pg=5,kc=6,Qc=7,Ph=8,Bh=9,rs=0,Dh=1,Qv=300,_a=301,Aa=302,as=303,ss=304,xa=306,Qn=1e3,mt=1001,fr=1002,st=1003,ca=1004,Wv=1004,cr=1005,Hv=1005,Le=1006,Bs=1007,Xv=1007,In=1008,Yv=1008,Ft=1009,fg=1010,mg=1011,Nh=1012,gg=1013,Zi=1014,Ct=1015,_t=1016,vg=1017,_g=1018,ur=1020,Ag=1021,xg=1022,Qe=1023,yg=1024,bg=1025,Bo=1026,mr=1027,Ki=1028,Cg=1029,Sg=1030,Mg=1031,Eg=1033,ia=33776,pc=33777,fc=33778,oa=33779,ls=35840,Gd=35841,cs=35842,kd=35843,Wc=36196,us=37492,ds=37496,hs=37808,Qd=37809,Wd=37810,Hd=37811,Xd=37812,Yd=37813,jd=37814,Kd=37815,qd=37816,Zd=37817,Jd=37818,$d=37819,eh=37820,th=37821,ps=36492,jv=2200,Kv=2201,qv=2202,Zv=2300,Jv=2301,$v=2302,e_=2400,t_=2401,n_=2402,i_=2500,Oh=2501,wg=0,Fh=1,fs=2,_n=3e3,Ke=3001,o_=3200,Hc=3201,r_=3202,Uh=3301,Tg=3302,Uo=0,Ig=1,a_="",si="srgb",ms="srgb-linear",s_=0,l_=7680,c_=7681,u_=7682,d_=7683,h_=34055,p_=34056,f_=5386,m_=512,g_=513,v_=514,__=515,A_=516,x_=517,y_=518,b_=519,C_=35044,S_=35048,M_=35040,E_=35045,w_=35049,T_=35041,I_=35046,R_=35050,L_=35042,P_="100",nh="300 es",Mc=1035,Rg="ALL",Ec="__V3DL__0000000000",B_=0,D_=1,N_=2,O_=3,F_=4,U_=5,z_=0,V_=1,G_=2,k_=3,wc=0,Q_=1,W_=0,H_=1,X_=2,qr=0,Y_=1,j_=0,K_=1,q_=2;class An{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const n=this._listeners[e];if(n!==void 0){const i=n.indexOf(t);i!==-1&&n.splice(i,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const t=this._listeners[e.type];if(t!==void 0){e.target=this;const n=t.slice(0);for(let i=0,o=n.length;i<o;i++)n[i].call(this,e);e.target=null}}}const dn=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let af=1234567;const eo=Math.PI/180,ua=180/Math.PI;function wn(){const a=4294967295*Math.random()|0,e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(dn[255&a]+dn[a>>8&255]+dn[a>>16&255]+dn[a>>24&255]+"-"+dn[255&e]+dn[e>>8&255]+"-"+dn[e>>16&15|64]+dn[e>>24&255]+"-"+dn[63&t|128]+dn[t>>8&255]+"-"+dn[t>>16&255]+dn[t>>24&255]+dn[255&n]+dn[n>>8&255]+dn[n>>16&255]+dn[n>>24&255]).toLowerCase()}function Ye(a,e=0,t=1){return Math.max(e,Math.min(t,a))}function zh(a,e){return(a%e+e)%e}function Z_(a,e,t,n,i){return n+(a-e)*(i-n)/(t-e)}function J_(a,e,t){return a!==e?(t-a)/(e-a):0}function wi(a,e,t){return(1-t)*a+t*e}function $_(a,e,t,n){return wi(a,e,1-Math.exp(-t*n))}function eA(a,e=1){return e-Math.abs(zh(a,2*e)-e)}function tA(a,e,t){return a<=e?0:a>=t?1:(a=(a-e)/(t-e))*a*(3-2*a)}function ih(a,e,t){return a<=e?0:a>=t?1:(a=(a-e)/(t-e))*a*a*(a*(6*a-15)+10)}function nA(a,e){return a+Math.floor(Math.random()*(e-a+1))}function iA(a,e){return a+Math.random()*(e-a)}function oA(a){return a*(.5-Math.random())}function rA(a){a!==void 0&&(af=a);let e=af+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296}function Ds(a){return a*eo}function Xc(a){return a*ua}function oh(a){return(a&a-1)==0&&a!==0}function Lg(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))}function Tc(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}function aA(a,e,t,n,i){const o=Math.cos,r=Math.sin,s=o(t/2),l=r(t/2),c=o((e+n)/2),d=r((e+n)/2),u=o((e-n)/2),h=r((e-n)/2),p=o((n-e)/2),m=r((n-e)/2);switch(i){case"XYX":a.set(s*d,l*u,l*h,s*c);break;case"YZY":a.set(l*h,s*d,l*u,s*c);break;case"ZXZ":a.set(l*u,l*h,s*d,s*c);break;case"XZX":a.set(s*d,l*m,l*p,s*c);break;case"YXY":a.set(l*p,s*d,l*m,s*c);break;case"ZYZ":a.set(l*m,l*p,s*d,s*c);break;default:console.warn("v3d.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Ji(a,e){switch(e.constructor){case Float32Array:return a;case Uint16Array:return a/65535;case Uint8Array:return a/255;case Int16Array:return Math.max(a/32767,-1);case Int8Array:return Math.max(a/127,-1);default:throw new Error("Invalid component type.")}}function ut(a,e){switch(e.constructor){case Float32Array:return a;case Uint16Array:return Math.round(65535*a);case Uint8Array:return Math.round(255*a);case Int16Array:return Math.round(32767*a);case Int8Array:return Math.round(127*a);default:throw new Error("Invalid component type.")}}function da(a){let e=5381,t=a.length;for(;t;)e=33*e^a.charCodeAt(--t);return e>>>0}function Pg(a,e,t,n){let i=Math.exp(-t/n);return a*i+(1-i)*e}function Ht(a,e,t,n,i){let o=Pg(a,e,t,n);return Math.abs(a-e)<i&&(o=e),o}function gs(a){return Ye(a-2*Math.PI*Math.floor(a/(2*Math.PI)),0,2*Math.PI)}function mc(a){let e=a+Math.PI;return e%=2*Math.PI,e+=2*Math.PI,e%=2*Math.PI,e-=Math.PI,e}function Vh(a,e,t){let n=gs(a-e),i=gs(t-e);return n>i&&(n=n<i/2+Math.PI?i:0),n+e}var sA=Object.freeze({__proto__:null,DEG2RAD:eo,RAD2DEG:ua,angleToRange_0_2Pi:gs,angleToRange_mPi_Pi:mc,ceilPowerOfTwo:Lg,clamp:Ye,clampAngle:Vh,damp:$_,degToRad:Ds,denormalize:Ji,euclideanModulo:zh,expAverage:Pg,expAverageClamp:Ht,floorPowerOfTwo:Tc,generateUUID:wn,hashString:da,inverseLerp:J_,isPowerOfTwo:oh,lerp:wi,mapLinear:Z_,normalize:ut,pingpong:eA,radToDeg:Xc,randFloat:iA,randFloatSpread:oA,randInt:nA,seededRandom:rA,setQuaternionFromProperEuler:aA,smootherstep:ih,smoothstep:tA});class te{constructor(e=0,t=0){te.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),o=this.x-e.x,r=this.y-e.y;return this.x=o*n-r*i+e.x,this.y=o*i+r*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class ln{constructor(){ln.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(e,t,n,i,o,r,s,l,c){const d=this.elements;return d[0]=e,d[1]=i,d[2]=s,d[3]=t,d[4]=o,d[5]=l,d[6]=n,d[7]=r,d[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,o=this.elements,r=n[0],s=n[3],l=n[6],c=n[1],d=n[4],u=n[7],h=n[2],p=n[5],m=n[8],f=i[0],g=i[3],_=i[6],A=i[1],x=i[4],S=i[7],M=i[2],T=i[5],L=i[8];return o[0]=r*f+s*A+l*M,o[3]=r*g+s*x+l*T,o[6]=r*_+s*S+l*L,o[1]=c*f+d*A+u*M,o[4]=c*g+d*x+u*T,o[7]=c*_+d*S+u*L,o[2]=h*f+p*A+m*M,o[5]=h*g+p*x+m*T,o[8]=h*_+p*S+m*L,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],o=e[3],r=e[4],s=e[5],l=e[6],c=e[7],d=e[8];return t*r*d-t*s*c-n*o*d+n*s*l+i*o*c-i*r*l}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],o=e[3],r=e[4],s=e[5],l=e[6],c=e[7],d=e[8],u=d*r-s*c,h=s*l-d*o,p=c*o-r*l,m=t*u+n*h+i*p;if(m===0)return this.set(0,0,0,0,0,0,0,0,0);const f=1/m;return e[0]=u*f,e[1]=(i*c-d*n)*f,e[2]=(s*n-i*r)*f,e[3]=h*f,e[4]=(d*t-i*l)*f,e[5]=(i*o-s*t)*f,e[6]=p*f,e[7]=(n*l-c*t)*f,e[8]=(r*t-n*o)*f,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,o,r,s){const l=Math.cos(o),c=Math.sin(o);return this.set(n*l,n*c,-n*(l*r+c*s)+r+e,-i*c,i*l,-i*(-c*r+l*s)+s+t,0,0,1),this}scale(e,t){return this.premultiply(xu.makeScale(e,t)),this}rotate(e){return this.premultiply(xu.makeRotation(-e)),this}translate(e,t){return this.premultiply(xu.makeTranslation(e,t)),this}makeTranslation(e,t){return this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const xu=new ln;function lA(a){if(a.length===0)return 1/0;let e=a[0];for(let t=1,n=a.length;t<n;++t)a[t]<e&&(e=a[t]);return e}function Bg(a){if(a.length===0)return-1/0;let e=a[0];for(let t=1,n=a.length;t<n;++t)a[t]>e&&(e=a[t]);return e}function Dg(a){for(let e=a.length-1;e>=0;--e)if(a[e]>=65535)return!0;return!1}const cA={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Zr(a,e){return new cA[a](e)}function vs(a){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}function q(a){return a!==void 0}function Ng(a,e,t){for(let n=0;n<a.length;n++)a[n]=Ye(a[n],e,t);return a}function uA(){switch(Rg){case"BLENDER":return"for Blender";case"MAX":return"for 3ds Max";case"MAYA":return"for Maya";case"ALL":return"Ultimate";default:return"Unknown"}}function sf(a){const e=a.match(/^[a-zA-Z38 ]*(\d+).(\d+).(\d+)(?: (.*))?$/)??[];let t=Number(e[1]),n=Number(e[2]),i=Number(e[3]);return t=Number.isNaN(t)?0:t,n=Number.isNaN(n)?0:n,i=Number.isNaN(i)?0:i,{major:t,minor:n,patch:i,pre:e[4]??""}}function lf(a){if(a==="")return 1/0;const e=a.match(/^pre(\d+)$/)??[];let t=Number(e[1]);return t=Number.isNaN(t)?0:t,t}function Og(a,e,t=4){const n=sf(a),i=sf(e);let o=i.major-n.major;return o===0&&t>1&&(o=i.minor-n.minor,o===0&&t>2&&(o=i.patch-n.patch,o===0&&t>3&&(o=lf(i.pre)-lf(n.pre)))),Math.sign(o)}function Do(a){return`${a%1?a:`${a}.0`}`}function _s(){return typeof window<"u"?window:typeof self<"u"?self:global}const ko={};function Yc(a=""){const e=document.getElementsByTagName("script");let t=a;for(let n=e.length-1;n>=0;--n){const i=e[n].src,o=i.search(/\/v3d[\w.]+js/);o>-1&&(t=i.substr(0,o)+"/"+a)}return t}function Fg(a,e=function(n){},t=function(n){}){ko[a]=ko[a]||{status:0,loadCallbacks:[],errorCallbacks:[]};const n=ko[a];if(n.status==4)return void e(a);if(n.loadCallbacks.push(e),n.errorCallbacks.push(t),n.status>0)return;let i=Yc(a);const o=document.createElement("script");o.type="text/javascript",o.src=i,function(r){o.onload=function(){ko[r].loadCallbacks.forEach(function(s){s(r)}),ko[r].status=4},o.onerror=function(){ko[r].errorCallbacks.forEach(function(s){s(r)}),ko[r].status=0}}(a),document.getElementsByTagName("head")[0].appendChild(o),n.status=3}function dA(a,e,t=0){const n=function(o,r,s,l){const c=performance.now();return e(o,r,s),c-l>t?(l=c,new Promise(function(d){setTimeout(function(){d(l)},1)})):l};let i=Promise.resolve(performance.now());return a.forEach(function(o,r,s){i=i.then(n.bind(null,o,r,s))}),i}function dr(a){return a<.04045?.0773993808*a:Math.pow(.9478672986*a+.0521327014,2.4)}function gc(a){return a<.0031308?12.92*a:1.055*Math.pow(a,.41666)-.055}const yu={[si]:{[ms]:dr},[ms]:{[si]:gc}},rn={legacyMode:!0,get workingColorSpace(){return ms},set workingColorSpace(a){console.warn("v3d.ColorManagement: .workingColorSpace is readonly.")},convert:function(a,e,t){if(this.legacyMode||e===t||!e||!t)return a;if(yu[e]&&yu[e][t]!==void 0){const n=yu[e][t];return a.r=n(a.r),a.g=n(a.g),a.b=n(a.b),a}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(a,e){return this.convert(a,this.workingColorSpace,e)},toWorkingColorSpace:function(a,e){return this.convert(a,e,this.workingColorSpace)}},Ug={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Wt={r:0,g:0,b:0},oi={h:0,s:0,l:0},tl={h:0,s:0,l:0};function bu(a,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?a+6*(e-a)*t:t<.5?e:t<2/3?a+6*(e-a)*(2/3-t):a}function nl(a,e){return e.r=a.r,e.g=a.g,e.b=a.b,e}class me{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=si){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,rn.toWorkingColorSpace(this,t),this}setRGB(e,t,n,i=rn.workingColorSpace){return this.r=e,this.g=t,this.b=n,rn.toWorkingColorSpace(this,i),this}setHSL(e,t,n,i=rn.workingColorSpace){if(e=zh(e,1),t=Ye(t,0,1),n=Ye(n,0,1),t===0)this.r=this.g=this.b=n;else{const o=n<=.5?n*(1+t):n+t-n*t,r=2*n-o;this.r=bu(r,o,e+1/3),this.g=bu(r,o,e),this.b=bu(r,o,e-1/3)}return rn.toWorkingColorSpace(this,i),this}setStyle(e,t=si){function n(o){o!==void 0&&parseFloat(o)<1&&console.warn("v3d.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let o;const r=i[1],s=i[2];switch(r){case"rgb":case"rgba":if(o=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(255,parseInt(o[1],10))/255,this.g=Math.min(255,parseInt(o[2],10))/255,this.b=Math.min(255,parseInt(o[3],10))/255,rn.toWorkingColorSpace(this,t),n(o[4]),this;if(o=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(100,parseInt(o[1],10))/100,this.g=Math.min(100,parseInt(o[2],10))/100,this.b=Math.min(100,parseInt(o[3],10))/100,rn.toWorkingColorSpace(this,t),n(o[4]),this;break;case"hsl":case"hsla":if(o=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)){const l=parseFloat(o[1])/360,c=parseFloat(o[2])/100,d=parseFloat(o[3])/100;return n(o[4]),this.setHSL(l,c,d,t)}}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const o=i[1],r=o.length;if(r===3)return this.r=parseInt(o.charAt(0)+o.charAt(0),16)/255,this.g=parseInt(o.charAt(1)+o.charAt(1),16)/255,this.b=parseInt(o.charAt(2)+o.charAt(2),16)/255,rn.toWorkingColorSpace(this,t),this;if(r===6)return this.r=parseInt(o.charAt(0)+o.charAt(1),16)/255,this.g=parseInt(o.charAt(2)+o.charAt(3),16)/255,this.b=parseInt(o.charAt(4)+o.charAt(5),16)/255,rn.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=si){const n=Ug[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("v3d.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=dr(e.r),this.g=dr(e.g),this.b=dr(e.b),this}copyLinearToSRGB(e){return this.r=gc(e.r),this.g=gc(e.g),this.b=gc(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=si){return rn.fromWorkingColorSpace(nl(this,Wt),e),Ye(255*Wt.r,0,255)<<16^Ye(255*Wt.g,0,255)<<8^Ye(255*Wt.b,0,255)<<0}getHexString(e=si){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=rn.workingColorSpace){rn.fromWorkingColorSpace(nl(this,Wt),t);const n=Wt.r,i=Wt.g,o=Wt.b,r=Math.max(n,i,o),s=Math.min(n,i,o);let l,c;const d=(s+r)/2;if(s===r)l=0,c=0;else{const u=r-s;switch(c=d<=.5?u/(r+s):u/(2-r-s),r){case n:l=(i-o)/u+(i<o?6:0);break;case i:l=(o-n)/u+2;break;case o:l=(n-i)/u+4}l/=6}return e.h=l,e.s=c,e.l=d,e}getRGB(e,t=rn.workingColorSpace){return rn.fromWorkingColorSpace(nl(this,Wt),t),e.r=Wt.r,e.g=Wt.g,e.b=Wt.b,e}getStyle(e=si){return rn.fromWorkingColorSpace(nl(this,Wt),e),e!==si?`color(${e} ${Wt.r} ${Wt.g} ${Wt.b})`:`rgb(${255*Wt.r|0},${255*Wt.g|0},${255*Wt.b|0})`}offsetHSL(e,t,n){return this.getHSL(oi),oi.h+=e,oi.s+=t,oi.l+=n,this.setHSL(oi.h,oi.s,oi.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(oi),e.getHSL(tl);const n=wi(oi.h,tl.h,t),i=wi(oi.s,tl.s,t),o=wi(oi.l,tl.l,t);return this.setHSL(n,i,o),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let Sr;me.NAMES=Ug;class Gh{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Sr===void 0&&(Sr=vs("canvas")),Sr.width=e.width,Sr.height=e.height;const n=Sr.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=Sr}return t.width>2048||t.height>2048?(console.warn("v3d.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=vs("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),o=i.data;for(let r=0;r<o.length;r++)o[r]=255*dr(o[r]/255);return n.putImageData(i,0,0),t}if(e.data){const t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(255*dr(t[n]/255)):t[n]=dr(t[n]);return{data:t,width:e.width,height:e.height}}return console.warn("v3d.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let nr=class{constructor(a=null){this.isSource=!0,this.uuid=wn(),this.data=a,this.version=0}set needsUpdate(a){a===!0&&this.version++}toJSON(a){const e=a===void 0||typeof a=="string";if(!e&&a.images[this.uuid]!==void 0)return a.images[this.uuid];const t={uuid:this.uuid,url:""},n=this.data;if(n!==null){let i;if(Array.isArray(n)){i=[];for(let o=0,r=n.length;o<r;o++)n[o].isDataTexture?i.push(Cu(n[o].image)):i.push(Cu(n[o]))}else i=Cu(n);t.url=i}return e||(a.images[this.uuid]=t),t}};function Cu(a){return typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&a instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&a instanceof ImageBitmap?Gh.getDataURL(a):a.data?{data:Array.from(a.data),width:a.width,height:a.height,type:a.data.constructor.name}:(console.warn("v3d.Texture: Unable to serialize Texture."),{})}let hA=0;class yt extends An{constructor(e=yt.DEFAULT_IMAGE,t=yt.DEFAULT_MAPPING,n=mt,i=mt,o=Le,r=In,s=Qe,l=Ft,c=yt.DEFAULT_ANISOTROPY,d=_n){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:hA++}),this.uuid=wn(),this.name="",this.source=new nr(e),this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=i,this.magFilter=o,this.minFilter=r,this.anisotropy=c,this.format=s,this.internalFormat=null,this.type=l,this.offset=new te(0,0),this.repeat=new te(1,1),this.center=new te(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new ln,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=d,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==300)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Qn:e.x=e.x-Math.floor(e.x);break;case mt:e.x=e.x<0?0:1;break;case fr:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case Qn:e.y=e.y-Math.floor(e.y);break;case mt:e.y=e.y<0?0:1;break;case fr:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}}yt.DEFAULT_IMAGE=null,yt.DEFAULT_MAPPING=300,yt.DEFAULT_ANISOTROPY=1;class Re{constructor(e=0,t=0,n=0,i=1){Re.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,o=this.w,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*i+r[12]*o,this.y=r[1]*t+r[5]*n+r[9]*i+r[13]*o,this.z=r[2]*t+r[6]*n+r[10]*i+r[14]*o,this.w=r[3]*t+r[7]*n+r[11]*i+r[15]*o,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,o;const l=e.elements,c=l[0],d=l[4],u=l[8],h=l[1],p=l[5],m=l[9],f=l[2],g=l[6],_=l[10];if(Math.abs(d-h)<.01&&Math.abs(u-f)<.01&&Math.abs(m-g)<.01){if(Math.abs(d+h)<.1&&Math.abs(u+f)<.1&&Math.abs(m+g)<.1&&Math.abs(c+p+_-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const x=(c+1)/2,S=(p+1)/2,M=(_+1)/2,T=(d+h)/4,L=(u+f)/4,z=(m+g)/4;return x>S&&x>M?x<.01?(n=0,i=.707106781,o=.707106781):(n=Math.sqrt(x),i=T/n,o=L/n):S>M?S<.01?(n=.707106781,i=0,o=.707106781):(i=Math.sqrt(S),n=T/i,o=z/i):M<.01?(n=.707106781,i=.707106781,o=0):(o=Math.sqrt(M),n=L/o,i=z/o),this.set(n,i,o,t),this}let A=Math.sqrt((g-m)*(g-m)+(u-f)*(u-f)+(h-d)*(h-d));return Math.abs(A)<.001&&(A=1),this.x=(g-m)/A,this.y=(u-f)/A,this.z=(h-d)/A,this.w=Math.acos((c+p+_-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class et extends An{constructor(e=1,t=1,n={}){super(),this.isWebGLRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Re(0,0,e,t),this.scissorTest=!1,this.viewport=new Re(0,0,e,t);const i={width:e,height:t,depth:1};this.texture=new yt(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps!==void 0&&n.generateMipmaps,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Le,this.depthBuffer=n.depthBuffer===void 0||n.depthBuffer,this.stencilBuffer=n.stencilBuffer!==void 0&&n.stencilBuffer,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null,this.samples=n.samples!==void 0?n.samples:0}setSize(e,t,n=1){this.width===e&&this.height===t&&this.depth===n||(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new nr(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Ns extends yt{constructor(e=null,t=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=st,this.minFilter=st,this.wrapR=mt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class pA extends et{constructor(e=1,t=1,n=1){super(e,t),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new Ns(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class jc extends yt{constructor(e=null,t=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=st,this.minFilter=st,this.wrapR=mt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class fA extends et{constructor(e=1,t=1,n=1){super(e,t),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new jc(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class rh extends et{constructor(e=1,t=1,n=1,i={}){super(e,t,i),this.isWebGLMultipleRenderTargets=!0;const o=this.texture;this.texture=[];for(let r=0;r<n;r++)this.texture[r]=o.clone(),this.texture[r].isRenderTargetTexture=!0}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let i=0,o=this.texture.length;i<o;i++)this.texture[i].image.width=e,this.texture[i].image.height=t,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}class Ge{constructor(e=0,t=0,n=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=i}static slerpFlat(e,t,n,i,o,r,s){let l=n[i+0],c=n[i+1],d=n[i+2],u=n[i+3];const h=o[r+0],p=o[r+1],m=o[r+2],f=o[r+3];if(s===0)return e[t+0]=l,e[t+1]=c,e[t+2]=d,void(e[t+3]=u);if(s===1)return e[t+0]=h,e[t+1]=p,e[t+2]=m,void(e[t+3]=f);if(u!==f||l!==h||c!==p||d!==m){let g=1-s;const _=l*h+c*p+d*m+u*f,A=_>=0?1:-1,x=1-_*_;if(x>Number.EPSILON){const M=Math.sqrt(x),T=Math.atan2(M,_*A);g=Math.sin(g*T)/M,s=Math.sin(s*T)/M}const S=s*A;if(l=l*g+h*S,c=c*g+p*S,d=d*g+m*S,u=u*g+f*S,g===1-s){const M=1/Math.sqrt(l*l+c*c+d*d+u*u);l*=M,c*=M,d*=M,u*=M}}e[t]=l,e[t+1]=c,e[t+2]=d,e[t+3]=u}static multiplyQuaternionsFlat(e,t,n,i,o,r){const s=n[i],l=n[i+1],c=n[i+2],d=n[i+3],u=o[r],h=o[r+1],p=o[r+2],m=o[r+3];return e[t]=s*m+d*u+l*p-c*h,e[t+1]=l*m+d*h+c*u-s*p,e[t+2]=c*m+d*p+s*h-l*u,e[t+3]=d*m-s*u-l*h-c*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){const n=e._x,i=e._y,o=e._z,r=e._order,s=Math.cos,l=Math.sin,c=s(n/2),d=s(i/2),u=s(o/2),h=l(n/2),p=l(i/2),m=l(o/2);switch(r){case"XYZ":this._x=h*d*u+c*p*m,this._y=c*p*u-h*d*m,this._z=c*d*m+h*p*u,this._w=c*d*u-h*p*m;break;case"YXZ":this._x=h*d*u+c*p*m,this._y=c*p*u-h*d*m,this._z=c*d*m-h*p*u,this._w=c*d*u+h*p*m;break;case"ZXY":this._x=h*d*u-c*p*m,this._y=c*p*u+h*d*m,this._z=c*d*m+h*p*u,this._w=c*d*u-h*p*m;break;case"ZYX":this._x=h*d*u-c*p*m,this._y=c*p*u+h*d*m,this._z=c*d*m-h*p*u,this._w=c*d*u+h*p*m;break;case"YZX":this._x=h*d*u+c*p*m,this._y=c*p*u+h*d*m,this._z=c*d*m-h*p*u,this._w=c*d*u-h*p*m;break;case"XZY":this._x=h*d*u-c*p*m,this._y=c*p*u-h*d*m,this._z=c*d*m+h*p*u,this._w=c*d*u+h*p*m;break;default:console.warn("v3d.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],o=t[8],r=t[1],s=t[5],l=t[9],c=t[2],d=t[6],u=t[10],h=n+s+u;if(h>0){const p=.5/Math.sqrt(h+1);this._w=.25/p,this._x=(d-l)*p,this._y=(o-c)*p,this._z=(r-i)*p}else if(n>s&&n>u){const p=2*Math.sqrt(1+n-s-u);this._w=(d-l)/p,this._x=.25*p,this._y=(i+r)/p,this._z=(o+c)/p}else if(s>u){const p=2*Math.sqrt(1+s-n-u);this._w=(o-c)/p,this._x=(i+r)/p,this._y=.25*p,this._z=(l+d)/p}else{const p=2*Math.sqrt(1+u-n-s);this._w=(r-i)/p,this._x=(o+c)/p,this._y=(l+d)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ye(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,o=e._z,r=e._w,s=t._x,l=t._y,c=t._z,d=t._w;return this._x=n*d+r*s+i*c-o*l,this._y=i*d+r*l+o*s-n*c,this._z=o*d+r*c+n*l-i*s,this._w=r*d-n*s-i*l-o*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,o=this._z,r=this._w;let s=r*e._w+n*e._x+i*e._y+o*e._z;if(s<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,s=-s):this.copy(e),s>=1)return this._w=r,this._x=n,this._y=i,this._z=o,this;const l=1-s*s;if(l<=Number.EPSILON){const p=1-t;return this._w=p*r+t*this._w,this._x=p*n+t*this._x,this._y=p*i+t*this._y,this._z=p*o+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),d=Math.atan2(c,s),u=Math.sin((1-t)*d)/c,h=Math.sin(t*d)/c;return this._w=r*u+this._w*h,this._x=n*u+this._x*h,this._y=i*u+this._y*h,this._z=o*u+this._z*h,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),i=2*Math.PI*Math.random(),o=2*Math.PI*Math.random();return this.set(t*Math.cos(i),n*Math.sin(o),n*Math.cos(o),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class b{constructor(e=0,t=0,n=0){b.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(cf.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(cf.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,o=e.elements;return this.x=o[0]*t+o[3]*n+o[6]*i,this.y=o[1]*t+o[4]*n+o[7]*i,this.z=o[2]*t+o[5]*n+o[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,o=e.elements,r=1/(o[3]*t+o[7]*n+o[11]*i+o[15]);return this.x=(o[0]*t+o[4]*n+o[8]*i+o[12])*r,this.y=(o[1]*t+o[5]*n+o[9]*i+o[13])*r,this.z=(o[2]*t+o[6]*n+o[10]*i+o[14])*r,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,o=e.x,r=e.y,s=e.z,l=e.w,c=l*t+r*i-s*n,d=l*n+s*t-o*i,u=l*i+o*n-r*t,h=-o*t-r*n-s*i;return this.x=c*l+h*-o+d*-s-u*-r,this.y=d*l+h*-r+u*-o-c*-s,this.z=u*l+h*-s+c*-r-d*-o,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*i,this.y=o[1]*t+o[5]*n+o[9]*i,this.z=o[2]*t+o[6]*n+o[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,o=e.z,r=t.x,s=t.y,l=t.z;return this.x=i*l-o*s,this.y=o*r-n*l,this.z=n*s-i*r,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return Su.copy(this).projectOnVector(e),this.sub(Su)}reflect(e){return this.sub(Su.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Ye(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=2*(Math.random()-.5),t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Su=new b,cf=new Ge;class At{constructor(e=new b(1/0,1/0,1/0),t=new b(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,i=1/0,o=-1/0,r=-1/0,s=-1/0;for(let l=0,c=e.length;l<c;l+=3){const d=e[l],u=e[l+1],h=e[l+2];d<t&&(t=d),u<n&&(n=u),h<i&&(i=h),d>o&&(o=d),u>r&&(r=u),h>s&&(s=h)}return this.min.set(t,n,i),this.max.set(o,r,s),this}setFromBufferAttribute(e){let t=1/0,n=1/0,i=1/0,o=-1/0,r=-1/0,s=-1/0;for(let l=0,c=e.count;l<c;l++){const d=e.getX(l),u=e.getY(l),h=e.getZ(l);d<t&&(t=d),u<n&&(n=u),h<i&&(i=h),d>o&&(o=d),u>r&&(r=u),h>s&&(s=h)}return this.min.set(t,n,i),this.max.set(o,r,s),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Qo.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(n!==void 0)if(t&&n.attributes!=null&&n.attributes.position!==void 0){const o=n.attributes.position;for(let r=0,s=o.count;r<s;r++)Qo.fromBufferAttribute(o,r).applyMatrix4(e.matrixWorld),this.expandByPoint(Qo)}else n.boundingBox===null&&n.computeBoundingBox(),Mu.copy(n.boundingBox),Mu.applyMatrix4(e.matrixWorld),this.union(Mu);const i=e.children;for(let o=0,r=i.length;o<r;o++)this.expandByObject(i[o],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Qo),Qo.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Ui),ho.subVectors(this.max,Ui),Mr.subVectors(e.a,Ui),Er.subVectors(e.b,Ui),wr.subVectors(e.c,Ui),co.subVectors(Er,Mr),uo.subVectors(wr,Er),Wo.subVectors(Mr,wr);let t=[0,-co.z,co.y,0,-uo.z,uo.y,0,-Wo.z,Wo.y,co.z,0,-co.x,uo.z,0,-uo.x,Wo.z,0,-Wo.x,-co.y,co.x,0,-uo.y,uo.x,0,-Wo.y,Wo.x,0];return!!Eu(t,Mr,Er,wr,ho)&&(t=[1,0,0,0,1,0,0,0,1],!!Eu(t,Mr,Er,wr,ho)&&(il.crossVectors(co,uo),t=[il.x,il.y,il.z],Eu(t,Mr,Er,wr,ho)))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Qo.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=.5*this.getSize(Qo).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(Fi[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Fi[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Fi[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Fi[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Fi[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Fi[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Fi[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Fi[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Fi)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}scale(e){return this.getCenter(Ui),ho.subVectors(this.max,Ui),ho.multiply(e),this.min.copy(Ui).sub(ho),this.max.copy(Ui).add(ho),this}}const Fi=[new b,new b,new b,new b,new b,new b,new b,new b],Qo=new b,Mu=new At,Mr=new b,Er=new b,wr=new b,co=new b,uo=new b,Wo=new b,Ui=new b,ho=new b,il=new b,Ho=new b;function Eu(a,e,t,n,i){for(let o=0,r=a.length-3;o<=r;o+=3){Ho.fromArray(a,o);const s=i.x*Math.abs(Ho.x)+i.y*Math.abs(Ho.y)+i.z*Math.abs(Ho.z),l=e.dot(Ho),c=t.dot(Ho),d=n.dot(Ho);if(Math.max(-Math.max(l,c,d),Math.min(l,c,d))>s)return!1}return!0}const mA=new At,Ba=new b,wu=new b;class Rn{constructor(e=new b,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):mA.setFromPoints(e).getCenter(n);let i=0;for(let o=0,r=e.length;o<r;o++)i=Math.max(i,n.distanceToSquared(e[o]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;Ba.subVectors(e,this.center);const t=Ba.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=.5*(n-this.radius);this.center.addScaledVector(Ba,i/n),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(wu.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(Ba.copy(e.center).add(wu)),this.expandByPoint(Ba.copy(e.center).sub(wu))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const zi=new b,Tu=new b,ol=new b,po=new b,Iu=new b,rl=new b,Ru=new b;class ya{constructor(e=new b,t=new b(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,zi)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=zi.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(zi.copy(this.direction).multiplyScalar(t).add(this.origin),zi.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){Tu.copy(e).add(t).multiplyScalar(.5),ol.copy(t).sub(e).normalize(),po.copy(this.origin).sub(Tu);const o=.5*e.distanceTo(t),r=-this.direction.dot(ol),s=po.dot(this.direction),l=-po.dot(ol),c=po.lengthSq(),d=Math.abs(1-r*r);let u,h,p,m;if(d>0)if(u=r*l-s,h=r*s-l,m=o*d,u>=0)if(h>=-m)if(h<=m){const f=1/d;u*=f,h*=f,p=u*(u+r*h+2*s)+h*(r*u+h+2*l)+c}else h=o,u=Math.max(0,-(r*h+s)),p=-u*u+h*(h+2*l)+c;else h=-o,u=Math.max(0,-(r*h+s)),p=-u*u+h*(h+2*l)+c;else h<=-m?(u=Math.max(0,-(-r*o+s)),h=u>0?-o:Math.min(Math.max(-o,-l),o),p=-u*u+h*(h+2*l)+c):h<=m?(u=0,h=Math.min(Math.max(-o,-l),o),p=h*(h+2*l)+c):(u=Math.max(0,-(r*o+s)),h=u>0?o:Math.min(Math.max(-o,-l),o),p=-u*u+h*(h+2*l)+c);else h=r>0?-o:o,u=Math.max(0,-(r*h+s)),p=-u*u+h*(h+2*l)+c;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),i&&i.copy(ol).multiplyScalar(h).add(Tu),p}intersectSphere(e,t){zi.subVectors(e.center,this.origin);const n=zi.dot(this.direction),i=zi.dot(zi)-n*n,o=e.radius*e.radius;if(i>o)return null;const r=Math.sqrt(o-i),s=n-r,l=n+r;return s<0&&l<0?null:s<0?this.at(l,t):this.at(s,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0?!0:e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,o,r,s,l;const c=1/this.direction.x,d=1/this.direction.y,u=1/this.direction.z,h=this.origin;return c>=0?(n=(e.min.x-h.x)*c,i=(e.max.x-h.x)*c):(n=(e.max.x-h.x)*c,i=(e.min.x-h.x)*c),d>=0?(o=(e.min.y-h.y)*d,r=(e.max.y-h.y)*d):(o=(e.max.y-h.y)*d,r=(e.min.y-h.y)*d),n>r||o>i?null:((o>n||isNaN(n))&&(n=o),(r<i||isNaN(i))&&(i=r),u>=0?(s=(e.min.z-h.z)*u,l=(e.max.z-h.z)*u):(s=(e.max.z-h.z)*u,l=(e.min.z-h.z)*u),n>l||s>i?null:((s>n||n!=n)&&(n=s),(l<i||i!=i)&&(i=l),i<0?null:this.at(n>=0?n:i,t)))}intersectsBox(e){return this.intersectBox(e,zi)!==null}intersectTriangle(e,t,n,i,o){Iu.subVectors(t,e),rl.subVectors(n,e),Ru.crossVectors(Iu,rl);let r,s=this.direction.dot(Ru);if(s>0){if(i)return null;r=1}else{if(!(s<0))return null;r=-1,s=-s}po.subVectors(this.origin,e);const l=r*this.direction.dot(rl.crossVectors(po,rl));if(l<0)return null;const c=r*this.direction.dot(Iu.cross(po));if(c<0||l+c>s)return null;const d=-r*po.dot(Ru);return d<0?null:this.at(d/s,o)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Ae{constructor(){Ae.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(e,t,n,i,o,r,s,l,c,d,u,h,p,m,f,g){const _=this.elements;return _[0]=e,_[4]=t,_[8]=n,_[12]=i,_[1]=o,_[5]=r,_[9]=s,_[13]=l,_[2]=c,_[6]=d,_[10]=u,_[14]=h,_[3]=p,_[7]=m,_[11]=f,_[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Ae().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/Vi.setFromMatrixColumn(e,0).length(),o=1/Vi.setFromMatrixColumn(e,1).length(),r=1/Vi.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*o,t[5]=n[5]*o,t[6]=n[6]*o,t[7]=0,t[8]=n[8]*r,t[9]=n[9]*r,t[10]=n[10]*r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,n=e.x,i=e.y,o=e.z,r=Math.cos(n),s=Math.sin(n),l=Math.cos(i),c=Math.sin(i),d=Math.cos(o),u=Math.sin(o);if(e.order==="XYZ"){const h=r*d,p=r*u,m=s*d,f=s*u;t[0]=l*d,t[4]=-l*u,t[8]=c,t[1]=p+m*c,t[5]=h-f*c,t[9]=-s*l,t[2]=f-h*c,t[6]=m+p*c,t[10]=r*l}else if(e.order==="YXZ"){const h=l*d,p=l*u,m=c*d,f=c*u;t[0]=h+f*s,t[4]=m*s-p,t[8]=r*c,t[1]=r*u,t[5]=r*d,t[9]=-s,t[2]=p*s-m,t[6]=f+h*s,t[10]=r*l}else if(e.order==="ZXY"){const h=l*d,p=l*u,m=c*d,f=c*u;t[0]=h-f*s,t[4]=-r*u,t[8]=m+p*s,t[1]=p+m*s,t[5]=r*d,t[9]=f-h*s,t[2]=-r*c,t[6]=s,t[10]=r*l}else if(e.order==="ZYX"){const h=r*d,p=r*u,m=s*d,f=s*u;t[0]=l*d,t[4]=m*c-p,t[8]=h*c+f,t[1]=l*u,t[5]=f*c+h,t[9]=p*c-m,t[2]=-c,t[6]=s*l,t[10]=r*l}else if(e.order==="YZX"){const h=r*l,p=r*c,m=s*l,f=s*c;t[0]=l*d,t[4]=f-h*u,t[8]=m*u+p,t[1]=u,t[5]=r*d,t[9]=-s*d,t[2]=-c*d,t[6]=p*u+m,t[10]=h-f*u}else if(e.order==="XZY"){const h=r*l,p=r*c,m=s*l,f=s*c;t[0]=l*d,t[4]=-u,t[8]=c*d,t[1]=h*u+f,t[5]=r*d,t[9]=p*u-m,t[2]=m*u-p,t[6]=s*d,t[10]=f*u+h}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(gA,e,vA)}lookAt(e,t,n){const i=this.elements;return Dn.subVectors(e,t),Dn.lengthSq()===0&&(Dn.z=1),Dn.normalize(),fo.crossVectors(n,Dn),fo.lengthSq()===0&&(Math.abs(n.z)===1?Dn.x+=1e-4:Dn.z+=1e-4,Dn.normalize(),fo.crossVectors(n,Dn)),fo.normalize(),al.crossVectors(Dn,fo),i[0]=fo.x,i[4]=al.x,i[8]=Dn.x,i[1]=fo.y,i[5]=al.y,i[9]=Dn.y,i[2]=fo.z,i[6]=al.z,i[10]=Dn.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,o=this.elements,r=n[0],s=n[4],l=n[8],c=n[12],d=n[1],u=n[5],h=n[9],p=n[13],m=n[2],f=n[6],g=n[10],_=n[14],A=n[3],x=n[7],S=n[11],M=n[15],T=i[0],L=i[4],z=i[8],W=i[12],V=i[1],N=i[5],j=i[9],oe=i[13],H=i[2],ne=i[6],le=i[10],re=i[14],ae=i[3],E=i[7],F=i[11],U=i[15];return o[0]=r*T+s*V+l*H+c*ae,o[4]=r*L+s*N+l*ne+c*E,o[8]=r*z+s*j+l*le+c*F,o[12]=r*W+s*oe+l*re+c*U,o[1]=d*T+u*V+h*H+p*ae,o[5]=d*L+u*N+h*ne+p*E,o[9]=d*z+u*j+h*le+p*F,o[13]=d*W+u*oe+h*re+p*U,o[2]=m*T+f*V+g*H+_*ae,o[6]=m*L+f*N+g*ne+_*E,o[10]=m*z+f*j+g*le+_*F,o[14]=m*W+f*oe+g*re+_*U,o[3]=A*T+x*V+S*H+M*ae,o[7]=A*L+x*N+S*ne+M*E,o[11]=A*z+x*j+S*le+M*F,o[15]=A*W+x*oe+S*re+M*U,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],o=e[12],r=e[1],s=e[5],l=e[9],c=e[13],d=e[2],u=e[6],h=e[10],p=e[14];return e[3]*(+o*l*u-i*c*u-o*s*h+n*c*h+i*s*p-n*l*p)+e[7]*(+t*l*p-t*c*h+o*r*h-i*r*p+i*c*d-o*l*d)+e[11]*(+t*c*u-t*s*p-o*r*u+n*r*p+o*s*d-n*c*d)+e[15]*(-i*s*d-t*l*u+t*s*h+i*r*u-n*r*h+n*l*d)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],o=e[3],r=e[4],s=e[5],l=e[6],c=e[7],d=e[8],u=e[9],h=e[10],p=e[11],m=e[12],f=e[13],g=e[14],_=e[15],A=u*g*c-f*h*c+f*l*p-s*g*p-u*l*_+s*h*_,x=m*h*c-d*g*c-m*l*p+r*g*p+d*l*_-r*h*_,S=d*f*c-m*u*c+m*s*p-r*f*p-d*s*_+r*u*_,M=m*u*l-d*f*l-m*s*h+r*f*h+d*s*g-r*u*g,T=t*A+n*x+i*S+o*M;if(T===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const L=1/T;return e[0]=A*L,e[1]=(f*h*o-u*g*o-f*i*p+n*g*p+u*i*_-n*h*_)*L,e[2]=(s*g*o-f*l*o+f*i*c-n*g*c-s*i*_+n*l*_)*L,e[3]=(u*l*o-s*h*o-u*i*c+n*h*c+s*i*p-n*l*p)*L,e[4]=x*L,e[5]=(d*g*o-m*h*o+m*i*p-t*g*p-d*i*_+t*h*_)*L,e[6]=(m*l*o-r*g*o-m*i*c+t*g*c+r*i*_-t*l*_)*L,e[7]=(r*h*o-d*l*o+d*i*c-t*h*c-r*i*p+t*l*p)*L,e[8]=S*L,e[9]=(m*u*o-d*f*o-m*n*p+t*f*p+d*n*_-t*u*_)*L,e[10]=(r*f*o-m*s*o+m*n*c-t*f*c-r*n*_+t*s*_)*L,e[11]=(d*s*o-r*u*o-d*n*c+t*u*c+r*n*p-t*s*p)*L,e[12]=M*L,e[13]=(d*f*i-m*u*i+m*n*h-t*f*h-d*n*g+t*u*g)*L,e[14]=(m*s*i-r*f*i-m*n*l+t*f*l+r*n*g-t*s*g)*L,e[15]=(r*u*i-d*s*i+d*n*l-t*u*l-r*n*h+t*s*h)*L,this}scale(e){const t=this.elements,n=e.x,i=e.y,o=e.z;return t[0]*=n,t[4]*=i,t[8]*=o,t[1]*=n,t[5]*=i,t[9]*=o,t[2]*=n,t[6]*=i,t[10]*=o,t[3]*=n,t[7]*=i,t[11]*=o,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),o=1-n,r=e.x,s=e.y,l=e.z,c=o*r,d=o*s;return this.set(c*r+n,c*s-i*l,c*l+i*s,0,c*s+i*l,d*s+n,d*l-i*r,0,c*l-i*s,d*l+i*r,o*l*l+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,o,r){return this.set(1,n,o,0,e,1,r,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,o=t._x,r=t._y,s=t._z,l=t._w,c=o+o,d=r+r,u=s+s,h=o*c,p=o*d,m=o*u,f=r*d,g=r*u,_=s*u,A=l*c,x=l*d,S=l*u,M=n.x,T=n.y,L=n.z;return i[0]=(1-(f+_))*M,i[1]=(p+S)*M,i[2]=(m-x)*M,i[3]=0,i[4]=(p-S)*T,i[5]=(1-(h+_))*T,i[6]=(g+A)*T,i[7]=0,i[8]=(m+x)*L,i[9]=(g-A)*L,i[10]=(1-(h+f))*L,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let o=Vi.set(i[0],i[1],i[2]).length();const r=Vi.set(i[4],i[5],i[6]).length(),s=Vi.set(i[8],i[9],i[10]).length();this.determinant()<0&&(o=-o),e.x=i[12],e.y=i[13],e.z=i[14],It.copy(this);const l=1/o,c=1/r,d=1/s;return It.elements[0]*=l,It.elements[1]*=l,It.elements[2]*=l,It.elements[4]*=c,It.elements[5]*=c,It.elements[6]*=c,It.elements[8]*=d,It.elements[9]*=d,It.elements[10]*=d,t.setFromRotationMatrix(It),n.x=o,n.y=r,n.z=s,this}makePerspective(e,t,n,i,o,r){const s=this.elements,l=2*o/(t-e),c=2*o/(n-i),d=(t+e)/(t-e),u=(n+i)/(n-i),h=-(r+o)/(r-o),p=-2*r*o/(r-o);return s[0]=l,s[4]=0,s[8]=d,s[12]=0,s[1]=0,s[5]=c,s[9]=u,s[13]=0,s[2]=0,s[6]=0,s[10]=h,s[14]=p,s[3]=0,s[7]=0,s[11]=-1,s[15]=0,this}makeOrthographic(e,t,n,i,o,r){const s=this.elements,l=1/(t-e),c=1/(n-i),d=1/(r-o),u=(t+e)*l,h=(n+i)*c,p=(r+o)*d;return s[0]=2*l,s[4]=0,s[8]=0,s[12]=-u,s[1]=0,s[5]=2*c,s[9]=0,s[13]=-h,s[2]=0,s[6]=0,s[10]=-2*d,s[14]=-p,s[3]=0,s[7]=0,s[11]=0,s[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}composeE(e,t,n){const i=this.elements;this.makeRotationFromEuler(t);const o=n.x,r=n.y,s=n.z;return i[0]*=o,i[1]*=o,i[2]*=o,i[3]=0,i[4]*=r,i[5]*=r,i[6]*=r,i[7]=0,i[8]*=s,i[9]*=s,i[10]*=s,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decomposeE(e,t,n,i=t.order){const o=this.elements;let r=Vi.set(o[0],o[1],o[2]).length();const s=Vi.set(o[4],o[5],o[6]).length(),l=Vi.set(o[8],o[9],o[10]).length();this.determinant()<0&&(r=-r),e.x=o[12],e.y=o[13],e.z=o[14],It.copy(this);const c=1/r,d=1/s,u=1/l;return It.elements[0]*=c,It.elements[1]*=c,It.elements[2]*=c,It.elements[4]*=d,It.elements[5]*=d,It.elements[6]*=d,It.elements[8]*=u,It.elements[9]*=u,It.elements[10]*=u,t.setFromRotationMatrix(It,i),n.x=r,n.y=s,n.z=l,this}}const Vi=new b,It=new Ae,gA=new b(0,0,0),vA=new b(1,1,1),fo=new b,al=new b,Dn=new b,uf=new Ae,df=new Ge;class gr{constructor(e=0,t=0,n=0,i=gr.DefaultOrder){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,o=i[0],r=i[4],s=i[8],l=i[1],c=i[5],d=i[9],u=i[2],h=i[6],p=i[10];switch(t){case"XYZ":this._y=Math.asin(Ye(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-d,p),this._z=Math.atan2(-r,o)):(this._x=Math.atan2(h,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Ye(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(s,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-u,o),this._z=0);break;case"ZXY":this._x=Math.asin(Ye(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-u,p),this._z=Math.atan2(-r,c)):(this._y=0,this._z=Math.atan2(l,o));break;case"ZYX":this._y=Math.asin(-Ye(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(h,p),this._z=Math.atan2(l,o)):(this._x=0,this._z=Math.atan2(-r,c));break;case"YZX":this._z=Math.asin(Ye(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-d,c),this._y=Math.atan2(-u,o)):(this._x=0,this._y=Math.atan2(s,p));break;case"XZY":this._z=Math.asin(-Ye(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(h,c),this._y=Math.atan2(s,o)):(this._x=Math.atan2(-d,p),this._y=0);break;default:console.warn("v3d.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return uf.makeRotationFromQuaternion(e),this.setFromRotationMatrix(uf,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return df.setFromEuler(this),this.setFromQuaternion(df,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(e){return console.warn("v3d.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"),e?e.set(this._x,this._y,this._z):new b(this._x,this._y,this._z)}makeAlternative(){var e=this._order[1]==="X"?-1:1,t=this._order[1]==="Y"?-1:1,n=this._order[1]==="Z"?-1:1;return this._x=mc(e*(this._x+Math.PI)),this._y=mc(t*(this._y+Math.PI)),this._z=mc(n*(this._z+Math.PI)),this}equalsEps(e,t){return Math.abs(this._x-e._x)<t&&Math.abs(this._y-e._y)<t&&Math.abs(this._z-e._z)<t&&this._order===e._order}}gr.DefaultOrder="XYZ",gr.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class ba{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!=0}isEnabled(e){return(this.mask&(1<<e|0))!=0}}let _A=0;const hf=new b,Tr=new Ge,Nn=new Ae,mo=new b,Gi=new b,pf=new b,AA=new Ge,ff=new b(1,0,0),mf=new b(0,1,0),gf=new b(0,0,1),xA={type:"added"},vf={type:"removed"};class ze extends An{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_A++}),this.uuid=wn(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ze.DefaultUp.clone();const e=new b,t=new gr,n=new Ge,i=new b(1,1,1);t._onChange(function(){n.setFromEuler(t,!1)}),n._onChange(function(){t.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Ae},normalMatrix:{value:new ln}}),this.matrix=new Ae,this.matrixWorld=new Ae,this.matrixAutoUpdate=ze.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=ze.DefaultMatrixWorldAutoUpdate,this.layers=new ba,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={},this.internVisible=!0,this.externVisible=!0,this.constraints=[],this.disableChildRendering=!1,this.hidpiCompositing=!1,this.groupNames=[],this.objectIndex=0,this.objectColor=new me,this.objectAlpha=1}set visible(e){this.externVisible=e}get visible(){return this.internVisible&&this.externVisible}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Tr.setFromAxisAngle(e,t),this.quaternion.multiply(Tr),this}rotateOnWorldAxis(e,t){return Tr.setFromAxisAngle(e,t),this.quaternion.premultiply(Tr),this}rotateX(e){return this.rotateOnAxis(ff,e)}rotateY(e){return this.rotateOnAxis(mf,e)}rotateZ(e){return this.rotateOnAxis(gf,e)}translateOnAxis(e,t){return hf.copy(e).applyQuaternion(this.quaternion),this.position.add(hf.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(ff,e)}translateY(e){return this.translateOnAxis(mf,e)}translateZ(e){return this.translateOnAxis(gf,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Nn.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?mo.copy(e):mo.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Gi.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Nn.lookAt(Gi,mo,this.up):Nn.lookAt(mo,Gi,this.up),this.quaternion.setFromRotationMatrix(Nn),i&&(Nn.extractRotation(i.matrixWorld),Tr.setFromRotationMatrix(Nn),this.quaternion.premultiply(Tr.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("v3d.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(xA)):console.error("v3d.Object3D.add: object not an instance of v3d.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(vf)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(vf)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),Nn.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Nn.multiply(e.parent.matrixWorld)),e.applyMatrix4(Nn),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const o=this.children[n].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t){let n=[];this[e]===t&&n.push(this);for(let i=0,o=this.children.length;i<o;i++){const r=this.children[i].getObjectsByProperty(e,t);r.length>0&&(n=n.concat(r))}return n}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Gi,e,pf),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Gi,AA,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[4],t[5],t[6]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.updateConstraints(),this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++){const o=t[n];o.matrixWorldAutoUpdate!==!0&&e!==!0||o.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.matrixWorldAutoUpdate===!0&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let o=0,r=i.length;o<r;o++){const s=i[o];s.matrixWorldAutoUpdate===!0&&s.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function o(s,l){return s[l.uuid]===void 0&&(s[l.uuid]=l.toJSON(e)),l.uuid}if(i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),this.disableChildRendering===!1&&(i.disableChildRendering=!1),this.hidpiCompositing===!0&&(i.hidpiCompositing=!0),this.objectIndex!==0&&(i.objectIndex=this.objectIndex),this.objectColor&&this.objectColor.isColor&&(i.objectColor=this.objectColor.getHex()),this.objectAlpha!==1&&(i.objectAlpha=this.objectAlpha),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=o(e.geometries,this.geometry);const s=this.geometry.parameters;if(s!==void 0&&s.shapes!==void 0){const l=s.shapes;if(Array.isArray(l))for(let c=0,d=l.length;c<d;c++){const u=l[c];o(e.shapes,u)}else o(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(o(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const s=[];for(let l=0,c=this.material.length;l<c;l++)s.push(o(e.materials,this.material[l]));i.material=s}else i.material=o(e.materials,this.material);if(this.children.length>0){i.children=[];for(let s=0;s<this.children.length;s++)i.children.push(this.children[s].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let s=0;s<this.animations.length;s++){const l=this.animations[s];i.animations.push(o(e.animations,l))}}if(t){const s=r(e.geometries),l=r(e.materials),c=r(e.textures),d=r(e.images),u=r(e.shapes),h=r(e.skeletons),p=r(e.animations),m=r(e.nodes);s.length>0&&(n.geometries=s),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),d.length>0&&(n.images=d),u.length>0&&(n.shapes=u),h.length>0&&(n.skeletons=h),p.length>0&&(n.animations=p),m.length>0&&(n.nodes=m)}return n.object=i,n;function r(s){const l=[];for(const c in s){const d=s[c];delete d.metadata,l.push(d)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.disableChildRendering=e.disableChildRendering,this.hidpiCompositing=e.hidpiCompositing,this.objectIndex=e.objectIndex,this.objectColor.copy(e.objectColor),this.objectAlpha=e.objectAlpha,this.constraints=[];for(let n=0;n<e.constraints.length;n++)this.constraints.push(e.constraints[n].clone());if(this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}copyTransform(e){this.matrix.copy(e.matrixWorld),this.parent&&this.matrix.multiplyMatrices(Nn.copy(this.parent.matrixWorld).invert(),this.matrix),this.matrix.decompose(this.position,this.quaternion,this.scale)}isVisible(){return this.visible}updateConstraints(){for(let e=0;e<this.constraints.length;e++)this.constraints[e].update(this)}getWorldPositionNU(e){return e.setFromMatrixPosition(this.matrixWorld)}getLocalDirection(e){const t=this.matrix.elements;return this.isCamera||this.isLight?e.set(-t[8],-t[9],-t[10]).normalize():e.set(t[8],t[9],t[10]).normalize()}lookAtLocal(e,t,n){e.isVector3?mo.copy(e):mo.set(e,t,n),Gi.setFromMatrixPosition(this.matrix),this.isCamera||this.isLight?Nn.lookAt(Gi,mo,this.up):Nn.lookAt(mo,Gi,this.up),this.quaternion.setFromRotationMatrix(Nn)}findRoot(){let e=this;return this.traverseAncestors(function(t){e=t}),e}resolveMultiMaterial(){const e=[];for(let t=0;t<this.children.length;t++){const n=this.children[t];n.isMesh&&n.isMaterialGeneratedMesh&&e.push(n)}return e.length||e.push(this),e}getAuxClippingMeshes(){const e=[];for(let t=0;t<this.children.length;t++){const n=this.children[t];n.isMesh&&n.isAuxClippingMesh&&e.push(n)}return e}getWorldEuler(e,t=e._order){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decomposeE(Gi,e,pf,t),e}}ze.DefaultUp=new b(0,1,0),ze.DefaultMatrixAutoUpdate=!0,ze.DefaultMatrixWorldAutoUpdate=!0;const ri=new b,ki=new b,Lu=new b,Qi=new b,Ir=new b,Rr=new b,_f=new b,Pu=new b,Bu=new b,Du=new b;class gn{constructor(e=new b,t=new b,n=new b){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),ri.subVectors(e,t),i.cross(ri);const o=i.lengthSq();return o>0?i.multiplyScalar(1/Math.sqrt(o)):i.set(0,0,0)}static getBarycoord(e,t,n,i,o){ri.subVectors(i,t),ki.subVectors(n,t),Lu.subVectors(e,t);const r=ri.dot(ri),s=ri.dot(ki),l=ri.dot(Lu),c=ki.dot(ki),d=ki.dot(Lu),u=r*c-s*s;if(u===0)return o.set(-2,-1,-1);const h=1/u,p=(c*l-s*d)*h,m=(r*d-s*l)*h;return o.set(1-p-m,m,p)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,Qi),Qi.x>=0&&Qi.y>=0&&Qi.x+Qi.y<=1}static getUV(e,t,n,i,o,r,s,l){return this.getBarycoord(e,t,n,i,Qi),l.set(0,0),l.addScaledVector(o,Qi.x),l.addScaledVector(r,Qi.y),l.addScaledVector(s,Qi.z),l}static isFrontFacing(e,t,n,i){return ri.subVectors(n,t),ki.subVectors(e,t),ri.cross(ki).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,n,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return ri.subVectors(this.c,this.b),ki.subVectors(this.a,this.b),.5*ri.cross(ki).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return gn.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return gn.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,o){return gn.getUV(e,this.a,this.b,this.c,t,n,i,o)}containsPoint(e){return gn.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return gn.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,o=this.c;let r,s;Ir.subVectors(i,n),Rr.subVectors(o,n),Pu.subVectors(e,n);const l=Ir.dot(Pu),c=Rr.dot(Pu);if(l<=0&&c<=0)return t.copy(n);Bu.subVectors(e,i);const d=Ir.dot(Bu),u=Rr.dot(Bu);if(d>=0&&u<=d)return t.copy(i);const h=l*u-d*c;if(h<=0&&l>=0&&d<=0)return r=l/(l-d),t.copy(n).addScaledVector(Ir,r);Du.subVectors(e,o);const p=Ir.dot(Du),m=Rr.dot(Du);if(m>=0&&p<=m)return t.copy(o);const f=p*c-l*m;if(f<=0&&c>=0&&m<=0)return s=c/(c-m),t.copy(n).addScaledVector(Rr,s);const g=d*m-p*u;if(g<=0&&u-d>=0&&p-m>=0)return _f.subVectors(o,i),s=(u-d)/(u-d+(p-m)),t.copy(i).addScaledVector(_f,s);const _=1/(g+f+h);return r=f*_,s=h*_,t.copy(n).addScaledVector(Ir,r).addScaledVector(Rr,s)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let yA=0;class Ut extends An{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:yA++}),this.uuid=wn(),this.name="",this.type="Material",this.blending=lr,this.side=kn,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=xr,this.blendDst=Ri,this.blendEquation=tn,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Sc,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0,this.depthPrepass=!1,this.receiveShadow=!1,this.castShadow=!1,this.profile="",this.defines={},this.definesFragOnly=[],this.DefaultEnvMapAutoAssign=!0,this.envMapAutoAssign=this.DefaultEnvMapAutoAssign,this.gtaoVisible=!0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn("v3d.Material: '"+t+"' parameter is undefined.");continue}const i=this[t];i!==void 0?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n:console.warn("v3d."+this.type+": '"+t+"' is not a property of this material.")}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(o){const r=[];for(const s in o){const l=o[s];delete l.metadata,r.push(l)}return r}if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&!this.isMeshNodeMaterial&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==lr&&(n.blending=this.blending),this.side!==kn&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData),t){const o=i(e.textures),r=i(e.images);o.length>0&&(n.textures=o),r.length>0&&(n.images=r)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let o=0;o!==i;++o)n[o]=t[o].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this.depthPrepass=e.depthPrepass,this.defines=Object.assign({},e.defines),this.definesFragOnly=e.definesFragOnly.slice(),this.receiveShadow=e.receiveShadow,this.castShadow=e.castShadow,this.profile=e.profile,this.envMapAutoAssign=e.envMapAutoAssign,this.gtaoVisible=e.gtaoVisible,this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}get needsUpdate(){return this.version!=0}}class Xt extends Ut{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new me(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ps,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Gt=new b,sl=new te;class Te{constructor(e,t,n=!1){if(Array.isArray(e))throw new TypeError("v3d.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,o=this.itemSize;i<o;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)sl.fromBufferAttribute(this,t),sl.applyMatrix3(e),this.setXY(t,sl.x,sl.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)Gt.fromBufferAttribute(this,t),Gt.applyMatrix3(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)Gt.fromBufferAttribute(this,t),Gt.applyMatrix4(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Gt.fromBufferAttribute(this,t),Gt.applyNormalMatrix(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Gt.fromBufferAttribute(this,t),Gt.transformDirection(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Ji(t,this.array)),t}setX(e,t){return this.normalized&&(t=ut(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Ji(t,this.array)),t}setY(e,t){return this.normalized&&(t=ut(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Ji(t,this.array)),t}setZ(e,t){return this.normalized&&(t=ut(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Ji(t,this.array)),t}setW(e,t){return this.normalized&&(t=ut(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=ut(t,this.array),n=ut(n,this.array)),this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=ut(t,this.array),n=ut(n,this.array),i=ut(i,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,o){return e*=this.itemSize,this.normalized&&(t=ut(t,this.array),n=ut(n,this.array),i=ut(i,this.array),o=ut(o,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=o,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==35044&&(e.usage=this.usage),this.updateRange.offset===0&&this.updateRange.count===-1||(e.updateRange=this.updateRange),e}copyColorsArray(){console.error("v3d.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("v3d.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("v3d.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("v3d.BufferAttribute: copyVector4sArray() was removed in r144.")}}class bA extends Te{constructor(e,t,n){super(new Int8Array(e),t,n)}}class CA extends Te{constructor(e,t,n){super(new Uint8Array(e),t,n)}}class SA extends Te{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}}class MA extends Te{constructor(e,t,n){super(new Int16Array(e),t,n)}}class kh extends Te{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class EA extends Te{constructor(e,t,n){super(new Int32Array(e),t,n)}}class Qh extends Te{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class wA extends Te{constructor(e,t,n){super(new Uint16Array(e),t,n),this.isFloat16BufferAttribute=!0}}class Ie extends Te{constructor(e,t,n){super(new Float32Array(e),t,n)}}class TA extends Te{constructor(e,t,n){super(new Float64Array(e),t,n)}}let IA=0;const Yn=new Ae,Nu=new ze,Lr=new b,On=new At,Da=new At,Jt=new b;class Pe extends An{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:IA++}),this.uuid=wn(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(Dg(e)?Qh:kh)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const o=new ln().getNormalMatrix(e);n.applyNormalMatrix(o),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Yn.makeRotationFromQuaternion(e),this.applyMatrix4(Yn),this}rotateX(e){return Yn.makeRotationX(e),this.applyMatrix4(Yn),this}rotateY(e){return Yn.makeRotationY(e),this.applyMatrix4(Yn),this}rotateZ(e){return Yn.makeRotationZ(e),this.applyMatrix4(Yn),this}translate(e,t,n){return Yn.makeTranslation(e,t,n),this.applyMatrix4(Yn),this}scale(e,t,n){return Yn.makeScale(e,t,n),this.applyMatrix4(Yn),this}lookAt(e){return Nu.lookAt(e),Nu.updateMatrix(),this.applyMatrix4(Nu.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Lr).negate(),this.translate(Lr.x,Lr.y,Lr.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const o=e[n];t.push(o.x,o.y,o.z||0)}return this.setAttribute("position",new Ie(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new At);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('v3d.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new b(-1/0,-1/0,-1/0),new b(1/0,1/0,1/0));if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const o=t[n];On.setFromBufferAttribute(o),this.morphTargetsRelative?(Jt.addVectors(this.boundingBox.min,On.min),this.boundingBox.expandByPoint(Jt),Jt.addVectors(this.boundingBox.max,On.max),this.boundingBox.expandByPoint(Jt)):(this.boundingBox.expandByPoint(On.min),this.boundingBox.expandByPoint(On.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('v3d.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Rn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('v3d.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new b,1/0);if(e){const n=this.boundingSphere.center;if(On.setFromBufferAttribute(e),t)for(let o=0,r=t.length;o<r;o++){const s=t[o];Da.setFromBufferAttribute(s),this.morphTargetsRelative?(Jt.addVectors(On.min,Da.min),On.expandByPoint(Jt),Jt.addVectors(On.max,Da.max),On.expandByPoint(Jt)):(On.expandByPoint(Da.min),On.expandByPoint(Da.max))}On.getCenter(n);let i=0;for(let o=0,r=e.count;o<r;o++)Jt.fromBufferAttribute(e,o),i=Math.max(i,n.distanceToSquared(Jt));if(t)for(let o=0,r=t.length;o<r;o++){const s=t[o],l=this.morphTargetsRelative;for(let c=0,d=s.count;c<d;c++)Jt.fromBufferAttribute(s,c),l&&(Lr.fromBufferAttribute(e,c),Jt.add(Lr)),i=Math.max(i,n.distanceToSquared(Jt))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('v3d.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0)return void console.error("v3d.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=e.array,i=t.position.array,o=t.normal.array,r=t.uv.array,s=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Te(new Float32Array(4*s),4));const l=this.getAttribute("tangent").array,c=[],d=[];for(let V=0;V<s;V++)c[V]=new b,d[V]=new b;const u=new b,h=new b,p=new b,m=new te,f=new te,g=new te,_=new b,A=new b;function x(V,N,j){u.fromArray(i,3*V),h.fromArray(i,3*N),p.fromArray(i,3*j),m.fromArray(r,2*V),f.fromArray(r,2*N),g.fromArray(r,2*j),h.sub(u),p.sub(u),f.sub(m),g.sub(m);const oe=1/(f.x*g.y-g.x*f.y);isFinite(oe)&&(_.copy(h).multiplyScalar(g.y).addScaledVector(p,-f.y).multiplyScalar(oe),A.copy(p).multiplyScalar(f.x).addScaledVector(h,-g.x).multiplyScalar(oe),c[V].add(_),c[N].add(_),c[j].add(_),d[V].add(A),d[N].add(A),d[j].add(A))}let S=this.groups;S.length===0&&(S=[{start:0,count:n.length}]);for(let V=0,N=S.length;V<N;++V){const j=S[V],oe=j.start;for(let H=oe,ne=oe+j.count;H<ne;H+=3)x(n[H+0],n[H+1],n[H+2])}const M=new b,T=new b,L=new b,z=new b;function W(V){L.fromArray(o,3*V),z.copy(L);const N=c[V];M.copy(N),M.sub(L.multiplyScalar(L.dot(N))).normalize(),T.crossVectors(z,N);const j=T.dot(d[V])<0?-1:1;l[4*V]=M.x,l[4*V+1]=M.y,l[4*V+2]=M.z,l[4*V+3]=j}for(let V=0,N=S.length;V<N;++V){const j=S[V],oe=j.start;for(let H=oe,ne=oe+j.count;H<ne;H+=3)W(n[H+0]),W(n[H+1]),W(n[H+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Te(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let h=0,p=n.count;h<p;h++)n.setXYZ(h,0,0,0);const i=new b,o=new b,r=new b,s=new b,l=new b,c=new b,d=new b,u=new b;if(e)for(let h=0,p=e.count;h<p;h+=3){const m=e.getX(h+0),f=e.getX(h+1),g=e.getX(h+2);i.fromBufferAttribute(t,m),o.fromBufferAttribute(t,f),r.fromBufferAttribute(t,g),d.subVectors(r,o),u.subVectors(i,o),d.cross(u),s.fromBufferAttribute(n,m),l.fromBufferAttribute(n,f),c.fromBufferAttribute(n,g),s.add(d),l.add(d),c.add(d),n.setXYZ(m,s.x,s.y,s.z),n.setXYZ(f,l.x,l.y,l.z),n.setXYZ(g,c.x,c.y,c.z)}else for(let h=0,p=t.count;h<p;h+=3)i.fromBufferAttribute(t,h+0),o.fromBufferAttribute(t,h+1),r.fromBufferAttribute(t,h+2),d.subVectors(r,o),u.subVectors(i,o),d.cross(u),n.setXYZ(h+0,d.x,d.y,d.z),n.setXYZ(h+1,d.x,d.y,d.z),n.setXYZ(h+2,d.x,d.y,d.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(){return console.error("v3d.BufferGeometry.merge() has been removed. Use v3d.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Jt.fromBufferAttribute(e,t),Jt.normalize(),e.setXYZ(t,Jt.x,Jt.y,Jt.z)}toNonIndexed(){function e(s,l){const c=s.array,d=s.itemSize,u=s.normalized,h=new c.constructor(l.length*d);let p=0,m=0;for(let f=0,g=l.length;f<g;f++){p=s.isInterleavedBufferAttribute?l[f]*s.data.stride+s.offset:l[f]*d;for(let _=0;_<d;_++)h[m++]=c[p++]}return new Te(h,d,u)}if(this.index===null)return console.warn("v3d.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Pe,n=this.index.array,i=this.attributes;for(const s in i){const l=e(i[s],n);t.setAttribute(s,l)}const o=this.morphAttributes;for(const s in o){const l=[],c=o[s];for(let d=0,u=c.length;d<u;d++){const h=e(c[d],n);l.push(h)}t.morphAttributes[s]=l}t.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let s=0,l=r.length;s<l;s++){const c=r[s];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const l in n){const c=n[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let o=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],d=[];for(let u=0,h=c.length;u<h;u++){const p=c[u];d.push(p.toJSON(e.data))}d.length>0&&(i[l]=d,o=!0)}o&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(e.data.groups=JSON.parse(JSON.stringify(r)));const s=this.boundingSphere;return s!==null&&(e.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const c in i){const d=i[c];this.setAttribute(c,d.clone(t))}const o=e.morphAttributes;for(const c in o){const d=[],u=o[c];for(let h=0,p=u.length;h<p;h++)d.push(u[h].clone(t));this.morphAttributes[c]=d}this.morphTargetsRelative=e.morphTargetsRelative;const r=e.groups;for(let c=0,d=r.length;c<d;c++){const u=r[c];this.addGroup(u.start,u.count,u.materialIndex)}const s=e.boundingBox;s!==null&&(this.boundingBox=s.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const Af=new Ae,Pr=new ya,Ou=new Rn,go=new b,vo=new b,_o=new b,ra=new b,Fu=new b,Uu=new b,Ro=new b,ll=new b,cl=new b,ul=new te,dl=new te,hl=new te,zu=new b,pl=new b;class Ue extends ze{constructor(e=new Pe,t=new Xt){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets(),this.isMaterialGeneratedMesh=!1,this.isAuxClippingMesh=!1}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this.isMaterialGeneratedMesh=e.isMaterialGeneratedMesh,this}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=n.length;i<o;i++){const r=n[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=i}}}}getVertexPosition(e,t){const n=this.geometry,i=n.attributes.position,o=n.morphAttributes.position,r=n.morphTargetsRelative;t.fromBufferAttribute(i,e);const s=this.morphTargetInfluences;if(o&&s){Ro.set(0,0,0);for(let l=0,c=o.length;l<c;l++){const d=s[l],u=o[l];d!==0&&(ra.fromBufferAttribute(u,e),r?Ro.addScaledVector(ra,d):Ro.addScaledVector(ra.sub(t),d))}t.add(Ro)}return this.isSkinnedMesh&&this.boneTransform(e,t),t}raycast(e,t){if(this.isAuxClippingMesh)return;const n=this.geometry,i=this.material,o=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),Ou.copy(n.boundingSphere),Ou.applyMatrix4(o),e.ray.intersectsSphere(Ou)===!1)||(Af.copy(o).invert(),Pr.copy(e.ray).applyMatrix4(Af),n.boundingBox!==null&&Pr.intersectsBox(n.boundingBox)===!1))return;let r;const s=n.index,l=n.attributes.position,c=n.morphAttributes.position,d=n.morphTargetsRelative,u=n.attributes.uv,h=n.attributes.uv2,p=n.groups,m=n.drawRange;if(s!==null)if(Array.isArray(i))for(let f=0,g=p.length;f<g;f++){const _=p[f],A=i[_.materialIndex];for(let x=Math.max(_.start,m.start),S=Math.min(s.count,Math.min(_.start+_.count,m.start+m.count));x<S;x+=3){const M=s.getX(x),T=s.getX(x+1),L=s.getX(x+2);r=fl(this,A,e,Pr,l,c,d,u,h,M,T,L),r&&(r.faceIndex=Math.floor(x/3),r.face.materialIndex=_.materialIndex,t.push(r))}}else for(let f=Math.max(0,m.start),g=Math.min(s.count,m.start+m.count);f<g;f+=3){const _=s.getX(f),A=s.getX(f+1),x=s.getX(f+2);r=fl(this,i,e,Pr,l,c,d,u,h,_,A,x),r&&(r.faceIndex=Math.floor(f/3),t.push(r))}else if(l!==void 0)if(Array.isArray(i))for(let f=0,g=p.length;f<g;f++){const _=p[f],A=i[_.materialIndex];for(let x=Math.max(_.start,m.start),S=Math.min(l.count,Math.min(_.start+_.count,m.start+m.count));x<S;x+=3)r=fl(this,A,e,Pr,l,c,d,u,h,x,x+1,x+2),r&&(r.faceIndex=Math.floor(x/3),r.face.materialIndex=_.materialIndex,t.push(r))}else for(let f=Math.max(0,m.start),g=Math.min(l.count,m.start+m.count);f<g;f+=3)r=fl(this,i,e,Pr,l,c,d,u,h,f,f+1,f+2),r&&(r.faceIndex=Math.floor(f/3),t.push(r))}clone(){return new this.constructor(this.geometry,this.material).copy(this)}getWorldDirection(e){this.updateMatrixWorld(!0);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}isVisible(){return this.isMaterialGeneratedMesh&&this.parent?this.visible&&this.parent.visible:this.visible}}function RA(a,e,t,n,i,o,r,s){let l;if(l=e.side===nn?n.intersectTriangle(r,o,i,!0,s):n.intersectTriangle(i,o,r,e.side===kn,s),l===null)return null;pl.copy(s),pl.applyMatrix4(a.matrixWorld);const c=t.ray.origin.distanceTo(pl);return c<t.near||c>t.far?null:{distance:c,point:pl.clone(),object:a}}function fl(a,e,t,n,i,o,r,s,l,c,d,u){go.fromBufferAttribute(i,c),vo.fromBufferAttribute(i,d),_o.fromBufferAttribute(i,u);const h=a.morphTargetInfluences;if(o&&h){Ro.set(0,0,0),ll.set(0,0,0),cl.set(0,0,0);for(let m=0,f=o.length;m<f;m++){const g=h[m],_=o[m];g!==0&&(ra.fromBufferAttribute(_,c),Fu.fromBufferAttribute(_,d),Uu.fromBufferAttribute(_,u),r?(Ro.addScaledVector(ra,g),ll.addScaledVector(Fu,g),cl.addScaledVector(Uu,g)):(Ro.addScaledVector(ra.sub(go),g),ll.addScaledVector(Fu.sub(vo),g),cl.addScaledVector(Uu.sub(_o),g)))}go.add(Ro),vo.add(ll),_o.add(cl)}a.isSkinnedMesh&&(a.boneTransform(c,go),a.boneTransform(d,vo),a.boneTransform(u,_o));const p=RA(a,e,t,n,go,vo,_o,zu);if(p){s&&(ul.fromBufferAttribute(s,c),dl.fromBufferAttribute(s,d),hl.fromBufferAttribute(s,u),p.uv=gn.getUV(zu,go,vo,_o,ul,dl,hl,new te)),l&&(ul.fromBufferAttribute(l,c),dl.fromBufferAttribute(l,d),hl.fromBufferAttribute(l,u),p.uv2=gn.getUV(zu,go,vo,_o,ul,dl,hl,new te));const m={a:c,b:d,c:u,normal:new b,materialIndex:0};gn.getNormal(go,vo,_o,m.normal),p.face=m}return p}class ao extends Pe{constructor(e=1,t=1,n=1,i=1,o=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:o,depthSegments:r};const s=this;i=Math.floor(i),o=Math.floor(o),r=Math.floor(r);const l=[],c=[],d=[],u=[];let h=0,p=0;function m(f,g,_,A,x,S,M,T,L,z,W){const V=S/L,N=M/z,j=S/2,oe=M/2,H=T/2,ne=L+1,le=z+1;let re=0,ae=0;const E=new b;for(let F=0;F<le;F++){const U=F*N-oe;for(let B=0;B<ne;B++){const Z=B*V-j;E[f]=Z*A,E[g]=U*x,E[_]=H,c.push(E.x,E.y,E.z),E[f]=0,E[g]=0,E[_]=T>0?1:-1,d.push(E.x,E.y,E.z),u.push(B/L),u.push(1-F/z),re+=1}}for(let F=0;F<z;F++)for(let U=0;U<L;U++){const B=h+U+ne*F,Z=h+U+ne*(F+1),k=h+(U+1)+ne*(F+1),X=h+(U+1)+ne*F;l.push(B,Z,X),l.push(Z,k,X),ae+=6}s.addGroup(p,ae,W),p+=ae,h+=re}m("z","y","x",-1,-1,n,t,e,r,o,0),m("z","y","x",1,-1,n,t,-e,r,o,1),m("x","z","y",1,1,e,n,t,i,r,2),m("x","z","y",1,-1,e,n,-t,i,r,3),m("x","y","z",1,-1,e,t,n,i,o,4),m("x","y","z",-1,-1,e,t,-n,i,o,5),this.setIndex(l),this.setAttribute("position",new Ie(c,3)),this.setAttribute("normal",new Ie(d,3)),this.setAttribute("uv",new Ie(u,2))}static fromJSON(e){return new ao(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function ha(a){const e={};for(const t in a){e[t]={};for(const n in a[t]){const i=a[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function an(a){const e={};for(let t=0;t<a.length;t++){const n=ha(a[t]);for(const i in n)e[i]=n[i]}return e}function LA(a){const e=[];for(let t=0;t<a.length;t++)e.push(a[t].clone());return e}function zg(a){return a.getRenderTarget()===null&&a.outputEncoding===Ke?si:ms}const hn={clone:ha,merge:an};var PA=`void main() {
gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`,BA=`void main() {
gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}`;class vt extends Ut{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.customPrepTokens={},this.vertexShader=PA,this.fragmentShader=BA,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=ha(e.uniforms),this.uniformsGroups=LA(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.customPrepTokens=Object.assign({},e.customPrepTokens),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?t.uniforms[i]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[i]={type:"m4",value:o.toArray()}:t.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}class Os extends ze{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Ae,this.projectionMatrix=new Ae,this.projectionMatrixInverse=new Ae,this.controls=null,this.viewportFit={type:0,initialAspect:1},this.ignoreShadowLayers=!1}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),e.controls&&(this.controls=e.controls.clone()),this.viewportFit.type=e.viewportFit.type,this.viewportFit.initialAspect=e.viewportFit.initialAspect,this.ignoreShadowLayers=e.ignoreShadowLayers,this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(e){return new this.constructor().copy(this,e)}}class Qt extends Os{constructor(e=50,t=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=2*ua*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*eo*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*ua*Math.atan(Math.tan(.5*eo*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,i,o,r){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=o,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(.5*eo*this.fov)/this.zoom,n=2*t,i=this.aspect*n,o=-.5*i;const r=this.view;if(this.view!==null&&this.view.enabled){const l=r.fullWidth,c=r.fullHeight;o+=r.offsetX*i/l,t-=r.offsetY*n/c,i*=r.width/l,n*=r.height/c}const s=this.filmOffset;s!==0&&(o+=e*s/this.getFilmWidth()),this.projectionMatrix.makePerspective(o,o+i,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}class Ic extends ze{constructor(e,t,n){super(),this.type="CubeCamera",this.renderTarget=n;const i=new Qt(-90,1,e,t);i.layers=this.layers,i.up.set(0,1,0),i.lookAt(1,0,0),this.add(i);const o=new Qt(-90,1,e,t);o.layers=this.layers,o.up.set(0,1,0),o.lookAt(-1,0,0),this.add(o);const r=new Qt(-90,1,e,t);r.layers=this.layers,r.up.set(0,0,-1),r.lookAt(0,1,0),this.add(r);const s=new Qt(-90,1,e,t);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(0,-1,0),this.add(s);const l=new Qt(-90,1,e,t);l.layers=this.layers,l.up.set(0,1,0),l.lookAt(0,0,1),this.add(l);const c=new Qt(-90,1,e,t);c.layers=this.layers,c.up.set(0,1,0),c.lookAt(0,0,-1),this.add(c)}update(e,t){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,o,r,s,l,c]=this.children,d=e.getRenderTarget(),u=e.toneMapping,h=e.xr.enabled;e.toneMapping=ci,e.xr.enabled=!1;const p=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,i),e.setRenderTarget(n,1),e.render(t,o),e.setRenderTarget(n,2),e.render(t,r),e.setRenderTarget(n,3),e.render(t,s),e.setRenderTarget(n,4),e.render(t,l),n.texture.generateMipmaps=p,e.setRenderTarget(n,5),e.render(t,c),e.setRenderTarget(d),e.toneMapping=u,e.xr.enabled=h,n.texture.needsPMREMUpdate=!0}}class Fs extends yt{constructor(e,t,n,i,o,r,s,l,c,d){super(e=e!==void 0?e:[],t=t!==void 0?t:_a,n,i,o,r,s,l,c,d),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.source.data}set images(e){this.source.data=e}}class Us extends et{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},i=[n,n,n,n,n,n];this.texture=new Fs(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0&&t.generateMipmaps,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Le}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

                varying vec3 vWorldDirection;

                vec3 transformDirection(in vec3 dir, in mat4 matrix) {

                    return normalize((matrix * vec4(dir, 0.0)).xyz);

                }

                void main() {

                    vWorldDirection = transformDirection(position, modelMatrix);

                    #include <begin_vertex>
                    #include <project_vertex>

                }
            `,fragmentShader:`

                uniform sampler2D tEquirect;

                varying vec3 vWorldDirection;

                #include <common>

                void main() {

                    vec3 direction = normalize(vWorldDirection);

                    vec2 sampleUV = equirectUv(direction);

                    gl_FragColor = texture2D(tEquirect, sampleUV);

                }
            `},i=new ao(5,5,5),o=new vt({name:"CubemapFromEquirect",uniforms:ha(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:nn,blending:En});o.uniforms.tEquirect.value=t;const r=new Ue(i,o),s=t.minFilter;return t.minFilter===In&&(t.minFilter=Le),new Ic(1,10,this).update(e,r),t.minFilter=s,r.geometry.dispose(),r.material.dispose(),this}clear(e,t,n,i){const o=e.getRenderTarget();for(let r=0;r<6;r++)e.setRenderTarget(this,r),e.clear(t,n,i);e.setRenderTarget(o)}}const Vu=new b,DA=new b,NA=new ln;class Gn{constructor(e=new b(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=Vu.subVectors(n,t).cross(DA.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(Vu),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const o=-(e.start.dot(this.normal)+this.constant)/i;return o<0||o>1?null:t.copy(n).multiplyScalar(o).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||NA.getNormalMatrix(e),i=this.coplanarPoint(Vu).applyMatrix4(e),o=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(o),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Br=new Rn,ml=new b;class Kc{constructor(e=new Gn,t=new Gn,n=new Gn,i=new Gn,o=new Gn,r=new Gn){this.planes=[e,t,n,i,o,r]}set(e,t,n,i,o,r){const s=this.planes;return s[0].copy(e),s[1].copy(t),s[2].copy(n),s[3].copy(i),s[4].copy(o),s[5].copy(r),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,i=n[0],o=n[1],r=n[2],s=n[3],l=n[4],c=n[5],d=n[6],u=n[7],h=n[8],p=n[9],m=n[10],f=n[11],g=n[12],_=n[13],A=n[14],x=n[15];return t[0].setComponents(s-i,u-l,f-h,x-g).normalize(),t[1].setComponents(s+i,u+l,f+h,x+g).normalize(),t[2].setComponents(s+o,u+c,f+p,x+_).normalize(),t[3].setComponents(s-o,u-c,f-p,x-_).normalize(),t[4].setComponents(s-r,u-d,f-m,x-A).normalize(),t[5].setComponents(s+r,u+d,f+m,x+A).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Br.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Br)}intersectsSprite(e){return Br.center.set(0,0,0),Br.radius=.7071067811865476,Br.applyMatrix4(e.matrixWorld),this.intersectsSphere(Br)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let o=0;o<6;o++)if(t[o].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(ml.x=i.normal.x>0?e.max.x:e.min.x,ml.y=i.normal.y>0?e.max.y:e.min.y,ml.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(ml)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Vg(){let a=null,e=!1,t=null,n=null;function i(o,r){t(o,r),n=a.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=a.requestAnimationFrame(i),e=!0)},stop:function(){a.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(o){t=o},setContext:function(o){a=o}}}function OA(a,e){const t=e.isWebGL2;let n=new WeakMap;return{get:function(i){return i.isInterleavedBufferAttribute&&(i=i.data),n.get(i)},remove:function(i){i.isInterleavedBufferAttribute&&(i=i.data);const o=n.get(i);o&&(a.deleteBuffer(o.buffer),n.delete(i))},update:function(i,o){if(i.isGLBufferAttribute){const s=n.get(i);return void((!s||s.version<i.version)&&n.set(i,{buffer:i.buffer,type:i.type,bytesPerElement:i.elementSize,version:i.version}))}i.isInterleavedBufferAttribute&&(i=i.data);const r=n.get(i);r===void 0?n.set(i,function(s,l){const c=s.array,d=s.usage,u=a.createBuffer();let h;if(a.bindBuffer(l,u),a.bufferData(l,c,d),s.onUploadCallback(),c instanceof Float32Array)h=5126;else if(c instanceof Uint16Array)if(s.isFloat16BufferAttribute){if(!t)throw new Error("v3d.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");h=5131}else h=5123;else if(c instanceof Int16Array)h=5122;else if(c instanceof Uint32Array)h=5125;else if(c instanceof Int32Array)h=5124;else if(c instanceof Int8Array)h=5120;else if(c instanceof Uint8Array)h=5121;else{if(!(c instanceof Uint8ClampedArray))throw new Error("v3d.WebGLAttributes: Unsupported buffer data format: "+c);h=5121}return{buffer:u,type:h,bytesPerElement:c.BYTES_PER_ELEMENT,version:s.version}}(i,o)):r.version<i.version&&(function(s,l,c){const d=l.array,u=l.updateRange;a.bindBuffer(c,s),u.count===-1?a.bufferSubData(c,0,d):(t?a.bufferSubData(c,u.offset*d.BYTES_PER_ELEMENT,d,u.offset,u.count):a.bufferSubData(c,u.offset*d.BYTES_PER_ELEMENT,d.subarray(u.offset,u.offset+u.count)),u.count=-1),l.onUploadCallback()}(r.buffer,i,o),r.version=i.version)},dispose:function(){n=new WeakMap}}}class ni extends Pe{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const o=e/2,r=t/2,s=Math.floor(n),l=Math.floor(i),c=s+1,d=l+1,u=e/s,h=t/l,p=[],m=[],f=[],g=[];for(let _=0;_<d;_++){const A=_*h-r;for(let x=0;x<c;x++){const S=x*u-o;m.push(S,-A,0),f.push(0,0,1),g.push(x/s),g.push(1-_/l)}}for(let _=0;_<l;_++)for(let A=0;A<s;A++){const x=A+c*_,S=A+c*(_+1),M=A+1+c*(_+1),T=A+1+c*_;p.push(x,S,T),p.push(S,M,T)}this.setIndex(p),this.setAttribute("position",new Ie(m,3)),this.setAttribute("normal",new Ie(f,3)),this.setAttribute("uv",new Ie(g,2))}static fromJSON(e){return new ni(e.width,e.height,e.widthSegments,e.heightSegments)}}var FA=`#ifdef USE_ALPHAMAP
diffuseColor.a *= texture2D(alphaMap, vUv).g;
#endif`,UA=`#ifdef USE_ALPHAMAP
uniform sampler2D alphaMap;
#endif`,zA=`#ifdef USE_ALPHATEST
if (diffuseColor.a < alphaTest)
discard;
else
diffuseColor.a = 1.0;
#endif`,VA=`#ifdef USE_ALPHATEST
uniform float alphaTest;
#endif`,GA=`#ifdef USE_AOMAP
float ambientOcclusion = (texture2D(aoMap, vUv2).r - 1.0) * aoMapIntensity + 1.0;
reflectedLight.indirectDiffuse *= ambientOcclusion;
#if defined(USE_ENVMAP) && defined(STANDARD)
float dotNV = saturate(dot(geometry.normal, geometry.viewDir));
reflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.roughness);
#endif
#endif`,kA=`#ifdef USE_AOMAP
uniform sampler2D aoMap;
uniform float aoMapIntensity;
#endif`,QA="vec3 transformed = vec3(position);",WA=`vec3 objectNormal = vec3(normal);
#ifdef USE_TANGENT
vec3 objectTangent = vec3(tangent.xyz);
#endif`,HA=`
vec2 integrateSpecularBRDF(const in float dotNV, const in float roughness) {
const vec4 c0 = vec4(- 1, - 0.0275, - 0.572, 0.022);
const vec4 c1 = vec4(1, 0.0425, 1.04, - 0.04);
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(- 9.28 * dotNV)) * r.x + r.y;
return vec2(-1.04, 1.04) * a004 + r.zw;
}
vec3 BRDF_Lambert(const in vec3 diffuseColor) {
return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick(const in vec3 f0, const in float f90, const in float dotVH) {
float fresnel = exp2((- 5.55473 * dotVH - 6.98316) * dotVH);
return f0 * (1.0 - fresnel) + (f90 * fresnel);
}
float F_Schlick(const in float f0, const in float f90, const in float dotVH) {
float fresnel = exp2((- 5.55473 * dotVH - 6.98316) * dotVH);
return f0 * (1.0 - fresnel) + (f90 * fresnel);
}
vec3 Schlick_to_F0(const in vec3 f, const in float f90, const in float dotVH) {
float x = clamp(1.0 - dotVH, 0.0, 1.0);
float x2 = x * x;
float x5 = clamp(x * x2 * x2, 0.0, 0.9999);
return (f - vec3(f90) * x5) / (1.0 - x5);
}
vec3 F_Schlick_RoughnessDependent(const in vec3 F0, const in float dotNV, const in float roughness) {
float fresnel = exp2((-5.55473 * dotNV - 6.98316) * dotNV);
vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
return Fr * fresnel + F0;
}
float V_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {
float a2 = pow2(alpha);
float gv = dotNL * sqrt(a2 + (1.0 - a2) * pow2(dotNV));
float gl = dotNV * sqrt(a2 + (1.0 - a2) * pow2(dotNL));
return 0.5 / max(gv + gl, EPSILON);
}
float D_GGX(const in float alpha, const in float dotNH) {
float a2 = pow2(alpha);
float denom = pow2(dotNH) * (a2 - 1.0) + 1.0;
return RECIPROCAL_PI * a2 / pow2(denom);
}
vec3 BRDF_GGX(const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness) {
float alpha = pow2(clamp(roughness, 0.04, 1.0));
vec3 halfDir = normalize(lightDir + viewDir);
float dotNL = saturate(dot(normal, lightDir));
float dotNV = saturate(dot(normal, viewDir));
float dotNH = saturate(dot(normal, halfDir));
float dotVH = saturate(dot(viewDir, halfDir));
vec3 F = F_Schlick(f0, f90, dotVH);
float V = V_GGX_SmithCorrelated(alpha, dotNL, dotNV);
float D = D_GGX(alpha, dotNH);
return F * (V * D);
}
#ifdef USE_IRIDESCENCE
vec3 BRDF_GGX_Iridescence(const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness) {
float alpha = pow2(roughness);
vec3 halfDir = normalize(lightDir + viewDir);
float dotNL = saturate(dot(normal, lightDir));
float dotNV = saturate(dot(normal, viewDir));
float dotNH = saturate(dot(normal, halfDir));
float dotVH = saturate(dot(viewDir, halfDir));
vec3 F = mix(F_Schlick(f0, f90, dotVH), iridescenceFresnel, iridescence);
float V = V_GGX_SmithCorrelated(alpha, dotNL, dotNV);
float D = D_GGX(alpha, dotNH);
return F * (V * D);
}
#endif
vec2 LTC_Uv(const in vec3 N, const in vec3 V, const in float roughness) {
const float LUT_SIZE = 64.0;
const float LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;
const float LUT_BIAS = 0.5 / LUT_SIZE;
float dotNV = saturate(dot(N, V));
vec2 uv = vec2(roughness, sqrt(1.0 - dotNV));
uv = uv * LUT_SCALE + LUT_BIAS;
return uv;
}
float LTC_ClippedSphereFormFactor(const in vec3 f) {
float l = length(f);
return max((l * l + f.z) / (l + 1.0), 0.0);
}
vec3 LTC_EdgeVectorFormFactor(const in vec3 v1, const in vec3 v2) {
float x = dot(v1, v2);
float y = abs(x);
float a = 0.8543985 + (0.4965155 + 0.0145206 * y) * y;
float b = 3.4175940 + (4.1616724 + y) * y;
float v = a / b;
float theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt(max(1.0 - x * x, 1e-7)) - v;
return cross(v1, v2) * theta_sintheta;
}
vec3 LTC_Evaluate(const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[4]) {
vec3 v1 = rectCoords[1] - rectCoords[0];
vec3 v2 = rectCoords[3] - rectCoords[0];
vec3 lightNormal = cross(v1, v2);
if(dot(lightNormal, P - rectCoords[0]) < 0.0) return vec3(0.0);
vec3 T1, T2;
T1 = normalize(V - N * dot(V, N));
T2 = -cross(N, T1);
mat3 mat = mInv * transposeMat3(mat3(T1, T2, N));
vec3 coords[4];
coords[0] = mat * (rectCoords[0] - P);
coords[1] = mat * (rectCoords[1] - P);
coords[2] = mat * (rectCoords[2] - P);
coords[3] = mat * (rectCoords[3] - P);
coords[0] = normalize(coords[0]);
coords[1] = normalize(coords[1]);
coords[2] = normalize(coords[2]);
coords[3] = normalize(coords[3]);
vec3 vectorFormFactor = vec3(0.0);
vectorFormFactor += LTC_EdgeVectorFormFactor(coords[0], coords[1]);
vectorFormFactor += LTC_EdgeVectorFormFactor(coords[1], coords[2]);
vectorFormFactor += LTC_EdgeVectorFormFactor(coords[2], coords[3]);
vectorFormFactor += LTC_EdgeVectorFormFactor(coords[3], coords[0]);
float result = LTC_ClippedSphereFormFactor(vectorFormFactor);
return vec3(result);
}
vec2 get_BRDF_SpecCoeffsBlender(float x, float y) {
vec3 xyFactors0 = vec3(x * x, y * y, x * y);
vec3 xyFactors1 = vec3(x, y, 1);
vec3 a0a1a2 = vec3(0.33749372, 0.15167605, 1.09684597);
vec3 a3a4a5 = vec3(-1.26123466, -0.927699, 0.9199188);
vec3 b0b1b2 = vec3(0.41699717, 0.44675109, 0.79947684);
vec3 b3b4b5 = vec3(-1.19307849, -0.89813958, 0.89305222);
vec3 c0c1c2 = vec3(0.29920727, 0.09505591, -0.9136233);
vec3 c3c4c5 = vec3(0.77055201, 0.13006674, -0.23085581);
vec3 d0d1d2 = vec3(15.05004149, 7.98517355, 13.30473726);
vec3 d3d4d5 = vec3(-32.00353547, -12.97743434, 17.83646751);
float coeff0 = (dot(xyFactors0, a0a1a2) + dot(xyFactors1, a3a4a5))
/ (dot(xyFactors0, b0b1b2) + dot(xyFactors1, b3b4b5));
float coeff1 = (dot(xyFactors0, c0c1c2) + dot(xyFactors1, c3c4c5))
/ (dot(xyFactors0, d0d1d2) + dot(xyFactors1, d3d4d5));
coeff1 = clamp(coeff1, 0.0, 1.0);
return vec2(coeff0, coeff1);
}
vec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness) {
float dotNV = saturate(dot(normal, viewDir));
vec2 brdf = integrateSpecularBRDF(dotNV, roughness);
return specularColor * brdf.x + brdf.y;
}
vec3 BRDF_Specular_GGX_Environment_Blender_Approx(const in GeometricContext geometry,
const in vec3 fresnelRefl0, const in vec3 fresnelRefl90,
const in float roughness, const int useCoat) {
vec3 normal = geometry.normal;
#ifdef USE_CLEARCOAT
if (useCoat == 1) {
normal = geometry.clearcoatNormal;
}
#endif
float dotNV = saturate(dot(normal, geometry.viewDir));
float angle = acos(abs(dotNV)) / PI_HALF;
vec2 specCoeffs = get_BRDF_SpecCoeffsBlender(angle, roughness);
vec3 specular = specCoeffs.x * fresnelRefl0
+ specCoeffs.y * fresnelRefl90
* vec3(saturate(50.0 * linearToRelativeLuminance(fresnelRefl0)));
#if defined (COMPAT_SATURATE_SPEC_ENV_BLENDER_APPROX)
specular = saturate(specular);
#endif
return specular;
}
vec3 BRDF_Specular_GGX_Environment_Maya(const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in vec3 specularColor90, const in float roughness) {
float dotNV = saturate(dot(normal, viewDir));
vec2 brdf = integrateSpecularBRDF(dotNV, roughness);
return specularColor * brdf.x + specularColor90 * brdf.y;
}
void BRDF_Specular_Multiscattering_Environment(const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter) {
float dotNV = saturate(dot(geometry.normal, geometry.viewDir));
vec3 F = F_Schlick_RoughnessDependent(specularColor, dotNV, roughness);
vec2 brdf = integrateSpecularBRDF(dotNV, roughness);
vec3 FssEss = F * brdf.x + brdf.y;
float Ess = brdf.x + brdf.y;
float Ems = 1.0 - Ess;
vec3 Favg = specularColor + (1.0 - specularColor) * 0.047619;
vec3 Fms = FssEss * Favg / (1.0 - Ems * Favg);
singleScatter += FssEss;
multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit() {
return 0.25;
}
float D_BlinnPhong(const in float shininess, const in float dotNH) {
return RECIPROCAL_PI * (shininess * 0.5 + 1.0) * pow(dotNH, shininess);
}
vec3 BRDF_BlinnPhong(const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess) {
vec3 halfDir = normalize(lightDir + viewDir);
float dotNH = saturate(dot(normal, halfDir));
float dotVH = saturate(dot(viewDir, halfDir));
vec3 F = F_Schlick(specularColor, 1.0, dotVH);
float G = G_BlinnPhong_Implicit();
float D = D_BlinnPhong(shininess, dotNH);
return F * (G * D);
}
float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {
return (2.0 / pow2(ggxRoughness + 0.0001) - 2.0);
}
float BlinnExponentToGGXRoughness(const in float blinnExponent) {
return sqrt(2.0 / (blinnExponent + 2.0));
}
#if defined(USE_SHEEN)
float D_Charlie(float roughness, float dotNH) {
float alpha = pow2(roughness);
float invAlpha = 1.0 / alpha;
float cos2h = dotNH * dotNH;
float sin2h = max(1.0 - cos2h, 0.0078125);
return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float dotNV, float dotNL) {
return saturate(1.0 / (4.0 * (dotNL + dotNV - dotNL * dotNV)));
}
vec3 BRDF_Sheen(const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness) {
vec3 halfDir = normalize(lightDir + viewDir);
float dotNL = saturate(dot(normal, lightDir));
float dotNV = saturate(dot(normal, viewDir));
float dotNH = saturate(dot(normal, halfDir));
float D = D_Charlie(sheenRoughness, dotNH);
float V = V_Neubelt(dotNV, dotNL);
return sheenColor * (D * V);
}
#endif`,XA=`#ifdef USE_IRIDESCENCE
const mat3 XYZ_TO_REC709 = mat3(
3.2404542, -0.9692660, 0.0556434,
-1.5371385, 1.8760108, -0.2040259,
-0.4985314, 0.0415560, 1.0572252
);
vec3 Fresnel0ToIor(vec3 fresnel0) {
vec3 sqrtF0 = sqrt(fresnel0);
return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}
vec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {
return pow2((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
float IorToFresnel0(float transmittedIor, float incidentIor) {
return pow2((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}
vec3 evalSensitivity(float OPD, vec3 shift) {
float phase = 2.0 * PI * OPD * 1.0e-9;
vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);
vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(- pow2(phase) * var);
xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(- 4.5282e+09 * pow2(phase));
xyz /= 1.0685e-7;
vec3 rgb = XYZ_TO_REC709 * xyz;
return rgb;
}
vec3 evalIridescence(float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {
vec3 I;
float iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));
float sinTheta2Sq = pow2(outsideIOR / iridescenceIOR) * (1.0 - pow2(cosTheta1));
float cosTheta2Sq = 1.0 - sinTheta2Sq;
if (cosTheta2Sq < 0.0) {
return vec3(1.0);
}
float cosTheta2 = sqrt(cosTheta2Sq);
float R0 = IorToFresnel0(iridescenceIOR, outsideIOR);
float R12 = F_Schlick(R0, 1.0, cosTheta1);
float R21 = R12;
float T121 = 1.0 - R12;
float phi12 = 0.0;
if (iridescenceIOR < outsideIOR) phi12 = PI;
float phi21 = PI - phi12;
vec3 baseIOR = Fresnel0ToIor(clamp(baseF0, 0.0, 0.9999));
vec3 R1 = IorToFresnel0(baseIOR, iridescenceIOR);
vec3 R23 = F_Schlick(R1, 1.0, cosTheta2);
vec3 phi23 = vec3(0.0);
if (baseIOR[0] < iridescenceIOR) phi23[0] = PI;
if (baseIOR[1] < iridescenceIOR) phi23[1] = PI;
if (baseIOR[2] < iridescenceIOR) phi23[2] = PI;
float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
vec3 phi = vec3(phi21) + phi23;
vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);
vec3 r123 = sqrt(R123);
vec3 Rs = pow2(T121) * R23 / (vec3(1.0) - R123);
vec3 C0 = R12 + Rs;
I = C0;
vec3 Cm = Rs - T121;
for (int m = 1; m <= 2; ++ m) {
Cm *= r123;
vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);
I += Cm * Sm;
}
return max(I, vec3(0.0));
}
#endif`,YA=`#ifdef USE_BUMPMAP
uniform sampler2D bumpMap;
uniform float bumpScale;
vec2 dHdxy_fwd() {
vec2 dSTdx = dFdx(vUv);
vec2 dSTdy = dFdy(vUv);
float Hll = bumpScale * texture2D(bumpMap, vUv).x;
float dBx = bumpScale * texture2D(bumpMap, vUv + dSTdx).x - Hll;
float dBy = bumpScale * texture2D(bumpMap, vUv + dSTdy).x - Hll;
return vec2(dBx, dBy);
}
vec3 perturbNormalArb(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection) {
vec3 vSigmaX = dFdx(surf_pos.xyz);
vec3 vSigmaY = dFdy(surf_pos.xyz);
vec3 vN = surf_norm;
vec3 R1 = cross(vSigmaY, vN);
vec3 R2 = cross(vN, vSigmaX);
float fDet = dot(vSigmaX, R1) * faceDirection;
vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);
return normalize(abs(fDet) * surf_norm - vGrad);
}
#endif`,jA=`#if NUM_CLIPPING_PLANES > 0
vec4 plane;
#pragma unroll_loop_start
for (int i = 0; i < UNION_CLIPPING_PLANES; i++) {
plane = clippingPlanes[i];
if (dot(vClipPosition, plane.xyz) > plane.w) discard;
}
#pragma unroll_loop_end
#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
bool clipped = true;
#pragma unroll_loop_start
for (int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i++) {
plane = clippingPlanes[i];
clipped = (dot(vClipPosition, plane.xyz) > plane.w) && clipped;
}
#pragma unroll_loop_end
if (clipped) discard;
#endif
#endif`,KA=`#if NUM_CLIPPING_PLANES > 0
varying vec3 vClipPosition;
uniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];
#endif`,qA=`#if NUM_CLIPPING_PLANES > 0
varying vec3 vClipPosition;
#endif`,ZA=`#if NUM_CLIPPING_PLANES > 0
vClipPosition = -mvPosition.xyz;
#endif`,JA=`#if defined(USE_COLOR_ALPHA)
diffuseColor *= vColor;
#elif defined(USE_COLOR)
diffuseColor.rgb *= vColor;
#endif`,$A=`#if defined(USE_COLOR_ALPHA)
varying vec4 vColor;
#elif defined(USE_COLOR)
varying vec3 vColor;
#endif`,ex=`#if defined(USE_COLOR_ALPHA)
varying vec4 vColor;
#elif defined(USE_COLOR) || defined(USE_INSTANCING_COLOR)
varying vec3 vColor;
#endif`,tx=`#if defined(USE_COLOR_ALPHA)
vColor = vec4(1.0);
#elif defined(USE_COLOR) || defined(USE_INSTANCING_COLOR)
vColor = vec3(1.0);
#endif
#ifdef USE_COLOR
vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
vColor.xyz *= instanceColor.xyz;
#endif`,nx=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp(a, 0.0, 1.0)
#endif
#define whiteComplement(a) (1.0 - saturate(a))
#define RECIPROCAL_3 0.333333333333
float pow2(const in float x) { return x*x; }
vec3 pow2(const in vec3 x) { return x*x; }
float pow3(const in float x) { return x*x*x; }
float pow4(const in float x) { float x2 = x*x; return x2*x2; }
float max3(const in vec3 v) { return max(max(v.x, v.y), v.z); }
float average(const in vec3 v) { return dot(v, vec3(0.3333333)); }
highp float rand(const in vec2 uv) {
const highp float a = 12.9898, b = 78.233, c = 43758.5453;
highp float dt = dot(uv.xy, vec2(a,b)), sn = mod(dt, PI);
return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
float precisionSafeLength(vec3 v) { return length(v); }
#else
float precisionSafeLength(vec3 v) {
float maxComponent = max3(abs(v));
return length(v / maxComponent) * maxComponent;
}
#endif
struct IncidentLight {
vec3 color;
vec3 direction;
bool visible;
};
struct ReflectedLight {
vec3 directDiffuse;
vec3 directSpecular;
vec3 indirectDiffuse;
vec3 indirectSpecular;
};
struct GeometricContext {
vec3 position;
vec3 normal;
vec3 viewDir;
vec3 probeNormal;
#ifdef USE_CLEARCOAT
vec3 clearcoatNormal;
#endif
};
vec3 transformDirection(in vec3 dir, in mat4 matrix) {
return normalize((matrix * vec4(dir, 0.0)).xyz);
}
vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {
return normalize((vec4(dir, 0.0) * matrix).xyz);
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {
float distance = dot(planeNormal, point - pointOnPlane);
return - distance * planeNormal + point;
}
float sideOfPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {
return sign(dot(point - pointOnPlane, planeNormal));
}
vec3 linePlaneIntersect(in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal) {
return lineDirection * (dot(planeNormal, pointOnPlane - pointOnLine) / dot(planeNormal, lineDirection)) + pointOnLine;
}
mat3 transposeMat3(const in mat3 m) {
mat3 tmp;
tmp[0] = vec3(m[0].x, m[1].x, m[2].x);
tmp[1] = vec3(m[0].y, m[1].y, m[2].y);
tmp[2] = vec3(m[0].z, m[1].z, m[2].z);
return tmp;
}
float linearToRelativeLuminance(const in vec3 color) {
const vec3 weights = vec3(0.2126729, 0.7151522, 0.0721750);
return dot(weights, color.rgb);
}
bool isPerspectiveMatrix(mat4 m) {
return m[2][3] == -1.0;
}
vec2 equirectUv(in vec3 dir) {
float u = atan(dir.z, dir.x) * RECIPROCAL_PI2 + 0.5;
float v = asin(clamp(dir.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;
return vec2(u, v);
}
float powCompat(const in float val, const in float power) {
if (power == 0.0)
return 1.0;
else if (val < 0.0) {
if (mod(-power, 2.0) == 0.0)
return pow(abs(val), power);
else
return -pow(abs(val), power);
} else if (val == 0.0)
return 0.0;
return pow(abs(val), power);
}
float maxFromRGB(vec3 rgb) {
return max(max(rgb.r, rgb.g), rgb.b);
}
vec3 swizzleUpZ(const vec3 vec) {
return vec3(vec[0], -vec[2], vec[1]);
}
vec3 swizzleUpY(const vec3 vec) {
return vec3(vec[0], vec[2], -vec[1]);
}
vec3 octUVToCubeVec(vec2 octUV, vec2 texelSize) {
octUV = (1.0 + 2.0 * texelSize) * octUV - texelSize;
octUV = octUV * 2.0 - 1.0;
float x = octUV.x;
float z = -octUV.y;
float absX = abs(x);
float absZ = abs(z);
vec3 cubeVec = vec3(x, 1.0 - absX - absZ, z);
if (absX + absZ > 1.0) {
cubeVec.xz = -(vec2(absZ, absX) - 1.0) * sign(vec2(x, z));
}
return cubeVec;
}
vec2 cubeVecToOctUV(vec3 cubeVec, vec2 texelSize) {
cubeVec /= dot(vec3(1.0), abs(cubeVec));
vec2 octUV = vec2(cubeVec.x, -cubeVec.z);
if (cubeVec.y < 0.0) {
octUV = sign(octUV) * (1.0 - abs(octUV.ts));
}
octUV = (octUV + 1.0) / 2.0;
octUV = (1.0 - 2.0 * texelSize) * octUV + texelSize;
return octUV;
}
#if __VERSION__ == 100
float cosh(float x) {
return (exp(x) + exp(-x)) / 2.0;
}
vec2 cosh(vec2 x) {
return (exp(x) + exp(-x)) / 2.0;
}
vec3 cosh(vec3 x) {
return (exp(x) + exp(-x)) / 2.0;
}
vec4 cosh(vec4 x) {
return (exp(x) + exp(-x)) / 2.0;
}
float sinh(float x) {
return (exp(x) - exp(-x)) / 2.0;
}
vec2 sinh(vec2 x) {
return (exp(x) - exp(-x)) / 2.0;
}
vec3 sinh(vec3 x) {
return (exp(x) - exp(-x)) / 2.0;
}
vec4 sinh(vec4 x) {
return (exp(x) - exp(-x)) / 2.0;
}
float tanh(float x) {
float exp2x = exp(2.0 * x);
return (exp2x - 1.0) / (exp2x + 1.0);
}
vec2 tanh(vec2 x) {
vec2 exp2x = exp(2.0 * x);
return (exp2x - 1.0) / (exp2x + 1.0);
}
vec3 tanh(vec3 x) {
vec3 exp2x = exp(2.0 * x);
return (exp2x - 1.0) / (exp2x + 1.0);
}
vec4 tanh(vec4 x) {
vec4 exp2x = exp(2.0 * x);
return (exp2x - 1.0) / (exp2x + 1.0);
}
float trunc(float x) {
return floor(abs(x)) * sign(x);
}
vec2 trunc(vec2 x) {
return floor(abs(x)) * sign(x);
}
vec3 trunc(vec3 x) {
return floor(abs(x)) * sign(x);
}
vec4 trunc(vec4 x) {
return floor(abs(x)) * sign(x);
}
#endif
vec3 vec3RotateAxisAngle(vec3 vector, vec3 axis, float angle) {
vec3 axisNorm = normalize(axis);
float x = axisNorm.x, y = axisNorm.y, z = axisNorm.z;
float s = sin(angle), c = cos(angle);
return mat3(
x * x * (1.0 - c) + c, x * y * (1.0 - c) + z * s, x * z * (1.0 - c) - y * s,
x * y * (1.0 - c) - z * s, y * y * (1.0 - c) + c, y * z * (1.0 - c) + x * s,
x * z * (1.0 - c) + y * s, y * z * (1.0 - c) - x * s, z * z * (1.0 - c) + c
) * vector;
}
mat3 mat3RotateX(float angle) {
float s = sin(angle), c = cos(angle);
return mat3(1.0, 0.0, 0.0,
0.0, c, s,
0.0, -s, c);
}
mat3 mat3RotateY(float angle) {
float s = sin(angle), c = cos(angle);
return mat3(c, 0.0, -s,
0.0, 1.0, 0.0,
s, 0.0, c);
}
mat3 mat3RotateZ(float angle) {
float s = sin(angle), c = cos(angle);
return mat3(c, s, 0.0,
-s, c, 0.0,
0.0, 0.0, 1.0);
}
vec3 vec3RotateXAngle(vec3 vector, float angle) {
return mat3RotateX(angle) * vector;
}
vec3 vec3RotateYAngle(vec3 vector, float angle) {
return mat3RotateY(angle) * vector;
}
vec3 vec3RotateZAngle(vec3 vector, float angle) {
return mat3RotateZ(angle) * vector;
}
vec4 eulerToAxisAngle(vec3 euler) {
float c1 = cos(euler.x / 2.0), c2 = cos(euler.y / 2.0), c3 = cos(euler.z / 2.0);
float s1 = sin(euler.x / 2.0), s2 = sin(euler.y / 2.0), s3 = sin(euler.z / 2.0);
vec4 axisAngle = vec4(
s1 * c2 * c3 - c1 * s2 * s3,
c1 * s2 * c3 + s1 * c2 * s3,
c1 * c2 * s3 - s1 * s2 * c3,
2.0 * acos(c1 * c2 * c3 + s1 * s2 * s3)
);
axisAngle.xyz = length(axisAngle.xyz) > 0.0 ? normalize(axisAngle.xyz) : vec3(1.0, 0.0, 0.0);
return axisAngle;
}
float mat3GetDeterminant(mat3 mat) {
return mat[0][0] * mat[1][1] * mat[2][2]
+ mat[0][2] * mat[1][0] * mat[2][1]
+ mat[0][1] * mat[1][2] * mat[2][0]
- mat[0][2] * mat[1][1] * mat[2][0]
- mat[0][0] * mat[1][2] * mat[2][1]
- mat[0][1] * mat[1][0] * mat[2][2];
}
mat3 mat3GetInverseTransposed(mat3 mat) {
float det = mat3GetDeterminant(mat);
float a00 = (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]) / det;
float a01 = - (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]) / det;
float a02 = (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0]) / det;
float a10 = - (mat[0][1] * mat[2][2] - mat[0][2] * mat[2][1]) / det;
float a11 = (mat[0][0] * mat[2][2] - mat[0][2] * mat[2][0]) / det;
float a12 = - (mat[0][0] * mat[2][1] - mat[0][1] * mat[2][0]) / det;
float a20 = (mat[0][1] * mat[1][2] - mat[0][2] * mat[1][1]) / det;
float a21 = - (mat[0][0] * mat[1][2] - mat[0][2] * mat[1][0]) / det;
float a22 = (mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0]) / det;
return mat3(
a00, a01, a02,
a10, a11, a12,
a20, a21, a22
);
}
mat3 toMat3(mat4 mat) {
return mat3(mat[0][0], mat[0][1], mat[0][2],
mat[1][0], mat[1][1], mat[1][2],
mat[2][0], mat[2][1], mat[2][2]);
}
mat4 toMat4(mat3 mat) {
return mat4(mat[0][0], mat[0][1], mat[0][2], 0.0,
mat[1][0], mat[1][1], mat[1][2], 0.0,
mat[2][0], mat[2][1], mat[2][2], 0.0,
0.0, 0.0, 0.0, 1.0);
}`,ix=`#ifdef ENVMAP_TYPE_CUBE_UV
float getFace(vec3 direction) {
vec3 absDirection = abs(direction);
float face = -1.0;
if (absDirection.x > absDirection.z) {
if (absDirection.x > absDirection.y) {
face = direction.x > 0.0 ? 0.0 : 3.0;
} else {
face = direction.y > 0.0 ? 1.0 : 4.0;
}
} else {
if (absDirection.z > absDirection.y) {
face = direction.z > 0.0 ? 2.0 : 5.0;
} else {
face = direction.y > 0.0 ? 1.0 : 4.0;
}
}
return face;
}
vec2 getUV(vec3 direction, float face) {
vec2 uv;
if (face == 0.0) {
uv = vec2(-direction.z, direction.y) / abs(direction.x);
} else if (face == 1.0) {
uv = vec2(direction.x, -direction.z) / abs(direction.y);
} else if (face == 2.0) {
uv = direction.xy / abs(direction.z);
} else if (face == 3.0) {
uv = vec2(direction.z, direction.y) / abs(direction.x);
} else if (face == 4.0) {
uv = direction.xz / abs(direction.y);
} else {
uv = vec2(-direction.x, direction.y) / abs(direction.z);
}
return 0.5 * (uv + 1.0);
}
#ifndef cubeUV_maxTileSize
#define cubeUV_maxTileSize 256.0
#endif
#define cubeUV_lodIdxMin 0.0
#define cubeUV_lodIdxLastDownscaled 4.0
#define cubeUV_lodIdxMax 10.0
#define cubeUV_minTileSize (cubeUV_maxTileSize / exp2(cubeUV_lodIdxLastDownscaled))
float getLodTileSize(float lodIdx) {
return cubeUV_maxTileSize / exp2(min(lodIdx, cubeUV_lodIdxLastDownscaled));
}
float getLodFilterLevel(float lodIdx) {
return max(lodIdx - cubeUV_lodIdxLastDownscaled, 0.0);
}
vec2 fixCubeUVSeams(vec2 uv, float faceSize) {
float BORDER_WIDTH_PX = max(cubeUV_maxTileSize / 256.0 - 1.0, 0.0);
float scale = (faceSize - BORDER_WIDTH_PX) / faceSize;
float offset = 0.5 * BORDER_WIDTH_PX / faceSize;
return uv * scale + offset;
}
vec2 getUVPixels(vec3 direction, float lodIdx) {
float face = getFace(direction);
float faceSize = getLodTileSize(lodIdx);
float filterLevel = getLodFilterLevel(lodIdx);
vec2 uv = getUV(direction, face);
uv = fixCubeUVSeams(uv, faceSize);
uv *= (faceSize - 1.0);
if (face > 2.0) {
uv.y += faceSize;
face -= 3.0;
}
uv.x += face * faceSize;
if (lodIdx > 0.0) {
uv.y += 2.0 * cubeUV_maxTileSize;
}
uv.y += filterLevel * 2.0 * cubeUV_minTileSize;
uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
return uv;
}
vec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float lodIdx) {
float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
vec2 uv = getUVPixels(direction, lodIdx);
vec2 f = fract(uv);
uv += 0.5 - f;
uv *= texelSize;
vec3 tl = texture2D(envMap, uv).rgb;
uv.x += texelSize;
vec3 tr = texture2D(envMap, uv).rgb;
uv.y += texelSize;
vec3 br = texture2D(envMap, uv).rgb;
uv.x -= texelSize;
vec3 bl = texture2D(envMap, uv).rgb;
vec3 tm = mix(tl, tr, f.x);
vec3 bm = mix(bl, br, f.x);
return mix(tm, bm, f.y);
}
vec3 sampleCubeUV(sampler2D envMap, vec3 direction, float lodIdx) {
float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
vec2 uv = getUVPixels(direction, lodIdx);
uv += 0.5;
uv *= texelSize;
return texture2D(envMap, uv).rgb;
}
#define cubeUV_r0 1.0
#define cubeUV_v0 0.339
#define cubeUV_m0 -2.0
#define cubeUV_r1 0.8
#define cubeUV_v1 0.276
#define cubeUV_m1 -1.0
#define cubeUV_r4 0.4
#define cubeUV_v4 0.046
#define cubeUV_m4 2.0
#define cubeUV_r5 0.305
#define cubeUV_v5 0.016
#define cubeUV_m5 3.0
#define cubeUV_r6 0.21
#define cubeUV_v6 0.0038
#define cubeUV_m6 4.0
float roughnessToMip(float roughness) {
float r = roughness;
float r2 = r * r;
float r3 = r2 * r;
roughness = -1.20278049 * r3 + 1.86860137 * r2 + 0.32478081 * r + 0.0098139;
return roughness * (cubeUV_lodIdxMax - cubeUV_lodIdxMin);
}
vec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {
float lodIdx = clamp(roughnessToMip(roughness), cubeUV_lodIdxMin,
cubeUV_lodIdxMax);
float lodIdxF = fract(lodIdx);
float lodIdxI = floor(lodIdx);
vec3 color0 = sampleCubeUV(envMap, sampleDir, lodIdxI);
if (lodIdxF == 0.0) {
return vec4(color0, 1.0);
} else {
vec3 color1 = sampleCubeUV(envMap, sampleDir, lodIdxI + 1.0);
return vec4(mix(color0, color1, lodIdxF), 1.0);
}
}
#endif`,ox=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
mat3 m = mat3(instanceMatrix);
transformedNormal /= vec3(dot(m[0], m[0]), dot(m[1], m[1]), dot(m[2], m[2]));
transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
transformedNormal = -transformedNormal;
#endif
#ifdef USE_TANGENT
vec3 transformedTangent = (modelViewMatrix * vec4(objectTangent, 0.0)).xyz;
#ifdef FLIP_SIDED
transformedTangent = -transformedTangent;
#endif
#endif`,rx=`#ifdef USE_DISPLACEMENTMAP
uniform sampler2D displacementMap;
uniform float displacementScale;
uniform float displacementBias;
#endif`,ax=`#ifdef USE_DISPLACEMENTMAP
transformed += normalize(objectNormal) * (texture2D(displacementMap, vUv).x * displacementScale + displacementBias);
#endif`,sx=`#ifdef USE_EMISSIVEMAP
vec4 emissiveColor = texture2D(emissiveMap, vUv);
totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,lx=`#ifdef USE_EMISSIVEMAP
uniform sampler2D emissiveMap;
#endif`,cx="gl_FragColor = linearToOutputTexel(gl_FragColor);",ux=`vec4 LinearToLinear(in vec4 value) {
return value;
}
vec4 LinearTosRGB(in vec4 value) {
return vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.a);
}`,dx=`#ifdef USE_ENVMAP
#ifdef ENV_WORLDPOS
vec3 cameraToFrag;
if (isOrthographic) {
cameraToFrag = normalize(vec3(-viewMatrix[0][2], - viewMatrix[1][2], - viewMatrix[2][2]));
} else {
cameraToFrag = normalize(vWorldPosition - cameraPosition);
}
vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);
#ifdef ENVMAP_MODE_REFLECTION
vec3 reflectVec = reflect(cameraToFrag, worldNormal);
#else
vec3 reflectVec = refract(cameraToFrag, worldNormal, refractionRatio);
#endif
#else
vec3 reflectVec = vReflect;
#endif
#ifdef ENVMAP_TYPE_CUBE
vec4 envColor = textureCube(envMap, vec3(flipEnvMap * reflectVec.x, reflectVec.yz));
#else
vec4 envColor = vec4(0.0);
#endif
#ifdef ENVMAP_BLENDING_MULTIPLY
outgoingLight = mix(outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity);
#elif defined(ENVMAP_BLENDING_MIX)
outgoingLight = mix(outgoingLight, envColor.xyz, specularStrength * reflectivity);
#elif defined(ENVMAP_BLENDING_ADD)
outgoingLight += envColor.xyz * specularStrength * reflectivity;
#endif
#endif`,hx=`#ifdef USE_ENVMAP
uniform float envMapIntensity;
uniform float flipEnvMap;
#ifdef ENVMAP_TYPE_CUBE
uniform samplerCube envMap;
#else
uniform sampler2D envMap;
#endif
#if defined(ENVMAP_TYPE_CUBE) && defined(NODE) || defined(ENVMAP_TYPE_CUBE_UV)
float calcGeometryRoughness(vec3 geometryNormal) {
vec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));
return max(max(dxy.x, dxy.y), dxy.z);
}
float calcCubeUVAdjustedRoughness(float origRoughness, float geomRoughness) {
return min(max(origRoughness, 0.0525) + geomRoughness, 1.0);
}
#endif
#endif`,px=`#ifdef USE_ENVMAP
uniform float reflectivity;
#if defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(PHONG) || defined(LAMBERT)
#define ENV_WORLDPOS
#endif
#ifdef ENV_WORLDPOS
varying vec3 vWorldPosition;
uniform float refractionRatio;
#else
varying vec3 vReflect;
#endif
#endif`,fx=`#ifdef USE_ENVMAP
#if defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(PHONG) || defined(LAMBERT)
#define ENV_WORLDPOS
#endif
#ifdef ENV_WORLDPOS
varying vec3 vWorldPosition;
#else
varying vec3 vReflect;
uniform float refractionRatio;
#endif
#endif`,mx=`#ifdef USE_ENVMAP
#ifdef ENV_WORLDPOS
vWorldPosition = worldPosition.xyz;
#else
vec3 cameraToVertex;
if (isOrthographic) {
cameraToVertex = normalize(vec3(-viewMatrix[0][2], - viewMatrix[1][2], - viewMatrix[2][2]));
} else {
cameraToVertex = normalize(worldPosition.xyz - cameraPosition);
}
vec3 worldNormal = inverseTransformDirection(transformedNormal, viewMatrix);
#ifdef ENVMAP_MODE_REFLECTION
vReflect = reflect(cameraToVertex, worldNormal);
#else
vReflect = refract(cameraToVertex, worldNormal, refractionRatio);
#endif
#endif
#endif`,gx=`#ifdef USE_FOG
vFogDepth = -mvPosition.z;
#endif`,vx=`#ifdef USE_FOG
varying float vFogDepth;
#endif`,_x=`#ifdef USE_FOG
#ifdef FOG_EXP2
float fogFactor = 1.0 - exp(-fogDensity * fogDensity * vFogDepth * vFogDepth);
#else
float fogFactor = smoothstep(fogNear, fogFar, vFogDepth);
#endif
gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, fogFactor);
#endif`,Ax=`#ifdef USE_FOG
uniform vec3 fogColor;
varying float vFogDepth;
#ifdef FOG_EXP2
uniform float fogDensity;
#else
uniform float fogNear;
uniform float fogFar;
#endif
#endif`,xx=`#ifdef USE_GRADIENTMAP
uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance(vec3 normal, vec3 lightDirection) {
float dotNL = dot(normal, lightDirection);
vec2 coord = vec2(dotNL * 0.5 + 0.5, 0.0);
#ifdef USE_GRADIENTMAP
return vec3(texture2D(gradientMap, coord).r);
#else
vec2 fw = fwidth(coord) * 0.5;
return mix(vec3(0.7), vec3(1.0), smoothstep(0.7 - fw.x, 0.7 + fw.x, coord.x));
#endif
}`,yx=`#ifdef USE_LIGHTMAP
vec4 lightMapTexel = texture2D(lightMap, vUv2);
vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,bx=`#ifdef USE_LIGHTMAP
uniform sampler2D lightMap;
uniform float lightMapIntensity;
#endif`,Cx=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Sx=`varying vec3 vViewPosition;
struct LambertMaterial {
vec3 diffuseColor;
float specularStrength;
};
void RE_Direct_Lambert(const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight) {
float dotNL = saturate(dot(geometry.normal, directLight.direction));
vec3 irradiance = dotNL * directLight.color;
reflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
void RE_IndirectDiffuse_Lambert(const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight) {
reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
#define RE_Direct RE_Direct_Lambert
#define RE_IndirectDiffuse RE_IndirectDiffuse_Lambert`,Mx=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[9];
vec3 shGetIrradianceAt(in vec3 normal, in vec3 shCoefficients[9]) {
float x = normal.x, y = normal.y, z = normal.z;
vec3 result = shCoefficients[0] * 0.886227;
result += shCoefficients[1] * 2.0 * 0.511664 * y;
result += shCoefficients[2] * 2.0 * 0.511664 * z;
result += shCoefficients[3] * 2.0 * 0.511664 * x;
result += shCoefficients[4] * 2.0 * 0.429043 * x * y;
result += shCoefficients[5] * 2.0 * 0.429043 * y * z;
result += shCoefficients[6] * (0.743125 * z * z - 0.247708);
result += shCoefficients[7] * 2.0 * 0.429043 * x * z;
result += shCoefficients[8] * 0.429043 * (x * x - y * y);
return result;
}
vec3 getLightProbeIrradiance(const in vec3 lightProbe[9], const in vec3 normal) {
vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);
vec3 irradiance = shGetIrradianceAt(worldNormal, lightProbe);
return irradiance;
}
vec3 getAmbientLightIrradiance(const in vec3 ambientLightColor) {
vec3 irradiance = ambientLightColor;
return irradiance;
}
float getDistanceAttenuation(float lightDistance, const in float cutoffDistance, const in float decayExponent) {
#if defined (PHYSICALLY_CORRECT_LIGHTS)
lightDistance = UNITS_SCALE_FACTOR * lightDistance;
#ifdef MT_MAYA
float distanceFalloff = 1.0 / pow(lightDistance + 1.0, decayExponent);
#else
float distanceFalloff = 1.0 / max(pow(lightDistance, decayExponent), 0.01);
#endif
if (cutoffDistance > 0.0) {
distanceFalloff *= pow2(saturate(1.0 - pow4(lightDistance / (UNITS_SCALE_FACTOR * cutoffDistance))));
}
return distanceFalloff;
#else
if (cutoffDistance > 0.0 && decayExponent > 0.0) {
return pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);
}
return 1.0;
#endif
}
float getSpotAttenuation(const in float coneCosine, const in float penumbraCosine, const in float angleCosine) {
return smoothstep(coneCosine, penumbraCosine, angleCosine);
}
#if NUM_DIR_LIGHTS > 0
struct DirectionalLight {
vec3 direction;
vec3 color;
};
uniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];
void getDirectionalLightInfo(const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light) {
light.color = directionalLight.color;
light.direction = directionalLight.direction;
light.visible = true;
}
#endif
#if NUM_POINT_LIGHTS > 0
struct PointLight {
vec3 position;
vec3 color;
float distance;
float decay;
};
uniform PointLight pointLights[NUM_POINT_LIGHTS];
void getPointLightInfo(const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light) {
vec3 lVector = pointLight.position - geometry.position;
light.direction = normalize(lVector);
float lightDistance = length(lVector);
light.color = pointLight.color;
light.color *= getDistanceAttenuation(lightDistance, pointLight.distance, pointLight.decay);
light.visible = (light.color != vec3(0.0));
}
#endif
#if NUM_SPOT_LIGHTS > 0
struct SpotLight {
vec3 position;
vec3 direction;
vec3 color;
float distance;
float decay;
float coneCos;
float penumbraCos;
};
uniform SpotLight spotLights[NUM_SPOT_LIGHTS];
void getSpotLightInfo(const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light) {
vec3 lVector = spotLight.position - geometry.position;
light.direction = normalize(lVector);
float angleCos = dot(light.direction, spotLight.direction);
#if defined(MT_MAX) && defined(PHYSICALLY_CORRECT_LIGHTS)
float coneCosDecayed = 2.0 * spotLight.coneCos - spotLight.penumbraCos;
if (angleCos > coneCosDecayed) {
float spotAttenuation = pow(max(angleCos, 0.0), log(0.5) / log(spotLight.penumbraCos) - 1.0);
if (angleCos < spotLight.coneCos) {
float decayFac = 1.0 + (spotLight.coneCos - angleCos)
/ (spotLight.coneCos - spotLight.penumbraCos);
spotAttenuation *= pow2(decayFac) * (3.0 - 2.0 * decayFac);
}
float lightDistance = length(lVector);
light.color = spotLight.color * spotAttenuation;
light.color *= getDistanceAttenuation(lightDistance, spotLight.distance, spotLight.decay);
light.visible = true;
} else {
light.color = vec3(0.0);
light.visible = false;
}
#else
float spotAttenuation = getSpotAttenuation(spotLight.coneCos, spotLight.penumbraCos, angleCos);
if (spotAttenuation > 0.0) {
float lightDistance = length(lVector);
light.color = spotLight.color * spotAttenuation;
light.color *= getDistanceAttenuation(lightDistance, spotLight.distance, spotLight.decay);
light.visible = true;
} else {
light.color = vec3(0.0);
light.visible = false;
}
#endif
}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
struct RectAreaLight {
vec3 color;
vec3 position;
vec3 halfWidth;
vec3 halfHeight;
};
uniform sampler2D ltc_1;
uniform sampler2D ltc_2;
uniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];
#endif
#if NUM_HEMI_LIGHTS > 0
struct HemisphereLight {
vec3 direction;
vec3 skyColor;
vec3 groundColor;
};
uniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];
vec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight, const in vec3 normal) {
float dotNL = dot(normal, hemiLight.direction);
float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
vec3 irradiance = mix(hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight);
return irradiance;
}
#endif`,Ex=`#if defined(USE_ENVMAP)
#define ENVMAP_PARALLAX_INFINITE 0
#define ENVMAP_PARALLAX_SPHERE 1
#define ENVMAP_PARALLAX_BOX 2
uniform int envMapParallaxType;
uniform mat4 envMapParallaxMatrix;
uniform mat4 envMapParallaxMatrixInv;
vec3 correctParallax(vec3 directionVecWorld, vec3 posWorld, int parallaxType) {
vec3 posProbe = (envMapParallaxMatrix * vec4(posWorld, 1.0)).xyz;
vec3 reflectVecProbe = transformDirection(directionVecWorld, envMapParallaxMatrix);
if (parallaxType == ENVMAP_PARALLAX_SPHERE) {
float b = 2.0 * dot(reflectVecProbe, posProbe);
float c = dot(posProbe, posProbe) - 1.0;
float D = b * b - 4.0 * c;
if (D >= 0.0) {
float x = (sqrt(D) - b) / 2.0;
reflectVecProbe = posProbe + x * reflectVecProbe;
}
} else if (parallaxType == ENVMAP_PARALLAX_BOX) {
vec3 scalePos = (vec3(1.0) - posProbe) / reflectVecProbe;
vec3 scaleNeg = (vec3(-1.0) - posProbe) / reflectVecProbe;
vec3 scalePosNeg = mix(scaleNeg, scalePos, step(vec3(0.0), reflectVecProbe));
float x = min(scalePosNeg.x, min(scalePosNeg.y, scalePosNeg.z));
reflectVecProbe = posProbe + x * reflectVecProbe;
}
vec3 directionVecWorldCorrected = transformDirection(reflectVecProbe,
envMapParallaxMatrixInv);
return directionVecWorldCorrected;
}
vec3 getIBLIrradiance(const in vec3 normal) {
#if defined(ENVMAP_TYPE_CUBE_UV)
vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);
vec4 envMapColor = textureCubeUV(envMap, worldNormal, 1.0);
return PI * envMapColor.rgb * envMapIntensity;
#else
return vec3(0.0);
#endif
}
vec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness, vec3 position) {
#if defined(ENVMAP_TYPE_CUBE_UV)
vec3 reflectVec = reflect(-viewDir, normal);
reflectVec = inverseTransformDirection(reflectVec, viewMatrix);
if (envMapParallaxType != ENVMAP_PARALLAX_INFINITE) {
vec3 posWorld = (invViewMatrix * vec4(position, 1.0)).xyz;
reflectVec = correctParallax(reflectVec, posWorld, envMapParallaxType);
}
vec4 envMapColor = textureCubeUV(envMap, reflectVec, roughness);
return envMapColor.rgb * envMapIntensity;
#else
return vec3(0.0);
#endif
}
vec3 getIBLRefraction(const in vec3 viewDir, const in vec3 normal, const in float roughness, const float refrRatio, vec3 position) {
#if defined(ENVMAP_TYPE_CUBE_UV)
vec3 refractVec = refract(-viewDir, normal, refrRatio);
refractVec = inverseTransformDirection(refractVec, viewMatrix);
if (envMapParallaxType != ENVMAP_PARALLAX_INFINITE) {
vec3 posWorld = (invViewMatrix * vec4(position, 1.0)).xyz;
refractVec = correctParallax(refractVec, posWorld, envMapParallaxType);
}
vec4 envMapColor = textureCubeUV(envMap, refractVec, roughness);
return envMapColor.rgb * envMapIntensity;
#else
return vec3(0.0);
#endif
}
#endif`,wx=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Tx=`varying vec3 vViewPosition;
struct ToonMaterial {
vec3 diffuseColor;
};
void RE_Direct_Toon(const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight) {
vec3 irradiance = getGradientIrradiance(geometry.normal, directLight.direction) * directLight.color;
reflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
void RE_IndirectDiffuse_Toon(const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight) {
reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
#define RE_Direct RE_Direct_Toon
#define RE_IndirectDiffuse RE_IndirectDiffuse_Toon`,Ix=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Rx=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
vec3 diffuseColor;
vec3 specularColor;
float specularShininess;
float specularStrength;
};
void RE_Direct_BlinnPhong(const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight) {
float dotNL = saturate(dot(geometry.normal, directLight.direction));
vec3 irradiance = dotNL * directLight.color;
reflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong(directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong(const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight) {
reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
#define RE_Direct RE_Direct_BlinnPhong
#define RE_IndirectDiffuse RE_IndirectDiffuse_BlinnPhong`,Lx=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * (1.0 - metalnessFactor);
vec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));
float geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
material.roughness = max(roughnessFactor, 0.0525);
material.roughness += geometryRoughness;
material.roughness = min(material.roughness, 1.0);
#ifdef IOR
material.ior = ior;
#ifdef SPECULAR
float specularIntensityFactor = specularIntensity;
vec3 specularColorFactor = specularColor;
#ifdef USE_SPECULARINTENSITYMAP
specularIntensityFactor *= texture2D(specularIntensityMap, vUv).a;
#endif
#ifdef USE_SPECULARCOLORMAP
specularColorFactor *= texture2D(specularColorMap, vUv).rgb;
#endif
material.specularF90 = mix(specularIntensityFactor, 1.0, metalnessFactor);
#else
float specularIntensityFactor = 1.0;
vec3 specularColorFactor = vec3(1.0);
material.specularF90 = 1.0;
#endif
material.specularColor = mix(min(pow2((material.ior - 1.0) / (material.ior + 1.0)) * specularColorFactor, vec3(1.0)) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor);
#else
material.specularColor = mix(vec3(0.04), diffuseColor.rgb, metalnessFactor);
material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
material.clearcoat = clearcoat;
material.clearcoatRoughness = clearcoatRoughness;
material.clearcoatF0 = vec3(0.04);
material.clearcoatF90 = 1.0;
#ifdef USE_CLEARCOATMAP
material.clearcoat *= texture2D(clearcoatMap, vUv).x;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
material.clearcoatRoughness *= texture2D(clearcoatRoughnessMap, vUv).y;
#endif
material.clearcoat = saturate(material.clearcoat);
material.clearcoatRoughness = max(material.clearcoatRoughness, 0.0525);
material.clearcoatRoughness += geometryRoughness;
material.clearcoatRoughness = min(material.clearcoatRoughness, 1.0);
#endif
#ifdef USE_IRIDESCENCE
material.iridescence = iridescence;
material.iridescenceIOR = iridescenceIOR;
#ifdef USE_IRIDESCENCEMAP
material.iridescence *= texture2D(iridescenceMap, vUv).r;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D(iridescenceThicknessMap, vUv).g + iridescenceThicknessMinimum;
#else
material.iridescenceThickness = iridescenceThicknessMaximum;
#endif
#endif
#ifdef USE_SHEEN
material.sheenColor = sheenColor;
#ifdef USE_SHEENCOLORMAP
material.sheenColor *= texture2D(sheenColorMap, vUv).rgb;
#endif
material.sheenRoughness = clamp(sheenRoughness, 0.07, 1.0);
#ifdef USE_SHEENROUGHNESSMAP
material.sheenRoughness *= texture2D(sheenRoughnessMap, vUv).a;
#endif
#endif`,Px=`struct PhysicalMaterial {
vec3 diffuseColor;
float roughness;
vec3 specularColor;
float specularF90;
#ifdef USE_CLEARCOAT
float clearcoat;
float clearcoatRoughness;
vec3 clearcoatF0;
float clearcoatF90;
#endif
#ifdef USE_IRIDESCENCE
float iridescence;
float iridescenceIOR;
float iridescenceThickness;
vec3 iridescenceFresnel;
vec3 iridescenceF0;
#endif
#ifdef USE_SHEEN
vec3 sheenColor;
float sheenRoughness;
#endif
#ifdef IOR
float ior;
#endif
#ifdef USE_TRANSMISSION
float transmission;
float transmissionAlpha;
float thickness;
float attenuationDistance;
vec3 attenuationColor;
#endif
};
vec3 clearcoatSpecular = vec3(0.0);
vec3 sheenSpecular = vec3(0.0);
float IBLSheenBRDF(const in vec3 normal, const in vec3 viewDir, const in float roughness) {
float dotNV = saturate(dot(normal, viewDir));
float r2 = roughness * roughness;
float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
float DG = exp(a * dotNV + b) + (roughness < 0.25 ? 0.0 : 0.1 * (roughness - 0.25));
return saturate(DG * RECIPROCAL_PI);
}
vec2 DFGApprox(const in vec3 normal, const in vec3 viewDir, const in float roughness) {
float dotNV = saturate(dot(normal, viewDir));
const vec4 c0 = vec4(- 1, -0.0275, -0.572, 0.022);
const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(- 9.28 * dotNV)) * r.x + r.y;
vec2 fab = vec2(- 1.04, 1.04) * a004 + r.zw;
return fab;
}
vec3 EnvironmentBRDF(const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness) {
vec2 fab = DFGApprox(normal, viewDir, roughness);
return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence(const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter) {
#else
void computeMultiscattering(const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter) {
#endif
vec2 fab = DFGApprox(normal, viewDir, roughness);
#ifdef USE_IRIDESCENCE
vec3 Fr = mix(specularColor, iridescenceF0, iridescence);
#else
vec3 Fr = specularColor;
#endif
vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
float Ess = fab.x + fab.y;
float Ems = 1.0 - Ess;
vec3 Favg = Fr + (1.0 - Fr) * 0.047619;
vec3 Fms = FssEss * Favg / (1.0 - Ems * Favg);
singleScatter += FssEss;
multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
void RE_Direct_RectArea_Physical(const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
vec3 normal = geometry.normal;
vec3 viewDir = geometry.viewDir;
vec3 position = geometry.position;
vec3 lightPos = rectAreaLight.position;
vec3 halfWidth = rectAreaLight.halfWidth;
vec3 halfHeight = rectAreaLight.halfHeight;
vec3 lightColor = rectAreaLight.color;
float roughness = material.roughness;
vec3 rectCoords[4];
rectCoords[0] = lightPos + halfWidth - halfHeight;
rectCoords[1] = lightPos - halfWidth - halfHeight;
rectCoords[2] = lightPos - halfWidth + halfHeight;
rectCoords[3] = lightPos + halfWidth + halfHeight;
vec2 uv = LTC_Uv(normal, viewDir, roughness);
vec4 t1 = texture2D(ltc_1, uv);
vec4 t2 = texture2D(ltc_2, uv);
mat3 mInv = mat3(
vec3(t1.x, 0, t1.y),
vec3( 0, 1, 0),
vec3(t1.z, 0, t1.w)
);
vec3 fresnel = (material.specularColor * t2.x + (vec3(1.0) - material.specularColor) * t2.y);
reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate(normal, viewDir, position, mInv, rectCoords);
reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate(normal, viewDir, position, mat3(1.0), rectCoords);
}
#endif
void RE_Direct_Physical(const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
float dotNL = saturate(dot(geometry.normal, directLight.direction));
vec3 irradiance = dotNL * directLight.color;
#ifdef USE_CLEARCOAT
float dotNLcc = saturate(dot(geometry.clearcoatNormal, directLight.direction));
vec3 ccIrradiance = dotNLcc * directLight.color;
clearcoatSpecular += ccIrradiance * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness);
#endif
#ifdef USE_SHEEN
sheenSpecular += irradiance * BRDF_Sheen(directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness);
#endif
#ifdef USE_IRIDESCENCE
reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence(directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness);
#else
reflectedLight.directSpecular += irradiance * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness);
#endif
reflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
void RE_IndirectDiffuse_Physical(const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
void RE_IndirectSpecular_Physical(const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
#ifdef USE_CLEARCOAT
clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF(geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness);
#endif
#ifdef USE_SHEEN
sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF(geometry.normal, geometry.viewDir, material.sheenRoughness);
#endif
vec3 singleScattering = vec3(0.0);
vec3 multiScattering = vec3(0.0);
vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
#ifdef USE_IRIDESCENCE
computeMultiscatteringIridescence(geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering);
#else
computeMultiscattering(geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering);
#endif
vec3 totalScattering = singleScattering + multiScattering;
vec3 diffuse = material.diffuseColor * (1.0 - max(max(totalScattering.r, totalScattering.g), totalScattering.b));
reflectedLight.indirectSpecular += radiance * singleScattering;
reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct RE_Direct_Physical
#define RE_Direct_RectArea RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular RE_IndirectSpecular_Physical
float computeSpecularOcclusion(const in float dotNV, const in float ambientOcclusion, const in float roughness) {
return saturate(pow(abs(dotNV + ambientOcclusion), exp2(- 16.0 * roughness - 1.0)) - 1.0 + ambientOcclusion);
}`,Bx=`
GeometricContext geometry;
geometry.position = -vViewPosition;
geometry.normal = normal;
geometry.viewDir = (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition);
#ifdef USE_CLEARCOAT
geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef PROBE_NORMAL
geometry.probeNormal = PROBE_NORMAL;
#else
geometry.probeNormal = normal;
#endif
#ifdef USE_IRIDESCENCE
float dotNVi = saturate(dot(normal, geometry.viewDir));
if (material.iridescenceThickness == 0.0) {
material.iridescence = 0.0;
} else {
material.iridescence = saturate(material.iridescence);
}
if (material.iridescence > 0.0) {
material.iridescenceFresnel = evalIridescence(1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor);
material.iridescenceF0 = Schlick_to_F0(material.iridescenceFresnel, 1.0, dotNVi);
}
#endif
IncidentLight directLight;
#if (NUM_POINT_LIGHTS > 0) && defined(RE_Direct)
PointLight pointLight;
#if defined(USE_SHADOWMAP) && NUM_POINT_LIGHT_SHADOWS > 0
PointLightShadow pointLightShadow;
#endif
#pragma unroll_loop_start
for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
pointLight = pointLights[i];
getPointLightInfo(pointLight, geometry, directLight);
#if defined(USE_SHADOWMAP) && ((i) < NUM_POINT_LIGHT_SHADOWS)
pointLightShadow = pointLightShadows[i];
directLight.color *= (directLight.visible && receiveShadow) ? getPointShadow(pointLightShadow, pointShadowMap[i], vPointShadowCoord[i]) : 1.0;
#endif
RE_Direct(directLight, geometry, material, reflectedLight);
}
#pragma unroll_loop_end
#endif
#if (NUM_SPOT_LIGHTS > 0) && defined(RE_Direct)
SpotLight spotLight;
vec4 spotColor;
vec3 spotLightCoord;
bool inSpotLightMap;
#if defined(USE_SHADOWMAP) && NUM_SPOT_LIGHT_SHADOWS > 0
SpotLightShadow spotLightShadow;
#endif
#pragma unroll_loop_start
for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
spotLight = spotLights[i];
getSpotLightInfo(spotLight, geometry, directLight);
#if defined(USE_SHADOWMAP) && ((i) < NUM_SPOT_LIGHT_SHADOWS)
spotLightShadow = spotLightShadows[i];
if (directLight.visible && receiveShadow) {
if (spotLightShadow.shadow == 1) {
float distWorld = 0.0;
#if defined(SHADOWMAP_TYPE_ESM)
distWorld = length((invViewMatrix * vec4(spotLight.position
- geometry.position, 0.0)).xyz);
#endif
directLight.color *= getSpotShadow(spotLightShadow, spotShadowMap[i],
vSpotLightCoord[i], distWorld);
} else if (spotLightShadow.shadow == 2) {
directLight.color *= getSpotOmniShadow(spotLightShadow,
spotShadowMap[i], vSpotLightCoord[i]);
}
}
#endif
RE_Direct(directLight, geometry, material, reflectedLight);
}
#pragma unroll_loop_end
#endif
#if (NUM_DIR_LIGHTS > 0) && defined(RE_Direct)
DirectionalLight directionalLight;
#if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS_CSM > 0
DirectionalLightShadowCSM directionalLightShadowCSM;
DirectionalLightShadowCascade dirShadowCascade;
vec2 cascade;
float cascadeCenter;
float closestEdge;
float margin;
float csmx, csmy;
float linearDepth;
int maxCascadeIdx;
#pragma unroll_loop_start
for (int i = 0; i < NUM_DIR_LIGHT_SHADOW_CASCADES_CSM; i++) {
dirShadowCascade = directionalLightShadowsCSMCascade[i];
#if defined(LUT_DIR_LIGHT_SHADOWS_CSM)
directionalLightShadowCSM = directionalLightShadowsCSM[LUT_DIR_LIGHT_SHADOWS_CSM[i]];
directionalLight = directionalLights[LUT_DIR_LIGHT_SHADOWS_CSM[i]];
getDirectionalLightInfo(directionalLight, geometry, directLight);
#else
if (dirShadowCascade.csmIdx == 0) {
directionalLightShadowCSM = directionalLightShadowsCSM[0];
directionalLight = directionalLights[0];
getDirectionalLightInfo(directionalLight, geometry, directLight);
}
#if NUM_DIR_LIGHT_SHADOWS_CSM >= 2
else if (dirShadowCascade.csmIdx == 1) {
directionalLightShadowCSM = directionalLightShadowsCSM[1];
directionalLight = directionalLights[1];
getDirectionalLightInfo(directionalLight, geometry, directLight);
}
#endif
#if NUM_DIR_LIGHT_SHADOWS_CSM >= 3
else if (dirShadowCascade.csmIdx == 2) {
directionalLightShadowCSM = directionalLightShadowsCSM[2];
directionalLight = directionalLights[2];
getDirectionalLightInfo(directionalLight, geometry, directLight);
}
#endif
#if NUM_DIR_LIGHT_SHADOWS_CSM >= 4
else if (dirShadowCascade.csmIdx == 3) {
directionalLightShadowCSM = directionalLightShadowsCSM[3];
directionalLight = directionalLights[3];
getDirectionalLightInfo(directionalLight, geometry, directLight);
}
#endif
#if NUM_DIR_LIGHT_SHADOWS_CSM >= 5
else if (dirShadowCascade.csmIdx == 4) {
directionalLightShadowCSM = directionalLightShadowsCSM[4];
directionalLight = directionalLights[4];
getDirectionalLightInfo(directionalLight, geometry, directLight);
}
#endif
#endif
maxCascadeIdx = directionalLightShadowCSM.cascadeIdxEnd;
linearDepth = (vViewPosition.z) / (directionalLightShadowCSM.shadowFar - directionalLightShadowCSM.cameraNear);
cascade = dirShadowCascade.cascade;
#if (i) < NUM_DIR_LIGHT_SHADOWS_CSM_WITH_FADE
cascadeCenter = (cascade.x + cascade.y) / 2.0;
closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
margin = directionalLightShadowCSM.fade * pow(closestEdge, 2.0);
csmx = cascade.x - margin / 2.0;
csmy = cascade.y + margin / 2.0;
if (linearDepth >= csmx && (linearDepth < csmy || (i) == maxCascadeIdx - 1)) {
float dist = min(linearDepth - csmx, csmy - linearDepth);
float ratio = clamp(dist / margin, 0.0, 1.0);
vec3 prevColor = directLight.color;
float distWorld = 0.0;
#if defined(SHADOWMAP_TYPE_ESM)
distWorld = length((invViewMatrix * vec4(dirShadowCascade.position
- directionalLight.direction * dirShadowCascade.shadowCameraNear
- geometry.position, 0.0)).xyz);
#endif
directLight.color *= (directLight.visible && receiveShadow) ?
getDirShadowCSM(dirShadowCascade, directionalShadowCSMMap[i], vDirectionalShadowCSMCoord[i], distWorld)
: 1.0;
bool shouldFadeLastCascade = (i) == maxCascadeIdx - 1 && linearDepth > cascadeCenter;
directLight.color = mix(prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0);
ReflectedLight prevLight = reflectedLight;
RE_Direct(directLight, geometry, material, reflectedLight);
bool shouldBlend = (i) != maxCascadeIdx - 1 || ((i) == maxCascadeIdx - 1 && linearDepth < cascadeCenter);
float blendRatio = shouldBlend ? ratio : 1.0;
reflectedLight.directDiffuse = mix(prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio);
reflectedLight.directSpecular = mix(prevLight.directSpecular, reflectedLight.directSpecular, blendRatio);
reflectedLight.indirectDiffuse = mix(prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio);
reflectedLight.indirectSpecular = mix(prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio);
}
#else
if (linearDepth >= cascade.x && (linearDepth < cascade.y || (i) == maxCascadeIdx - 1)) {
if (directLight.visible && receiveShadow) {
float distWorld = 0.0;
#if defined(SHADOWMAP_TYPE_ESM)
distWorld = length((invViewMatrix * vec4(dirShadowCascade.position
- directionalLight.direction * dirShadowCascade.shadowCameraNear
- geometry.position, 0.0)).xyz);
#endif
directLight.color *= getDirShadowCSM(dirShadowCascade, directionalShadowCSMMap[i], vDirectionalShadowCSMCoord[i], distWorld);
}
RE_Direct(directLight, geometry, material, reflectedLight);
}
#endif
}
#pragma unroll_loop_end
#endif
#pragma unroll_loop_start
for (int i = NUM_DIR_LIGHT_SHADOWS_CSM; i < NUM_DIR_LIGHTS; i++) {
directionalLight = directionalLights[i];
getDirectionalLightInfo(directionalLight, geometry, directLight);
RE_Direct(directLight, geometry, material, reflectedLight);
}
#pragma unroll_loop_end
#endif
#if (NUM_RECT_AREA_LIGHTS > 0) && defined(RE_Direct_RectArea)
RectAreaLight rectAreaLight;
#if defined(USE_SHADOWMAP) && NUM_RECT_AREA_LIGHT_SHADOWS > 0
RectAreaLightShadow rectAreaLightShadow;
#endif
#pragma unroll_loop_start
for (int i = 0; i < NUM_RECT_AREA_LIGHTS; i++) {
rectAreaLight = rectAreaLights[i];
#if defined(USE_SHADOWMAP) && ((i) < NUM_RECT_AREA_LIGHT_SHADOWS)
rectAreaLightShadow = rectAreaLightShadows[i];
rectAreaLight.color *= receiveShadow ?
getRectAreaShadow(rectAreaLightShadow, rectAreaShadowMap[i], vRectAreaShadowCoord[i]) : 1.0;
#endif
RE_Direct_RectArea(rectAreaLight, geometry, material, reflectedLight);
}
#pragma unroll_loop_end
#endif
#if defined(RE_IndirectDiffuse)
vec3 iblIrradiance = vec3(0.0);
vec3 irradiance = getAmbientLightIrradiance(ambientLightColor);
irradiance += getLightProbeIrradiance(lightProbe, geometry.probeNormal);
#if (NUM_HEMI_LIGHTS > 0)
#pragma unroll_loop_start
for (int i = 0; i < NUM_HEMI_LIGHTS; i++) {
irradiance += getHemisphereLightIrradiance(hemisphereLights[i], geometry.probeNormal);
}
#pragma unroll_loop_end
#endif
#endif
#if defined(RE_IndirectSpecular)
vec3 radiance = vec3(0.0);
vec3 clearcoatRadiance = vec3(0.0);
#endif
#if defined(RE_Refraction)
vec3 refraction = vec3(0.0);
#endif`,Dx=`#if defined(RE_IndirectDiffuse)
#ifdef USE_LIGHTMAP
vec4 lightMapTexel = texture2D(lightMap, vUv2);
vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
irradiance += lightMapIrradiance;
#endif
#if defined(USE_ENVMAP) && defined(STANDARD) && defined(ENVMAP_TYPE_CUBE_UV)
iblIrradiance += getIBLIrradiance(geometry.probeNormal);
#endif
#endif
#if defined(USE_ENVMAP) && defined(RE_IndirectSpecular)
radiance += getIBLRadiance(geometry.viewDir, geometry.normal, material.roughness, geometry.position);
#if defined(USE_SSR) && !defined(USE_SSR_REFRACT)
radiance = computeSSR(radiance, geometry.normal, 0.0);
#endif
#if defined(USE_PLANE_REFLECTION)
radiance = computePlaneReflection(radiance, material.roughness, geometry.position, geometry.normal, modelMatrix);
#endif
#ifdef USE_CLEARCOAT
clearcoatRadiance += getIBLRadiance(geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, geometry.position);
#endif
#endif
#if defined(USE_ENVMAP) && defined(RE_Refraction)
refraction += getIBLRefraction(geometry.viewDir, geometry.normal, material.refractionRoughness, 1.0 / material.refractionIOR, geometry.position);
#ifdef USE_SSR_REFRACT
refraction = computeSSR(refraction, geometry.normal, material.refractionIOR);
#endif
#endif`,Nx=`#if defined(RE_IndirectDiffuse)
#ifdef NODE
irradiance += iblIrradiance;
#endif
RE_IndirectDiffuse(irradiance, geometry, material, reflectedLight);
#endif
#if defined(RE_IndirectSpecular)
RE_IndirectSpecular(radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight);
#endif
#if defined(RE_Refraction)
RE_Refraction(refraction, material, refractedLight);
#endif`,Ox=`#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2(vFragDepth) * logDepthBufFC * 0.5;
#endif`,Fx=`#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
uniform float logDepthBufFC;
varying float vFragDepth;
varying float vIsPerspective;
#endif`,Ux=`#ifdef USE_LOGDEPTHBUF
#ifdef USE_LOGDEPTHBUF_EXT
varying float vFragDepth;
varying float vIsPerspective;
#else
uniform float logDepthBufFC;
#endif
#endif`,zx=`#ifdef USE_LOGDEPTHBUF
#ifdef USE_LOGDEPTHBUF_EXT
vFragDepth = 1.0 + gl_Position.w;
vIsPerspective = float(isPerspectiveMatrix(projectionMatrix));
#else
if (isPerspectiveMatrix(projectionMatrix)) {
gl_Position.z = log2(max(EPSILON, gl_Position.w + 1.0)) * logDepthBufFC - 1.0;
gl_Position.z *= gl_Position.w;
}
#endif
#endif`,Vx=`#ifdef USE_MAP
vec4 sampledDiffuseColor = texture2D(map, vUv);
#ifdef DECODE_VIDEO_TEXTURE
sampledDiffuseColor = vec4(mix(pow(sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(sampledDiffuseColor.rgb, vec3(0.04045)))), sampledDiffuseColor.w);
#endif
diffuseColor *= sampledDiffuseColor;
#endif`,Gx=`#ifdef USE_MAP
uniform sampler2D map;
#endif`,kx=`#if defined(USE_MAP) || defined(USE_ALPHAMAP)
vec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy;
#endif
#ifdef USE_MAP
diffuseColor *= texture2D(map, uv);
#endif
#ifdef USE_ALPHAMAP
diffuseColor.a *= texture2D(alphaMap, uv).g;
#endif`,Qx=`#if defined(USE_MAP) || defined(USE_ALPHAMAP)
uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
uniform sampler2D alphaMap;
#endif`,Wx=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
vec4 texelMetalness = texture2D(metalnessMap, vUv);
metalnessFactor *= texelMetalness.b;
#endif`,Hx=`#ifdef USE_METALNESSMAP
uniform sampler2D metalnessMap;
#endif`,Xx=`#if defined(USE_MORPHCOLORS) && defined(MORPHTARGETS_TEXTURE)
vColor *= morphTargetBaseInfluence;
for (int i = 0; i < MORPHTARGETS_COUNT; i++) {
#if defined(USE_COLOR_ALPHA)
if (morphTargetInfluences[i] != 0.0) vColor += getMorph(gl_VertexID, i, 2) * morphTargetInfluences[i];
#elif defined(USE_COLOR)
if (morphTargetInfluences[i] != 0.0) vColor += getMorph(gl_VertexID, i, 2).rgb * morphTargetInfluences[i];
#endif
}
#endif`,Yx=`#ifdef USE_MORPHNORMALS
objectNormal *= morphTargetBaseInfluence;
#ifdef MORPHTARGETS_TEXTURE
for (int i = 0; i < MORPHTARGETS_COUNT; i++) {
if (morphTargetInfluences[i] != 0.0) objectNormal += getMorph(gl_VertexID, i, 1).xyz * morphTargetInfluences[i];
}
#else
#if MORPHTARGETS_COUNT > 0
objectNormal += morphNormal0 * morphTargetInfluences[0];
#endif
#if MORPHTARGETS_COUNT > 1
objectNormal += morphNormal1 * morphTargetInfluences[1];
#endif
#if MORPHTARGETS_COUNT > 2
objectNormal += morphNormal2 * morphTargetInfluences[2];
#endif
#if MORPHTARGETS_COUNT > 3
objectNormal += morphNormal3 * morphTargetInfluences[3];
#endif
#if MORPHTARGETS_COUNT > 4
objectNormal += morphNormal4 * morphTargetInfluences[4];
#endif
#if MORPHTARGETS_COUNT > 5
objectNormal += morphNormal5 * morphTargetInfluences[5];
#endif
#endif
#endif`,jx=`#ifdef USE_MORPHTARGETS
uniform float morphTargetBaseInfluence;
#ifdef MORPHTARGETS_TEXTURE
uniform float morphTargetInfluences[MORPHTARGETS_COUNT];
uniform sampler2DArray morphTargetsTexture;
uniform ivec2 morphTargetsTextureSize;
vec4 getMorph(const in int vertexIndex, const in int morphTargetIndex, const in int offset) {
int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
int y = texelIndex / morphTargetsTextureSize.x;
int x = texelIndex - y * morphTargetsTextureSize.x;
ivec3 morphUV = ivec3(x, y, morphTargetIndex);
return texelFetch(morphTargetsTexture, morphUV, 0);
}
#else
#ifndef USE_MORPHNORMALS
uniform float morphTargetInfluences[12];
#else
uniform float morphTargetInfluences[6];
#endif
#endif
#endif`,Kx=`#ifdef USE_MORPHTARGETS
transformed *= morphTargetBaseInfluence;
#ifdef MORPHTARGETS_TEXTURE
for (int i = 0; i < MORPHTARGETS_COUNT; i++) {
if (morphTargetInfluences[i] != 0.0) transformed += getMorph(gl_VertexID, i, 0).xyz * morphTargetInfluences[i];
}
#else
#if MORPHTARGETS_COUNT > 0
transformed += morphTarget0 * morphTargetInfluences[0];
#endif
#if MORPHTARGETS_COUNT > 1
transformed += morphTarget1 * morphTargetInfluences[1];
#endif
#if MORPHTARGETS_COUNT > 2
transformed += morphTarget2 * morphTargetInfluences[2];
#endif
#if MORPHTARGETS_COUNT > 3
transformed += morphTarget3 * morphTargetInfluences[3];
#endif
#if MORPHTARGETS_COUNT > 4
transformed += morphTarget4 * morphTargetInfluences[4];
#endif
#if MORPHTARGETS_COUNT > 5
transformed += morphTarget5 * morphTargetInfluences[5];
#endif
#ifndef USE_MORPHNORMALS
#if MORPHTARGETS_COUNT > 6
transformed += morphTarget6 * morphTargetInfluences[6];
#endif
#if MORPHTARGETS_COUNT > 7
transformed += morphTarget7 * morphTargetInfluences[7];
#endif
#if MORPHTARGETS_COUNT > 8
transformed += morphTarget8 * morphTargetInfluences[8];
#endif
#if MORPHTARGETS_COUNT > 9
transformed += morphTarget9 * morphTargetInfluences[9];
#endif
#if MORPHTARGETS_COUNT > 10
transformed += morphTarget10 * morphTargetInfluences[10];
#endif
#if MORPHTARGETS_COUNT > 11
transformed += morphTarget1 * morphTargetInfluences[11];
#endif
#endif
#endif
#endif`,qx=`float faceDirection = gl_FrontFacing ? 1.0 : -1.0;
#ifdef FLAT_SHADED
vec3 fdx = dFdx(vViewPosition);
vec3 fdy = dFdy(vViewPosition);
vec3 normal = normalize(cross(fdx, fdy));
#else
vec3 normal = normalize(vNormal);
#ifdef DOUBLE_SIDED
normal = normal * faceDirection;
#endif
#ifdef USE_TANGENT
vec3 tangent = normalize(vTangent);
vec3 bitangent = normalize(vBitangent);
#ifdef DOUBLE_SIDED
tangent = tangent * faceDirection;
bitangent = bitangent * faceDirection;
#endif
#if defined(TANGENTSPACE_NORMALMAP) || defined(USE_CLEARCOAT_NORMALMAP)
mat3 vTBN = mat3(tangent, bitangent, normal);
#endif
#endif
#endif
vec3 geometryNormal = normal;`,Zx=`#ifdef OBJECTSPACE_NORMALMAP
normal = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;
#ifdef FLIP_SIDED
normal = -normal;
#endif
#ifdef DOUBLE_SIDED
normal = normal * faceDirection;
#endif
normal = normalize(normalMatrix * normal);
#elif defined(TANGENTSPACE_NORMALMAP)
vec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;
mapN.xy *= normalScale;
#ifdef USE_TANGENT
normal = normalize(vTBN * mapN);
#else
normal = perturbNormal2Arb(-vViewPosition, normal, mapN, faceDirection);
#endif
#elif defined(USE_BUMPMAP)
normal = perturbNormalArb(-vViewPosition, normal, dHdxy_fwd(), faceDirection);
#endif`,Jx=`#ifndef FLAT_SHADED
varying vec3 vNormal;
#ifdef USE_TANGENT
varying vec3 vTangent;
varying vec3 vBitangent;
#endif
#endif`,$x=`#ifndef FLAT_SHADED
varying vec3 vNormal;
#ifdef USE_TANGENT
varying vec3 vTangent;
varying vec3 vBitangent;
#endif
#endif`,e2=`#ifndef FLAT_SHADED
vNormal = normalize(transformedNormal);
#ifdef USE_TANGENT
vTangent = normalize(transformedTangent);
vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);
#endif
#endif`,t2=`#ifdef USE_NORMALMAP
uniform sampler2D normalMap;
uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat3 normalMatrix;
#endif
#if !defined (USE_TANGENT) && (defined (TANGENTSPACE_NORMALMAP) || defined (USE_CLEARCOAT_NORMALMAP))
vec3 perturbNormal2Arb(vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection) {
vec3 q0 = dFdx(eye_pos.xyz);
vec3 q1 = dFdy(eye_pos.xyz);
vec2 st0 = dFdx(vUv.st);
vec2 st1 = dFdy(vUv.st);
vec3 N = surf_norm;
vec3 q1perp = cross(q1, N);
vec3 q0perp = cross(N, q0);
vec3 T = q1perp * st0.x + q0perp * st1.x;
vec3 B = q1perp * st0.y + q0perp * st1.y;
float det = max(dot(T, T), dot(B, B));
float scale = (det == 0.0) ? 0.0 : faceDirection * inversesqrt(det);
return normalize(T * (mapN.x * scale) + B * (mapN.y * scale) + N * mapN.z);
}
#endif`,n2=`#ifdef USE_CLEARCOAT
vec3 clearcoatNormal = geometryNormal;
#endif`,i2=`#ifdef USE_CLEARCOAT_NORMALMAP
vec3 clearcoatMapN = texture2D(clearcoatNormalMap, vUv).xyz * 2.0 - 1.0;
clearcoatMapN.xy *= clearcoatNormalScale;
#ifdef USE_TANGENT
clearcoatNormal = normalize(vTBN * clearcoatMapN);
#else
clearcoatNormal = perturbNormal2Arb(-vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection);
#endif
#endif`,o2=`#ifdef USE_CLEARCOATMAP
uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
uniform sampler2D clearcoatNormalMap;
uniform vec2 clearcoatNormalScale;
#endif`,r2=`#ifdef USE_IRIDESCENCEMAP
uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
uniform sampler2D iridescenceThicknessMap;
#endif`,a2=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4(outgoingLight, diffuseColor.a);`,s2=`vec3 packNormalToRGB(const in vec3 normal) {
return normalize(normal) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal(const in vec3 rgb) {
return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;
const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3(256. * 256. * 256., 256. * 256., 256.);
const vec4 UnpackFactors = UnpackDownscale / vec4(PackFactors, 1.);
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA(const in float v) {
vec4 r = vec4(fract(v * PackFactors), v);
r.yzw -= r.xyz * ShiftRight8;
return r * PackUpscale;
}
float unpackRGBAToDepth(const in vec4 v) {
return dot(v, UnpackFactors);
}
vec2 packDepthToRG(in highp float v) {
return packDepthToRGBA(v).yx;
}
float unpackRGToDepth(const in highp vec2 v) {
return unpackRGBAToDepth(vec4(v.xy, 0.0, 0.0));
}
vec4 pack2HalfToRGBA(vec2 v) {
vec4 r = vec4(v.x, fract(v.x * 255.0), v.y, fract(v.y * 255.0));
return vec4(r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half(vec4 v) {
return vec2(v.x + (v.y / 255.0), v.z + (v.w / 255.0));
}
float viewZToOrthographicDepth(const in float viewZ, const in float near, const in float far) {
return (viewZ + near) / (near - far);
}
float orthographicDepthToViewZ(const in float linearClipZ, const in float near, const in float far) {
return linearClipZ * (near - far) - near;
}
float viewZToPerspectiveDepth(const in float viewZ, const in float near, const in float far) {
return ((near + viewZ) * far) / ((far - near) * viewZ);
}
float perspectiveDepthToViewZ(const in float invClipZ, const in float near, const in float far) {
return (near * far) / ((far - near) * invClipZ - far);
}`,l2=`#ifdef PREMULTIPLIED_ALPHA
gl_FragColor.rgb *= gl_FragColor.a;
#endif`,c2=`vec4 mvPosition = vec4(transformed, 1.0);
#ifdef USE_INSTANCING
mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;
#if defined(BACKGROUND_DEPTH)
gl_Position.z = gl_Position.w;
#endif`,u2=`#ifdef DITHERING
gl_FragColor.rgb = dithering(gl_FragColor.rgb);
#endif`,d2=`#ifdef DITHERING
vec3 dithering(vec3 color) {
float grid_position = rand(gl_FragCoord.xy);
vec3 dither_shift_RGB = vec3(0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0);
dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);
return color + dither_shift_RGB;
}
#endif`,h2=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
vec4 texelRoughness = texture2D(roughnessMap, vUv);
roughnessFactor *= texelRoughness.g;
#endif`,p2=`#ifdef USE_ROUGHNESSMAP
uniform sampler2D roughnessMap;
#endif`,f2=`#if NUM_SPOT_LIGHT_COORDS > 0
varying vec4 vSpotLightCoord[NUM_SPOT_LIGHT_COORDS];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
uniform sampler2D spotLightMap[NUM_SPOT_LIGHT_MAPS];
#endif
#define BIAS_FRUSTUM_SCALE_COEFF 30.0
#define ESM_SPOT_SINGLE_BLUR_COEFF 0.25
#define PCF_POISSON_SPOT_OMNI_BLUR_COEFF 4.0
#define PCF_POISSON_POINT_BLUR_COEFF 2.5
#define PCF_PCF_SOFT_DIR_SPOT_BLUR_COEFF 0.5
#define ESM_BIAS_COEFF 100.0
#ifndef ESM_DISTANCE_SCALE
#define ESM_DISTANCE_SCALE 1.0
#endif
#ifdef USE_SHADOWMAP
#if NUM_SPOT_LIGHT_SHADOWS > 0
uniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];
struct SpotLightShadow {
float shadowBias;
float shadowNormalBias;
float shadowRadius;
vec2 shadowMapSize;
int shadow;
float shadowCameraNear;
float shadowCameraFar;
float expBias;
};
uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];
#endif
#if NUM_POINT_LIGHT_SHADOWS > 0
uniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];
varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];
struct PointLightShadow {
float shadowBias;
float shadowNormalBias;
float shadowRadius;
vec2 shadowMapSize;
float shadowCameraNear;
float shadowCameraFar;
float expBias;
};
uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];
#endif
#if NUM_RECT_AREA_LIGHT_SHADOWS > 0
uniform sampler2D rectAreaShadowMap[NUM_RECT_AREA_LIGHT_SHADOWS];
varying vec4 vRectAreaShadowCoord[NUM_RECT_AREA_LIGHT_SHADOWS];
struct RectAreaLightShadow {
float shadowBias;
float shadowNormalBias;
float shadowRadius;
vec2 shadowMapSize;
float shadowCameraNear;
float shadowCameraFar;
float expBias;
};
uniform RectAreaLightShadow rectAreaLightShadows[NUM_RECT_AREA_LIGHT_SHADOWS];
#endif
#if NUM_DIR_LIGHT_SHADOWS_CSM > 0
uniform sampler2D directionalShadowCSMMap[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];
varying vec4 vDirectionalShadowCSMCoord[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];
struct DirectionalLightShadowCascade {
float shadowBias;
float shadowNormalBias;
float shadowRadius;
vec2 shadowMapSize;
float shadowCameraNear;
float shadowCameraFar;
vec2 cascade;
float expBias;
vec3 position;
int csmIdx;
};
struct DirectionalLightShadowCSM {
int cascadeIdxEnd;
float cameraNear;
float shadowFar;
float fade;
};
uniform DirectionalLightShadowCSM directionalLightShadowsCSM[NUM_DIR_LIGHT_SHADOWS_CSM];
uniform DirectionalLightShadowCascade directionalLightShadowsCSMCascade[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];
#endif
const vec3 PERMUTE_DIR_X = vec3(1.0, 0.0, 0.0);
const vec3 PERMUTE_DIR_Y = vec3(0.0, 1.0, 0.0);
const vec3 PERMUTE_DIR_Z = vec3(0.0, 0.0, 1.0);
const mat4 POISSON_DISK_0 = mat4(
0.954845, 0.242214, -0.623893, -0.235473,
-0.173288, 0.799228, 0.605969, -0.548050,
-0.560406, 0.327647, -0.448307, -0.774344,
0.308258, 0.417332, -0.125623, -0.056098
);
const mat4 POISSON_DISK_1 = mat4(
0.145585, -0.305634, 0.264060, -0.661648,
0.617942, 0.652121, -0.041412, -0.893582,
0.463911, 0.039752, 0.212664, 0.810727,
-0.955989, -0.014390, -0.652588, 0.671204
);
float texture2DCompare(sampler2D depths, vec2 uv, float compare) {
return step(compare, unpackRGBAToDepth(texture2D(depths, uv)));
}
float texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare) {
const vec2 offset = vec2(0.0, 1.0);
vec2 texelSize = vec2(1.0) / size;
vec2 centroidUV = floor(uv * size + 0.5) / size;
float lb = texture2DCompare(depths, centroidUV + texelSize * offset.xx, compare);
float lt = texture2DCompare(depths, centroidUV + texelSize * offset.xy, compare);
float rb = texture2DCompare(depths, centroidUV + texelSize * offset.yx, compare);
float rt = texture2DCompare(depths, centroidUV + texelSize * offset.yy, compare);
vec2 f = fract(uv * size + 0.5);
float a = mix(lb, lt, f.y);
float b = mix(rb, rt, f.y);
float c = mix(a, b, f.x);
return c;
}
vec2 cubeToUV(vec3 v, float texelSizeY) {
vec3 absV = abs(v);
float scaleToCube = 1.0 / max(absV.x, max(absV.y, absV.z));
absV *= scaleToCube;
v *= scaleToCube * (1.0 - 2.0 * texelSizeY);
vec2 planar = v.xy;
float almostATexel = 1.5 * texelSizeY;
float almostOne = 1.0 - almostATexel;
if (absV.z >= almostOne) {
if (v.z > 0.0)
planar.x = 4.0 - v.x;
} else if (absV.x >= almostOne) {
float signX = sign(v.x);
planar.x = v.z * signX + 2.0 * signX;
} else if (absV.y >= almostOne) {
float signY = sign(v.y);
planar.x = v.x + 2.0 * signY + 2.0;
planar.y = v.z * signY - 2.0;
}
return vec2(0.125, 0.25) * planar + vec2(0.375, 0.75);
}
float texture2DShadowAvgCube(sampler2D depths, vec2 size, vec3 bd3D, float compare) {
vec2 texelSize = vec2(1.0) / size;
vec3 dirX = normalize(abs(bd3D.y) < 0.99999 ? vec3(bd3D.z, 0.0, -bd3D.x)
: vec3(0.0, -bd3D.z, bd3D.y));
vec3 dirY = cross(bd3D, dirX);
float theta = PI_HALF * texelSize.y;
vec3 sX = sin(theta) * dirX;
vec3 sY = sin(theta) * dirY;
float cosT = cos(theta);
vec3 sampleVec[4];
sampleVec[0] = bd3D;
sampleVec[1] = bd3D * cosT + sY;
sampleVec[2] = bd3D * cosT + sX;
sampleVec[3] = sampleVec[2] * cosT + sY;
float avg = 0.0;
for (int i = 0; i < 4; i++) {
avg += texture2DCompare(depths, cubeToUV(sampleVec[i], texelSize.y), compare);
}
avg /= 4.0;
return avg;
}
float getShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord,
float expBias, float distWorld) {
float shadow = 1.0;
shadowCoord.xyz /= shadowCoord.w;
bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
bool frustumTest = inFrustum && shadowCoord.z <= 1.0 && shadowCoord.z >= 0.0;
if (frustumTest) {
#if defined(SHADOWMAP_TYPE_BILINEAR)
shadowCoord.z += shadowBias;
shadow = texture2DShadowLerp(shadowMap, shadowMapSize,
shadowCoord.xy, shadowCoord.z);
#elif defined(SHADOWMAP_TYPE_PCF)
shadowCoord.z += shadowBias;
vec2 texelSize = vec2(1.0) / shadowMapSize;
float dx0 = - texelSize.x * shadowRadius;
float dy0 = - texelSize.y * shadowRadius;
float dx1 = + texelSize.x * shadowRadius;
float dy1 = + texelSize.y * shadowRadius;
vec2 offsetVec[9];
offsetVec[0] = vec2(dx0, dy0);
offsetVec[1] = vec2(0.0, dy0);
offsetVec[2] = vec2(dx1, dy0);
offsetVec[3] = vec2(dx0, 0.0);
offsetVec[4] = vec2(0.0);
offsetVec[5] = vec2(dx1, 0.0);
offsetVec[6] = vec2(dx0, dy1);
offsetVec[7] = vec2(0.0, dy1);
offsetVec[8] = vec2(dx1, dy1);
shadow = 0.0;
for (int i = 0; i < 9; i++) {
shadow += texture2DCompare(shadowMap, shadowCoord.xy + offsetVec[i], shadowCoord.z);
}
shadow /= 9.0;
#elif defined(SHADOWMAP_TYPE_PCF_SOFT)
shadowCoord.z += shadowBias;
vec2 texelSize = vec2(1.0) / shadowMapSize;
float dx0 = - texelSize.x * shadowRadius;
float dy0 = - texelSize.y * shadowRadius;
float dx1 = + texelSize.x * shadowRadius;
float dy1 = + texelSize.y * shadowRadius;
vec2 offsetVec[9];
offsetVec[0] = vec2(dx0, dy0);
offsetVec[1] = vec2(0.0, dy0);
offsetVec[2] = vec2(dx1, dy0);
offsetVec[3] = vec2(dx0, 0.0);
offsetVec[4] = vec2(0.0);
offsetVec[5] = vec2(dx1, 0.0);
offsetVec[6] = vec2(dx0, dy1);
offsetVec[7] = vec2(0.0, dy1);
offsetVec[8] = vec2(dx1, dy1);
shadow = 0.0;
for (int i = 0; i < 9; i++) {
shadow += texture2DShadowLerp(shadowMap, shadowMapSize,
shadowCoord.xy + offsetVec[i], shadowCoord.z);
}
shadow /= 9.0;
#elif defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)
shadowCoord.z += shadowBias;
vec2 texelSize = vec2(1.0) / shadowMapSize;
float randAngle = rand(gl_FragCoord.xy) * PI2;
float c = cos(randAngle), s = sin(randAngle);
mat2 sampleMat = mat2(c, s, -s, c)
* mat2(shadowRadius * texelSize.x, 0.0, 0.0, shadowRadius * texelSize.y);
vec2 sampleVec[16];
sampleVec[0] = POISSON_DISK_0[0].xy;
sampleVec[1] = POISSON_DISK_0[0].zw;
sampleVec[2] = POISSON_DISK_0[1].xy;
sampleVec[3] = POISSON_DISK_0[1].zw;
sampleVec[4] = POISSON_DISK_0[2].xy;
sampleVec[5] = POISSON_DISK_0[2].zw;
sampleVec[6] = POISSON_DISK_0[3].xy;
sampleVec[7] = POISSON_DISK_0[3].zw;
sampleVec[8] = POISSON_DISK_1[0].xy;
sampleVec[9] = POISSON_DISK_1[0].zw;
sampleVec[10] = POISSON_DISK_1[1].xy;
sampleVec[11] = POISSON_DISK_1[1].zw;
sampleVec[12] = POISSON_DISK_1[2].xy;
sampleVec[13] = POISSON_DISK_1[2].zw;
sampleVec[14] = POISSON_DISK_1[3].xy;
sampleVec[15] = POISSON_DISK_1[3].zw;
shadow = 0.0;
for (int i = 0; i < 16; i++) {
shadow += texture2DCompare(shadowMap, shadowCoord.xy
+ sampleMat * sampleVec[i], shadowCoord.z);
}
shadow /= 16.0;
#elif defined(SHADOWMAP_TYPE_ESM)
shadow = saturate(exp(expBias * (texture2D(shadowMap, shadowCoord.xy).x
- length(distWorld) * ESM_DISTANCE_SCALE
- ESM_BIAS_COEFF * shadowBias)));
#else
shadowCoord.z += shadowBias;
shadow = texture2DCompare(shadowMap, shadowCoord.xy, shadowCoord.z);
#endif
}
return shadow;
}
float getOmniShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias,
float expBias, float shadowRadius, vec4 shadowCoord,
float shadowCameraNear, float shadowCameraFar) {
float shadow = 1.0;
vec3 lightToPosition = shadowCoord.xyz;
float dp = (length(lightToPosition) - shadowCameraNear)
/ (shadowCameraFar - shadowCameraNear);
bool frustumTest = dp <= 1.0 && dp >= 0.0;
if (frustumTest) {
float biasScaleCoeff = BIAS_FRUSTUM_SCALE_COEFF
/ (shadowCameraFar - shadowCameraNear);
dp += shadowBias * biasScaleCoeff;
vec3 bd3D = normalize(lightToPosition);
vec2 texelSize = 1.0 / shadowMapSize;
#if defined(SHADOWMAP_TYPE_BILINEAR)
shadow = texture2DShadowAvgCube(shadowMap, shadowMapSize, bd3D, dp);
#elif defined(SHADOWMAP_TYPE_ESM)
shadow = saturate(exp(expBias * (texture2D(shadowMap,
cubeVecToOctUV(bd3D, texelSize)).x
- length(lightToPosition) * ESM_DISTANCE_SCALE
- ESM_BIAS_COEFF * shadowBias)));
#elif defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT)
vec2 offset = vec2(-1, 1) * shadowRadius * texelSize.y;
vec3 offsetVec[9];
offsetVec[0] = offset.xyy;
offsetVec[1] = offset.yyy;
offsetVec[2] = offset.xyx;
offsetVec[3] = offset.yyx;
offsetVec[4] = vec3(0.0);
offsetVec[5] = offset.xxy;
offsetVec[6] = offset.yxy;
offsetVec[7] = offset.xxx;
offsetVec[8] = offset.yxx;
shadow = 0.0;
for (int i = 0; i < 9; i++) {
shadow += texture2DCompare(shadowMap, cubeToUV(bd3D + offsetVec[i], texelSize.y), dp);
}
shadow /= 9.0;
#elif defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)
float randAngle = rand(gl_FragCoord.xy) * PI2;
float c = cos(randAngle), s = sin(randAngle);
mat2 sampleMat = mat2(c, s, -s, c)
* mat2(shadowRadius * texelSize.y, 0.0, 0.0, shadowRadius * texelSize.y);
vec3 absBd3D = abs(bd3D);
absBd3D /= max(absBd3D.x, max(absBd3D.y, absBd3D.z));
bvec2 isPointingCubeFace = greaterThan(absBd3D.xy, vec2(0.999));
mat3 permuteMat = mat3(
isPointingCubeFace.x ? PERMUTE_DIR_Y : PERMUTE_DIR_X,
isPointingCubeFace.x || isPointingCubeFace.y ? PERMUTE_DIR_Z : PERMUTE_DIR_Y,
isPointingCubeFace.x ? PERMUTE_DIR_X : isPointingCubeFace.y ? PERMUTE_DIR_Y : PERMUTE_DIR_Z
);
vec2 sampleVec[16];
sampleVec[0] = POISSON_DISK_0[0].xy;
sampleVec[1] = POISSON_DISK_0[0].zw;
sampleVec[2] = POISSON_DISK_0[1].xy;
sampleVec[3] = POISSON_DISK_0[1].zw;
sampleVec[4] = POISSON_DISK_0[2].xy;
sampleVec[5] = POISSON_DISK_0[2].zw;
sampleVec[6] = POISSON_DISK_0[3].xy;
sampleVec[7] = POISSON_DISK_0[3].zw;
sampleVec[8] = POISSON_DISK_1[0].xy;
sampleVec[9] = POISSON_DISK_1[0].zw;
sampleVec[10] = POISSON_DISK_1[1].xy;
sampleVec[11] = POISSON_DISK_1[1].zw;
sampleVec[12] = POISSON_DISK_1[2].xy;
sampleVec[13] = POISSON_DISK_1[2].zw;
sampleVec[14] = POISSON_DISK_1[3].xy;
sampleVec[15] = POISSON_DISK_1[3].zw;
shadow = 0.0;
for (int i = 0; i < 16; i++) {
shadow += texture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * sampleVec[i], 0.0), texelSize.y), dp);
}
shadow /= 16.0;
#else
shadow = texture2DCompare(shadowMap, cubeToUV(bd3D, texelSize.y), dp);
#endif
}
return shadow;
}
#if NUM_POINT_LIGHT_SHADOWS > 0
float getPointShadow(PointLightShadow light, sampler2D shadowMap, vec4 shadowCoord) {
float shadowRadius = light.shadowRadius;
vec2 mapSize = light.shadowMapSize;
#if defined(SHADOWMAP_TYPE_ESM)
mapSize *= 2.0;
#else
mapSize *= vec2(4.0, 2.0);
#if defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)
shadowRadius *= PCF_POISSON_POINT_BLUR_COEFF;
#endif
#endif
return getOmniShadow(shadowMap, mapSize, light.shadowBias, light.expBias,
shadowRadius, shadowCoord, light.shadowCameraNear,
light.shadowCameraFar);
}
#endif
#if NUM_RECT_AREA_LIGHT_SHADOWS > 0
float getRectAreaShadow(RectAreaLightShadow light, sampler2D shadowMap, vec4 shadowCoord) {
float shadowRadius = light.shadowRadius;
vec2 mapSize = light.shadowMapSize;
#if defined(SHADOWMAP_TYPE_ESM)
mapSize *= 2.0;
#else
mapSize *= vec2(4.0, 2.0);
#if defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)
shadowRadius *= PCF_POISSON_POINT_BLUR_COEFF;
#endif
#endif
return getOmniShadow(shadowMap, mapSize, light.shadowBias, light.expBias,
shadowRadius, shadowCoord, light.shadowCameraNear,
light.shadowCameraFar);
}
#endif
#if NUM_SPOT_LIGHT_SHADOWS > 0
float getSpotOmniShadow(SpotLightShadow light, sampler2D shadowMap, vec4 shadowCoord) {
float shadowRadius = light.shadowRadius;
vec2 mapSize = light.shadowMapSize;
#if defined(SHADOWMAP_TYPE_ESM)
#else
mapSize *= vec2(4.0, 2.0);
#if defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)
shadowRadius *= PCF_POISSON_SPOT_OMNI_BLUR_COEFF;
#endif
#endif
return getOmniShadow(shadowMap, mapSize, light.shadowBias, light.expBias,
shadowRadius, shadowCoord, light.shadowCameraNear,
light.shadowCameraFar);
}
float biasLinearNormalizedToNonlinear(float bias, float near, float far,
float projZ, float projW) {
return (bias * (far + near) + 2.0 * projZ) / (bias * (far - near) + 2.0 * projW)
- projZ / projW;
}
float getSpotShadow(SpotLightShadow light, sampler2D shadowMap, vec4 shadowCoord,
float distWorld) {
float shadowRadius = light.shadowRadius;
float shadowBias = light.shadowBias;
#if defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT)
shadowRadius *= PCF_PCF_SOFT_DIR_SPOT_BLUR_COEFF;
#elif defined(SHADOWMAP_TYPE_ESM)
shadowRadius *= ESM_SPOT_SINGLE_BLUR_COEFF;
#endif
shadowBias *= BIAS_FRUSTUM_SCALE_COEFF
/ (light.shadowCameraFar - light.shadowCameraNear);
#if defined(SHADOWMAP_TYPE_BASIC) || defined(SHADOWMAP_TYPE_BILINEAR) || defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT) || defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)
shadowBias = biasLinearNormalizedToNonlinear(shadowBias,
light.shadowCameraNear, light.shadowCameraFar, shadowCoord.z,
shadowCoord.w);
#endif
return getShadow(shadowMap, light.shadowMapSize, shadowBias, shadowRadius, shadowCoord,
light.expBias, distWorld);
}
#endif
#if NUM_DIR_LIGHT_SHADOWS_CSM > 0
float getDirShadowCSM(DirectionalLightShadowCascade light, sampler2D shadowMap,
vec4 shadowCoord, float distWorld) {
float shadowRadius = light.shadowRadius;
#if defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT)
shadowRadius *= PCF_PCF_SOFT_DIR_SPOT_BLUR_COEFF;
#endif
return getShadow(shadowMap, light.shadowMapSize, light.shadowBias, shadowRadius, shadowCoord,
light.expBias, distWorld);
}
#endif
#endif`,m2=`#if NUM_SPOT_LIGHT_COORDS > 0
uniform mat4 spotLightMatrix[NUM_SPOT_LIGHT_COORDS];
varying vec4 vSpotLightCoord[NUM_SPOT_LIGHT_COORDS];
#endif
#ifdef USE_SHADOWMAP
#if NUM_SPOT_LIGHT_SHADOWS > 0
struct SpotLightShadow {
float shadowBias;
float shadowNormalBias;
float shadowRadius;
vec2 shadowMapSize;
int shadow;
float shadowCameraNear;
float shadowCameraFar;
float expBias;
};
uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];
#endif
#if NUM_POINT_LIGHT_SHADOWS > 0
uniform mat4 pointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];
varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];
struct PointLightShadow {
float shadowBias;
float shadowNormalBias;
float shadowRadius;
vec2 shadowMapSize;
float shadowCameraNear;
float shadowCameraFar;
float expBias;
};
uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];
#endif
#if NUM_RECT_AREA_LIGHT_SHADOWS > 0
uniform mat4 rectAreaShadowMatrix[NUM_RECT_AREA_LIGHT_SHADOWS];
varying vec4 vRectAreaShadowCoord[NUM_RECT_AREA_LIGHT_SHADOWS];
struct RectAreaLightShadow {
float shadowBias;
float shadowNormalBias;
float shadowRadius;
vec2 shadowMapSize;
float shadowCameraNear;
float shadowCameraFar;
float expBias;
};
uniform RectAreaLightShadow rectAreaLightShadows[NUM_RECT_AREA_LIGHT_SHADOWS];
#endif
#if NUM_DIR_LIGHT_SHADOWS_CSM > 0
uniform mat4 directionalShadowCSMMatrix[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];
varying vec4 vDirectionalShadowCSMCoord[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];
struct DirectionalLightShadowCascade {
float shadowBias;
float shadowNormalBias;
float shadowRadius;
vec2 shadowMapSize;
float shadowCameraNear;
float shadowCameraFar;
vec2 cascade;
float expBias;
vec3 position;
int csmIdx;
};
struct DirectionalLightShadowCSM {
int cascadeIdxEnd;
float cameraNear;
float shadowFar;
float fade;
};
uniform DirectionalLightShadowCSM directionalLightShadowsCSM[NUM_DIR_LIGHT_SHADOWS_CSM];
uniform DirectionalLightShadowCascade directionalLightShadowsCSMCascade[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];
#endif
#endif`,g2=`#if defined(USE_SHADOWMAP) || (NUM_SPOT_LIGHT_COORDS > 0)
#if NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 || NUM_RECT_AREA_LIGHT_SHADOWS > 0 || NUM_DIR_LIGHT_SHADOWS_CSM > 0
vec3 shadowWorldNormal = inverseTransformDirection(transformedNormal, viewMatrix);
vec4 shadowWorldPosition;
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
#pragma unroll_loop_start
for (int i = 0; i < NUM_SPOT_LIGHT_COORDS; i++) {
shadowWorldPosition = worldPosition + vec4(shadowWorldNormal * spotLightShadows[i].shadowNormalBias, 0);
vSpotLightCoord[i] = spotLightMatrix[i] * shadowWorldPosition;
}
#pragma unroll_loop_end
#endif
#if NUM_POINT_LIGHT_SHADOWS > 0
#pragma unroll_loop_start
for (int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i++) {
shadowWorldPosition = worldPosition + vec4(shadowWorldNormal * pointLightShadows[i].shadowNormalBias, 0);
vPointShadowCoord[i] = pointShadowMatrix[i] * shadowWorldPosition;
}
#pragma unroll_loop_end
#endif
#if NUM_RECT_AREA_LIGHT_SHADOWS > 0
#pragma unroll_loop_start
for (int i = 0; i < NUM_RECT_AREA_LIGHT_SHADOWS; i++) {
shadowWorldPosition = worldPosition + vec4(shadowWorldNormal * rectAreaLightShadows[i].shadowNormalBias, 0);
vRectAreaShadowCoord[i] = rectAreaShadowMatrix[i] * shadowWorldPosition;
}
#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHT_SHADOWS_CSM > 0
#pragma unroll_loop_start
for (int i = 0; i < NUM_DIR_LIGHT_SHADOW_CASCADES_CSM; i++) {
shadowWorldPosition = worldPosition + vec4(shadowWorldNormal * directionalLightShadowsCSMCascade[i].shadowNormalBias, 0);
vDirectionalShadowCSMCoord[i] = directionalShadowCSMMatrix[i] * shadowWorldPosition;
}
#pragma unroll_loop_end
#endif
#endif`,v2=`float getShadowMask() {
float shadow = 1.0;
#ifdef USE_SHADOWMAP
#if NUM_SPOT_LIGHT_SHADOWS > 0
SpotLightShadow spotLight;
#pragma unroll_loop_start
for (int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i++) {
spotLight = spotLightShadows[i];
if (receiveShadow) {
if (spotLight.shadow == 1) {
float distWorld = 0.0;
#if defined(SHADOWMAP_TYPE_ESM)
distWorld = length((invViewMatrix * vec4(spotLight.position
+ vViewPosition, 0.0)).xyz);
#endif
shadow *= getSpotShadow(spotLight, spotShadowMap[i], vSpotLightCoord[i],
distWorld);
} else if (spotLight.shadow == 2) {
shadow *= getSpotOmniShadow(spotLight, spotShadowMap[i],
vSpotLightCoord[i]);
}
}
}
#pragma unroll_loop_end
#endif
#if NUM_POINT_LIGHT_SHADOWS > 0
PointLightShadow pointLight;
#pragma unroll_loop_start
for (int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i++) {
pointLight = pointLightShadows[i];
shadow *= receiveShadow ? getPointShadow(pointLight, pointShadowMap[i], vPointShadowCoord[i]) : 1.0;
}
#pragma unroll_loop_end
#endif
#if NUM_RECT_AREA_LIGHT_SHADOWS > 0
RectAreaLightShadow rectAreaLight;
#pragma unroll_loop_start
for (int i = 0; i < NUM_RECT_AREA_LIGHT_SHADOWS; i++) {
rectAreaLight = rectAreaLightShadows[i];
shadow *= receiveShadow ? getRectAreaShadow(rectAreaLight, rectAreaShadowMap[i], vRectAreaShadowCoord[i]) : 1.0;
}
#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHT_SHADOWS_CSM > 0
DirectionalLightShadowCascade dirShadowCascade;
#pragma unroll_loop_start
for (int i = 0; i < NUM_DIR_LIGHT_SHADOW_CASCADES_CSM; i++) {
dirShadowCascade = directionalLightShadowsCSMCascade[i];
float distWorld = 0.0;
#if defined(SHADOWMAP_TYPE_ESM)
distWorld = length((invViewMatrix * vec4(dirShadowCascade.position
+ vViewPosition, 0.0)).xyz);
#endif
shadow *= ((vViewPosition.z < dirShadowCascade.shadowCameraFar) && receiveShadow) ?
getDirShadowCSM(dirShadowCascade, directionalShadowCSMMap[i], vDirectionalShadowCSMCoord[i], distWorld)
: 1.0;
}
#pragma unroll_loop_end
#endif
#endif
return shadow;
}`,_2=`#ifdef USE_SKINNING
mat4 boneMatX = getBoneMatrix(skinIndex.x);
mat4 boneMatY = getBoneMatrix(skinIndex.y);
mat4 boneMatZ = getBoneMatrix(skinIndex.z);
mat4 boneMatW = getBoneMatrix(skinIndex.w);
#endif`,A2=`#ifdef USE_SKINNING
uniform mat4 bindMatrix;
uniform mat4 bindMatrixInverse;
uniform highp sampler2D boneTexture;
uniform int boneTextureSize;
mat4 getBoneMatrix(const in float i) {
float j = i * 4.0;
float x = mod(j, float(boneTextureSize));
float y = floor(j / float(boneTextureSize));
float dx = 1.0 / float(boneTextureSize);
float dy = 1.0 / float(boneTextureSize);
y = dy * (y + 0.5);
vec4 v1 = texture2D(boneTexture, vec2(dx * (x + 0.5), y));
vec4 v2 = texture2D(boneTexture, vec2(dx * (x + 1.5), y));
vec4 v3 = texture2D(boneTexture, vec2(dx * (x + 2.5), y));
vec4 v4 = texture2D(boneTexture, vec2(dx * (x + 3.5), y));
mat4 bone = mat4(v1, v2, v3, v4);
return bone;
}
#endif`,x2=`#ifdef USE_SKINNING
vec4 skinVertex = bindMatrix * vec4(transformed, 1.0);
vec4 skinned = vec4(0.0);
skinned += boneMatX * skinVertex * skinWeight.x;
skinned += boneMatY * skinVertex * skinWeight.y;
skinned += boneMatZ * skinVertex * skinWeight.z;
skinned += boneMatW * skinVertex * skinWeight.w;
transformed = (bindMatrixInverse * skinned).xyz;
#endif`,y2=`#ifdef USE_SKINNING
mat4 skinMatrix = mat4(0.0);
skinMatrix += skinWeight.x * boneMatX;
skinMatrix += skinWeight.y * boneMatY;
skinMatrix += skinWeight.z * boneMatZ;
skinMatrix += skinWeight.w * boneMatW;
skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
objectNormal = vec4(skinMatrix * vec4(objectNormal, 0.0)).xyz;
#ifdef USE_TANGENT
objectTangent = vec4(skinMatrix * vec4(objectTangent, 0.0)).xyz;
#endif
#endif`,b2=`float specularStrength;
#ifdef USE_SPECULARMAP
vec4 texelSpecular = texture2D(specularMap, vUv);
specularStrength = texelSpecular.r;
#else
specularStrength = 1.0;
#endif`,C2=`#ifdef USE_SPECULARMAP
uniform sampler2D specularMap;
#endif`,S2=`#if defined(TONE_MAPPING)
gl_FragColor.rgb = toneMapping(gl_FragColor.rgb);
#endif`,M2=`#ifndef saturate
#define saturate(a) clamp(a, 0.0, 1.0)
#endif
uniform float toneMappingExposure;
uniform float toneMappingMidTones;
uniform float toneMappingPhysicalScale;
uniform float toneMappingBrightness;
uniform float toneMappingContrast;
uniform bool toneMappingChromaticAdaptation;
uniform vec3 toneMappingWhiteColor;
uniform bool toneMappingColorDifferentiation;
uniform bool toneMappingExteriorDaylight;
uniform vec3 toneMappingWhiteBalance;
uniform float toneMappingHighlights;
uniform float toneMappingShadows;
uniform float toneMappingSaturation;
uniform float toneMappingAperture;
uniform float toneMappingShutter;
uniform float toneMappingISO;
uniform float toneMappingVignetting;
uniform vec2 toneMappingResolution;
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
vec3(1.6605, -0.1246, -0.0182),
vec3(- 0.5876, 1.1329, -0.1006),
vec3(- 0.0728, -0.0083, 1.1187)
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
vec3(0.6274, 0.0691, 0.0164),
vec3(0.3293, 0.9195, 0.0880),
vec3(0.0433, 0.0113, 0.8956)
);
#define TONE_MAPPING_LOOK_NONE 0
#define TONE_MAPPING_LOOK_AGX_PUNCHY 1
const float FILMIC_BLENDER_LOG_MIN = -12.473931188;
const float FILMIC_BLENDER_LOG_MAX = 12.526068812;
const float FILMIC_BLENDER_EXPOSURE_LATITUDE_RATIO = 0.66;
vec3 LinearToneMapping(vec3 color) {
return toneMappingExposure * color;
}
vec3 ReinhardToneMapping(vec3 color) {
color *= toneMappingExposure;
return saturate(color / (vec3(1.0) + color));
}
vec3 OptimizedCineonToneMapping(vec3 color) {
color *= toneMappingExposure;
color = max(vec3(0.0), color - 0.004);
return pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));
}
vec3 RRTAndODTFit(vec3 v) {
vec3 a = v * (v + 0.0245786) -0.000090537;
vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
return a / b;
}
vec3 ACESFilmicToneMapping(vec3 color) {
const mat3 ACESInputMat = mat3(
vec3(0.59719, 0.07600, 0.02840),
vec3(0.35458, 0.90834, 0.13383),
vec3(0.04823, 0.01566, 0.83777)
);
const mat3 ACESOutputMat = mat3(
vec3( 1.60475, -0.10208, -0.00327),
vec3(-0.53108, 1.10813, -0.07276),
vec3(-0.07367, -0.00605, 1.07602)
);
color *= toneMappingExposure / 0.6;
color = ACESInputMat * color;
color = RRTAndODTFit(color);
color = ACESOutputMat * color;
return saturate(color);
}
vec3 agxDefaultContrastApprox(vec3 x) {
vec3 x2 = x * x;
vec3 x4 = x2 * x2;
return + 15.5 * x4 * x2
-40.14 * x4 * x
+ 31.96 * x4
-6.868 * x2 * x
+ 0.4298 * x2
+ 0.1191 * x
-0.00232;
}
vec3 toneMappingLook(vec3 color, int look) {
if (look == TONE_MAPPING_LOOK_NONE) {
return color;
}
const vec3 lw = vec3(0.2126, 0.7152, 0.0722);
float luma = dot(color, lw);
vec3 offset = vec3(0.0);
vec3 slope = vec3(1.0);
vec3 power = vec3(1.0);
float sat = 1.0;
if (look == TONE_MAPPING_LOOK_AGX_PUNCHY) {
slope = vec3(1.0);
power = vec3(1.35, 1.35, 1.35);
sat = 1.4;
}
color = pow(color * slope + offset, power);
return luma + sat * (color - luma);
}
vec3 AgXToneMapping(vec3 color) {
const mat3 AgXInsetMatrix = mat3(
vec3(0.856627153315983, 0.137318972929847, 0.11189821299995),
vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903),
vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859)
);
const mat3 AgXOutsetMatrix = mat3(
vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826),
vec3(- 0.11060664309660323, 1.157823702216272, -0.11060664309660294),
vec3(- 0.016493938717834573, -0.016493938717834257, 1.2519364065950405)
);
const float AgxMinEv = -12.47393;
const float AgxMaxEv = 4.026069;
color *= toneMappingExposure;
color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
color = AgXInsetMatrix * color;
color = max(color, 1e-10);
color = log2(color);
color = (color - AgxMinEv) / (AgxMaxEv - AgxMinEv);
color = clamp(color, 0.0, 1.0);
color = agxDefaultContrastApprox(color);
color = toneMappingLook(color, TONE_MAPPING_LOOK);
color = AgXOutsetMatrix * color;
color = pow(max(vec3(0.0), color), vec3(2.2));
color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
color = clamp(color, 0.0, 1.0);
return color;
}
vec3 CustomToneMapping(vec3 color) { return color; }
#define ORDERS_OF_MAG 5.0
#define PI_TONE 3.14159265359
float toneCalcBrightness(in vec3 color)
{
return (abs(color.r) * 0.263 + abs(color.g) * 0.655 + abs(color.b) * 0.082);
}
float toneApproximateScotopicLuminance(vec3 color)
{
return (0.062 * color.r + 0.608 * color.g + 0.330 * color.b);
}
vec3 LogarithmicMaxToneMapping(vec3 color) {
float inputScaleFactor = toneMappingPhysicalScale / PI_TONE;
float brightness = (toneMappingBrightness < 0.0) ? 0.0 : (toneMappingBrightness * 0.7);
float powerBot = toneMappingExteriorDaylight ? 4.0 : 2.0;
float res = 100.0 / ORDERS_OF_MAG;
float mag = floor((50.0 / res));
float power = ((brightness / 20.0 - ORDERS_OF_MAG) - powerBot) + mag;
float stepsize = 9.0 / res;
float step = 50.0 - (mag * res);
float param_c = (0.02 * toneMappingContrast) * 2.0;
float param_b = pow(10.0, power) * (1.0 + (stepsize * step));
float param_a = param_b * (1.0 + param_c);
param_c /= pow(2.0, toneMappingMidTones - 1.0);
param_b *= PI_TONE;
vec3 whiteConstancyFactor = toneMappingWhiteColor;
if (toneMappingChromaticAdaptation) {
float luminance = toneCalcBrightness(whiteConstancyFactor);
whiteConstancyFactor.r = (whiteConstancyFactor.r > 0.001) ? luminance / whiteConstancyFactor.r : luminance / 0.001;
whiteConstancyFactor.g = (whiteConstancyFactor.g > 0.001) ? luminance / whiteConstancyFactor.g : luminance / 0.001;
whiteConstancyFactor.b = (whiteConstancyFactor.b > 0.001) ? luminance / whiteConstancyFactor.b : luminance / 0.001;
}
vec3 outColor = inputScaleFactor * color;
if (toneMappingChromaticAdaptation) {
outColor *= whiteConstancyFactor.rgb;
}
float luminance = toneCalcBrightness(outColor);
if (toneMappingColorDifferentiation && (luminance < 5.62)) {
float sLuminance = toneApproximateScotopicLuminance(outColor);
if (luminance <= 5.62e-3) {
outColor = vec3(sLuminance);
} else {
float w = (luminance - 5.62e-3) / 5.61438;
outColor = outColor * w + sLuminance * (1.0 - w);
}
}
outColor = outColor * (param_a / (param_b * outColor + param_c));
return outColor;
}
float maxExposurePhotographic(in vec4 color1, in vec4 color2)
{
return ((color1.r * color2.r) + (color1.g * color2.g)) + (color1.b * color2.b);
}
vec3 PhysicalMaxToneMapping(vec3 color) {
float vignettingInfluence = 1.0;
if (toneMappingVignetting > 0.0) {
vec3 vignettingCoords = vec3(0.0, 0.0, 0.0);
float aspect = toneMappingResolution.x / toneMappingResolution.y;
vignettingCoords.x = gl_FragCoord.x / toneMappingResolution.x - 0.5;
vignettingCoords.y = (gl_FragCoord.y / toneMappingResolution.y - 0.5) / aspect;
vignettingCoords.z = 1.0;
vignettingCoords = normalize(vignettingCoords);
vignettingInfluence = pow(vignettingCoords.z, toneMappingVignetting);
}
float inputScaleFactor = toneMappingPhysicalScale / PI_TONE;
float filmISO = toneMappingISO;
float camShutter = 1.0 / toneMappingShutter;
float fNumber = toneMappingAperture;
float cm2 = 1.0;
float burnHighlights = toneMappingHighlights;
float crushBlacks = toneMappingShadows;
float saturation = toneMappingSaturation;
vec3 whitePointInfluence = toneMappingWhiteBalance;
if (whitePointInfluence.r > 0.0) {
whitePointInfluence.r = 1.0 / whitePointInfluence.r;
} else {
whitePointInfluence.r = 1.0;
}
if (whitePointInfluence.g > 0.0) {
whitePointInfluence.g = 1.0 / whitePointInfluence.g;
} else {
whitePointInfluence.g = 1.0;
}
if (whitePointInfluence.b > 0.0) {
whitePointInfluence.b = 1.0 / whitePointInfluence.b;
} else {
whitePointInfluence.b = 1.0;
}
vec4 lumFactor = vec4(0.212671, 0.715160, 0.072169, 0.0);
float whiteLumFactor = maxExposurePhotographic(lumFactor, vec4(whitePointInfluence, 0.0));
whitePointInfluence.r /= whiteLumFactor;
whitePointInfluence.g /= whiteLumFactor;
whitePointInfluence.b /= whiteLumFactor;
float isoInfluence = 0.0;
float camShutterInv = 1.0 / camShutter;
if (filmISO > 0.0) {
isoInfluence = ((cm2 * 0.169811) * (filmISO * camShutterInv)) / ((15.4 * fNumber) * fNumber);
} else {
isoInfluence = cm2;
}
vec3 outColor = inputScaleFactor * color;
outColor.r = outColor.r * whitePointInfluence.r * isoInfluence * vignettingInfluence;
outColor.g = outColor.g * whitePointInfluence.g * isoInfluence * vignettingInfluence;
outColor.b = outColor.b * whitePointInfluence.b * isoInfluence * vignettingInfluence;
outColor.r = (outColor.r * (1.0 + (outColor.r * burnHighlights))) / (1.0 + outColor.r);
outColor.g = (outColor.g * (1.0 + (outColor.g * burnHighlights))) / (1.0 + outColor.g);
outColor.b = (outColor.b * (1.0 + (outColor.b * burnHighlights))) / (1.0 + outColor.b);
float lumFactor2 = maxExposurePhotographic(lumFactor, vec4(outColor, 0.0));
float tmpFloat = 1.0 - saturation;
outColor.r = outColor.r * saturation + lumFactor2 * tmpFloat;
outColor.g = outColor.g * saturation + lumFactor2 * tmpFloat;
outColor.b = outColor.b * saturation + lumFactor2 * tmpFloat;
outColor = max(vec3(0.0), outColor);
float crushBlacksFac = crushBlacks * 2.0 + 1.0;
float crushBlacksFac2 = pow(maxExposurePhotographic(lumFactor, vec4(outColor, 0.0)), 0.5);
tmpFloat = (1.0 - crushBlacksFac2);
if (crushBlacksFac2 < 1.0) {
outColor.r = outColor.r * crushBlacksFac2 + pow(outColor.r, crushBlacksFac) * tmpFloat;
outColor.g = outColor.g * crushBlacksFac2 + pow(outColor.g, crushBlacksFac) * tmpFloat;
outColor.b = outColor.b * crushBlacksFac2 + pow(outColor.b, crushBlacksFac) * tmpFloat;
}
return outColor;
}
float filmicBlenderDesaturationMinIntensity(vec3 color) {
float maxChannel = max(color.r, max(color.g, color.b));
float x = max(maxChannel, 0.6251);
return (1.2192868 * x - 0.63221059)
* ((x - 0.65069831) / (abs(x - 0.65069831) + 0.00952982) + 0.73015231);
}
vec3 filmicBlenderDesaturationTransform(vec3 color) {
const float CURVE_SMOOTHNESS = 0.03;
float minIntensity = filmicBlenderDesaturationMinIntensity(color);
vec4 x = vec4(color, 1.0) - minIntensity;
x = pow(x, vec4(2.0)) / (abs(x) + CURVE_SMOOTHNESS);
return (x.rgb - x.a + color + 1.0) / 2.0;
}
vec3 filmicBlenderDynamicRangeTransform(vec3 color) {
return pow(
(0.28882259 * color - 0.15880336)
/ (pow(color - 0.6229693, vec3(2.0)) + 0.16965022)
+ 0.20453365 * color + 0.37847142,
vec3(3.0)
);
}
vec3 FilmicBlenderToneMapping(vec3 color) {
color *= toneMappingExposure;
color = max(color, 0.000175);
color = clamp((log2(color) - FILMIC_BLENDER_LOG_MIN)
/ (FILMIC_BLENDER_LOG_MAX - FILMIC_BLENDER_LOG_MIN), 0.0, 1.0);
color = filmicBlenderDesaturationTransform(color);
color = clamp(color / FILMIC_BLENDER_EXPOSURE_LATITUDE_RATIO, 0.0, 1.0);
color = filmicBlenderDynamicRangeTransform(color);
return color;
}`,E2=`#ifdef USE_TRANSMISSION
material.transmission = transmission;
material.transmissionAlpha = 1.0;
material.thickness = thickness;
material.attenuationDistance = attenuationDistance;
material.attenuationColor = attenuationColor;
#ifdef USE_TRANSMISSIONMAP
material.transmission *= texture2D(transmissionMap, vUv).r;
#endif
#ifdef USE_THICKNESSMAP
material.thickness *= texture2D(thicknessMap, vUv).g;
#endif
vec3 pos = vWorldPosition;
vec3 v = normalize(cameraPosition - pos);
vec3 n = inverseTransformDirection(normal, viewMatrix);
vec4 transmission = getIBLVolumeRefraction(
n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
material.attenuationColor, material.attenuationDistance);
material.transmissionAlpha = mix(material.transmissionAlpha, transmission.a, material.transmission);
totalDiffuse = mix(totalDiffuse, transmission.rgb, material.transmission);
#endif`,w2=`#ifdef USE_TRANSMISSION
uniform float transmission;
uniform float thickness;
uniform float attenuationDistance;
uniform vec3 attenuationColor;
#ifdef USE_TRANSMISSIONMAP
uniform sampler2D transmissionMap;
#endif
#ifdef USE_THICKNESSMAP
uniform sampler2D thicknessMap;
#endif
uniform vec2 transmissionSamplerSize;
uniform sampler2D transmissionSamplerMap;
uniform mat4 modelMatrix;
uniform mat4 projectionMatrix;
varying vec3 vWorldPosition;
vec3 getVolumeTransmissionRay(const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix) {
vec3 refractionVector = refract(- v, normalize(n), 1.0 / ior);
vec3 modelScale;
modelScale.x = length(vec3(modelMatrix[0].xyz));
modelScale.y = length(vec3(modelMatrix[1].xyz));
modelScale.z = length(vec3(modelMatrix[2].xyz));
return normalize(refractionVector) * thickness * modelScale;
}
float applyIorToRoughness(const in float roughness, const in float ior) {
return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);
}
vec4 getTransmissionSample(const in vec2 fragCoord, const in float roughness, const in float ior) {
float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);
#ifdef texture2DLodEXT
return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);
#else
return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);
#endif
}
vec3 applyVolumeAttenuation(const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance) {
if (isinf(attenuationDistance)) {
return radiance;
} else {
vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;
vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);
return transmittance * radiance;
}
}
vec4 getIBLVolumeRefraction(const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
const in vec3 attenuationColor, const in float attenuationDistance) {
vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
vec3 refractedRayExit = position + transmissionRay;
vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);
vec2 refractionCoords = ndcPos.xy / ndcPos.w;
refractionCoords += 1.0;
refractionCoords /= 2.0;
vec4 transmittedLight = getTransmissionSample(refractionCoords, roughness, ior);
vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight.rgb, length(transmissionRay), attenuationColor, attenuationDistance);
vec3 F = EnvironmentBRDF(n, v, specularColor, specularF90, roughness);
return vec4((1.0 - F) * attenuatedColor * diffuseColor, transmittedLight.a);
}
#endif`,T2=`#if (defined(USE_UV) && !defined(UVS_VERTEX_ONLY))
varying vec2 vUv;
#endif`,I2=`#ifdef USE_UV
#ifdef UVS_VERTEX_ONLY
vec2 vUv;
#else
varying vec2 vUv;
#endif
uniform mat3 uvTransform;
#endif`,R2=`#ifdef USE_UV
vUv = (uvTransform * vec3(uv, 1)).xy;
#endif`,L2=`#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)
varying vec2 vUv2;
#endif`,P2=`#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)
attribute vec2 uv2;
varying vec2 vUv2;
uniform mat3 uv2Transform;
#endif`,B2=`#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)
vUv2 = (uv2Transform * vec3(uv2, 1)).xy;
#endif`,D2=`#if defined(USE_ENVMAP) || defined(DISTANCE) || defined (USE_SHADOWMAP) || defined (USE_TRANSMISSION) || NUM_SPOT_LIGHT_COORDS > 0 || defined(MASK) || defined(NODE)
vec4 worldPosition = vec4(transformed, 1.0);
#ifdef USE_INSTANCING
worldPosition = instanceMatrix * worldPosition;
#endif
worldPosition = modelMatrix * worldPosition;
#endif`;const N2=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
vUv = (uvTransform * vec3(uv, 1)).xy;
gl_Position = vec4(position.xy, 1.0, 1.0);
}`,O2=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
vec4 texColor = texture2D(t2D, vUv);
#ifdef DECODE_VIDEO_TEXTURE
texColor = vec4(mix(pow(texColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), texColor.rgb * 0.0773993808, vec3(lessThanEqual(texColor.rgb, vec3(0.04045)))), texColor.w);
#endif
texColor.rgb *= backgroundIntensity;
gl_FragColor = texColor;
#include <tonemapping_fragment>
#include <encodings_fragment>
}`,F2=`varying vec3 vWorldDirection;
#include <common>
void main() {
vWorldDirection = transformDirection(position, modelMatrix);
#include <begin_vertex>
#include <project_vertex>
gl_Position.z = gl_Position.w;
}`,U2=`#ifdef ENVMAP_TYPE_CUBE
uniform samplerCube envMap;
#elif defined(ENVMAP_TYPE_CUBE_UV)
uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
#ifdef ENVMAP_TYPE_CUBE
vec4 texColor = textureCube(envMap, vec3(flipEnvMap * vWorldDirection.x, vWorldDirection.yz));
#elif defined(ENVMAP_TYPE_CUBE_UV)
vec4 texColor = textureCubeUV(envMap, vWorldDirection, backgroundBlurriness);
#else
vec4 texColor = vec4(0.0, 0.0, 0.0, 1.0);
#endif
texColor.rgb *= backgroundIntensity;
gl_FragColor = texColor;
#include <tonemapping_fragment>
#include <encodings_fragment>
}`,z2=`varying vec3 vWorldDirection;
#include <common>
void main() {
vWorldDirection = transformDirection(position, modelMatrix);
#include <begin_vertex>
#include <project_vertex>
gl_Position.z = gl_Position.w;
}`,V2=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
vec4 texColor = textureCube(tCube, vec3(tFlip * vWorldDirection.x, vWorldDirection.yz));
gl_FragColor = texColor;
gl_FragColor.a *= opacity;
#include <tonemapping_fragment>
#include <encodings_fragment>
}`,G2=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec3 vViewPosition;
varying vec2 vProjectedPosZW;
void main() {
#include <uv_vertex>
#include <skinbase_vertex>
#ifdef USE_DISPLACEMENTMAP
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinnormal_vertex>
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition = mvPosition.xyz;
vProjectedPosZW = mat2(
projectionMatrix[2][2], projectionMatrix[2][3],
projectionMatrix[3][2], projectionMatrix[3][3]
) * mvPosition.zw;
#ifdef PANCAKE_DEPTH
gl_Position.z = max(gl_Position.z, -1.0);
#endif
}`,k2=`#if DEPTH_PACKING == 3200
uniform float opacity;
#endif
#ifdef USE_SLOPE_SCALED_BIAS
uniform float slopeScaledBias;
const float ONE_MINUS_EPS = 0.9999999;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec3 vViewPosition;
varying vec2 vProjectedPosZW;
void main() {
#include <clipping_planes_fragment>
vec4 diffuseColor = vec4(1.0);
#if DEPTH_PACKING == 3200
diffuseColor.a = opacity;
#endif
#include <map_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <logdepthbuf_fragment>
#if DEPTH_PACKING != 3202
float depth = vProjectedPosZW.x / vProjectedPosZW.y;
depth = (depth + 1.0) / 2.0;
#ifdef PANCAKE_DEPTH
depth = max(depth, 0.0);
#endif
#ifdef USE_SLOPE_SCALED_BIAS
vec2 dxdy = abs(vec2(dFdx(depth), dFdy(depth)));
float bias = slopeScaledBias * max(dxdy.x, dxdy.y);
depth = clamp(depth + max(bias, 1e-6), 0.0, ONE_MINUS_EPS);
#endif
#if DEPTH_PACKING == 3200
gl_FragColor = vec4(vec3(1.0 - depth), opacity);
#elif DEPTH_PACKING == 3201
gl_FragColor = packDepthToRGBA(depth);
#endif
#else
gl_FragColor = vec4(vViewPosition.z);
#endif
}`,Q2=`#define DISTANCE
varying vec3 vWorldPosition;
#ifdef PANCAKE_DEPTH
varying vec4 vMVPPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
#include <uv_vertex>
#include <skinbase_vertex>
#ifdef USE_DISPLACEMENTMAP
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinnormal_vertex>
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <worldpos_vertex>
#include <clipping_planes_vertex>
vWorldPosition = worldPosition.xyz;
#ifdef PANCAKE_DEPTH
vec4 mvpPosition = projectionMatrix * mvPosition;
gl_Position.z = max(mvpPosition.z, -1.0);
vMVPPosition = mvpPosition;
#endif
}`,W2=`#define DISTANCE
#ifdef USE_SLOPE_SCALED_BIAS
uniform float slopeScaledBias;
const float ONE_MINUS_EPS = 0.9999999;
#endif
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#ifdef PANCAKE_DEPTH
varying vec4 vMVPPosition;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
#ifndef DISTANCE_SCALE
#define DISTANCE_SCALE 1.0
#endif
void main () {
#include <clipping_planes_fragment>
vec4 diffuseColor = vec4(1.0);
#include <map_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
float dist = length(vWorldPosition - referencePosition);
#if DISTANCE_PACKING == 3301
dist = (dist - nearDistance) / (farDistance - nearDistance);
dist = saturate(dist);
#ifdef USE_SLOPE_SCALED_BIAS
vec2 dxdy = abs(vec2(dFdx(dist), dFdy(dist)));
float bias = slopeScaledBias * max(dxdy.x, dxdy.y);
dist = clamp(dist + bias, 0.0, ONE_MINUS_EPS);
#endif
gl_FragColor = packDepthToRGBA(dist);
#elif DISTANCE_PACKING == 3302
#ifdef USE_SLOPE_SCALED_BIAS
vec2 dxdy = abs(vec2(dFdx(dist), dFdy(dist)));
dist += slopeScaledBias * max(dxdy.x, dxdy.y);
#endif
#ifdef PANCAKE_DEPTH
if (vMVPPosition.z < -1.0) {
dist = length(vec3(vMVPPosition.x * CAM_WIDTH, vMVPPosition.y * CAM_HEIGHT, nearDistance));
}
#endif
gl_FragColor = vec4(dist * DISTANCE_SCALE, 0.0, 0.0, 1.0);
#endif
}`,H2=`varying vec3 vWorldDirection;
#include <common>
void main() {
vWorldDirection = transformDirection(position, modelMatrix);
#include <begin_vertex>
#include <project_vertex>
}`,X2=`uniform sampler2D tEquirect;
uniform bool invertU;
uniform float offsetU;
varying vec3 vWorldDirection;
#include <common>
void main() {
vec3 direction = normalize(vWorldDirection);
vec2 sampleUV;
sampleUV.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;
sampleUV.x = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;
if (invertU) {
sampleUV.x = 1.0 - sampleUV.x;
}
sampleUV.x += offsetU;
gl_FragColor = texture2D(tEquirect, sampleUV);
#include <tonemapping_fragment>
#include <encodings_fragment>
}`,Y2=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
vLineDistance = scale * lineDistance;
#include <color_vertex>
#include <morphcolor_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <fog_vertex>
}`,j2=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
#include <clipping_planes_fragment>
if (mod(vLineDistance, totalSize) > dashSize) {
discard;
}
vec3 outgoingLight = vec3(0.0);
vec4 diffuseColor = vec4(diffuse, opacity);
#include <logdepthbuf_fragment>
#include <color_fragment>
outgoingLight = diffuseColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
}`,K2=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <morphcolor_vertex>
#if defined (USE_ENVMAP) || defined (USE_SKINNING)
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <worldpos_vertex>
#include <envmap_vertex>
#include <fog_vertex>
}`,q2=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
#include <clipping_planes_fragment>
vec4 diffuseColor = vec4(diffuse, opacity);
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <specularmap_fragment>
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#ifdef USE_LIGHTMAP
vec4 lightMapTexel = texture2D(lightMap, vUv2);
reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
#else
reflectedLight.indirectDiffuse += vec3(1.0);
#endif
#include <aomap_fragment>
reflectedLight.indirectDiffuse *= diffuseColor.rgb;
vec3 outgoingLight = reflectedLight.indirectDiffuse;
#include <envmap_fragment>
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,Z2=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <morphcolor_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition = -mvPosition.xyz;
#include <worldpos_vertex>
#include <envmap_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,J2=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#if defined(SHADOWMAP_TYPE_ESM) || defined(USE_ENVMAP)
uniform mat4 invViewMatrix;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
#include <clipping_planes_fragment>
vec4 diffuseColor = vec4(diffuse, opacity);
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
vec3 totalEmissiveRadiance = emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <specularmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_lambert_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
#include <envmap_fragment>
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,$2=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
#include <uv_vertex>
#include <color_vertex>
#include <morphcolor_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <fog_vertex>
vViewPosition = -mvPosition.xyz;
}`,e3=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
#include <clipping_planes_fragment>
vec4 diffuseColor = vec4(diffuse, opacity);
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
vec3 viewDir = normalize(vViewPosition);
vec3 x = normalize(vec3(viewDir.z, 0.0, - viewDir.x));
vec3 y = cross(viewDir, x);
vec2 uv = vec2(dot(x, normal), dot(y, normal)) * 0.495 + 0.5;
#ifdef USE_MATCAP
vec4 matcapColor = texture2D(matcap, uv);
#else
vec4 matcapColor = vec4(vec3(mix(0.2, 0.8, uv.y)), 1.0);
#endif
vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,t3=`#define NORMAL
#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)
varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
#include <uv_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)
vViewPosition = -mvPosition.xyz;
#endif
}`,n3=`#define NORMAL
uniform float opacity;
#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)
varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
#include <clipping_planes_fragment>
#include <logdepthbuf_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
gl_FragColor = vec4(packNormalToRGB(normal), opacity);
#ifdef OPAQUE
gl_FragColor.a = 1.0;
#endif
}`,i3=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <morphcolor_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition = -mvPosition.xyz;
#include <worldpos_vertex>
#include <envmap_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,o3=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#if defined(SHADOWMAP_TYPE_ESM) || defined(USE_ENVMAP)
uniform mat4 invViewMatrix;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
#include <clipping_planes_fragment>
vec4 diffuseColor = vec4(diffuse, opacity);
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
vec3 totalEmissiveRadiance = emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <specularmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_phong_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
#include <envmap_fragment>
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,r3=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#include <plane_reflection_pars_vertex>
void main() {
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <morphcolor_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <plane_reflection_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition = -mvPosition.xyz;
#include <worldpos_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
#ifdef USE_TRANSMISSION
vWorldPosition = worldPosition.xyz;
#endif
}`,a3=`#define STANDARD
#ifdef PHYSICAL
#define IOR
#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
uniform float ior;
#endif
#ifdef SPECULAR
uniform float specularIntensity;
uniform vec3 specularColor;
#ifdef USE_SPECULARINTENSITYMAP
uniform sampler2D specularIntensityMap;
#endif
#ifdef USE_SPECULARCOLORMAP
uniform sampler2D specularColorMap;
#endif
#endif
#ifdef USE_CLEARCOAT
uniform float clearcoat;
uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
uniform float iridescence;
uniform float iridescenceIOR;
uniform float iridescenceThicknessMinimum;
uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
uniform vec3 sheenColor;
uniform float sheenRoughness;
#ifdef USE_SHEENCOLORMAP
uniform sampler2D sheenColorMap;
#endif
#ifdef USE_SHEENROUGHNESSMAP
uniform sampler2D sheenRoughnessMap;
#endif
#endif
#if defined(SHADOWMAP_TYPE_ESM) || defined(USE_ENVMAP)
uniform mat4 invViewMatrix;
#endif
#if defined(USE_PLANE_REFLECTION) && !defined(USE_TRANSMISSION)
uniform mat4 modelMatrix;
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
#include <plane_reflection_pars_fragment>
#include <oit_weighted_pars_fragment>
void main() {
#include <clipping_planes_fragment>
vec4 diffuseColor = vec4(diffuse, opacity);
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
vec3 totalEmissiveRadiance = emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <roughnessmap_fragment>
#include <metalnessmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <clearcoat_normal_fragment_begin>
#include <clearcoat_normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_physical_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
#include <transmission_fragment>
vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
#ifdef USE_SHEEN
float sheenEnergyComp = 1.0 - 0.157 * max3(material.sheenColor);
outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
#endif
#ifdef USE_CLEARCOAT
float dotNVcc = saturate(dot(geometry.clearcoatNormal, geometry.viewDir));
vec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);
outgoingLight = outgoingLight * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;
#endif
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
#include <oit_weighted_fragment>
}`,s3=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <morphcolor_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition = -mvPosition.xyz;
#include <worldpos_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,l3=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#if defined(SHADOWMAP_TYPE_ESM)
uniform mat4 invViewMatrix;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
#include <clipping_planes_fragment>
vec4 diffuseColor = vec4(diffuse, opacity);
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
vec3 totalEmissiveRadiance = emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_toon_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,c3=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
#include <color_vertex>
#include <morphcolor_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
gl_PointSize = size;
#ifdef USE_SIZEATTENUATION
bool isPerspective = isPerspectiveMatrix(projectionMatrix);
if (isPerspective) gl_PointSize *= (scale / - mvPosition.z);
#endif
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <worldpos_vertex>
#include <fog_vertex>
}`,u3=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
#include <clipping_planes_fragment>
vec3 outgoingLight = vec3(0.0);
vec4 diffuseColor = vec4(diffuse, opacity);
#include <logdepthbuf_fragment>
#include <map_particle_fragment>
#include <color_fragment>
#include <alphatest_fragment>
outgoingLight = diffuseColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
}`,d3=`#include <common>
#ifdef USE_SHADOWMAP
varying vec3 vViewPosition;
#endif
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
#include <worldpos_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
#ifdef USE_SHADOWMAP
vViewPosition = -mvPosition.xyz;
#endif
}`,h3=`uniform vec3 color;
uniform float opacity;
#ifdef USE_SHADOWMAP
varying vec3 vViewPosition;
#ifdef SHADOWMAP_TYPE_ESM
uniform mat4 invViewMatrix;
#endif
#endif
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
gl_FragColor = vec4(color, opacity * (1.0 - getShadowMask()));
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
}`,p3=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
#include <uv_vertex>
vec4 mvPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);
vec2 scale;
scale.x = length(vec3(modelMatrix[0].x, modelMatrix[0].y, modelMatrix[0].z));
scale.y = length(vec3(modelMatrix[1].x, modelMatrix[1].y, modelMatrix[1].z));
#ifndef USE_SIZEATTENUATION
bool isPerspective = isPerspectiveMatrix(projectionMatrix);
if (isPerspective) scale *= -mvPosition.z;
#endif
vec2 alignedPosition = (position.xy - (center - vec2(0.5))) * scale;
vec2 rotatedPosition;
rotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;
rotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;
mvPosition.xy += rotatedPosition;
gl_Position = projectionMatrix * mvPosition;
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <fog_vertex>
}`,f3=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
#include <clipping_planes_fragment>
vec3 outgoingLight = vec3(0.0);
vec4 diffuseColor = vec4(diffuse, opacity);
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
outgoingLight = diffuseColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
}`,m3=`#define MASK
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
uniform mat4 textureMatrix;
varying vec3 vViewPosition;
varying vec4 projTexCoord;
void main() {
#include <uv_vertex>
#include <skinbase_vertex>
#ifdef USE_DISPLACEMENTMAP
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinnormal_vertex>
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
vViewPosition = -mvPosition.xyz;
#include <worldpos_vertex>
projTexCoord = textureMatrix * worldPosition;
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
}`,g3=`#define MASK
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
uniform float opacity;
uniform sampler2D depthTexture;
uniform vec2 cameraNearFar;
varying vec3 vViewPosition;
varying vec4 projTexCoord;
void main() {
#include <clipping_planes_fragment>
vec4 diffuseColor = vec4(1.0);
diffuseColor.a = opacity;
#include <map_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <logdepthbuf_fragment>
float depth = unpackRGBAToDepth(texture2DProj(depthTexture, projTexCoord));
float viewZ;
if (isOrthographic)
viewZ = -orthographicDepthToViewZ(depth,
cameraNearFar.x, cameraNearFar.y);
else
viewZ = -perspectiveDepthToViewZ(depth,
cameraNearFar.x, cameraNearFar.y);
float depthTest = (vViewPosition.z > viewZ) ? 1.0 : 0.0;
gl_FragColor = vec4(0.0, depthTest, 1.0, 0.0);
}`,v3=`#define NODE
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
varying vec3 vNormal;
#endif
#include <common>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#include <plane_reflection_pars_vertex>
#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_SKYDOME_LIGHT_AR) || defined(NODE_ENV_SPHERE_MY)
varying vec3 vWorldPosition;
#endif
#include <node_pars_vertex>
void main() {
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
vNormal = normalize(transformedNormal);
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <plane_reflection_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition = -mvPosition.xyz;
#include <worldpos_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_SKYDOME_LIGHT_AR) || defined(NODE_ENV_SPHERE_MY)
vWorldPosition = worldPosition.xyz;
#endif
#include <node_vertex>
}`,_3=`#define NODE
#define STANDARD
#define PHYSICAL
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <alphatest_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#if defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_TEX_COORD_BL) || defined(NODE_NORMAL_MAP_BL) || defined(NODE_LAYER_WEIGHT_BL) || defined(NODE_FRESNEL_BL) || defined(NODE_BUMP_BL) || defined(NODE_BSDF_GLASS_BL) || defined(NODE_BSDF_PRINCIPLED_BL) || defined(NODE_TANGENT_BL) || defined(NODE_BITMAP_MX) || defined(NODE_GRADIENT_MX) || defined(NODE_GRADIENT_RAMP_MX) || defined(NODE_NOISE_MX) || defined(NODE_SAMPLER_INFO_MY) || defined(NODE_INCIDENT) || defined(NODE_POSITION) || defined(NODE_NORMAL) || defined(USE_OSL) || defined(USE_ENVMAP) || defined(SHADOWMAP_TYPE_ESM) && (defined(NODE_BSDF_DIFFUSE_BL) || defined(NODE_EEVEE_SPECULAR_BL) || defined(NODE_BSDF_GLOSSY_BL) || defined(NODE_BSDF_REFRACTION_BL) || defined(NODE_MATERIAL_MX) || defined(NODE_PHYSICAL_MX) || defined(NODE_STANDARD_SURFACE_AR) || defined(NODE_SHADOW_MATTE_AR))
uniform mat4 invViewMatrix;
#endif
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_node_pars_fragment>
#include <lights_node_gtao_pars_fragment>
#include <shadowmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
#if defined(USE_SSR)
uniform mat4 projectionMatrix;
#endif
#if defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_TEX_COORD_BL) || defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_TANGENT_BL) || defined(NODE_OBJECT_INFO_BL) || defined(NODE_BITMAP_MX) || defined(NODE_GRADIENT_MX) || defined(NODE_GRADIENT_RAMP_MX) || defined(NODE_NOISE_MX) || defined(NODE_SAMPLER_INFO_MY) || defined(NODE_TRANSFORM_MY) || defined(USE_OSL) || defined(USE_PLANE_REFLECTION)
uniform mat4 modelMatrix;
uniform mat4 invModelMatrix;
#endif
#if defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_NORMAL_MAP_BL) || defined(NODE_NORMAL_BUMP_MX) || defined(NODE_BUMP_2D_MY) || defined(NODE_SAMPLER_INFO_MY)
uniform mat4 modelViewMatrix;
#endif
#if defined(NODE_TEX_IMAGE_BL)
uniform mat3 normalMatrix;
#endif
#if defined(NODE_TEX_COORD_BL) || defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_TANGENT_BL)
uniform vec3 boundingBoxMin;
uniform vec3 boundingBoxMax;
#endif
#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_SKYDOME_LIGHT_AR) || defined(NODE_ENV_SPHERE_MY)
varying vec3 vWorldPosition;
#endif
#if defined(NODE_TEX_COORD_BL)
uniform vec2 viewWidthHeight;
#endif
#include <ssr_pars_fragment>
#include <plane_reflection_pars_fragment>
#include <node_common_frag>
#include <node_pars_fragment>
#include <oit_weighted_pars_fragment>
void main() {
#include <clipping_planes_fragment>
#include <logdepthbuf_fragment>
#include <normal_fragment_begin>
vec4 outgoingLight = vec4(0.0);
#include <node_fragment>
#if WORLD_NODES == 1
outgoingLight.a = 1.0;
#endif
#ifdef USE_ALPHATEST
if (outgoingLight.a < alphaTest)
discard;
else
outgoingLight.a = 1.0;
#endif
#if defined(OPAQUE) && !(defined(NODE_HOLDOUT_BL) || defined(NODE_MATTE_SHADOW_MX) || defined(NODE_SHADOW_MATTE_AR) || defined(NODE_AI_SHADOW_MATTE_MY))
outgoingLight.a = 1.0;
#endif
gl_FragColor = vec4(outgoingLight);
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
#include <normal_output_fragment>
#include <oit_weighted_fragment>
}`;var A3=`
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
varying vec3 vNormal;
#endif
struct NodeMaterial {
vec3 diffuseColor;
float roughness;
vec3 specularColor;
float specularF90;
vec3 fresnelRefl90;
vec3 refractionColor;
float refractionRoughness;
float refractionIOR;
#ifdef USE_CLEARCOAT
float clearcoat;
float clearcoatRoughness;
vec3 clearcoatF0;
float clearcoatF90;
#endif
#ifdef USE_SHEEN
vec3 sheenColor;
float sheenRoughness;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
#define BLENDER_SPECULAR_COEFFICIENT 0.08
vec3 clearcoatSpecular = vec3(0.0);
vec3 sheenSpecular = vec3(0.0);
float IBLSheenBRDF(const in vec3 normal, const in vec3 viewDir, const in float roughness) {
float dotNV = saturate(dot(normal, viewDir));
float r2 = roughness * roughness;
float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
float DG = exp(a * dotNV + b) + (roughness < 0.25 ? 0.0 : 0.1 * (roughness - 0.25));
return saturate(DG * RECIPROCAL_PI);
}
vec2 DFGApprox(const in vec3 normal, const in vec3 viewDir, const in float roughness) {
float dotNV = saturate(dot(normal, viewDir));
const vec4 c0 = vec4(- 1, -0.0275, -0.572, 0.022);
const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(- 9.28 * dotNV)) * r.x + r.y;
vec2 fab = vec2(- 1.04, 1.04) * a004 + r.zw;
return fab;
}
vec3 EnvironmentBRDF(const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness) {
vec2 fab = DFGApprox(normal, viewDir, roughness);
return specularColor * fab.x + specularF90 * fab.y;
}
float clearcoatDHRApprox(const in float roughness, const in float dotNL) {
return DEFAULT_SPECULAR_COEFFICIENT + (1.0 - DEFAULT_SPECULAR_COEFFICIENT) * (pow(1.0 - dotNL, 5.0) * pow(1.0 - roughness, 2.0));
}
#if NUM_RECT_AREA_LIGHTS > 0
void RE_Direct_RectArea_Node(const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {
vec3 normal = geometry.normal;
vec3 viewDir = geometry.viewDir;
vec3 position = geometry.position;
vec3 lightPos = rectAreaLight.position;
vec3 halfWidth = rectAreaLight.halfWidth;
vec3 halfHeight = rectAreaLight.halfHeight;
vec3 lightColor = rectAreaLight.color;
float roughness = material.roughness;
vec3 rectCoords[4];
rectCoords[0] = lightPos + halfWidth - halfHeight;
rectCoords[1] = lightPos - halfWidth - halfHeight;
rectCoords[2] = lightPos - halfWidth + halfHeight;
rectCoords[3] = lightPos + halfWidth + halfHeight;
vec2 uv = LTC_Uv(normal, viewDir, roughness);
vec4 t1 = texture2D(ltc_1, uv);
vec4 t2 = texture2D(ltc_2, uv);
mat3 mInv = mat3(
vec3(t1.x, 0, t1.y),
vec3( 0, 1, 0),
vec3(t1.z, 0, t1.w)
);
vec3 fresnel = (material.specularColor * t2.x + (vec3(1.0) - material.specularColor) * t2.y);
reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate(normal, viewDir, position, mInv, rectCoords);
reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate(normal, viewDir, position, mat3(1.0), rectCoords);
}
#endif
void RE_Direct_Node(const in IncidentLight directLight, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {
float dotNL = saturate(dot(geometry.normal, directLight.direction));
vec3 irradiance = dotNL * directLight.color;
#ifdef USE_CLEARCOAT
float dotNLcc = saturate(dot(geometry.clearcoatNormal, directLight.direction));
vec3 ccIrradiance = dotNLcc * directLight.color;
clearcoatSpecular += ccIrradiance * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness);
#endif
#ifdef USE_SHEEN
sheenSpecular += irradiance * BRDF_Sheen(directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness);
#endif
reflectedLight.directSpecular += irradiance * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness);
reflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
void RE_IndirectDiffuse_Node(const in vec3 irradiance, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {
reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
void RE_IndirectSpecular_Node(const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {
#ifdef USE_CLEARCOAT
clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF(geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness);
#endif
#ifdef USE_SHEEN
sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF(geometry.normal, geometry.viewDir, material.sheenRoughness);
#endif
#ifdef MT_BLENDER
#ifdef COMPAT_USE_SPEC_ENV_BLENDER_APPROX
vec3 specEnv = BRDF_Specular_GGX_Environment_Blender_Approx(geometry,
material.specularColor, material.fresnelRefl90,
material.roughness, 0);
#else
vec3 specEnv = BRDF_Specular_GGX_Environment(geometry.viewDir,
geometry.normal, material.specularColor,
material.roughness);
#endif
#elif defined(MT_MAX)
float alphaEnv = pow2(pow2(material.roughness));
vec3 specEnv = material.specularColor / (1.0 - alphaEnv + PI * alphaEnv);
#elif defined(MT_MAYA)
vec3 specEnv = BRDF_Specular_GGX_Environment_Maya(geometry.viewDir, geometry.normal, material.specularColor, material.fresnelRefl90, material.roughness);
#else
vec3 specEnv = vec3(1.0);
#endif
reflectedLight.indirectSpecular += radiance * specEnv;
}
void RE_Refraction_Node(const vec3 refraction, const NodeMaterial material, inout vec3 refractedLight) {
refractedLight += refraction * material.refractionColor;
}
#ifdef MT_BLENDER
#define Material_BlinnShininessExponent(material) GGXRoughnessToBlinnExponent(material.roughness)
#define Material_Refraction_BlinnShininessExponent(material) GGXRoughnessToBlinnExponent(material.refractionRoughness)
#elif defined(MT_MAX)
#define Material_BlinnShininessExponent(material) GGXRoughnessToBlinnExponent(material.roughness * exp(0.35*(1.0-pow2(material.roughness))))
#define Material_Refraction_BlinnShininessExponent(material) GGXRoughnessToBlinnExponent(material.refractionRoughness * exp(0.35*(1.0-pow2(material.refractionRoughness))))
#else
#define Material_BlinnShininessExponent(material) GGXRoughnessToBlinnExponent(material.roughness)
#define Material_Refraction_BlinnShininessExponent(material) GGXRoughnessToBlinnExponent(material.refractionRoughness)
#endif
#define Material_ClearCoat_BlinnShininessExponent(material) GGXRoughnessToBlinnExponent(material.clearcoatRoughness)
float computeSpecularOcclusion(const in float dotNV, const in float ambientOcclusion, const in float roughness) {
return saturate(pow(abs(dotNV + ambientOcclusion), exp2(- 16.0 * roughness - 1.0)) - 1.0 + ambientOcclusion);
}
void RE_DirectDiffuseOnly_Node(const in IncidentLight directLight, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {
float dotNL = saturate(dot(geometry.normal, directLight.direction));
vec3 irradiance = dotNL * directLight.color;
reflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
void RE_IndirectDiffuse_Empty(const in vec3 irradiance, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {}
#define RE_Direct_RectArea RE_Direct_RectArea_Node`,x3=`#ifdef USE_GTAO
uniform sampler2D gtaoMap;
uniform vec2 currResolution;
float calcGTAOVisibilityFix(vec3 viewDir, vec3 normal) {
float slopeCoeff = saturate(dot(viewDir, normal));
return pow(2.0 / (slopeCoeff + 1.0), log2(PI) - 1.0);
}
float calcSolidAngle(float radiusAngle) {
return PI2 * (1.0 - cos(radiusAngle));
}
float calcSolidAnglesIntersectionApprox(float radiusAngle0, float radiusAngle1,
float distanceAngle) {
float rp = radiusAngle0, rl = radiusAngle1, d = distanceAngle;
float rDiff = abs(rp - rl);
return PI2 * (1.0 - cos(min(rp, rl))) * smoothstep(0.0, 1.0, 1.0 -
(d - rDiff) / (rp + rl - rDiff));
}
float calcGTSOVisibility(float aoVisibility, vec3 bentNormal, vec3 viewDir, vec3 normal,
float roughness) {
aoVisibility = saturate(aoVisibility * calcGTAOVisibilityFix(viewDir, normal));
float radiusAngleVisCone = acos(clamp(sqrt(1.0 - aoVisibility), -1.0, 1.0));
float radiusAngleSpecCone = acos(clamp(exp2(-3.32193 * pow2(roughness)), -1.0, 1.0));
radiusAngleSpecCone = max(0.001, radiusAngleSpecCone);
vec3 specularConeAxis = -reflect(viewDir, normal);
float distanceAngle = acos(clamp(dot(bentNormal, specularConeAxis), -1.0, 1.0));
float solidAngleIntersection = calcSolidAnglesIntersectionApprox(
radiusAngleVisCone, radiusAngleSpecCone, distanceAngle);
float solidAngleSpecular = calcSolidAngle(radiusAngleSpecCone);
float specVisibility = solidAngleIntersection / solidAngleSpecular;
return mix(specVisibility, 1.0, aoVisibility);
}
#endif`,y3=`#ifdef USE_GTAO
reflectedLight.indirectSpecular *= calcGTSOVisibility(gtaoVisibility,
gtaoBentNormal, gtaoViewDir, gtaoNormal, gtaoRoughness);
#endif`,b3=`#if NORMAL_OUTPUT == 1
gl_FragColor = vec4(packNormalToRGB(normal), gl_FragColor.a);
#endif`,C3=`#ifdef USE_SSR
uniform sampler2D ssrSourceBuffer;
uniform sampler2D ssrDepthBuffer;
uniform sampler2D ssrBackfaceDepthBuffer;
uniform mat4 invProjectionMatrix;
uniform vec2 ssrResolution;
uniform float ssrThickness;
uniform float ssrStride;
uniform float ssrJitter;
uniform float ssrMaxDistance;
#ifdef USE_SSR_REFRACT
#define STEPS_FADE_AMOUNT 0.1
#define SCREEN_FADE_THRESHOLD 0.6
#else
#define STEPS_FADE_AMOUNT 1.0
#define SCREEN_FADE_THRESHOLD 0.4
#endif
vec3 deproject(vec3 p) {
vec4 res = invProjectionMatrix * vec4(p, 1);
return res.xyz / res.w;
}
bool doesIntersect(float rayzmax, float rayzmin, vec2 uv) {
float sceneZMin = texture2D(ssrDepthBuffer, uv).r;
#ifdef USE_SSR_REFRACT
return rayzmin >= (sceneZMin-ssrThickness) && rayzmax <= sceneZMin;
#else
float sceneZMax = texture2D(ssrBackfaceDepthBuffer, uv).r;
return rayzmin >= sceneZMax && rayzmax <= sceneZMin;
#endif
}
float distanceSquared(vec2 a, vec2 b) { a -= b; return dot(a, a); }
void swapIfBigger(inout float a, inout float b) {
if (a > b) {
float t = a;
a = b;
b = t;
}
}
bool isOutsideUvBounds(float x) { return x < 0.0 || x > 1.0; }
bool isOutsideUvBounds(vec2 uv) { return isOutsideUvBounds(uv.x) || isOutsideUvBounds(uv.y); }
vec3 computeSSR(vec3 color, vec3 normal, float ior) {
vec2 uv = gl_FragCoord.xy / ssrResolution;
vec2 screenCoord = uv * 2.0 - vec2(1, 1);
float nearClip = deproject(vec3(0, 0, -1)).z;
vec3 ray = deproject(vec3(screenCoord, -1));
ray /= ray.z;
float depthSample = -vViewPosition.z;
vec3 vpos = depthSample * ray;
#ifdef USE_SSR_REFRACT
vec3 dir = normalize(refract(normalize(vpos), normalize(normal), 1.0/ior));
#else
vec3 dir = normalize(reflect(normalize(vpos), normalize(normal)));
#endif
float maxDist = ssrMaxDistance;
float rayLength = (vpos.z + dir.z * maxDist) > nearClip ? (nearClip - vpos.z) / dir.z : maxDist;
vec3 csOrig = vpos;
vec3 csEndPoint = csOrig + dir * rayLength;
vec4 H0 = projectionMatrix * vec4(csOrig, 1.0);
vec4 H1 = projectionMatrix * vec4(csEndPoint, 1.0);
float k0 = 1.0 / H0.w, k1 = 1.0 / H1.w;
vec3 Q0 = csOrig.xyz * k0, Q1 = csEndPoint.xyz * k1;
vec2 P0 = H0.xy * k0, P1 = H1.xy * k1;
P0 = P0 * 0.5 + vec2(0.5), P1 = P1 * 0.5 + vec2(0.5);
#ifndef SSR_SIMPLE_REFRACT
P0 *= ssrResolution, P1 *= ssrResolution;
P1 += vec2((distanceSquared(P0, P1) < 0.0001) ? 0.01 : 0.0);
vec2 delta = P1 - P0;
bool permute = false;
if (abs(delta.x) < abs(delta.y)) {
permute = true; delta = delta.yx; P0 = P0.yx; P1 = P1.yx;
}
float stepDir = sign(delta.x);
float invdx = stepDir / delta.x;
vec3 dQ = (Q1 - Q0) * invdx;
float dk = (k1 - k0) * invdx;
vec2 dP = vec2(stepDir, delta.y * invdx);
float pixelStride = ssrStride;
float jitterMod = (gl_FragCoord.x + gl_FragCoord.y) * 0.25;
vec4 PQK = vec4(P0, Q0.z, k0);
vec4 dPQK = vec4(dP, dQ.z, dk);
dPQK *= pixelStride;
PQK += dPQK * mod(jitterMod, 1.0) * ssrJitter;
float end = P1.x * stepDir;
float prevZMaxEstimate = PQK.z / PQK.w;
float rayZMin = prevZMaxEstimate, rayZMax = prevZMaxEstimate;
float stepped = 0.0;
vec2 hitUV;
bool intersected = false;
for (float stepCount = 1.0; stepCount <= float(MAX_STEPS); stepCount ++) {
PQK += dPQK;
rayZMin = prevZMaxEstimate;
rayZMax = (dPQK.z * 0.5 + PQK.z) / (dPQK.w * 0.5 + PQK.w);
prevZMaxEstimate = rayZMax;
swapIfBigger(rayZMax, rayZMin);
stepped = stepCount;
hitUV = (permute ? PQK.yx: PQK.xy) / ssrResolution;
if (isOutsideUvBounds(hitUV)) break;
intersected = doesIntersect(rayZMax, rayZMin, hitUV);
if (intersected || (P0.x * stepDir) > end) break;
}
if (intersected && pixelStride > 1.0) {
PQK -= dPQK;
dPQK /= ssrStride;
float ogStride = pixelStride * 0.5;
float currStride = pixelStride;
prevZMaxEstimate = PQK.z / PQK.w;
rayZMin = prevZMaxEstimate, rayZMax = prevZMaxEstimate;
for(int j = 0; j < int(BINARY_SEARCH_ITERATIONS); j ++) {
PQK += dPQK * currStride;
rayZMin = prevZMaxEstimate;
rayZMax = (dPQK.z * 0.5 + PQK.z) / (dPQK.w * 0.5 + PQK.w);
prevZMaxEstimate = rayZMax;
swapIfBigger(rayZMax, rayZMin);
vec2 newUV = (permute ? PQK.yx: PQK.xy) / ssrResolution;
ogStride *= 0.5;
if (doesIntersect(rayZMax, rayZMin, newUV)) {
hitUV = newUV;
currStride = -ogStride;
} else {
currStride = ogStride;
}
}
}
vec3 result = color;
#ifdef USE_SSR_REFRACT
#endif
if (intersected) {
vec4 col = texture2D(ssrSourceBuffer, hitUV);
vec2 ndc = abs(hitUV * 2.0 - 1.0);
float maxndc = max(ndc.x, ndc.y);
float fadeVal =
(1.0 - (max(0.0, maxndc - SCREEN_FADE_THRESHOLD) / (1.0 - SCREEN_FADE_THRESHOLD))) *
(1.0 - STEPS_FADE_AMOUNT * (stepped / float(MAX_STEPS)));
col.a = fadeVal;
result = mix(result, col.rgb, col.a);
}
#else
vec3 result = texture2D(ssrSourceBuffer, P1).xyz;
#endif
return result;
}
#endif`,S3=`#ifdef USE_PLANE_REFLECTION
uniform mat4 planeReflTextureMatrix;
varying vec4 vPlaneReflUv;
#endif`,M3=`#ifdef USE_PLANE_REFLECTION
uniform sampler2D planeReflTexture;
uniform mat4 planeReflTextureMatrix;
uniform vec3 planeReflDir;
uniform vec3 planeReflBoundingBoxMin;
uniform vec3 planeReflBoundingBoxMax;
uniform mat4 planeReflInvModelMatrix;
uniform float planeReflFalloff;
varying vec4 vPlaneReflUv;
vec3 computePlaneReflection(vec3 radiance, float roughness, vec3 position, vec3 normal, mat4 modelMatrix) {
vec3 posRefl = (planeReflInvModelMatrix * invViewMatrix * vec4(position, 1.0)).xyz;
if (any(lessThan(posRefl, planeReflBoundingBoxMin)) || any(greaterThan(posRefl, planeReflBoundingBoxMax)))
return radiance;
vec3 norWorld = transformDirection(normal, invViewMatrix);
vec3 uvNormalOffsetScale;
uvNormalOffsetScale.x = length(vec3(modelMatrix[0].xyz));
uvNormalOffsetScale.y = length(vec3(modelMatrix[1].xyz));
uvNormalOffsetScale.z = length(vec3(modelMatrix[2].xyz));
vec4 uvNormalOffset = planeReflTextureMatrix * vec4((norWorld - planeReflDir) * uvNormalOffsetScale, 0.0);
vec3 result = texture2DProj(planeReflTexture, vPlaneReflUv + uvNormalOffset).rgb;
float falloffFactor;
if (planeReflFalloff < EPSILON)
falloffFactor = 0.0;
else if (posRefl.y > 0.0)
falloffFactor = 1.0 - clamp((planeReflBoundingBoxMax.y - posRefl.y) / (planeReflBoundingBoxMax.y * (planeReflFalloff)), 0.0, 1.0);
else
falloffFactor = 1.0 - clamp((planeReflBoundingBoxMin.y - posRefl.y) / (planeReflBoundingBoxMin.y * (planeReflFalloff)), 0.0, 1.0);
result = mix(result, radiance, falloffFactor);
result = mix(result, radiance, (roughness < 0.0526) ? 0.0 : saturate(10.0*roughness));
return result;
}
#endif`,E3=`#ifdef USE_PLANE_REFLECTION
vPlaneReflUv = planeReflTextureMatrix * modelMatrix * vec4(position, 1.0);
#endif`,w3=`#ifdef USE_OIT_WEIGHTED
layout(location = 1) out float outBufferR;
#endif`,T3=`#ifdef USE_OIT_WEIGHTED
float weight = 1.0 - gl_FragCoord.z;
outBufferR = gl_FragColor.a * weight;
pc_fragColor = vec4(gl_FragColor.rgb * weight, gl_FragColor.a);
#endif`,I3=`
#define LUM_WEIGHTS vec3(0.2126, 0.7152, 0.0722)
#define LUM_WEIGHTS_MAYA vec3(0.3, 0.59, 0.11)
#define LUMENS_PER_WATT 683.0
#define MAX_ENV_COORDS_DIR 0
#define MAX_ENV_COORDS_REFLECT 1
#define MAX_ENV_COORDS_REFRACT 2
#if defined(NODE_COLOR_CONVERT_AR) || defined(NODE_COLOR_CORRECT_AR) || defined(NODE_COMBINE_COLOR_BL) || defined(NODE_SEPARATE_COLOR_BL) || defined(NODE_COMBHSV_BL) || defined(NODE_SEPHSV_BL) || defined(NODE_HUE_SAT_BL) || defined(NODE_COLOR_CORRECTION_MX) || defined(NODE_COMPOSITE_LAYER_MX) || defined(NODE_COLOR_CORRECT_MY) || defined(USE_OSL)
#define HSV_NODES
#endif
vec4 nodeTexelToLinear(in vec4 color, in int sourceType) {
if (sourceType == 1) {
return vec4(pow(color.rgb, vec3(2.2)), color.a);
}else
return color;
}
vec3 xyz_to_sRGB(vec3 xyz) {
mat3 convMat = mat3(
3.2406, -0.9689, 0.0557,
-1.5372, 1.8758, -0.2040,
-0.4986, 0.0415, 1.0570
);
return convMat * xyz;
}
vec3 xyY_to_XYZ(float x, float y, float Y) {
float X = 0.0;
float Z = 0.0;
if (y != 0.0) {
X = (Y / y) * x;
Z = (Y / y) * (1.0 - x - y);
}
return vec3(X, Y, Z);
}
float getSmoothFactor(float a, float b, float smoothness) {
return max(smoothness - abs(a - b), 0.0) / smoothness;
}
float smoothMin(float a, float b, float smoothness) {
float smoothFac = getSmoothFactor(a, b, smoothness);
return min(a, b) - smoothFac * smoothFac * smoothFac * smoothness * (1.0 / 6.0);
}
float smoothMax(float a, float b, float smoothness) {
float smoothFac = getSmoothFactor(a, b, smoothness);
return max(a, b) + smoothFac * smoothFac * smoothFac * smoothness * (1.0 / 6.0);
}
#if defined HSV_NODES
void hsvToRGB(vec4 hsv, out vec4 outCol)
{
float i, f, p, q, t, h, s, v;
vec3 rgb;
h = hsv[0];
s = hsv[1];
v = hsv[2];
if (s == 0.0)
rgb = vec3(v, v, v);
else {
if (h == 1.0)
h = 0.0;
h *= 6.0;
i = floor(h);
f = h - i;
rgb = vec3(f, f, f);
p = v * (1.0 - s);
q = v * (1.0 - (s * f));
t = v * (1.0 - (s * (1.0 - f)));
if (i == 0.0)
rgb = vec3(v, t, p);
else if (i == 1.0)
rgb = vec3(q, v, p);
else if (i == 2.0)
rgb = vec3(p, v, t);
else if (i == 3.0)
rgb = vec3(p, q, v);
else if (i == 4.0)
rgb = vec3(t, p, v);
else
rgb = vec3(v, p, q);
}
outCol = vec4(rgb, hsv.w);
}
void rgbToHSV(vec4 rgb, out vec4 outCol)
{
float cmax, cmin, h, s, v, cdelta;
vec3 c;
cmax = max(rgb[0], max(rgb[1], rgb[2]));
cmin = min(rgb[0], min(rgb[1], rgb[2]));
cdelta = cmax - cmin;
v = cmax;
if (cmax != 0.0)
s = cdelta / cmax;
else {
s = 0.0;
h = 0.0;
}
if (s == 0.0)
h = 0.0;
else {
c = (vec3(cmax, cmax, cmax) - rgb.xyz) / cdelta;
if (rgb.x == cmax) h = c[2] - c[1];
else if (rgb.y == cmax) h = 2.0 + c[0] - c[2];
else h = 4.0 + c[1] - c[0];
h /= 6.0;
if (h < 0.0)
h += 1.0;
}
outCol = vec4(h, s, v, rgb.w);
}
#endif
#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_SKYDOME_LIGHT_AR) || defined(NODE_ENV_SPHERE_MY)
vec4 sampleEquirectangular(sampler2D map, vec3 reflectVec, mat3 uvTransform, int encoding)
{
reflectVec = normalize(reflectVec);
vec2 sampleUV;
sampleUV.y = asin(clamp(reflectVec.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;
sampleUV.x = atan(reflectVec.x, reflectVec.z) * RECIPROCAL_PI2 + 0.5;
sampleUV.y *= -1.0;
const float seamWidth = 0.15;
const float seamBiasFactor = -10.0;
float seam = max(0.0, 1.0 - abs (reflectVec.x) / seamWidth) *
clamp (1.0 - reflectVec.z / seamWidth, 0.0, 1.0);
sampleUV = (uvTransform * vec3(sampleUV, 1.0)).xy;
return texture2D(map, sampleUV, seamBiasFactor * seam);
}
#endif
#if defined(NODE_FRESNEL_BL) || defined(NODE_LAYER_WEIGHT_BL) || defined(NODE_FALLOFF_MX) || defined(NODE_BSDF_GLASS_BL) || defined(NODE_BSDF_PRINCIPLED_BL)
float fresnelReflection(const vec3 dir, const vec3 normal, const float ior) {
float cosTheta = clamp(abs(dot(dir, normal)), -1.0, 1.0);
float gSquared = pow2(ior) + pow2(cosTheta) - 1.0;
if (gSquared < 0.0) return 1.0;
float g = sqrt(gSquared);
return 0.5 * pow2((g - cosTheta) / (g + cosTheta))
* (1.0 + pow2(
((g + cosTheta) * cosTheta - 1.0) /
((g - cosTheta) * cosTheta + 1.0)
));
}
#endif
#if defined(NODE_BITMAP_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_GRADIENT_MX) || defined(NODE_GRADIENT_RAMP_MX)
#define MAPPING_EXPLICIT_MAP_CHANNEL 1
#define MAPPING_VERTEX_COLOR_CHANNEL 2
#define MAPPING_PLANAR_OBJECT_XYZ 3
#define MAPPING_PLANAR_WORLD_XYZ 4
#define AXIS_XY 1
#define AXIS_YZ 2
#define AXIS_ZX 3
#endif
#if defined(NODE_BITMAP_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_MX) || defined(NODE_GRADIENT_MX) || defined(NODE_GRADIENT_RAMP_MX) || defined(NODE_PLACE_2D_TEXTURE_MY)
mat3 calcUvTransform(float uOffset, float vOffset, float uTiling, float vTiling, float wAngle)
{
if (abs(uOffset) < EPSILON && abs(vOffset) < EPSILON &&
(abs(uTiling - 1.0)) < EPSILON && (abs(vTiling - 1.0)) < EPSILON &&
abs(wAngle) < EPSILON)
return mat3(1.0);
float sx = uTiling;
float sy = vTiling;
float c = cos(-wAngle);
float s = sin(-wAngle);
#if defined(NODE_PLACE_2D_TEXTURE_MY)
float tx = uOffset;
float ty = vOffset;
float cx = 0.5;
float cy = 0.5;
return mat3(c*sx, s*sx, 0.0,
-s*sy, c*sy, 0.0,
s*(ty+sy-cy)+c*(tx-cx)+cx, -c*(ty+sy-cy)+s*(tx-cx)-cy+1.0, 1.0);
#else
float tx = -uOffset;
float ty = -vOffset;
float cx = uOffset + 0.5;
float cy = vOffset + 0.5;
return mat3(sx * c, -sy * s, 0.0,
sx * s, sy * c, 0.0,
-sx * (c * cx + s * cy) + cx + tx, -sy * (- s * cx + c * cy) + cy + ty, 1.0);
#endif
}
#endif
#if defined(NODE_NOISE_MX)
mat4 calcXYZTransform(vec3 offset, vec3 tiling, vec3 angle) {
mat4 rot = mat4(
cos(angle.y)*cos(angle.z), cos(angle.x)*sin(angle.z)+sin(angle.x)*sin(angle.y)*cos(angle.z), sin(angle.x)*sin(angle.z)-cos(angle.x)*sin(angle.y)*cos(angle.z), 0.0,
-cos(angle.y)*sin(angle.z), cos(angle.x)*cos(angle.z)-sin(angle.x)*sin(angle.y)*sin(angle.z), cos(angle.x)*sin(angle.y)*sin(angle.z)+sin(angle.x)*cos(angle.z), 0.0,
sin(angle.y), -sin(angle.x)*cos(angle.y), cos(angle.x)*cos(angle.y), 0.0,
0.0, 0.0, 0.0, 1.0
);
mat4 til = mat4(
tiling.x, 0.0, 0.0, 0.0,
0.0, tiling.y, 0.0, 0.0,
0.0, 0.0, tiling.z, 0.0,
0.0, 0.0, 0.0, 1.0
);
mat4 off = mat4(
1.0, 0.0, 0.0, 0.0,
0.0, 1.0, 0.0, 0.0,
0.0, 0.0, 1.0, 0.0,
offset.x, offset.y, offset.z, 1.0
);
return (til * rot * off);
}
#endif
#if defined(NODE_TEX_NOISE_BL) || defined(NODE_TEX_WAVE_BL) || defined(NODE_NOISE_MX) || defined(USE_OSL) || defined(NODE_NOISE_MY)
#define NOISE_AMP_HACK 0.75
#define NOISE_BLENDER_MEAN 0.78
#define NOISE_SCALE_HACK 0.5
#define noiseModulo(x) (x - floor(x * (1.0 / 289.0)) * 289.0)
vec4 noisePermute(vec4 x) {
return noiseModulo(((x * 34.0) + 1.0) * x);
}
vec4 taylorInvSqrt(vec4 r) {
return 1.79284291400159 - 0.85373472095314 * r;
}
float taylorInvSqrt(float r) {
return 1.79284291400159 - 0.85373472095314 * r;
}
float noisePerlin(vec3 v) {
const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
vec3 i = floor(v + dot(v, C.yyy));
vec3 x0 = v - i + dot(i, C.xxx);
vec3 g = step(x0.yzx, x0.xyz);
vec3 l = 1.0 - g;
vec3 i1 = min(g.xyz, l.zxy);
vec3 i2 = max(g.xyz, l.zxy);
vec3 x1 = x0 - i1 + C.xxx;
vec3 x2 = x0 - i2 + C.yyy;
vec3 x3 = x0 - D.yyy;
i = noiseModulo(i);
vec4 p = noisePermute(noisePermute(noisePermute(i.z + vec4(0.0, i1.z, i2.z, 1.0))
+ i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
float n_ = 0.142857142857;
vec3 ns = n_ * D.wyz - D.xzx;
vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
vec4 x_ = floor(j * ns.z);
vec4 y_ = floor(j - 7.0 * x_);
vec4 x = x_ * ns.x + ns.yyyy;
vec4 y = y_ * ns.x + ns.yyyy;
vec4 h = 1.0 - abs(x) - abs(y);
vec4 b0 = vec4(x.xy, y.xy);
vec4 b1 = vec4(x.zw, y.zw);
vec4 s0 = floor(b0) * 2.0 + 1.0;
vec4 s1 = floor(b1) * 2.0 + 1.0;
vec4 sh = -step(h, vec4(0.0));
vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
vec3 p0 = vec3(a0.xy, h.x);
vec3 p1 = vec3(a0.zw, h.y);
vec3 p2 = vec3(a1.xy, h.z);
vec3 p3 = vec3(a1.zw, h.w);
vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
p0 *= norm.x;
p1 *= norm.y;
p2 *= norm.z;
p3 *= norm.w;
vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
m = m * m;
return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),
dot(p2, x2), dot(p3, x3)));
}
vec4 permute(vec4 x) {
return mod(((x*34.0)+1.0)*x, 289.0);
}
float permute(float x) {
return floor(mod(((x*34.0)+1.0)*x, 289.0));
}
vec4 grad4(float j, vec4 ip) {
const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
vec4 p,s;
p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
s = vec4(lessThan(p, vec4(0.0)));
p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;
return p;
}
float snoise(vec4 v) {
const vec2 C = vec2(0.138196601125010504,
0.309016994374947451);
vec4 i = floor(v + dot(v, C.yyyy) );
vec4 x0 = v - i + dot(i, C.xxxx);
vec4 i0;
vec3 isX = step( x0.yzw, x0.xxx );
vec3 isYZ = step( x0.zww, x0.yyz );
i0.x = isX.x + isX.y + isX.z;
i0.yzw = 1.0 - isX;
i0.y += isYZ.x + isYZ.y;
i0.zw += 1.0 - isYZ.xy;
i0.z += isYZ.z;
i0.w += 1.0 - isYZ.z;
vec4 i3 = clamp( i0, 0.0, 1.0 );
vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );
vec4 x1 = x0 - i1 + 1.0 * C.xxxx;
vec4 x2 = x0 - i2 + 2.0 * C.xxxx;
vec4 x3 = x0 - i3 + 3.0 * C.xxxx;
vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;
i = mod(i, 289.0);
float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
vec4 j1 = permute( permute( permute( permute (
i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));
vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;
vec4 p0 = grad4(j0, ip);
vec4 p1 = grad4(j1.x, ip);
vec4 p2 = grad4(j1.y, ip);
vec4 p3 = grad4(j1.z, ip);
vec4 p4 = grad4(j1.w, ip);
vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
p0 *= norm.x;
p1 *= norm.y;
p2 *= norm.z;
p3 *= norm.w;
p4 *= taylorInvSqrt(dot(p4,p4));
vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4) ), 0.0);
m0 = m0 * m0;
m1 = m1 * m1;
return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
}
float noiseBlender(vec3 p) {
return 0.5 * NOISE_AMP_HACK * (noisePerlin(NOISE_SCALE_HACK * vec3(p.x, p.y, p.z))) + 0.5;
}
float noiseSmooth(vec3 p, float octaveLenPerPixel, float falloffFactor,
float dispersionFactor) {
float mixFac = mix(1.0, smoothstep(0.0, 1.0, octaveLenPerPixel) * falloffFactor,
dispersionFactor);
return mix(noiseBlender(p), NOISE_BLENDER_MEAN, mixFac);
}
#define MAX_OCTAVES_NUM 16
float noiseTurbulence(vec3 p, float octaves, float octaveLenPerPixel,
float falloffFactor, float dispersionFactor) {
float fscale = 1.0;
float amp = 1.0;
float sum = 0.0;
octaves = clamp(octaves, 0.0, 16.0);
int octavesInt = int(octaves);
for (int i = 0; i <= MAX_OCTAVES_NUM; i++) {
#if __VERSION__ == 300
if (i <= octavesInt) {
float t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,
dispersionFactor);
sum += t * amp;
amp *= 0.5;
fscale *= 2.0;
octaveLenPerPixel *= 2.0;
} else {
i = MAX_OCTAVES_NUM;
}
#else
if (i > octavesInt) break;
float t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,
dispersionFactor);
sum += t * amp;
amp *= 0.5;
fscale *= 2.0;
octaveLenPerPixel *= 2.0;
#endif
}
float octavesFrac = fract(octaves);
float octavesCoeff = pow(2.0, float(octavesInt));
if (octavesFrac != 0.0) {
float t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,
dispersionFactor);
float sum2 = sum + t * amp;
sum *= octavesCoeff / (2.0 * octavesCoeff - 1.0);
sum2 *= 2.0 * octavesCoeff / (4.0 * octavesCoeff - 1.0);
return mix(sum, sum2, octavesFrac);
} else {
return sum * octavesCoeff / (2.0 * octavesCoeff - 1.0);
}
}
#endif
#if (defined(USE_OSL) || defined(NODE_WAVELENGTH_BL)) && __VERSION__ == 300
vec3 cieColorMatch[81] = vec3[](
vec3(0.0014,0.0000,0.0065), vec3(0.0022,0.0001,0.0105), vec3(0.0042,0.0001,0.0201),
vec3(0.0076,0.0002,0.0362), vec3(0.0143,0.0004,0.0679), vec3(0.0232,0.0006,0.1102),
vec3(0.0435,0.0012,0.2074), vec3(0.0776,0.0022,0.3713), vec3(0.1344,0.0040,0.6456),
vec3(0.2148,0.0073,1.0391), vec3(0.2839,0.0116,1.3856), vec3(0.3285,0.0168,1.6230),
vec3(0.3483,0.0230,1.7471), vec3(0.3481,0.0298,1.7826), vec3(0.3362,0.0380,1.7721),
vec3(0.3187,0.0480,1.7441), vec3(0.2908,0.0600,1.6692), vec3(0.2511,0.0739,1.5281),
vec3(0.1954,0.0910,1.2876), vec3(0.1421,0.1126,1.0419), vec3(0.0956,0.1390,0.8130),
vec3(0.0580,0.1693,0.6162), vec3(0.0320,0.2080,0.4652), vec3(0.0147,0.2586,0.3533),
vec3(0.0049,0.3230,0.2720), vec3(0.0024,0.4073,0.2123), vec3(0.0093,0.5030,0.1582),
vec3(0.0291,0.6082,0.1117), vec3(0.0633,0.7100,0.0782), vec3(0.1096,0.7932,0.0573),
vec3(0.1655,0.8620,0.0422), vec3(0.2257,0.9149,0.0298), vec3(0.2904,0.9540,0.0203),
vec3(0.3597,0.9803,0.0134), vec3(0.4334,0.9950,0.0087), vec3(0.5121,1.0000,0.0057),
vec3(0.5945,0.9950,0.0039), vec3(0.6784,0.9786,0.0027), vec3(0.7621,0.9520,0.0021),
vec3(0.8425,0.9154,0.0018), vec3(0.9163,0.8700,0.0017), vec3(0.9786,0.8163,0.0014),
vec3(1.0263,0.7570,0.0011), vec3(1.0567,0.6949,0.0010), vec3(1.0622,0.6310,0.0008),
vec3(1.0456,0.5668,0.0006), vec3(1.0026,0.5030,0.0003), vec3(0.9384,0.4412,0.0002),
vec3(0.8544,0.3810,0.0002), vec3(0.7514,0.3210,0.0001), vec3(0.6424,0.2650,0.0000),
vec3(0.5419,0.2170,0.0000), vec3(0.4479,0.1750,0.0000), vec3(0.3608,0.1382,0.0000),
vec3(0.2835,0.1070,0.0000), vec3(0.2187,0.0816,0.0000), vec3(0.1649,0.0610,0.0000),
vec3(0.1212,0.0446,0.0000), vec3(0.0874,0.0320,0.0000), vec3(0.0636,0.0232,0.0000),
vec3(0.0468,0.0170,0.0000), vec3(0.0329,0.0119,0.0000), vec3(0.0227,0.0082,0.0000),
vec3(0.0158,0.0057,0.0000), vec3(0.0114,0.0041,0.0000), vec3(0.0081,0.0029,0.0000),
vec3(0.0058,0.0021,0.0000), vec3(0.0041,0.0015,0.0000), vec3(0.0029,0.0010,0.0000),
vec3(0.0020,0.0007,0.0000), vec3(0.0014,0.0005,0.0000), vec3(0.0010,0.0004,0.0000),
vec3(0.0007,0.0002,0.0000), vec3(0.0005,0.0002,0.0000), vec3(0.0003,0.0001,0.0000),
vec3(0.0002,0.0001,0.0000), vec3(0.0002,0.0001,0.0000), vec3(0.0001,0.0000,0.0000),
vec3(0.0001,0.0000,0.0000), vec3(0.0001,0.0000,0.0000), vec3(0.0000,0.0000,0.0000)
);
#endif
#if defined(USE_OSL) || defined(NODE_BLACKBODY_BL)
vec3 colorTempToRGB(float temp)
{
vec3 retColor;
temp = clamp(temp, 100.0, 40000.0) / 100.0;
if (temp <= 66.0) {
retColor.r = 1.0;
retColor.g = saturate(0.390081578 * log(temp) - 0.631841443);
} else {
float t = temp - 60.0;
retColor.r = saturate(1.292936186 * pow(t, -0.133204759));
retColor.g = saturate(1.129890860 * pow(t, -0.075514849));
}
if (temp >= 66.0)
retColor.b = 1.0;
else if (temp <= 19.0)
retColor.b = 0.0;
else
retColor.b = saturate(0.543206789 * log(temp - 10.0) - 1.196254089);
retColor.rgb = pow(retColor.rgb, vec3(2.2));
return retColor;
}
#endif`,R3=`#ifdef USE_OSL
#define M_PI PI
#define M_PI_2 PI / 2.0
#define M_PI_4 PI / 4.0
#define M_2_PI 2.0 / PI
#define M_2PI 2.0 * PI
#define M_4PI 4.0 * PI
#define M_2_SQRTPI 2.0 / sqrt(PI)
#define M_E 2.718281828459
#define M_LN2 0.69314718056
#define M_LN10 2.30258509299
#define M_LOG2E 1.4426950409
#define M_LOG10E 0.43429448190
#define M_SQRT2 sqrt(2.0)
#define M_SQRT1_2 sqrt(0.5)
#define OSL_ALPHA 33633
#define OSL_ANISOTROPIC 40205
#define OSL_AVERAGEALPHA 57701
#define OSL_AVERAGECOLOR 46077
#define OSL_BANDWIDTH 37485
#define OSL_BEZIER 27645
#define OSL_BLACK 62409
#define OSL_BSPLINE 16959
#define OSL_CAMERA 8198
#define OSL_CAMERA_CLIP 34380
#define OSL_CAMERA_CLIP_FAR 31933
#define OSL_CAMERA_CLIP_NEAR 21485
#define OSL_CAMERA_FOV 60706
#define OSL_CAMERA_PIXELASPECT 4950
#define OSL_CAMERA_PROJECTION 29369
#define OSL_CAMERA_RESOLUTION 39679
#define OSL_CAMERA_SCREEN_WINDOW 47009
#define OSL_CAMERA_SHUTTER 7107
#define OSL_CAMERA_SHUTTER_CLOSE 34406
#define OSL_CAMERA_SHUTTER_OPEN 40085
#define OSL_CATMULL_ROM 31642
#define OSL_CELL 20984
#define OSL_CHANNELS 8726
#define OSL_CLAMP 20052
#define OSL_COLOR 53753
#define OSL_COMMON 49871
#define OSL_CONSTANT 25144
#define OSL_DATAWINDOW 54276
#define OSL_DEFAULT 54870
#define OSL_DIFFUSE 40389
#define OSL_DIRECTION 42220
#define OSL_DISPLAYWINDOW 30728
#define OSL_DISTANCE 51337
#define OSL_DO_FILTER 35765
#define OSL_EMPTY 9314
#define OSL_ERRORMESSAGE 38305
#define OSL_EXISTS 41510
#define OSL_FILL 39132
#define OSL_FIRSTCHANNEL 48155
#define OSL_GABOR 57764
#define OSL_GEOM_NAME 63686
#define OSL_GLOSSY 47998
#define OSL_HASH 49390
#define OSL_HERMITE 63643
#define OSL_HIT 48491
#define OSL_HITDIST 22029
#define OSL_HSL 49898
#define OSL_HSV 29073
#define OSL_IMPULSES 56191
#define OSL_INDEX 1731
#define OSL_INTERP 10557
#define OSL_LINEAR 2182
#define OSL_MIRROR 64591
#define OSL_MISSINGALPHA 39755
#define OSL_MISSINGCOLOR 51667
#define OSL_NDC 48899
#define OSL_NORMAL 16520
#define OSL_OBJECT 59084
#define OSL_OSL_VERSION 47920
#define OSL_PERIODIC 8749
#define OSL_PERLIN 730
#define OSL_POSITION 43041
#define OSL_RASTER 2618
#define OSL_REFLECTION 37621
#define OSL_REFRACTION 37287
#define OSL_RESOLUTION 48704
#define OSL_RGB 26673
#define OSL_RWRAP 47801
#define OSL_SCREEN 55875
#define OSL_SHADER 21066
#define OSL_SHADER_GROUPNAME 62327
#define OSL_SHADER_LAYERNAME 51796
#define OSL_SHADER_SHADERNAME 65123
#define OSL_SHADOW 60708
#define OSL_SIMPLEX 61636
#define OSL_SUBIMAGE 33526
#define OSL_SUBIMAGES 2366
#define OSL_SWRAP 4328
#define OSL_TEXTUREFORMAT 17851
#define OSL_TIME 52235
#define OSL_TRACE 62908
#define OSL_TWRAP 30524
#define OSL_TYPE 64071
#define OSL_UPERLIN 65308
#define OSL_USIMPLEX 11314
#define OSL_WIDTH 48751
#define OSL_WORLD 9059
#define OSL_WORLDTOCAMERA 32273
#define OSL_WORLDTOSCREEN 33876
#define OSL_WRAP 58300
#define OSL_XYY 2228
#define OSL_XYZ 47351
#define OSL_YIQ 15839
vec3 oslGetP(vec3 viewPos) {
#if WORLD_NODES == 1
return swizzleUpZ((invViewMatrix * vec4(-viewPos, 0.0)).xyz);
#else
return swizzleUpZ((invViewMatrix * vec4(-viewPos, 1.0)).xyz);
#endif
}
vec3 oslGetI(vec3 viewPos) {
#if WORLD_NODES == 1
return swizzleUpZ((invViewMatrix * vec4(normalize(-viewPos), 0.0)).xyz);
#else
return swizzleUpZ((invViewMatrix * vec4(normalize(-viewPos), 0.0)).xyz);
#endif
}
vec3 oslGetN(vec3 viewNorm) {
return swizzleUpZ(normalize(invViewMatrix * vec4(viewNorm, 0.0)).xyz);
}
vec3 oslBlackbody(float temperatureK) {
return vec4(colorTempToRGB(temperatureK), 1.0).rgb;
}
float oslDistance(vec3 p0, vec3 p1) {
return distance(p0, p1);
}
float oslDistance(vec3 p0, vec3 p1, vec3 q) {
vec3 d = p1 - p0;
float dd = dot(d, d);
if (dd == 0.0)
return distance(q, p0);
float t = dot(q - p0, d) / dd;
return distance(q, p0 + clamp(t, 0.0, 1.0) * d);
}
int oslEndsWith(int name1, int name2) {
return int(name1 == name2);
}
int oslFormat(int name1, int name2) {
return name2;
}
int oslGetAttribute(int name, out int value) {
value = 0;
return 0;
}
int oslGetAttribute(int name, out float value) {
value = 0.0;
return 0;
}
int oslGetAttribute(int name, out vec3 vec) {
vec = vec3(0.0, 0.0, 0.0);
return 0;
}
void oslGetTextureInfo(int filename, int name, out int value) {
value = 4;
}
void oslGetTextureInfo(int filename, int name, out int value[2]) {
value[0] = 1024;
value[1] = 1024;
}
vec3 oslHSV(float h, float s, float v) {
vec4 outCol;
hsvToRGB(vec4(h, s, v, 1.0), outCol);
return outCol.rgb;
}
float oslHypot(float x, float y) {
return sqrt(x*x + y*y);
}
float oslHypot(float x, float y, float z) {
return sqrt(x*x + y*y + z*z);
}
float oslLog2(float x, float y) {
return log(x) / log(y);
}
float oslLuminance(vec3 color) {
return linearToRelativeLuminance(color);
}
float oslNoise(int type, vec3 vec, float phase) {
float n = snoise(vec4(vec, phase));
if (type == OSL_UPERLIN)
n = n * 0.5 + 0.5;
return n;
}
float oslNoise(int type, float value, float phase) {
return oslNoise(type, vec3(value), phase);
}
float oslNoise(int type, vec3 vec) {
return oslNoise(type, vec, 0.0);
}
float oslNoise(int type, float value) {
return oslNoise(type, vec3(value), 0.0);
}
vec3 oslNoise3D(int type, vec3 vec, float phase) {
float x = snoise(vec4(vec, phase));
float y = snoise(vec4(vec.y, vec.x, vec.z, phase));
float z = snoise(vec4(vec.y, vec.z, vec.x, phase));
vec3 n = vec3(x, y, z);
if (type == OSL_UPERLIN)
n = n * 0.5 + 0.5;
return n;
}
vec3 oslNoise3D(int type, float value, float phase) {
return oslNoise3D(type, vec3(value), phase);
}
vec3 oslNoise3D(int type, vec3 vec) {
return oslNoise3D(type, vec, 0.0);
}
vec3 oslNoise3D(int type, float value) {
return oslNoise3D(type, vec3(value), 0.0);
}
float oslPow(float a, float b) {
return pow(a, b);
}
vec3 oslPow(vec3 a, float b) {
return pow(a, vec3(b));
}
int oslRayType(int name) {
if (name == OSL_CAMERA)
#if LIGHT_PATH_IS_CAM_RAY
return 1;
#else
return 0;
#endif
else
return 0;
}
vec3 oslRotate(vec3 vec, float angle, vec3 p0, vec3 p1) {
vec3 axis = normalize(p1 - p0);
float c = cos(angle);
float s = sin(angle);
float x = axis[0];
float y = axis[1];
float z = axis[2];
mat4 mat = mat4(
x * x + (1.0 - x * x) * c, x * y * (1.0 - c) + z * s, x * z * (1.0 - c) - y * s, 0.0,
x * y * (1.0 - c) - z * s, y * y + (1.0 - y * y) * c, y * z * (1.0 - c) + x * s, 0.0,
x * z * (1.0 - c) + y * s, y * z * (1.0 - c) - x * s, z * z + (1.0 - z * z) * c, 0.0,
0.0, 0.0, 0.0, 1.0
);
return (mat * vec4((vec - p0), 1.0) + vec4(p0, 1.0)).xyz;
}
vec3 oslRotate(vec3 vec, float angle, vec3 axis) {
return oslRotate(vec, angle, vec3(0.0), axis);
}
int oslStartsWith(int name1, int name2) {
return int(name1 == name2);
}
int oslStrLen(int name) {
if (name == OSL_EMPTY)
return 0;
else
return 1;
}
int oslSubStr(int s, int start, int len) {
return s;
}
int oslSubStr(int s, int start) {
return s;
}
vec3 oslTexture(sampler2D image, float u, float v, int wrapModeFlag, int wrapMode, int alphaFlag, out float alpha) {
if (wrapMode == OSL_DEFAULT || wrapMode == OSL_BLACK) {
if (u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0)
return vec3(0.0);
} else if (wrapMode == OSL_CLAMP) {
u = clamp(u, 0.0, 1.0);
v = clamp(v, 0.0, 1.0);
} else if (wrapMode == OSL_PERIODIC) {
u = mod(u, 1.0);
v = mod(v, 1.0);
} else if (wrapMode == OSL_MIRROR) {
if (mod(floor(u), 2.0) == 0.0)
u = u - floor(u);
else
u = 1.0 - (u - floor(u));
if (mod(floor(v), 2.0) == 0.0)
v = v - floor(v);
else
v = 1.0 - (v - floor(v));
}
vec4 colAlpha = texture2D(image, vec2(u, v));
alpha = colAlpha.a;
return colAlpha.rgb;
}
vec3 oslTexture(sampler2D image, float u, float v, int alphaFlag, out float alpha, int wrapModeFlag, int wrapMode) {
return oslTexture(image, u, v, wrapModeFlag, wrapMode, alphaFlag, alpha);
}
vec3 oslTexture(sampler2D image, float u, float v, int alphaFlag, out float alpha) {
return oslTexture(image, u, v, OSL_WRAP, OSL_DEFAULT, alphaFlag, alpha);
}
vec3 oslTexture(sampler2D image, float u, float v, int wrapModeFlag, int wrapMode) {
float alpha;
return oslTexture(image, u, v, wrapModeFlag, wrapMode, OSL_ALPHA, alpha);
}
vec3 oslTexture(sampler2D image, float u, float v) {
float alpha;
return oslTexture(image, u, v, OSL_WRAP, OSL_DEFAULT, OSL_ALPHA, alpha);
}
vec3 oslTexture(sampler2D image, float u, float v, int wrapModeFlag, int wrapMode, int colorSpaceFlag, int colorSpace) {
float alpha;
return oslTexture(image, u, v, wrapModeFlag, wrapMode, OSL_ALPHA, alpha);
}
vec3 oslTransform(int fromSpace, int toSpace, vec4 vec) {
if (toSpace == OSL_WORLD || toSpace == OSL_SHADER || toSpace == OSL_COMMON) {
return vec.xyz;
} else if (toSpace == OSL_OBJECT) {
vec = vec4(swizzleUpY(vec.xyz), vec.w);
vec = invModelMatrix * vec;
return swizzleUpZ(vec.xyz);
} else if (toSpace == OSL_CAMERA) {
vec = vec4(swizzleUpY(vec.xyz), vec.w);
return (viewMatrix * vec).xyz;
} else if (toSpace == OSL_SCREEN) {
return vec.xyz;
} else if (toSpace == OSL_RASTER) {
return gl_FragCoord.xyz;
} else if (toSpace == OSL_NDC) {
return vec.xyz;
} else {
return vec.xyz;
}
}
vec3 oslTransform(int fromSpace, int toSpace, vec3 vec) {
return oslTransform(fromSpace, toSpace, vec4(vec, 1.0));
}
vec3 oslTransform(int toSpace, vec3 vec) {
return oslTransform(OSL_COMMON, toSpace, vec4(vec, 1.0));
}
vec3 oslTransformDir(int fromSpace, int toSpace, vec3 vec) {
return oslTransform(fromSpace, toSpace, vec4(vec, 0.0));
}
vec3 oslTransformDir(int toSpace, vec3 vec) {
return oslTransform(OSL_COMMON, toSpace, vec4(vec, 0.0));
}
vec3 oslTransformC(int fromSpace, int toSpace, vec3 vec) {
vec4 outVec = vec4(vec, 1.0);
if (fromSpace == OSL_HSV && toSpace == OSL_RGB)
hsvToRGB(vec4(vec, 1.0), outVec);
else if (fromSpace == OSL_RGB && toSpace == OSL_HSV)
rgbToHSV(vec4(vec, 1.0), outVec);
return outVec.rgb;
}
vec3 oslTransformC(int toSpace, vec3 vec) {
return oslTransformC(OSL_RGB, toSpace, vec);
}
void oslError() {}
void oslFPrintf() {}
void oslPrintf() {}
void oslWarning() {}
vec3 oslWaveLengthColor(float lambdaNM) {
#if __VERSION__ == 300
vec3 xyz = vec3(0.0);
float ii = (lambdaNM - 380.0) / 5.0;
int i = int(ii);
if (i < 0 || i >= 80)
return xyz;
ii -= float(i);
vec3 c1 = cieColorMatch[i];
vec3 c2 = cieColorMatch[i+1];
xyz = mix(c1, c2, ii);
return xyz_to_sRGB(xyz);
#else
return vec3(0.0);
#endif
}
#endif`,L3=`void node_incident(vec3 viewPos, out vec3 incident)
{

vec4 viewDir = vec4(normalize(viewPos), 0.0);
incident = -swizzleUpZ(viewDir.xyz);
}`,P3=`void node_normal(vec3 norParam, out vec3 norOut)
{
#ifdef MT_BLENDER
#if WORLD_NODES == 1
vec4 viewDir = isOrthographic ? vec4(0.0, 0.0, -1.0, 0.0) : vec4(normalize(-vViewPosition), 0.0);
viewDir = invViewMatrix * viewDir;
norOut = -swizzleUpZ(viewDir.xyz);
#else
norOut = normalize(invViewMatrix * vec4(norParam, 0.0)).xyz;
norOut = swizzleUpZ(norOut);
#endif
#else
norOut = norParam;
#endif
}`,B3=`void node_position(vec3 posParam, out vec3 posOut)
{
#if defined(MT_BLENDER) || defined(MT_MAX)
posOut = swizzleUpZ(-posParam);
#else
posOut = -posParam;
#endif
}`,D3=`uniform vec4 nodeRGB[NODE_RGB_NUM];
void node_rgb_alpha(vec4 color, out vec3 outColor, out float outAlpha)
{
outColor = color.rgb;
outAlpha = color.a;
}`,N3=`uniform float nodeValue[NODE_VALUE_NUM];
void node_value(float val, out float outVal)
{
outVal = val;
}`,O3=`void node_u_float(vec2 inUv, out float u)
{
u = inUv.x;
}`,F3=`void node_abs(
vec3 inputVal,
out vec3 outColor)
{
outColor = abs(inputVal);
}`,U3=`void node_add(
vec3 input1, vec3 input2,
out vec3 outColor)
{
outColor = input1 + input2;
}`,z3=`void node_atan(
int units,
vec3 x, vec3 y,
out vec3 outColor)
{
outColor = atan(y, x);
if (units == 1)
outColor = degrees(outColor);
}`,V3=`void node_checkerboard(
const vec2 inUv, vec3 color1, vec3 color2, float uFrequency, float vFrequency, float uOffset, float vOffset, float contrast,
out vec3 outColor) {
vec2 uv = -1.0 + 2.0 * inUv;
float fmodResult = mod(floor(uOffset * 2.0 + uFrequency * uv.x) + floor(vOffset * 2.0 + vFrequency * uv.y), 2.0);
float final = max(sign(fmodResult), 0.0);
vec3 col = vec3(final);
if (final == 0.0)
col = color1;
else
col = color2;
outColor = col * vec3(contrast) + vec3(1.0 - contrast);
}`,G3=`void node_clamp(
const int mode,
vec3 inputValue, float minValue, float maxValue, vec3 minColor, vec3 maxColor,
out vec3 outColor, out vec3 outTransparency)
{
if (mode == 0)
outColor = clamp(inputValue, vec3(minValue), vec3(maxValue));
else
outColor = clamp(inputValue, minColor, maxColor);
outTransparency = outColor;
}`,k3=`void node_color_to_float(
const int mode,
vec3 inputValue,
out float outValue)
{
if (mode == 0)
outValue = min(min(inputValue.r, inputValue.g), inputValue.b);
else if (mode == 1)
outValue = max(max(inputValue.r, inputValue.g), inputValue.b);
else if (mode == 2)
outValue = (inputValue.r + inputValue.g + inputValue.b) / 3.0;
else if (mode == 3)
outValue = inputValue.r + inputValue.g + inputValue.b;
else if (mode == 4) {
outValue = dot(inputValue, LUM_WEIGHTS);
}
else if (mode == 5)
outValue = inputValue.r;
else if (mode == 6)
outValue = inputValue.g;
else if (mode == 7)
outValue = inputValue.b;
}`,Q3=`void node_color_convert(
const int from, const int to,
vec3 inputValue,
out vec3 outColor, out vec3 outTransparency)
{
vec4 c;
if (from == to)
c = vec4(inputValue, 1.0);
else if (from == 0) 
rgbToHSV(vec4(inputValue, 1.0), c);
else if (from == 1)
hsvToRGB(vec4(inputValue, 1.0), c);
outColor = c.rgb;
outTransparency = outColor;
}`,W3=`void node_color_correct(
vec3 inputValue, float mask, float gamma, float hueShift, float saturation, float contrast, float contrastPivot,
float exposure, vec3 multiply, vec3 add, bool invert, bool alphaIsLuminance, float alphaMultiply, float alphaAdd, bool invertAlpha,
out vec3 outColor, out float outAlpha)
{ 
outColor = inputValue;
outColor = invert ? 1.0 - outColor : outColor;
outColor = vec3(pow(abs(outColor.r), gamma), pow(abs(outColor.g), gamma), pow(abs(outColor.b), gamma));
vec4 hsv;
rgbToHSV(vec4(outColor, 1.0), hsv);
hsv[0] += hueShift / 360.0;
if (hsv[0] > 1.0)
hsv[0] -= 1.0;
else if (hsv[0] < 0.0)
hsv[0] += 1.0;

hsv[1] *= (saturation);
hsv[1] = saturate(hsv[1]);
hsv[2] += exposure * 2.0;
vec4 c = hsv;
hsvToRGB(hsv, c);
c = ((c - contrastPivot) * contrast + contrastPivot) * vec4(multiply, 1.0) + vec4(add, 1.0);
outColor = c.rgb;
outAlpha = 1.0;
}`,H3=`void node_compare(
int test,
float input1, float input2,
out bool outValue)
{
if (test == 0)
outValue = input1 == input2;
else if (test == 1)
outvalue = input1 != input2;
else if (test == 2)
outValue = input1 < input2;
else if (test == 3)
outValue = input1 > input2;
else if (test == 4)
outValue = input1 <= input2;
else if (test == 5)
outValue = input1 >= input2;
}`,X3=`void node_complement(
vec3 inputValue,
out vec3 outColor)
{
outColor = 1.0 - inputValue;
}`,Y3=`void node_composite(
const int operation, const int alphaOperation,
vec3 A, vec3 B, float AA, float BA,
out float outAlpha, out vec3 outColor, out vec3 outTransparency)
{
vec4 A1 = vec4(A, AA);
vec4 B1 = vec4(B, BA);
vec4 color = vec4(0.0);
if (operation == 0)
color = A1;
else if (operation == 1)
color = B1;
else if (operation == 2)
color = A1 * B1.a + B1 * (1.0 - A1.a);
else if (operation == 3)
color = (A1 + B1) / 2.0;
else if (operation == 4)
color = A1.a > B1.a ? A1 : (A1 + B1 * (1.0 - A1.a) / B1.a);
else if (operation == 5)
color = abs(A1 - B1);
else if (operation == 6)
color = A1.a + B1.a < 1.0 ? A1 + B1 : A1 + B1 * (1.0 - A1.a) / B1.a;
else if (operation == 7)
for (int i = 0; i < 4; i++)
color[i] = B1[i] == 0.0 ? 0.0 : (A1[i] / B1[i]);
else if (operation == 8)
color = A1 + B1 - 2.0 * A1 * B1;
else if (operation == 9)
color = B1 - A1;
else if (operation == 10)
color = 2.0 * A1 * B1 / (A1 + B1);
else if (operation == 11)
for (int i = 0; i < 4; i++)
color[i] = A1[i] < 0.5 ? (A1[i] * B1[i]) : (A1[i] >= 0.0 && A1[i] <= 1.0 && B1[i] >= 0.0 && B1[i] <= 1.0) ? (A1[i] + B1[i] - A1[i] * B1[i]) : max(A1[i], B1[i]);
else if (operation == 12)
color = sqrt(A1 * A1 + B1 * B1);
else if (operation == 13)
color = A1 * B1.a;
else if (operation == 14)
color = B1 * A1.a;
else if (operation == 15)
color = A1 * A1.a + B1 * (1.0 - A1.a);
else if (operation == 16)
color = max(A1, B1);
else if (operation == 17)
color = min(A1, B1);
else if (operation == 18)
color = A1 - B1;
else if (operation == 19)
color = A1 * B1;
else if (operation == 20)
color = A1 * (1.0 - B1.a);
else if (operation == 21)
color = A1 + B1 * (1.0 - A1.a);
else if (operation == 22)
for (int i = 0; i < 4; i++)
color[i] = B1[i] < 0.5 ? (A1[i] * B1[i]) : (A1[i] >= 0.0 && A1[i] <= 1.0 && B1[i] >= 0.0 && B1[i] <= 1.0) ? (A1[i] + B1[i] - A1[i] * B1[i]) : max(A1[i], B1[i]);
else if (operation == 23)
color = A1 + B1;
else if (operation == 24)
for (int i = 0; i < 4; i++)
color[i] = (A1[i] >= 0.0 && A1[i] <= 1.0 && B1[i] >= 0.0 && B1[i] <= 1.0) ? (A1[i] + B1[i] - A1[i] * B1[i]) : max(A1[i], B1[i]);

else if (operation == 25)
for (int i = 0; i < 4; i++)
color[i] = (A1[i] < .75) ? (A1[i] * B1[i]) : (A1[i] >= 0.0 && A1[i] <= 1.0 && B1[i] >= 0.0 && B1[i] <= 1.0) ? (A1[i] + B1[i] - A1[i] * B1[i]) : max(A1[i], B1[i]);
else if (operation == 26)
color = B1 * (1.0 - A1.a);
else if (operation == 27)
color = A1 * (1.0 - B1.a) + B1;
else if (operation == 28)
color = A1 * (1.0 - B1.a) + B1 * (1.0 - A1.a);
if (alphaOperation == 1)
color.a = AA;
else if (alphaOperation ==2)
color.a = BA;
outColor = color.rgb;
outAlpha = color.a;
outTransparency = outColor;
}`,j3=`void node_cross(
vec3 input1, vec3 input2,
out vec3 outValue)
{
outValue = cross(input1, input2);
}`,K3=`void node_divide(
vec3 input1, vec3 input2,
out vec3 outColor)
{
outColor = input1 / input2;
}`,q3=`void node_dot(
vec3 input1, vec3 input2,
out vec3 outValue)
{
outValue = dot(input1, input2);
}`,Z3=`void node_exp(
vec3 inputVal,
out vec3 outColor)
{
outColor = exp(inputVal);
}`,J3=`void node_facing_ratio(
vec3 viewNorm,
const float bias, const float gain, const bool invert, const bool linear,
out float outValue)
{
outValue = dot(normalize(viewNorm), normalize(vViewPosition));
}`,$3=`void node_flat(vec3 color, out vec3 outColor)
{
outColor = color;
}`,ey=`void node_float_to_int(
const int mode, 
float inputValue,
out int outValue)
{
if (mode == 0)
outValue = round(inputValue);
else if (mode == 1)
outValue = trunc(inputValue);
else if (mode == 2)
outValue = floor(inputValue);
else if (mode == 3)
outValue = ceil(inputValue);
}`,ty=`void node_float_to_matrix(
float input00, float input01, float input02, float input03, float input10, float input11, float input12, float input13, float input20, float input21, float input22, float input23, float input30, float input31, float input32, float input33,
out mat4 outValue)
{
outValue = mat4(input00, input01, input02, input03,
input10, input11, input12, input13,
input20, input21, input22, input23,
input30, input31, input32, input33);
}`,ny=`void node_float_to_rgba(
float r, float g, float b, float a,
out vec4 outColor, out float outAlpha, out vec3 outTransparency)
{
outAlpha = a;
outColor = vec4(r, g, b, a);
outTransparency = vec3(1.0 - a);
}`,iy=`void node_float_to_rgb(
float r, float g, float b,
out vec3 outValue)
{
outValue = vec3(r, g, b);
}`,oy=`void node_fraction(
vec3 inputValue,
out vec3 outColor)
{
outColor = fract(inputValue);
}`,ry=`void node_is_finite(
vec3 inputValue,
out bool outValue)
{
outValue = !any(isinf(inputValue));
}`,ay=`float check(bool value) {
if (value == true) return -1.0;
return 1.0;
}
void node_image(sampler2D ima, const int encoding, 
vec3 multiply, vec3 offset, vec2 uvcoords, float soffset, float toffset, float sscale, float tscale, bool sflip, bool tflip, bool swapSt,
out vec3 outColor, out float outAlpha, out vec3 outTransparency) {

vec2 uv = vec2(uvcoords.x, uvcoords.y);
if (swapSt == false) {
if (sflip) uv.x = 1.0 - uv.x;
if (tflip) uv.y = 1.0 - uv.y;
uv = vec2(sscale, tscale) * (uv + vec2(soffset * check(sflip), toffset * check(tflip)));
} else {
if (sflip) uv.y = 1.0 - uv.y;
if (tflip) uv.x = 1.0 - uv.x;
uv = vec2(sscale, tscale) * (uv.yx + vec2(toffset * check(sflip), soffset * check(tflip)));
}
uv.y = 1.0 - uv.y;
vec4 tex = texture2D(ima, uv);
outColor = nodeTexelToLinear(tex, encoding).rgb * multiply + offset;
outAlpha = tex.a;
outTransparency = outColor.rgb;
}
void node_image(sampler2D ima, const int encoding, 
vec4 multiply, vec4 offset, vec2 uvcoords, float soffset, float toffset, float sscale, float tscale, bool sflip, bool tflip, bool swapSt,
out vec4 outColor) {
vec2 uv = vec2(uvcoords.x, uvcoords.y);
if (swapSt == false) {
if (sflip) uv.x = 1.0 - uv.x;
if (tflip) uv.y = 1.0 - uv.y;
uv = vec2(sscale, tscale) * (uv + vec2(soffset * check(sflip), toffset * check(tflip)));
} else {
if (sflip) uv.y = 1.0 - uv.y;
if (tflip) uv.x = 1.0 - uv.x;
uv = vec2(sscale, tscale) * (uv.yx + vec2(toffset * check(sflip), soffset * check(tflip)));
}
uv.y = 1.0 - uv.y;
vec4 tex = texture2D(ima, uv);
outColor = nodeTexelToLinear(tex, encoding).rgba * multiply + offset;
}`,sy=`void node_lambert(
vec3 geometryNormal,
float Kd, vec3 KdColor, vec3 normalCamera, vec3 opacity,
out vec4 outColor, out float outAlpha, out vec3 outTransparency)
{
NodeMaterial material;
material.diffuseColor = Kd * KdColor;
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
vec3 normal = normalCamera;
#define RE_Direct RE_DirectDiffuseOnly_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
outAlpha = average(opacity);
outColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, outAlpha);
outTransparency = vec3(1.0) - opacity;
}`,ly=`void node_length(
int mode,
vec3 inputVec,
out float outValue)
{
if (mode == 0)
outValue = length(inputVec);
else if (mode == 1)
outValue = dot(inputVec, inputVec);
else
outValue = abs(inputVec.x) + abs(inputVec.y) + abs(inputVec.z);
}`,cy=`void node_log(
vec3 inputVec, vec3 base,
out vec3 outColor)
{
outColor = log(inputVec) / log(base);
}`,uy=`void node_map_to_mtl(bool opaqueEnabled, vec4 color, out vec4 outColor)
{
outColor = vec4(color.rgb, opaqueEnabled ? color.a : 1.0);
}`,dy=`void node_max(
vec3 input1, vec3 input2,
out vec3 outColor)
{
outColor = max(input1, input2);
}`,hy=`void node_min(
vec3 input1, vec3 input2,
out vec3 outColor)
{
outColor = min(input1, input2);
}`,py=`void node_mix_shader(const int mode,
const float mixAmt, vec4 shader1, vec4 shader2,
out vec4 color)
{
shader1.rgb *= shader1.a;
shader2.rgb *= shader2.a;
if (mode == 0)
color = mix(shader1, shader2, clamp(mixAmt, 0.0, 1.0));
else
color = vec4(shader1.rgb + shader2.rgb, min(shader1.a, shader2.a));
color.rgb /= color.a;
}`,fy=`void node_modulo(
vec3 inputVec, vec3 divisor,
out vec3 outColor)
{
outColor = mod(inputVec, divisor);
}`,my=`void node_multiply(
vec3 input1, vec3 input2,
out vec3 outColor)
{
outColor = input1 * input2;
}`,gy=`void node_negate(
vec3 inputVec,
out vec3 outColor)
{
outColor = -inputVec;
}`,vy=`void node_normalize(
vec3 inputVec,
out vec3 outValue)
{
outValue = normalize(inputVec);
}`,_y=`void node_normal_map(
vec4 tangentParam,
vec3 inputVal, vec3 normal, float strength, vec3 tangent,
out vec3 outValue) {
#ifdef DOUBLE_SIDED
normal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);
#endif
vec3 normalTex = inputVal.xyz * 2.0 - 1.0;
vec3 bitangent = tangentParam.w * cross(normal, tangent);
outValue = normalize(normalTex.x * tangent + normalTex.y * bitangent + normalTex.z * normal);
}`,Ay=`void node_pow(
vec3 base, vec3 exponent,
out vec3 outColor)
{
outColor = pow(base, exponent);
}`,xy=`void node_abs(
vec3 inputColor,
out vec3 outColor)
{
outColor = inputColor;
}`,yy=`void node_range(
vec3 inputValue, float inputMin, float inputMax, 
float outputMin, float outputMax, bool smoothstep1, 
float contrast, float contrastPivot, float bias, float gain,
out vec3 outColor, out vec3 outTransparency)
{

outColor = min(max(inputValue, vec3(inputMin)), vec3(inputMax));
outColor = (outColor - contrastPivot) * contrast + contrastPivot;
if (smoothstep1 == true) {
for (int i = 0; i < 3; i++)
outColor[i] = smoothstep(outputMin, outputMax, outColor[i]);
} else
outColor = min(max(outColor, vec3(outputMin)), vec3(outputMax));
outTransparency = outColor;
}`,by=`void node_ray_switch(vec3 camera, vec3 diffuseReflection, vec3 diffuseTransmission,
vec3 shadow, vec3 specularReflection, vec3 specularTransmission,
out vec3 outColor, out float outAlpha)
{
#if LIGHT_PATH_IS_CAM_RAY
outColor = camera;
#else
outColor = diffuseReflection;
#endif
outAlpha = 1.0;
}`,Cy=`void node_reciprocal(
vec3 inputVec,
out vec3 outColor)
{
outColor = 1.0 / inputVec;
}`,Sy=`void node_rgba_to_float(
const int mode,
vec3 inputValue, float inputA,
out float outValue, out vec3 outTransparency)
{
outTransparency = inputValue + vec3(inputA / 4.0);
if (mode == 0)
outValue = min(min(min(inputValue.r, inputValue.g), inputValue.b), inputA);
else if (mode == 1)
outValue = max(max(max(inputValue.r, inputValue.g), inputValue.b), inputA);
else if (mode == 2)
outValue = (inputValue.r + inputValue.g + inputValue.b + inputA) / 4.0;
else if (mode == 3)
outValue = inputValue.r + inputValue.g + inputValue.b + inputA;
else if (mode == 4) {
outValue = dot(inputValue, LUM_WEIGHTS);
}
else if (mode == 5)
outValue = inputValue.r;
else if (mode == 6)
outValue = inputValue.g;
else if (mode == 7)
outValue = inputValue.b;
}`,My=`void node_rgb_to_float(
const int mode,
vec3 inputValue,
out float outValue)
{
if (mode == 0)
outValue = min(min(inputValue.r, inputValue.g), inputValue.b);
else if (mode == 1)
outValue = max(max(inputValue.r, inputValue.g), inputValue.b);
else if (mode == 2)
outValue = (inputValue.r + inputValue.g + inputValue.b) / 3.0;
else if (mode == 3)
outValue = inputValue.r + inputValue.g + inputValue.b;
else if (mode == 4) {
outValue = dot(inputValue, LUM_WEIGHTS);
}
else if (mode == 5)
outValue = inputValue.r;
else if (mode == 6)
outValue = inputValue.g;
else if (mode == 7)
outValue = inputValue.b;
}`,Ey=`void node_rgb_to_vector(
const int mode, 
vec3 inputValue,
out vec3 outValue)
{

outValue = inputValue;
}`,wy=`#include <shadowmask_pars_fragment>
void node_shadow_matte(
vec3 normal,
vec3 shadowColor, float backlighting, float shadowOpacity,
out vec4 outColor, out float outAlpha) {
float shadow = getShadowMask();
outColor = vec4(shadowColor, shadowOpacity * (1.0 - shadow));
outAlpha = outColor.a;
}`,Ty=`
void node_shuffle(const int channelR, const int channelG, const int channelB, const int channelA,
vec3 color, float alpha, bool negateR, bool negateG, bool negateB, bool negateA,
out vec3 outColor, out float outAlpha)
{
outColor = vec3(0.0);
vec4 choose = vec4(color, alpha);
outAlpha = 1.0;
#if __VERSION__ == 100
outColor.r = choose[0];
outColor.g = choose[1];
outColor.b = choose[2];
outAlpha = choose[3];
#else
outColor.r = choose[channelR];
outColor.g = choose[channelG];
outColor.b = choose[channelB];
outAlpha = choose[channelA];
#endif
if (negateR)
outColor.r = -outColor.r;
if (negateG)
outColor.g = -outColor.g;
if (negateB)
outColor.b = -outColor.b;
if (negateA)
outAlpha = -outAlpha;
}
void node_shuffle(const int channelR, const int channelG, const int channelB, const int channelA,
vec4 color, float alpha, bool negateR, bool negateG, bool negateB, bool negateA,
out vec4 outColor)
{
outColor = vec4(0.0);
vec4 choose = vec4(color.rgb, alpha);
#if __VERSION__ == 100
outColor.r = choose[0];
outColor.g = choose[1];
outColor.b = choose[2];
outColor.a = choose[3];
#else
outColor.r = choose[channelR];
outColor.g = choose[channelG];
outColor.b = choose[channelB];
outColor.a = choose[channelA];
#endif
if (negateR)
outColor.r = -outColor.r;
if (negateG)
outColor.g = -outColor.g;
if (negateB)
outColor.b = -outColor.b;
if (negateA)
outColor.a = -outColor.a;
}`,Iy=`void node_sign(
vec3 inputVec,
out vec3 outColor)
{
outColor = sign(inputVec);
}`,Ry=`void node_skydome_light(vec3 color, float intensity,
out vec4 outgoingLight)
{
outgoingLight = vec4(color * intensity, 1.0);
}
void node_skydome_light(sampler2D envMap, int encoding, vec3 normal,
float intensity,
out vec4 outgoingLight)
{
vec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);
vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);
vec3 reflectVec = normalize(cameraToVertex);
mat3 uvTransform = mat3(1.0);
vec4 color = sampleEquirectangular(envMap, reflectVec, uvTransform, encoding);
#if LIGHT_PATH_IS_CAM_RAY
intensity = 1.0;
#endif
outgoingLight = color * intensity;
}`,Ly=`void node_sqrt(
vec3 inputVec,
out vec3 outColor)
{
outColor = sqrt(inputVec);
}`,Py=`#define DEFAULT_REFLECTION_EDGE 1.0
#define DEFAULT_REFLECTION_SLOPE 5.0
void node_standard_surface(
vec3 geometryNormal, const bool thinWalled,
const float base, const vec3 baseColor, const float diffuseRoughness,
const float metalness, const float specular, const vec3 specularColor,
const float specularRoughness, const float trans, const vec3 transColor,
const float transDepth, const vec3 transScatter, const float transExtraRoughness,
const float subsurface, const vec3 subsurfaceColor, const vec3 subsurfaceRadius,
const float coat, const vec3 coatColor, const float coatRoughness,
const float sheen, const vec3 sheenColor, const float sheenRoughness,
const float emission, const vec3 emissionColor, const vec3 opacity,
const vec3 normal, const vec3 clearcoatNormal, const float specularIOR,
out vec4 outColor, out vec3 outTransparency)
{
NodeMaterial material;
vec3 baseColorWeighted = base * baseColor.rgb;
material.diffuseColor = baseColorWeighted * (1.0 - metalness) * (1.0 - trans);
#ifdef USE_CLEARCOAT
material.clearcoat = saturate(coat);
material.clearcoatRoughness = clamp(coatRoughness, 0.0, 1.0);
material.clearcoatF0 = vec3(0.04);
material.clearcoatF90 = 1.0;
#endif
#ifdef USE_SHEEN
material.sheenColor = saturate(sheen * sheenColor);
material.sheenRoughness = clamp(sheenRoughness, 0.0, 1.0);
#endif
vec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));
float geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
material.roughness = max(specularRoughness, 0.0525);
material.roughness += geometryRoughness;
material.roughness = min(material.roughness, 1.0);
vec3 specularColorWeighted = specular * specularColor;
vec3 dielRefl = pow2((1.0 - specularIOR) / (1.0 + specularIOR)) * specularColorWeighted;
material.specularColor = mix(dielRefl, baseColorWeighted, metalness);
material.fresnelRefl90 = mix(specularColorWeighted, vec3(1.0), metalness);
material.specularF90 = average(material.fresnelRefl90);
material.refractionColor = pow(trans * (1.0 - metalness) * transColor.rgb, vec3(2.0));
material.refractionIOR = specularIOR;
material.refractionRoughness = material.roughness;
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
vec3 refractedLight = vec3(0.0);
#ifdef USE_GTAO
vec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,
gl_FragCoord.xy / currResolution);
vec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));
#define PROBE_NORMAL bentNormal
#endif
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#define RE_Refraction RE_Refraction_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
#undef RE_Refraction
#ifdef PROBE_NORMAL
#undef PROBE_NORMAL
#endif
#ifdef USE_GTAO
reflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;
float gtaoVisibility = gtaoVisibilityBentNormal.r;
vec3 gtaoBentNormal = bentNormal;
vec3 gtaoViewDir = geometry.viewDir;
vec3 gtaoNormal = normal;
float gtaoRoughness = material.roughness;
#endif
#include <lights_fragment_gtso>
vec3 totalEmissiveRadiance = emission * emissionColor;
vec3 outSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
vec3 outColor3 = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +
outSpecular + totalEmissiveRadiance;
#ifdef USE_SHEEN
float sheenEnergyComp = 1.0 - 0.157 * max3(material.sheenColor);
outColor3 = outColor3 * sheenEnergyComp + sheenSpecular;
#endif
#ifdef USE_CLEARCOAT
float dotNVcc = saturate(dot(geometry.normal, geometry.viewDir));
vec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);
outColor3 = outColor3 * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;
#endif
float alpha = 1.0;
if (thinWalled) {
alpha = average(opacity) * (1.0 - saturate(trans) + maxFromRGB(outSpecular) * saturate(trans));
} else {
outColor3 += refractedLight;
}
outColor = vec4(outColor3, saturate(alpha));
outTransparency = outColor3;
}
void node_standard_surface(
vec3 geometryNormal, const bool thinWalled,
const float base, const vec3 baseColor, const float diffuseRoughness,
const float metalness, const float specular, const vec3 specularColor,
const float specularRoughness, const float trans, const vec3 transColor,
const float transDepth, const vec3 transScatter, const float transExtraRoughness,
const float subsurface, const vec3 subsurfaceColor, const vec3 subsurfaceRadius,
const float coat, const vec3 coatColor, const float coatRoughness,
const float sheen, const vec3 sheenColor, const float sheenRoughness,
const float emission, const vec3 emissionColor, const vec3 opacity,
const vec3 normal, const vec3 clearcoatNormal,
out vec4 outColor, out vec3 outTransparency)
{
node_standard_surface(
geometryNormal, thinWalled,
base, baseColor, diffuseRoughness,
metalness, specular, specularColor,
specularRoughness, trans, transColor,
transDepth, transScatter, transExtraRoughness,
subsurface, subsurfaceColor, subsurfaceRadius,
coat, coatColor, coatRoughness,
sheen, sheenColor, sheenRoughness,
emission, emissionColor, opacity,
normal, clearcoatNormal, 1.5,
outColor, outTransparency);
}`,By=`void node_subtract(
vec3 input1, vec3 input2,
out vec3 outColor)
{
outColor = input1 - input2;
}`,Dy=`void node_trigo(
const int function, const int units,
vec3 inputVec, float frequency, float phase,
out vec3 outColor)
{
if (units == 1 && function >= 0 && function <=2)
inputVec = radians(inputVec);
if (function == 0)
outColor = cos(inputVec * frequency + phase);
else if (function == 1)
outColor = sin(inputVec * frequency + phase);
else if (function == 2)
outColor = tan(inputVec * frequency + phase);
else if (function == 3)
outColor = acos(inputVec * frequency + phase);
else if (function == 4)
outColor = asin(inputVec * frequency + phase);
else if (function == 5)
outColor = atan(inputVec * frequency + phase);
else if (function == 6)
outColor = cosh(inputVec * frequency + phase);
else if (function == 7)
outColor = sinh(inputVec * frequency + phase);
else
outColor = tanh(inputVec * frequency + phase);
if (units == 1 && function >= 3 && function <=5)
outColor = degrees(outColor);
}`,Ny=`void node_two_sided(
float frontFacing,
vec3 front, vec3 back,
out vec3 outColor)
{
outColor = (frontFacing > 0.0) ? front : back;
}`,Oy=`void node_user_data_color(vec4 color, 
out vec3 outColor, out float outAlpha)
{
outColor = color.rgb;
outAlpha = color.a;
}`,Fy=`void node_vector_to_rgb(
const int mode, 
vec3 inputValue,
out vec3 outColor)
{
if (mode == 0)
outColor = inputValue;
else if (mode == 1)
outColor = normalize(inputValue);
else if (mode == 2)
outColor = inputValue;
}`,Uy=`void node_add_shader(vec4 color1, vec4 color2, out vec4 outColor) {
outColor.rgb = color1.rgb + color2.rgb;
outColor.a = clamp(color1.a + color2.a, 0.0, 1.0);
}`,zy=`void node_ambient_occlusion(vec4 color, float distance, vec3 normal,
out vec4 outColor, out float outAO) {
outColor = color;
outAO = 1.0;
}`,Vy=`void node_attribute(vec4 paramAttr,
out vec4 outColor, out vec3 outVector, out float outFac, out float outAlpha) {
outColor = vec4(paramAttr.xyz, 1.0);
outVector = paramAttr.xyz;
outFac = average(paramAttr.xyz);
outAlpha = paramAttr.w;
}`,Gy=`void node_background(vec4 color, float strength, out vec4 outColor)
{
outColor = strength * color;
}`,ky=`void node_bevel(float radius, vec3 normal, out vec3 outNormal) {
outNormal = normal;
}`,Qy=`void node_blackbody(float temp, out vec4 outColor)
{
outColor = vec4(colorTempToRGB(temp), 1.0);
}`,Wy=`void node_brightcontrast(vec4 color, float bright, float contrast, out vec4 outColor)
{
float bminc = bright - contrast * 0.5;
outColor.r = max((1.0 + contrast) * color.r + bminc, 0.0);
outColor.g = max((1.0 + contrast) * color.g + bminc, 0.0);
outColor.b = max((1.0 + contrast) * color.b + bminc, 0.0);
outColor.a = color.a;
}`,Hy=`void node_bsdf_anisotropic(
vec4 color, float roughness, float anisotropy, float rotation, vec3 normal, vec3 tangent,
out vec4 outColor)
{
outColor = color;
}`,Xy=`void node_bsdf_diffuse(
vec4 color, float roughness, vec3 normal,
out vec4 outColor) {
normal = vec3(normal[0], normal[2], -normal[1]);
normal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;
NodeMaterial material;
material.diffuseColor = color.rgb;
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
#ifdef USE_GTAO
vec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,
gl_FragCoord.xy / currResolution);
vec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));
#define PROBE_NORMAL bentNormal
#endif
#define RE_Direct RE_DirectDiffuseOnly_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#ifdef PROBE_NORMAL
#undef PROBE_NORMAL
#endif
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
#ifdef USE_GTAO
reflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;
#endif
outColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, 1.0);
}`,Yy=`void node_bsdf_glass(
vec3 geometryNormal,
vec4 color, float roughness, float ior, vec3 normal,
out vec4 outColor) {
normal = normalize(normal);
normal = swizzleUpY(normal);
vec3 normalWorld = normal;
normal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;
NodeMaterial material;
material.specularColor = vec3(1.0);
material.fresnelRefl90 = vec3(1.0);
material.roughness = clamp(roughness, 0.0, 1.0);
material.refractionColor = vec3(1.0);
material.refractionIOR = ior;
material.refractionRoughness = pow2(roughness);
#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)
float geomRoughness = calcGeometryRoughness(geometryNormal);
material.roughness = calcCubeUVAdjustedRoughness(
material.roughness, geomRoughness);
material.refractionRoughness = calcCubeUVAdjustedRoughness(
material.refractionRoughness, geomRoughness);
#endif
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0),
vec3(0.0), vec3(0.0));
vec3 refractedLight = vec3(0.0);
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
#ifdef USE_GTAO
vec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,
gl_FragCoord.xy / currResolution);
vec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));
#define PROBE_NORMAL bentNormal
#endif
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Empty
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#define RE_Refraction RE_Refraction_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
#undef RE_Refraction
#ifdef PROBE_NORMAL
#undef PROBE_NORMAL
#endif
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
#ifdef USE_GTAO
float gtaoVisibility = gtaoVisibilityBentNormal.r;
vec3 gtaoBentNormal = bentNormal;
vec3 gtaoViewDir = geometry.viewDir;
vec3 gtaoNormal = normal;
float gtaoRoughness = material.roughness;
#endif
#include <lights_fragment_gtso>
vec3 viewWorld;
if (isOrthographic)
viewWorld = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;
else
viewWorld = (invViewMatrix * vec4(-vViewPosition, 0.0)).xyz;
viewWorld = normalize(viewWorld);
float fresnel = fresnelReflection(viewWorld, normalWorld, ior);
outColor = vec4(color.rgb * mix(refractedLight, reflectedLight.directSpecular
+ reflectedLight.indirectSpecular, fresnel), 1.0);
}`,jy=`void node_bsdf_glossy(
vec3 geometryNormal,
vec4 color, float roughness, float anisotropy, float rotation, vec3 normal, vec3 tangent,
out vec4 outColor) {
normal = vec3(normal[0], normal[2], -normal[1]);
normal = normalize((viewMatrix * vec4(normal.xyz, 0.0)).xyz);
NodeMaterial material;
material.specularColor = vec3(1.0);
material.fresnelRefl90 = vec3(1.0);
material.roughness = clamp(roughness, 0.0, 1.0);
#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)
float geomRoughness = calcGeometryRoughness(geometryNormal);
material.roughness = calcCubeUVAdjustedRoughness(
material.roughness, geomRoughness);
#endif
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
#ifdef USE_GTAO
vec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,
gl_FragCoord.xy / currResolution);
vec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));
#define PROBE_NORMAL bentNormal
#endif
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Empty
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
#ifdef PROBE_NORMAL
#undef PROBE_NORMAL
#endif
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
#ifdef USE_GTAO
float gtaoVisibility = gtaoVisibilityBentNormal.r;
vec3 gtaoBentNormal = bentNormal;
vec3 gtaoViewDir = geometry.viewDir;
vec3 gtaoNormal = normal;
float gtaoRoughness = material.roughness;
#endif
#include <lights_fragment_gtso>
outColor = vec4(color.rgb * (reflectedLight.directSpecular
+ reflectedLight.indirectSpecular), 1.0);
}
void node_bsdf_glossy(
vec3 geometryNormal,
vec4 color, float roughness, vec3 normal,
out vec4 outColor) {
node_bsdf_glossy(geometryNormal, color, roughness, 0.0, 0.0, normal, vec3(0.0), outColor);
}`,Ky=`void node_bsdf_hair(vec4 color, float offset, float roughnessU, float roughnessV, vec3 tangent, out vec4 outColor)
{
outColor = color;
}`,qy=`
vec3 tintFromColor(vec3 color) {
float lum = dot(color, vec3(0.3, 0.6, 0.1));
return lum > 0.0 ? color / lum : vec3(1.0);
}
vec3 fresnelBlend(float ior, float fresnel, vec3 fresnelColor) {
float fresnelFac = fresnelReflection(vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), ior);
float mixFac = saturate((fresnel - fresnelFac) / max(1e-8, 1.0 - fresnelFac));
return mix(fresnelColor, vec3(1.0), mixFac);
}
#ifdef USE_SHEEN_BLENDER
float principledSheen(float NV, float rough) {
float den = 35.6694 * rough * rough - 24.4269 * rough * NV - 0.1405 * NV * NV + 6.1211 * rough + 0.28105 * NV - 0.1405;
float num = 58.5299 * rough * rough - 85.0941 * rough * NV + 9.8955 * NV * NV + 1.9250 * rough + 74.2268 * NV - 0.2246;
return saturate(den / num);
}
#elif defined(USE_SHEEN_BLENDER_OLD)
float principledSheen(float NV) {
float f = 1.0 - NV;
float sheen = f * f * f * 0.077 + f * 0.01 + 0.00026;
return sheen;
}
#endif
void node_bsdf_principled(
vec3 geometryNormal,
vec4 baseColor, float metallic, float roughness, float ior, float alpha, vec3 normal,
float subsurface, vec3 subsurfaceRadius, float subsurfaceScale, float subsurfaceIOR,
float subsurfaceAnisotropy,
float specularIORLevel, vec4 specularTint,
float anisotropic, float anisotropicRotation, vec3 tangent,
float transmission,
float clearcoat, float clearcoatRoughness, float clearcoatIOR, vec4 clearcoatTint,
vec3 clearcoatNormal,
float sheen, float sheenRoughness, vec4 sheenTint,
vec4 emission, float emissionStrength,
out vec4 outColor) {
normal = vec3(normal[0], normal[2], -normal[1]);
vec3 normalWorld = normal;
normal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;
NodeMaterial material;
metallic = clamp(metallic, 0.0, 1.0);
float dielectric = 1.0 - metallic;
transmission *= dielectric;
material.diffuseColor = baseColor.rgb * dielectric;
#ifndef USE_CLEARCOAT
float dielReflCoeff = BLENDER_SPECULAR_COEFFICIENT;
#else
float dielReflCoeff = MAXIMUM_SPECULAR_COEFFICIENT;
material.clearcoat = saturate(clearcoat);
material.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);
material.clearcoatF0 = vec3(0.04);
material.clearcoatF90 = 1.0;
#endif
#ifdef USE_SHEEN_BLENDER
float dotNVsh = dot(normal, (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition));
material.diffuseColor += sheen * sheenTint.rgb * principledSheen(dotNVsh, sheenRoughness);
#endif
vec3 dielRefl = dielReflCoeff * specularIORLevel * specularTint.rgb;
material.specularColor = mix(dielRefl, baseColor.rgb, metallic);
material.roughness = clamp(roughness, 0.0, 1.0);
vec3 viewWorld;
if (isOrthographic)
viewWorld = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;
else
viewWorld = (invViewMatrix * vec4(-vViewPosition, 0.0)).xyz;
viewWorld = normalize(viewWorld);
float fresnel = fresnelReflection(viewWorld, normalWorld, ior);
material.specularColor = mix(material.specularColor,
fresnelBlend(ior, fresnel, specularTint.rgb) * fresnel, transmission);
float isStrictDielectric = step(0.0, -length(vec4(subsurface, clearcoat,
transmission, float(metallic == 1.0))));
material.fresnelRefl90 = mix(vec3(1.0), material.specularColor,
(1.0 - specularIORLevel) * metallic * (1.0 - isStrictDielectric));
material.specularF90 = average(material.fresnelRefl90);
material.refractionColor = baseColor.rgb;
material.refractionIOR = ior;
material.refractionRoughness = pow2(roughness);
#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)
float geomRoughness = calcGeometryRoughness(geometryNormal);
material.roughness = calcCubeUVAdjustedRoughness(
material.roughness, geomRoughness);
material.refractionRoughness = calcCubeUVAdjustedRoughness(
material.refractionRoughness, geomRoughness);
#ifdef USE_CLEARCOAT
material.clearcoatRoughness = calcCubeUVAdjustedRoughness(
material.clearcoatRoughness, geomRoughness);
clearcoatNormal = normalize(vec3(clearcoatNormal[0], clearcoatNormal[2], -clearcoatNormal[1]));
clearcoatNormal = (viewMatrix * vec4(clearcoatNormal.xyz, 0.0)).xyz;
#endif
#endif
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
vec3 refractedLight = vec3(0.0);
#ifdef USE_GTAO
vec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,
gl_FragCoord.xy / currResolution);
vec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));
#define PROBE_NORMAL bentNormal
#endif
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#define RE_Refraction RE_Refraction_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
#undef RE_Refraction
#ifdef PROBE_NORMAL
#undef PROBE_NORMAL
#endif
#ifdef USE_GTAO
reflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;
float gtaoVisibility = gtaoVisibilityBentNormal.r;
vec3 gtaoBentNormal = bentNormal;
vec3 gtaoViewDir = geometry.viewDir;
vec3 gtaoNormal = normal;
float gtaoRoughness = material.roughness;
#endif
#include <lights_fragment_gtso>
vec3 outColor3 = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * (1.0 - transmission)
+ reflectedLight.directSpecular + reflectedLight.indirectSpecular
+ refractedLight * transmission * (1.0 - fresnel)
+ emission.rgb * emissionStrength;
#ifdef USE_CLEARCOAT
float dotNVcc = saturate(dot(geometry.normal, geometry.viewDir));
vec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);
outColor3 = outColor3 * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;
#endif
outColor = vec4(outColor3, alpha);
}
void node_bsdf_principled(
vec3 geometryNormal,
vec4 baseColor, float subsurface, vec3 subsurfaceRadius, vec4 subsurfaceColor,
float subsurfaceIOR, float subsurfaceAnisotropy,
float metallic, float specular, float specularTint, float roughness,
float anisotropic, float anisotropicRotation, float sheen, float sheenTint,
float clearcoat, float clearcoatRoughness, float ior,
float transmission, float transmissionRoughness, vec4 emission,
float emissionStrength, float alpha, vec3 normal, vec3 clearcoatNormal,
vec3 tangent,
out vec4 outColor) {
normal = vec3(normal[0], normal[2], -normal[1]);
vec3 normalWorld = normal;
normal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;
NodeMaterial material;
metallic = clamp(metallic, 0.0, 1.0);
float dielectric = 1.0 - metallic;
transmission *= dielectric;
material.diffuseColor = baseColor.rgb * dielectric;
#ifndef USE_CLEARCOAT
float dielReflCoeff = BLENDER_SPECULAR_COEFFICIENT;
#else
float dielReflCoeff = MAXIMUM_SPECULAR_COEFFICIENT;
material.clearcoat = saturate(clearcoat);
material.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);
material.clearcoatF0 = vec3(0.04);
material.clearcoatF90 = 1.0;
#endif
#if defined(USE_SHEEN_BLENDER_OLD)
float dotNVsh = dot(normal, (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition));
vec3 sheenColor = mix(vec3(1.0), tintFromColor(baseColor.rgb), sheenTint);
material.diffuseColor += sheen * sheenColor * principledSheen(dotNVsh);
#endif
vec3 dielRefl = dielReflCoeff * specular
* mix(vec3(1.0), tintFromColor(baseColor.rgb), specularTint);
material.specularColor = mix(dielRefl, baseColor.rgb, metallic);
material.roughness = clamp(roughness, 0.0, 1.0);
vec3 viewWorld;
if (isOrthographic)
viewWorld = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;
else
viewWorld = (invViewMatrix * vec4(-vViewPosition, 0.0)).xyz;
viewWorld = normalize(viewWorld);
float fresnel = fresnelReflection(viewWorld, normalWorld, ior);
vec3 fresnelColor = mix(vec3(1.0), baseColor.rgb, specularTint);
material.specularColor = mix(material.specularColor,
fresnelBlend(ior, fresnel, fresnelColor) * fresnel, transmission);
float isStrictDielectric = step(0.0, -length(vec4(subsurface, clearcoat,
transmission, float(metallic == 1.0))));
material.fresnelRefl90 = mix(vec3(1.0), material.specularColor,
(1.0 - specular) * metallic * (1.0 - isStrictDielectric));
material.specularF90 = average(material.fresnelRefl90);
material.refractionColor = baseColor.rgb;
material.refractionIOR = ior;
material.refractionRoughness = pow2(roughness);
#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)
float geomRoughness = calcGeometryRoughness(geometryNormal);
material.roughness = calcCubeUVAdjustedRoughness(
material.roughness, geomRoughness);
material.refractionRoughness = calcCubeUVAdjustedRoughness(
material.refractionRoughness, geomRoughness);
#ifdef USE_CLEARCOAT
material.clearcoatRoughness = calcCubeUVAdjustedRoughness(
material.clearcoatRoughness, geomRoughness);
clearcoatNormal = normalize(vec3(clearcoatNormal[0], clearcoatNormal[2], -clearcoatNormal[1]));
clearcoatNormal = (viewMatrix * vec4(clearcoatNormal.xyz, 0.0)).xyz;
#endif
#endif
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
vec3 refractedLight = vec3(0.0);
#ifdef USE_GTAO
vec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,
gl_FragCoord.xy / currResolution);
vec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));
#define PROBE_NORMAL bentNormal
#endif
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#define RE_Refraction RE_Refraction_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
#undef RE_Refraction
#ifdef PROBE_NORMAL
#undef PROBE_NORMAL
#endif
#ifdef USE_GTAO
reflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;
float gtaoVisibility = gtaoVisibilityBentNormal.r;
vec3 gtaoBentNormal = bentNormal;
vec3 gtaoViewDir = geometry.viewDir;
vec3 gtaoNormal = normal;
float gtaoRoughness = material.roughness;
#endif
#include <lights_fragment_gtso>
vec3 outColor3 = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * (1.0 - transmission)
+ reflectedLight.directSpecular + reflectedLight.indirectSpecular
+ refractedLight * transmission * (1.0 - fresnel)
+ emission.rgb * emissionStrength;
#ifdef USE_CLEARCOAT
float dotNVcc = saturate(dot(geometry.normal, geometry.viewDir));
vec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);
outColor3 = outColor3 * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;
#endif
outColor = vec4(outColor3, alpha);
}`,Zy=`#define BSDF_REFRACTION_GGX 0
#define BSDF_REFRACTION_BECKMANN 1
#define BSDF_REFRACTION_SHARP 2
void node_bsdf_refraction(
vec3 geometryNormal, const int distribution,
vec4 color, float roughness, float ior, vec3 normal,
out vec4 outColor) {
normal = swizzleUpY(normal);
normal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;
NodeMaterial material;
material.refractionColor = color.rgb;
material.refractionIOR = ior;
if (distribution == BSDF_REFRACTION_SHARP) {
material.refractionRoughness = 0.0;
} else {
material.refractionRoughness = pow2(roughness);
}
#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)
float geomRoughness = calcGeometryRoughness(geometryNormal);
material.refractionRoughness = calcCubeUVAdjustedRoughness(
material.refractionRoughness, geomRoughness);
#endif
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
vec3 refractedLight = vec3(0.0);
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
#define RE_Refraction RE_Refraction_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Refraction
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
outColor = vec4(refractedLight, 1.0);
}`,Jy=`
void node_bsdf_sheen(vec4 color, float roughness, vec3 normal, out vec4 outColor)
{
normal = vec3(normal[0], normal[2], -normal[1]);
normal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;
NodeMaterial material;
material.diffuseColor = color.rgb;
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
#define RE_Direct RE_DirectDiffuseOnly_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
outColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, 1.0);
}`,$y=`void node_bsdf_toon(
vec4 color, float size, float smoothFac, vec3 normal,
out vec4 outColor)
{
outColor = color;
}`,eb=`void node_bsdf_translucent(vec4 color, vec3 normal, out vec4 outColor) {
normal = -vec3(normal[0], normal[2], -normal[1]);
normal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;
NodeMaterial material;
material.diffuseColor = color.rgb;
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
#define RE_Direct RE_DirectDiffuseOnly_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
outColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, 1.0);
}`,tb=`void node_bsdf_transparent(vec4 color, out vec4 outColor)
{
float alpha = saturate(1.0 - dot(color.rgb, vec3(0.333333)));
outColor = vec4(0.0, 0.0, 0.0, alpha);
}`,nb=`
void node_bsdf_velvet(vec4 color, float sigma, vec3 normal, out vec4 outColor)
{
outColor = color;
}`,ib=`void node_bump(
const bool invert,
float strength, float bumpDist, float height, vec3 normal,
out vec3 outNormal) {
vec3 position = swizzleUpZ(vWorldPosition);
if (invert)
bumpDist *= -1.0;
vec3 dPdx = dFdx(position);
vec3 dPdy = dFdy(position);
float dHdx = dFdx(height);
float dHdy = dFdy(height);
vec3 tanX = cross(dPdy, normal);
vec3 tanY = cross(normal, dPdx);
vec3 surfaceGrad = dHdx * tanX + dHdy * tanY;
float dotPosTanX = dot(dPdx, tanX);
outNormal = normalize(normal * abs(dotPosTanX) - surfaceGrad * bumpDist * sign(dotPosTanX));
outNormal = normalize(mix(normal, outNormal, max(0.0, strength)));
}
void node_bump(const bool invert,
float strength, float bumpDist, float height, float height_dx, float height_dy, vec3 normal,
out vec3 outNormal) {
node_bump(invert, strength, bumpDist, height, normal, outNormal);
}`,ob=`void node_camera(
vec3 viewPos, const bool invCamZ,
out vec3 outViewVector, out float outViewZDepth, out float outViewDistance)
{
viewPos = -viewPos;
if (invCamZ)
viewPos.z = -viewPos.z;
outViewVector = normalize(viewPos);
outViewZDepth = abs(viewPos.z);
outViewDistance = length(viewPos);
}`,rb=`void node_clamp(bool clampRange, float value, float minVal, float maxVal, out float result) {
if (clampRange)
result = (maxVal > minVal) ? clamp(value, minVal, maxVal) : clamp(value, maxVal, minVal);
else
result = min(max(value, minVal), maxVal);
}`,ab=`
void node_combhsv(float h, float s, float v, out vec4 col)
{
hsvToRGB(vec4(h, s, v, 1.0), col);
}`,sb=`#define NODE_COMB_COL_RGB 0
#define NODE_COMB_COL_HSV 1
#define NODE_COMB_COL_HSL 2
void hslToRGB(vec3 hsl, out vec3 outCol)
{
float nr, ng, nb, chroma;
float h, s, l;
h = hsl[0];
s = hsl[1];
l = hsl[2];
nr = abs(h * 6.0 - 3.0) - 1.0;
ng = 2.0 - abs(h * 6.0 - 2.0);
nb = 2.0 - abs(h * 6.0 - 4.0);
nr = clamp(nr, 0.0, 1.0);
nb = clamp(nb, 0.0, 1.0);
ng = clamp(ng, 0.0, 1.0);
chroma = (1.0 - abs(2.0 * l - 1.0)) * s;
outCol = vec3((nr - 0.5) * chroma + l, (ng - 0.5) * chroma + l, (nb - 0.5) * chroma + l);
}
void node_combine_color(int mode, float r, float g, float b, out vec4 col)
{
if (mode == NODE_COMB_COL_RGB) {
col = vec4(r, g, b, 1.0);
} else if (mode == NODE_COMB_COL_HSV) {
hsvToRGB(vec4(r, g, b, 1.0), col);
} else {
vec3 col3;
hslToRGB(vec3(r, g, b), col3);
col = vec4(col3, 1.0);
}
}`,lb=`
void node_combrgb(float r, float g, float b, out vec4 col)
{
col = vec4(r, g, b, 1.0);
}`,cb=`void node_combxyz(float x, float y, float z, out vec3 outVector)
{
outVector = vec3(x, y, z);
}`,ub=`void node_curve_float(sampler2D curveData, float fac, float value, out float outValue)
{
outValue = texture2D(curveData, vec2((value + 1.0) * 0.5, 0.0)).x;
outValue = mix(value, outValue * 2.0 - 1.0, fac);
}`,db=`void node_curve_rgb(sampler2D curveData, float fac, vec4 col, out vec4 outCol)
{
outCol.r = texture2D(curveData, vec2(texture2D(curveData, vec2(col.r, 0.0)).a, 0.0)).r;
outCol.g = texture2D(curveData, vec2(texture2D(curveData, vec2(col.g, 0.0)).a, 0.0)).g;
outCol.b = texture2D(curveData, vec2(texture2D(curveData, vec2(col.b, 0.0)).a, 0.0)).b;
outCol = mix(col, outCol, fac);
outCol.a = col.a;
}`,hb=`void node_curve_vec(sampler2D curveData, float fac, vec3 vec, out vec3 outVec)
{
outVec.x = texture2D(curveData, vec2((vec.x + 1.0) * 0.5, 0.0)).x;
outVec.y = texture2D(curveData, vec2((vec.y + 1.0) * 0.5, 0.0)).y;
outVec.z = texture2D(curveData, vec2((vec.z + 1.0) * 0.5, 0.0)).z;
outVec = mix(vec, outVec * 2.0 - vec3(1.0), fac);
}`,pb=`void node_displacement(float height, float midlevel, float scale, vec3 normal, out vec3 outDisplacement) {
outDisplacement = vec3(0.0);
}`,fb=`void node_eevee_specular(
vec3 geometryNormal,
vec4 baseColor, vec4 specular, float roughness, vec4 emissiveColor,
float transparency, vec3 normal, float clearcoat, float clearcoatRoughness,
vec3 clearcoatNormal, float ambientOcclusion,
out vec4 outColor) {
normal = vec3(normal[0], normal[2], -normal[1]);
vec3 normalWorld = normal;
normal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;
NodeMaterial material;
material.diffuseColor = baseColor.rgb;
material.specularColor = specular.rgb;
material.roughness = clamp(roughness, 0.0, 1.0);
#ifdef USE_CLEARCOAT
material.clearcoat = saturate(clearcoat);
material.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);
#endif
#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)
float geomRoughness = calcGeometryRoughness(geometryNormal);
material.roughness = calcCubeUVAdjustedRoughness(
material.roughness, geomRoughness);
#ifdef USE_CLEARCOAT
material.clearcoatRoughness = calcCubeUVAdjustedRoughness(
material.clearcoatRoughness, geomRoughness);
clearcoatNormal = normalize(vec3(clearcoatNormal[0], clearcoatNormal[2], -clearcoatNormal[1]));
clearcoatNormal = (viewMatrix * vec4(clearcoatNormal.xyz, 0.0)).xyz;
#endif
#endif
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#ifdef USE_GTAO
vec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,
gl_FragCoord.xy / currResolution);
vec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));
#define PROBE_NORMAL bentNormal
#endif
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
#ifdef PROBE_NORMAL
#undef PROBE_NORMAL
#endif
#ifdef USE_GTAO
reflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;
float gtaoVisibility = gtaoVisibilityBentNormal.r;
vec3 gtaoBentNormal = bentNormal;
vec3 gtaoViewDir = geometry.viewDir;
vec3 gtaoNormal = normal;
float gtaoRoughness = material.roughness;
#endif
#include <lights_fragment_gtso>
vec3 outColor3 = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse
+ reflectedLight.directSpecular + reflectedLight.indirectSpecular) * ambientOcclusion
+ emissiveColor.rgb;
outColor = vec4(outColor3, 1.0 - transparency);
}`,mb=`void node_emission(vec4 color, float strength, out vec4 outColor)
{
outColor = vec4(strength * color.rgb, 1.0);
}`,gb=`void node_fresnel(vec3 viewPos, float IOR, vec3 normal, out float fac)
{
vec3 worldDir;
if (isOrthographic)
worldDir = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;
else
worldDir = (invViewMatrix * vec4(-viewPos, 0.0)).xyz;
worldDir = normalize(swizzleUpZ(worldDir));
float eta = max(IOR, 0.00001);
fac = fresnelReflection(worldDir, normal, (gl_FrontFacing) ? eta : 1.0 / eta);
}`,vb=`void node_gamma(vec4 col, float gamma, out vec4 outCol)
{
outCol = col;
if (col.r > 0.0)
outCol.r = powCompat(col.r, gamma);
if (col.g > 0.0)
outCol.g = powCompat(col.g, gamma);
if (col.b > 0.0)
outCol.b = powCompat(col.b, gamma);
}`,_b=`
void node_hair_info(out float isStrand, out float intercept, out float len, out float thickness,
out vec3 tangentNormal, out float random) {
isStrand = 0.0;
intercept = 0.0;
len = 0.0;
thickness = 0.0;
tangentNormal = vec3(0.0);
random = 1.0;
}
void node_hair_info(out float isStrand, out float intercept, out float thickness,
out vec3 tangentNormal, out float random) {
float len;
node_hair_info(isStrand, intercept, len, thickness, tangentNormal, random);
}`,Ab=`void node_holdout(out vec4 outColor)
{
outColor = vec4(0.0);
}`,xb=`void node_hue_sat(float hue, float sat, float value, float fac, vec4 col, out vec4 outCol)
{
vec4 hsv;
rgbToHSV(col, hsv);
hsv[0] += (fract(hue) - 0.5);
if (hsv[0] > 1.0) hsv[0] -= 1.0; else if (hsv[0] < 0.0) hsv[0] += 1.0;
hsv[1] *= sat;
if (hsv[1] > 1.0) hsv[1] = 1.0; else if (hsv[1] < 0.0) hsv[1] = 0.0;
hsv[2] *= value;
hsvToRGB(hsv, outCol);
outCol = mix(col, outCol, fac);
}`,yb=`void node_invert(float fac, vec4 col, out vec4 outCol)
{
outCol.xyz = mix(col.xyz, vec3(1.0, 1.0, 1.0) - col.xyz, fac);
outCol.w = col.w;
}`,bb=`void node_layer_weight(vec3 viewPos, float blend, vec3 normal, out float fresnel, out float facing)
{
vec3 worldDir;
if (isOrthographic)
worldDir = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;
else
worldDir = (invViewMatrix * vec4(-viewPos, 0.0)).xyz;
worldDir = normalize(swizzleUpZ(worldDir));
float eta = max(1.0 - blend, EPSILON);
fresnel = fresnelReflection(worldDir, normal, (gl_FrontFacing) ? 1.0 / eta : eta);
facing = abs(dot(worldDir, normal));
if (blend != 0.5) {
blend = clamp(blend, 0.0, 1.0 - EPSILON);
blend = (blend < 0.5) ? blend * 2.0 : 0.5 / (1.0 - blend);
facing = pow(facing, blend);
}
facing = 1.0 - facing;
}`,Cb=`void node_light_falloff(
float strength, float inSmooth,
out float quadratic, out float linear, out float constant)
{
quadratic = 1.0;
linear = 1.0;
constant = 1.0;
}`,Sb=`void node_light_path(
out float isCameraRay, out float isShadowRay, out float isDiffuseRay, 
out float isGlossyRay, out float isSingularRay, out float isReflectionRay,
out float isTransmissionRay, out float rayLength, out float rayDepth, 
out float diffuseDepth, out float glossyDepth, out float transparentDepth, 
out float transmissionDepth)
{
#if LIGHT_PATH_IS_CAM_RAY
isCameraRay = 1.0;
#else
isCameraRay = 0.0;
#endif
isShadowRay = 0.0;
isDiffuseRay = 0.0;
isGlossyRay = 0.0;
isSingularRay = 0.0;
isReflectionRay = 0.0;
isTransmissionRay = 0.0;
rayLength = 1.0;
rayDepth = 1.0;
diffuseDepth = 1.0;
glossyDepth = 1.0;
transparentDepth = 1.0; 
transmissionDepth = 1.0;
}`,Mb=`void node_mapping(mat4 mat, vec3 minVec, vec3 maxVec, bool useMin, bool useMax, vec3 vec, out vec3 outVec)
{
outVec = (mat * vec4(vec, 1.0)).xyz;
if (useMin)
outVec = max(outVec, minVec);
if (useMax)
outVec = min(outVec, maxVec);
}
mat3 rotationMatrix(float angleX, float angleY, float angleZ) {
float cx = cos(angleX);
float sx = sin(angleX);
float cy = cos(angleY);
float sy = sin(angleY);
float cz = cos(angleZ);
float sz = sin(angleZ);
mat3 mat;
mat[0][0] = cy * cz;
mat[0][1] = cy * sz;
mat[0][2] = -sy;
mat[1][0] = sy * sx * cz - cx * sz;
mat[1][1] = sy * sx * sz + cx * cz;
mat[1][2] = cy * sx;
mat[2][0] = sy * cx * cz + sx * sz;
mat[2][1] = sy * cx * sz - sx * cz;
mat[2][2] = cy * cx;
return mat;
}
#define NODE_MAPPING_POINT 1
#define NODE_MAPPING_TEXTURE 2
#define NODE_MAPPING_VECTOR 3
#define NODE_MAPPING_NORMAL 4
void node_mapping(int type, vec3 vec, vec3 loc, vec3 rot, vec3 scale, out vec3 outVec)
{
if (type == NODE_MAPPING_POINT)
outVec = rotationMatrix(rot.x, rot.y, rot.z) * (vec * scale) + loc;
else if (type == NODE_MAPPING_TEXTURE)
outVec = transposeMat3(rotationMatrix(rot.x, rot.y, rot.z)) * (vec - loc) / scale;
else if (type == NODE_MAPPING_VECTOR)
outVec = rotationMatrix(rot.x, rot.y, rot.z) * (vec * scale);
else {
mat3 rot = rotationMatrix(rot.x, rot.y, rot.z) * mat3(
scale[0], 0.0, 0.0,
0.0, scale[1], 0.0,
0.0, 0.0, scale[2]
);
outVec = normalize(mat3GetInverseTransposed(rot) * vec);
}
}`,Eb=`#define NODE_MAP_RANGE_INTERP_LINEAR 0
#define NODE_MAP_RANGE_INTERP_STEPPED 1
#define NODE_MAP_RANGE_INTERP_SMOOTHSTEP 2
#define NODE_MAP_RANGE_INTERP_SMOOTHERSTEP 3
#define NODE_MAP_RANGE_TYPE_FLOAT 0
#define NODE_MAP_RANGE_TYPE_FLOAT_VECTOR 1
float smootherstep(float edge0, float edge1, float x) {
float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}
vec3 smootherstep(vec3 x) {
vec3 t = clamp(x, 0.0, 1.0);
return (t * (t * 6.0 - 15.0) + 10.0) * t * t * t;
}
void node_map_range(const int interpolation, bool inClamp, float value, float fromMin, float fromMax,
float toMin, float toMax, float steps, out float result) {
if (fromMax == fromMin) {
result = 0.0;
} else if (interpolation == NODE_MAP_RANGE_INTERP_LINEAR) {
result = (value - fromMin) / (fromMax - fromMin) * (toMax - toMin) + toMin;
} else if (interpolation == NODE_MAP_RANGE_INTERP_STEPPED) {
float fac = (value - fromMin) / (fromMax - fromMin);
fac = (steps > 0.0) ? floor(fac * (steps + 1.0)) / steps : 0.0;
result = fac * (toMax - toMin) + toMin;
} else if (interpolation == NODE_MAP_RANGE_INTERP_SMOOTHSTEP) {
float fac = (fromMin > fromMax) ?
1.0 - smoothstep(fromMax, fromMin, value) :
smoothstep(fromMin, fromMax, value);
result = fac * (toMax - toMin) + toMin;
} else {
float fac = (fromMin > fromMax) ?
1.0 - smootherstep(fromMax, fromMin, value) :
smootherstep(fromMin, fromMax, value);
result = fac * (toMax - toMin) + toMin;
}
if (inClamp && interpolation <= NODE_MAP_RANGE_INTERP_STEPPED) {
result = clamp(result, toMin, toMax);
}
}
void node_map_range(const int dataType, const int interpolation, bool inClamp, float value,
float fromMin, float fromMax, float toMin, float toMax, float steps, vec3 valueVec,
vec3 fromMinVec, vec3 fromMaxVec, vec3 toMinVec, vec3 toMaxVec, vec3 stepsVec,
out float result, out vec3 resultVec) {
if (dataType == NODE_MAP_RANGE_TYPE_FLOAT) {
if (fromMax == fromMin) {
result = 0.0;
} else if (interpolation == NODE_MAP_RANGE_INTERP_LINEAR) {
result = (value - fromMin) / (fromMax - fromMin) * (toMax - toMin) + toMin;
} else if (interpolation == NODE_MAP_RANGE_INTERP_STEPPED) {
float fac = (value - fromMin) / (fromMax - fromMin);
fac = (steps > 0.0) ? floor(fac * (steps + 1.0)) / steps : 0.0;
result = fac * (toMax - toMin) + toMin;
} else if (interpolation == NODE_MAP_RANGE_INTERP_SMOOTHSTEP) {
float fac = (fromMin > fromMax) ?
1.0 - smoothstep(fromMax, fromMin, value) :
smoothstep(fromMin, fromMax, value);
result = fac * (toMax - toMin) + toMin;
} else {
float fac = (fromMin > fromMax) ?
1.0 - smootherstep(fromMax, fromMin, value) :
smootherstep(fromMin, fromMax, value);
result = fac * (toMax - toMin) + toMin;
}
if (inClamp && interpolation <= NODE_MAP_RANGE_INTERP_STEPPED) {
result = clamp(result, toMin, toMax);
}
} else if (dataType == NODE_MAP_RANGE_TYPE_FLOAT_VECTOR) {
vec3 deltaVec = fromMaxVec - fromMinVec;
vec3 fac = vec3(
deltaVec.x == 0.0 ? 0.0 : (valueVec.x - fromMinVec.x) / deltaVec.x,
deltaVec.y == 0.0 ? 0.0 : (valueVec.y - fromMinVec.y) / deltaVec.y,
deltaVec.z == 0.0 ? 0.0 : (valueVec.z - fromMinVec.z) / deltaVec.z
);
if (interpolation == NODE_MAP_RANGE_INTERP_LINEAR) {
resultVec = fac * (toMaxVec - toMinVec) + toMinVec;
} else if (interpolation == NODE_MAP_RANGE_INTERP_STEPPED) {
fac.x = stepsVec.x == 0.0 ? 0.0 : floor(fac.x * (stepsVec.x + 1.0)) / stepsVec.x;
fac.y = stepsVec.y == 0.0 ? 0.0 : floor(fac.y * (stepsVec.y + 1.0)) / stepsVec.y;
fac.z = stepsVec.z == 0.0 ? 0.0 : floor(fac.z * (stepsVec.z + 1.0)) / stepsVec.z;
resultVec = fac * (toMaxVec - toMinVec) + toMinVec;
} else if (interpolation == NODE_MAP_RANGE_INTERP_SMOOTHSTEP) {
fac = clamp(fac, 0.0, 1.0);
fac = fac * fac * (3.0 - 2.0 * fac);
resultVec = fac * (toMaxVec - toMinVec) + toMinVec;
} else {
resultVec = smootherstep(fac) * (toMaxVec - toMinVec) + toMinVec;
}
if (inClamp && interpolation <= NODE_MAP_RANGE_INTERP_STEPPED) {
vec3 sumVec = toMinVec + toMaxVec;
toMaxVec = max(toMaxVec, toMinVec);
toMinVec = sumVec - toMaxVec;
resultVec = clamp(resultVec, toMinVec, toMaxVec);
}
}
}`,wb=`void node_math_add(float val1, float val2, float val3, out float outVal)
{
outVal = val1 + val2;
}
void node_math_subtract(float val1, float val2, float val3, out float outVal)
{
outVal = val1 - val2;
}
void node_math_multiply(float val1, float val2, float val3, out float outVal)
{
outVal = val1 * val2;
}
void node_math_divide(float val1, float val2, float val3, out float outVal)
{
if (val2 == 0.0)
outVal = 0.0;
else
outVal = val1 / val2;
}
void node_math_sine(float val, float val2, float val3, out float outVal)
{
outVal = sin(val);
}
void node_math_cosine(float val, float val2, float val3, out float outVal)
{
outVal = cos(val);
}
void node_math_tangent(float val, float val2, float val3, out float outVal)
{
outVal = tan(val);
}
void node_math_arcsine(float val, float val2, float val3, out float outVal)
{
if (val <= 1.0 && val >= -1.0)
outVal = asin(val);
else
outVal = 0.0;
}
void node_math_arccosine(float val, float val2, float val3, out float outVal)
{
if (val <= 1.0 && val >= -1.0)
outVal = acos(val);
else
outVal = 0.0;
}
void node_math_arctangent(float val, float val2, float val3, out float outVal)
{
outVal = atan(val);
}
void node_math_arctan2(float val, float val2, float val3, out float outVal)
{
outVal = atan(val, val2);
}
void node_math_power(float val1, float val2, float val3, out float outVal)
{
if (val1 >= 0.0)
outVal = powCompat(val1, val2);
else {
float val2_mod_1 = mod(abs(val2), 1.0);
if (val2_mod_1 > 0.999 || val2_mod_1 < 0.001)
outVal = powCompat(val1, floor(val2 + 0.5));
else
outVal = 0.0;
}
}
void node_math_logarithm(float val1, float val2, float val3, out float outVal)
{
if (val1 > 0.0 && val2 > 0.0)
outVal = log2(val1) / log2(val2);
else
outVal = 0.0;
}
void node_math_sqrt(float val1, float val2, float val3, out float outVal)
{
outVal = sqrt(val1);
}
void node_math_maximum(float val1, float val2, float val3, out float outVal)
{
outVal = max(val1, val2);
}
void node_math_minimum(float val1, float val2, float val3, out float outVal)
{
outVal = min(val1, val2);
}
void node_math_round(float val1, float val2, float val3, out float outVal)
{
outVal = floor(val1 + 0.5);
}
void node_math_floor(float val1, float val2, float val3, out float outVal)
{
outVal = floor(val1);
}
void node_math_ceil(float val1, float val2, float val3, out float outVal)
{
outVal = ceil(val1);
}
void node_math_fract(float val1, float val2, float val3, out float outVal)
{
outVal = fract(val1);
}
void node_math_less_than(float val1, float val2, float val3, out float outVal)
{
if (val1 < val2)
outVal = 1.0;
else
outVal = 0.0;
}
void node_math_greater_than(float val1, float val2, float val3, out float outVal)
{
if (val1 > val2)
outVal = 1.0;
else
outVal = 0.0;
}
void node_math_modulo(float val1, float val2, float val3, out float outVal)
{
if (val2 == 0.0)
outVal = 0.0;
else
outVal = mod(val1, val2);
outVal = (val1 > 0.0) ? outVal : outVal - val2;
}
void node_math_absolute(float val1, float val2, float val3, out float outVal)
{
outVal = abs(val1);
}
void node_math_compare(float val1, float val2, float val3, out float outVal) {
outVal = step(abs(val1 - val2), val3);
}
void node_math_cosh(float val1, float val2, float val3, out float outVal) {
outVal = cosh(val1);
}
void node_math_degrees(float val1, float val2, float val3, out float outVal) {
outVal = val1 / PI * 180.0;
}
void node_math_exponent(float val1, float val2, float val3, out float outVal) {
outVal = exp(val1);
}
void node_math_inverse_sqrt(float val1, float val2, float val3, out float outVal) {
if (val1 >= 0.0) {
outVal = 1.0 / sqrt(val1);
} else {
outVal = 0.0;
}
}
void node_math_multiply_add(float val1, float val2, float val3, out float outVal) {
outVal = val1 * val2 + val3;
}
void node_math_pingpong(float val1, float val2, float val3, out float outVal) {
if (val2 == 0.0) {
outVal = 0.0;
} else {
float absVal2 = abs(val2);
float rem = mod(val1, absVal2);
outVal = mix(rem, absVal2 - rem, mod(floor(val1 / absVal2), 2.0));
}
}
void node_math_radians(float val1, float val2, float val3, out float outVal) {
outVal = val1 / 180.0 * PI;
}
void node_math_sign(float val1, float val2, float val3, out float outVal) {
outVal = sign(val1);
}
void node_math_sinh(float val1, float val2, float val3, out float outVal) {
outVal = sinh(val1);
}
void node_math_smooth_max(float val1, float val2, float val3, out float outVal) {
outVal = smoothMax(val1, val2, val3);
}
void node_math_smooth_min(float val1, float val2, float val3, out float outVal) {
outVal = smoothMin(val1, val2, val3);
}
void node_math_snap(float val1, float val2, float val3, out float outVal) {
val1 += 1e-5 * sign(val2);
float quot = val1 / val2;
outVal = floor(quot) * val2;
}
void node_math_tanh(float val1, float val2, float val3, out float outVal) {
outVal = tanh(val1);
}
void node_math_trunc(float val1, float val2, float val3, out float outVal) {
val1 += 1e-5;
outVal = trunc(val1);
}
void node_math_wrap(float val1, float val2, float val3, out float outVal) {
val1 += 1e-5;
outVal = mod(val1 - val3, val2 - val3) + val3;
}`,Tb=`void node_mix_rgba_mix(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = mix(col1, col2, fac);
outCol.a = col1.a;
}
void node_mix_rgba_add(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = mix(col1, col1 + col2, fac);
outCol.a = col1.a;
}
void node_mix_rgba_multiply(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = mix(col1, col1 * col2, fac);
outCol.a = col1.a;
}
void node_mix_rgba_screen(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = vec4(1.0) - (vec4(facm) + fac * (vec4(1.0) - col2)) * (vec4(1.0) - col1);
outCol.a = col1.a;
}
void node_mix_rgba_overlay(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = col1;
if (outCol.r < 0.5)
outCol.r *= facm + 2.0 * fac * col2.r;
else
outCol.r = 1.0 - (facm + 2.0 * fac * (1.0 - col2.r)) * (1.0 - outCol.r);
if (outCol.g < 0.5)
outCol.g *= facm + 2.0 * fac * col2.g;
else
outCol.g = 1.0 - (facm + 2.0 * fac * (1.0 - col2.g)) * (1.0 - outCol.g);
if (outCol.b < 0.5)
outCol.b *= facm + 2.0 * fac * col2.b;
else
outCol.b = 1.0 - (facm + 2.0 * fac * (1.0 - col2.b)) * (1.0 - outCol.b);
}
void node_mix_rgba_subtract(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = mix(col1, col1 - col2, fac);
outCol.a = col1.a;
}
void node_mix_rgba_divide(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = col1;
if (col2.r != 0.0) outCol.r = facm * outCol.r + fac * outCol.r / col2.r;
if (col2.g != 0.0) outCol.g = facm * outCol.g + fac * outCol.g / col2.g;
if (col2.b != 0.0) outCol.b = facm * outCol.b + fac * outCol.b / col2.b;
}
void node_mix_rgba_difference(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = mix(col1, abs(col1 - col2), fac);
outCol.a = col1.a;
}
void node_mix_rgba_darken(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol.rgb = min(col1.rgb, col2.rgb * fac);
outCol.a = col1.a;
}
void node_mix_rgba_lighten(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol.rgb = max(col1.rgb, col2.rgb * fac);
outCol.a = col1.a;
}
void node_mix_rgba_dodge(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = col1;
if (outCol.r != 0.0) {
float tmp = 1.0 - fac * col2.r;
if (tmp <= 0.0)
outCol.r = 1.0;
else if ((tmp = outCol.r / tmp) > 1.0)
outCol.r = 1.0;
else
outCol.r = tmp;
}
if (outCol.g != 0.0) {
float tmp = 1.0 - fac * col2.g;
if (tmp <= 0.0)
outCol.g = 1.0;
else if ((tmp = outCol.g / tmp) > 1.0)
outCol.g = 1.0;
else
outCol.g = tmp;
}
if (outCol.b != 0.0) {
float tmp = 1.0 - fac * col2.b;
if (tmp <= 0.0)
outCol.b = 1.0;
else if ((tmp = outCol.b / tmp) > 1.0)
outCol.b = 1.0;
else
outCol.b = tmp;
}
}
void node_mix_rgba_burn(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float tmp, facm = 1.0 - fac;
outCol = col1;
tmp = facm + fac * col2.r;
if (tmp <= 0.0)
outCol.r = 0.0;
else if ((tmp = (1.0 - (1.0 - outCol.r) / tmp)) < 0.0)
outCol.r = 0.0;
else if (tmp > 1.0)
outCol.r = 1.0;
else
outCol.r = tmp;
tmp = facm + fac * col2.g;
if (tmp <= 0.0)
outCol.g = 0.0;
else if ((tmp = (1.0 - (1.0 - outCol.g) / tmp)) < 0.0)
outCol.g = 0.0;
else if (tmp > 1.0)
outCol.g = 1.0;
else
outCol.g = tmp;
tmp = facm + fac * col2.b;
if (tmp <= 0.0)
outCol.b = 0.0;
else if ((tmp = (1.0 - (1.0 - outCol.b) / tmp)) < 0.0)
outCol.b = 0.0;
else if (tmp > 1.0)
outCol.b = 1.0;
else
outCol.b = tmp;
}
#ifdef HSV_NODES
void node_mix_rgba_hue(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = col1;
vec4 hsv, hsv2, tmp;
rgbToHSV(col2, hsv2);
if (hsv2.y != 0.0) {
rgbToHSV(outCol, hsv);
hsv.x = hsv2.x;
hsvToRGB(hsv, tmp);
outCol = mix(outCol, tmp, fac);
outCol.a = col1.a;
}
}
void node_mix_rgba_saturation(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = col1;
vec4 hsv, hsv2;
rgbToHSV(outCol, hsv);
if (hsv.y != 0.0) {
rgbToHSV(col2, hsv2);
hsv.y = facm * hsv.y + fac * hsv2.y;
hsvToRGB(hsv, outCol);
}
}
void node_mix_rgba_value(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
vec4 hsv, hsv2;
rgbToHSV(col1, hsv);
rgbToHSV(col2, hsv2);
hsv.z = facm * hsv.z + fac * hsv2.z;
hsvToRGB(hsv, outCol);
}
void node_mix_rgba_color(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = col1;
vec4 hsv, hsv2, tmp;
rgbToHSV(col2, hsv2);
if (hsv2.y != 0.0) {
rgbToHSV(outCol, hsv);
hsv.x = hsv2.x;
hsv.y = hsv2.y;
hsvToRGB(hsv, tmp);
outCol = mix(outCol, tmp, fac);
outCol.a = col1.a;
}
}
#endif
void node_mix_rgba_soft_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
vec4 one = vec4(1.0);
vec4 scr = one - (one - col2) * (one - col1);
outCol = facm * col1 + fac * ((one - col1) * col2 * col1 + col1 * scr);
}
void node_mix_rgba_linear_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = col1 + fac * (2.0 * (col2 - vec4(0.5)));
}
void node_mix_vector_uniform(float fac, vec3 facVec, vec3 v1, vec3 v2, out vec3 outVec)
{
fac = clamp(fac, 0.0, 1.0);
outVec = mix(v1, v2, fac);
}
void node_mix_vector_non_uniform(float fac, vec3 facVec, vec3 v1, vec3 v2, out vec3 outVec)
{
facVec = clamp(facVec, 0.0, 1.0);
outVec = mix(v1, v2, facVec);
}
void node_mix_float(float fac, float val1, float val2, out float outVal)
{
fac = clamp(fac, 0.0, 1.0);
outVal = mix(val1, val2, fac);
}`,Ib=`void node_mix_rgb_mix(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = mix(col1, col2, fac);
outCol.a = col1.a;
}
void node_mix_rgb_add(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = mix(col1, col1 + col2, fac);
outCol.a = col1.a;
}
void node_mix_rgb_multiply(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = mix(col1, col1 * col2, fac);
outCol.a = col1.a;
}
void node_mix_rgb_screen(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = vec4(1.0) - (vec4(facm) + fac * (vec4(1.0) - col2)) * (vec4(1.0) - col1);
outCol.a = col1.a;
}
void node_mix_rgb_overlay(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = col1;
if (outCol.r < 0.5)
outCol.r *= facm + 2.0 * fac * col2.r;
else
outCol.r = 1.0 - (facm + 2.0 * fac * (1.0 - col2.r)) * (1.0 - outCol.r);
if (outCol.g < 0.5)
outCol.g *= facm + 2.0 * fac * col2.g;
else
outCol.g = 1.0 - (facm + 2.0 * fac * (1.0 - col2.g)) * (1.0 - outCol.g);
if (outCol.b < 0.5)
outCol.b *= facm + 2.0 * fac * col2.b;
else
outCol.b = 1.0 - (facm + 2.0 * fac * (1.0 - col2.b)) * (1.0 - outCol.b);
}
void node_mix_rgb_subtract(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = mix(col1, col1 - col2, fac);
outCol.a = col1.a;
}
void node_mix_rgb_divide(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = col1;
if (col2.r != 0.0) outCol.r = facm * outCol.r + fac * outCol.r / col2.r;
if (col2.g != 0.0) outCol.g = facm * outCol.g + fac * outCol.g / col2.g;
if (col2.b != 0.0) outCol.b = facm * outCol.b + fac * outCol.b / col2.b;
}
void node_mix_rgb_difference(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = mix(col1, abs(col1 - col2), fac);
outCol.a = col1.a;
}
void node_mix_rgb_darken(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol.rgb = min(col1.rgb, col2.rgb * fac);
outCol.a = col1.a;
}
void node_mix_rgb_lighten(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol.rgb = max(col1.rgb, col2.rgb * fac);
outCol.a = col1.a;
}
void node_mix_rgb_dodge(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = col1;
if (outCol.r != 0.0) {
float tmp = 1.0 - fac * col2.r;
if (tmp <= 0.0)
outCol.r = 1.0;
else if ((tmp = outCol.r / tmp) > 1.0)
outCol.r = 1.0;
else
outCol.r = tmp;
}
if (outCol.g != 0.0) {
float tmp = 1.0 - fac * col2.g;
if (tmp <= 0.0)
outCol.g = 1.0;
else if ((tmp = outCol.g / tmp) > 1.0)
outCol.g = 1.0;
else
outCol.g = tmp;
}
if (outCol.b != 0.0) {
float tmp = 1.0 - fac * col2.b;
if (tmp <= 0.0)
outCol.b = 1.0;
else if ((tmp = outCol.b / tmp) > 1.0)
outCol.b = 1.0;
else
outCol.b = tmp;
}
}
void node_mix_rgb_burn(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float tmp, facm = 1.0 - fac;
outCol = col1;
tmp = facm + fac * col2.r;
if (tmp <= 0.0)
outCol.r = 0.0;
else if ((tmp = (1.0 - (1.0 - outCol.r) / tmp)) < 0.0)
outCol.r = 0.0;
else if (tmp > 1.0)
outCol.r = 1.0;
else
outCol.r = tmp;
tmp = facm + fac * col2.g;
if (tmp <= 0.0)
outCol.g = 0.0;
else if ((tmp = (1.0 - (1.0 - outCol.g) / tmp)) < 0.0)
outCol.g = 0.0;
else if (tmp > 1.0)
outCol.g = 1.0;
else
outCol.g = tmp;
tmp = facm + fac * col2.b;
if (tmp <= 0.0)
outCol.b = 0.0;
else if ((tmp = (1.0 - (1.0 - outCol.b) / tmp)) < 0.0)
outCol.b = 0.0;
else if (tmp > 1.0)
outCol.b = 1.0;
else
outCol.b = tmp;
}
#ifdef HSV_NODES
void node_mix_rgb_hue(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = col1;
vec4 hsv, hsv2, tmp;
rgbToHSV(col2, hsv2);
if (hsv2.y != 0.0) {
rgbToHSV(outCol, hsv);
hsv.x = hsv2.x;
hsvToRGB(hsv, tmp);
outCol = mix(outCol, tmp, fac);
outCol.a = col1.a;
}
}
void node_mix_rgb_saturation(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = col1;
vec4 hsv, hsv2;
rgbToHSV(outCol, hsv);
if (hsv.y != 0.0) {
rgbToHSV(col2, hsv2);
hsv.y = facm * hsv.y + fac * hsv2.y;
hsvToRGB(hsv, outCol);
}
}
void node_mix_rgb_value(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
vec4 hsv, hsv2;
rgbToHSV(col1, hsv);
rgbToHSV(col2, hsv2);
hsv.z = facm * hsv.z + fac * hsv2.z;
hsvToRGB(hsv, outCol);
}
void node_mix_rgb_color(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
outCol = col1;
vec4 hsv, hsv2, tmp;
rgbToHSV(col2, hsv2);
if (hsv2.y != 0.0) {
rgbToHSV(outCol, hsv);
hsv.x = hsv2.x;
hsv.y = hsv2.y;
hsvToRGB(hsv, tmp);
outCol = mix(outCol, tmp, fac);
outCol.a = col1.a;
}
}
#endif
void node_mix_rgb_soft_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
float facm = 1.0 - fac;
vec4 one = vec4(1.0);
vec4 scr = one - (one - col2) * (one - col1);
outCol = facm * col1 + fac * ((one - col1) * col2 * col1 + col1 * scr);
}
void node_mix_rgb_linear_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)
{
fac = clamp(fac, 0.0, 1.0);
outCol = col1 + fac * (2.0 * (col2 - vec4(0.5)));
}`,Rb=`void node_mix_shader(int transpShaderNum,
float fac, vec4 color1, vec4 color2, out vec4 outColor)
{
if (transpShaderNum == 0)
color1.rgb = color2.rgb;
else if (transpShaderNum == 1)
color2.rgb = color1.rgb;
outColor = mix(color1, color2, clamp(fac, 0.0, 1.0));
}`,Lb=`void node_new_geometry(
float frontFacing, vec3 viewPos, vec3 viewNorm,
out vec3 position, out vec3 normal, out vec3 tangent,
out vec3 trueNormal, out vec3 incoming, out vec3 parametric,
out float backfacing, out float pointiness, out float randomPerIsland)
{
vec4 posWorld = invViewMatrix * vec4(-viewPos, 1.0);
position = swizzleUpZ(posWorld.xyz);
vec4 viewDir = isOrthographic ? vec4(0.0, 0.0, -1.0, 0.0) : vec4(normalize(-viewPos), 0.0);
viewDir = invViewMatrix * viewDir;
vec3 incomingVec = -swizzleUpZ(viewDir.xyz);
#if WORLD_NODES == 1
normal = incomingVec;
tangent = vec3(0.0);
#else
vec3 norWorld = normalize(invViewMatrix * vec4(viewNorm, 0.0)).xyz;
normal = swizzleUpZ(norWorld);
vec4 posLocal = invModelMatrix * posWorld;
vec3 posLocalDelta = posLocal.xyz - boundingBoxMin;
vec3 bbDelta = boundingBoxMax - boundingBoxMin;
vec3 posOrco = vec3(
bbDelta.x < 1e-5 ? -sign(posLocal.y) : posLocalDelta.x / bbDelta.x,
0.0,
bbDelta.z < 1e-5 ? sign(posLocal.y) : posLocalDelta.z / bbDelta.z
);
posOrco -= 0.5;
vec3 tangWorld = (modelMatrix * vec4(posOrco.z, 0.0, -posOrco.x, 0.0)).xyz;
tangWorld = cross(norWorld, normalize(cross(tangWorld, norWorld)));
tangent = swizzleUpZ(tangWorld);
#endif
trueNormal = normal;
incoming = incomingVec;
parametric = vec3(0.0);
backfacing = (frontFacing > 0.0) ? 0.0 : 1.0;
#if WORLD_NODES == 1
pointiness = 0.0;
#else
pointiness = 0.5;
#endif
randomPerIsland = 0.0;
}`,Pb=`void node_normal(vec3 norParam, vec3 norIn, out vec3 norOut, out float dotOut)
{
norOut = norParam;
dotOut = dot(normalize(norIn), norParam);
}`,Bb=`void node_normal_map(vec4 tangent, vec3 normal, float strength, vec4 normalColor, out vec3 normalOut)
{
#ifdef DOUBLE_SIDED
normal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);
#endif
vec3 normalTex = (normalColor.xyz * 2.0 - 1.0);
vec4 viewTangent = vec4(normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz), tangent.w);
vec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);
normalOut = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent 
+ normalTex.z * normal);
normalOut = mix(normal, normalOut, strength);
normalOut = normalize((invViewMatrix * vec4(normalOut, 0.0)).xyz);
normalOut = swizzleUpZ(normalOut);
}`,Db=`uniform int objectIndex;
uniform vec4 objectColor;
uniform int materialIndex;
uniform float objectRandom;
void node_object_info(out vec3 location, out vec4 color, out float alpha, out float objIndex,
out float matIndex, out float random) {
#if WORLD_NODES == 1
location = vec3(0.0);
color = vec4(1.0);
alpha = 1.0;
objIndex = 0.0;
matIndex = 0.0;
random = 0.0;
#else
location = swizzleUpZ(modelMatrix[3].xyz);
color = vec4(objectColor.rgb, 1.0);
alpha = objectColor.a;
objIndex = float(objectIndex);
matIndex = float(materialIndex);
random = float(objectRandom);
#endif
}
void node_object_info(out vec3 location, out vec4 color, out float objIndex,
out float matIndex, out float random) {
float alpha;
node_object_info(location, color, alpha, objIndex, matIndex, random);
}`,Nb=`void node_output_lamp(out vec4 outColor)
{
outColor = vec4(0.0);
}`,Ob=`void node_output_material(vec4 surface, vec4 volume, vec3 displacement, float thickness, out vec4 outgoingLight) {
outgoingLight = surface + volume;
}
void node_output_material(vec4 surface, vec4 volume, vec3 displacement, out vec4 outgoingLight) {
node_output_material(surface, volume, displacement, 0.0, outgoingLight);
}`,Fb=`void node_output_world(vec4 surface, vec4 volume, out vec4 outgoingLight)
{
outgoingLight = surface;
}`,Ub=`void node_particle_info(out float index, out float random, out float age,
out float lifeTime, out vec3 location, out float size, out vec3 velocity,
out vec3 angularVelocity) {
#if WORLD_NODES == 1
index = 0.0;
random = 0.0;
age = 0.0;
lifeTime = 0.0;
location = vec3(0.0);
size = 0.0;
velocity = vec3(0.0);
angularVelocity = vec3(0.0);
#else
index = 0.0;
random = 0.0;
age = 0.0;
lifeTime = 0.0;
location = vec3(0.0);
size = 0.0;
velocity = vec3(0.0);
angularVelocity = vec3(0.0);
#endif
}`,zb=`void node_point_info(out vec3 position, out float radius, out float random) {
position = vec3(0.0);
radius = 0.0;
random = 0.0;
}`,Vb=`void node_principled_volume(vec4 color, float colorAttribute, float density,
float densityAttribute, float anisotropy, vec4 absorptionColor,
float emissionStrength, vec4 emissionColor, float blackbodyIntensity,
vec4 blackbodyTint, float temperature, float temperatureAttribute,
out vec4 volume) {
volume = vec4(0.0);
}`,Gb=`uniform vec4 nodeRGB[NODE_RGB_NUM];
void node_rgb(vec4 color, out vec4 outColor)
{
outColor = color;
}`,kb=`void node_rgbtobw(vec4 color, out float outVal) {
outVal = linearToRelativeLuminance(color.rgb);
}`,Qb=`void node_script(out vec4 outColor)
{
outColor = vec4(0.0);
}`,Wb=`
void node_sephsv(vec4 col, out float h, out float s, out float v)
{
vec4 hsv;
rgbToHSV(col, hsv);
h = hsv[0];
s = hsv[1];
v = hsv[2];
}`,Hb=`#define NODE_SEP_COL_RGB 0
#define NODE_SEP_COL_HSV 1
#define NODE_SEP_COL_HSL 2
void rgbToHSL(vec3 rgb, out vec3 outCol)
{
float cMax, cMin;
float h, s, l;
cMax = max(rgb[0], max(rgb[1], rgb[2]));
cMin = min(rgb[0], min(rgb[1], rgb[2]));
l = min(1.0, (cMax + cMin) / 2.0);
if (cMax == cMin) {
h = s = 0.0;
} else {
float cdelta = cMax - cMin;
s = l > 0.5 ? cdelta / (2.0 - cMax - cMin) : cdelta / (cMax + cMin);
if (cMax == rgb[0]) {
h = (rgb[1] - rgb[2]) / cdelta + (rgb[1] < rgb[2] ? 6.0 : 0.0);
} else if (cMax == rgb[1]) {
h = (rgb[2] - rgb[0]) / cdelta + 2.0;
} else {
h = (rgb[0] - rgb[1]) / cdelta + 4.0;
}
}
h /= 6.0;
outCol = vec3(h, s, l);
}
void node_separate_color(int mode, vec4 col, out float r, out float g, out float b)
{
if (mode == NODE_SEP_COL_RGB) {
r = col.r;
g = col.g;
b = col.b;
} else if (mode == NODE_SEP_COL_HSV) {
vec4 hsv;
rgbToHSV(col, hsv);
r = hsv[0];
g = hsv[1];
b = hsv[2];
} else {
vec3 hsl;
rgbToHSL(col.rgb, hsl);
r = hsl[0];
g = hsl[1];
b = hsl[2];
}
}`,Xb=`
void node_seprgb(vec4 col, out float r, out float g, out float b)
{
r = col.r;
g = col.g;
b = col.b;
}`,Yb=`void node_sepxyz(vec3 vector, out float x, out float y, out float z)
{
x = vector.x;
y = vector.y;
z = vector.z;
}`,jb=`void node_shadertorgb(vec4 shader, out vec4 color, out float alpha) {
color = vec4(shader.rgb, 1.0);
alpha = shader.a;
}`,Kb=`void node_squeeze(float val, float width, float center, out float outVal)
{
outVal = 1.0 / (1.0 + pow(2.71828183, -((val - center) * width)));
}`,qb=`void node_subsurface_scattering(
vec4 color, float scale, vec3 radius, float sharpen, float textureBlur, vec3 normal,
out vec4 outColor)
{
outColor = color;
}`,Zb=`#define TANGENT_AXIS_X 0
#define TANGENT_AXIS_Y 1
#define TANGENT_AXIS_Z 2
void node_tangent(int axis, vec3 viewPos, vec3 viewNorm, out vec3 outTangent) {
outTangent = vec3(0.0);
#if WORLD_NODES == 0
vec4 posWorld = invViewMatrix * vec4(-viewPos, 1.0);
vec3 norWorld = normalize(invViewMatrix * vec4(viewNorm, 0.0)).xyz;
vec3 posLocal = (invModelMatrix * posWorld).xyz;
vec3 posOrco = (posLocal - boundingBoxMin)
/ (boundingBoxMax - boundingBoxMin) - 0.5;
vec4 posOrcoPermuted;
if (axis == TANGENT_AXIS_X) {
posOrcoPermuted = vec4(0.0, -posOrco.z, posOrco.y, 0.0);
} else if (axis == TANGENT_AXIS_Y) {
posOrcoPermuted = vec4(-posOrco.y, posOrco.x, 0.0, 0.0);
} else if (axis == TANGENT_AXIS_Z) {
posOrcoPermuted = vec4(posOrco.z, 0.0, -posOrco.x, 0.0);
}
vec3 tangWorld = (modelMatrix * posOrcoPermuted).xyz;
tangWorld = cross(norWorld, normalize(cross(tangWorld, norWorld)));
outTangent = swizzleUpZ(tangWorld);
#endif
}
void node_tangent(vec4 tangent, out vec3 outTangent) {
#if WORLD_NODES == 0
outTangent = normalize((modelMatrix * vec4(tangent.xyz, 0.0)).xyz);
outTangent = swizzleUpZ(outTangent);
#endif
}`,Jb=`float integer_noise(int rowCount, int brickCount)
{
#if __VERSION__ == 300
int n = (rowCount << 16) + (brickCount & 0xFFFF);
n = (n + 1013) & 0x7fffffff;
n = (n >> 13) ^ n;
int nn = (n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;
return 0.5 * (float(nn) / 1073741824.0);
#else
const int RAND_MAX = 32767;
int next = ((123456 * rowCount) + brickCount) * 1103515245 + 12345;
return (mod(float(next/65536), float(RAND_MAX + 1))) / float(RAND_MAX);
#endif
}
void node_tex_brick(
float offset, int offsetFrequency, float squash, int squashFrequency, 
vec3 vector, vec4 color1, vec4 color2, vec4 mortar, float scale,
float mortarSize, float mortarSmooth, float bias, float brickWidth,
float rowHeight,
out vec4 outColor, out float outFac)
{
float x, y;
vec3 p = vector * scale;
float rowCount = floor(p.y / rowHeight);
if (offsetFrequency != 0 && squashFrequency != 0) {
brickWidth *= mod(rowCount, float(squashFrequency)) > 0.5 ? 1.0 : squash;
offset = mod(rowCount, float(offsetFrequency)) > 0.5 ? 0.0 : (brickWidth * offset);
} 
int brickCount = int((p.x + offset) / brickWidth); 
float tint = clamp((integer_noise(int(rowCount), brickCount) + bias), 0.0, 1.0);

x = abs((p.x + offset) - brickWidth * float(brickCount));
y = abs(p.y - rowHeight * rowCount);
float min_dist = min(min(x, y), min(brickWidth - x, rowHeight - y));

float f = step(min_dist, mortarSize);
if (mortarSmooth > 0.0) {
min_dist = 1.0 - min_dist / mortarSize;
f *= smoothstep(0.0, mortarSmooth, min_dist);
}
outColor = mix(mix(color1, color2, tint), mortar, f);
outFac = f;
}`,$b=`void node_tex_checker(vec3 vector, vec4 color1, vec4 color2, float scale, 
out vec4 outColor, out float outFac)
{
vec3 p = vector * scale;
p = (p + 0.00001) * 0.99999;
float cx = floor(p.x);
float cy = floor(p.y);
float cz = floor(p.z);
float result = sign(mod(cx + cy + cz, 2.0));
outFac = max(result, 0.0);
outColor = mix(color2, color1, outFac);
}`,eC=`uniform mat4 nodeTexCoordObjectMatrices[NODE_TEX_COORD_NUM];
void node_tex_coord(
mat4 objectMat, vec3 viewPos, vec3 viewNorm, vec2 uv,
out vec3 outGenerated, out vec3 outNormal, out vec3 outUV, out vec3 outObject,
out vec3 outCamera, out vec3 outWindow, out vec3 outReflection)
{
vec4 view = vec4(-viewPos, 1.0);
vec4 posWorld = invViewMatrix * view;
vec3 loc = swizzleUpZ((invModelMatrix * posWorld).xyz);
#if WORLD_NODES == 1
loc = normalize(loc);
#endif
#if WORLD_NODES == 1
outGenerated = loc;
#else
vec3 boxMin = vec3(boundingBoxMin.x, -boundingBoxMax.z, boundingBoxMin.y);
vec3 boxMax = vec3(boundingBoxMax.x, -boundingBoxMin.z, boundingBoxMax.y);
vec3 boxSize = boxMax - boxMin;
if (abs(boxSize.x) < 0.001) {
outGenerated.x = 0.5;
} else {
outGenerated.x = (loc.x - boxMin.x) / boxSize.x;
}
if (abs(boxSize.y) < 0.001) {
outGenerated.y = 0.5;
} else {
outGenerated.y = (loc.y - boxMin.y) / boxSize.y;
}
if (abs(boxSize.z) < 0.001) {
outGenerated.z = 0.5;
} else {
outGenerated.z = (loc.z - boxMin.z) / boxSize.z;
}
#endif
#if WORLD_NODES == 1
outNormal = -loc;
#else
outNormal = normalize(invModelMatrix * invViewMatrix * vec4(viewNorm, 0.0)).rgb;
outNormal = swizzleUpZ(outNormal);
#endif
#if WORLD_NODES == 1
outUV = vec3(0.0);
#else
uv.y = 1.0 - uv.y;
outUV = vec3(uv, 0.0);
#endif
#if WORLD_NODES == 1
outObject = loc;
#else
outObject = swizzleUpZ((objectMat * posWorld).xyz);
#endif
outCamera = vec3(view.xy, -view.z);
#if WORLD_NODES == 1
outWindow = vec3(0.0);
#else
outWindow = vec3(gl_FragCoord.xy / viewWidthHeight, 0.0);
#endif
#if WORLD_NODES == 1
outReflection = -loc;
#else
vec4 reflection = (invViewMatrix * vec4(reflect(view.xyz, normalize(viewNorm)), 0.0));
outReflection = normalize(swizzleUpZ(reflection.xyz));
#endif
}`,tC=`#define TEX_PROJ_EQUIRECTANGULAR 0
#define TEX_PROJ_MIRROR_BALL 1
void node_tex_environment(sampler2D tex, const int encoding, const int projection, vec3 vector, out vec4 outColor) {
vec2 uv;
float bias;
if (projection == TEX_PROJ_EQUIRECTANGULAR) {
vec3 direction = swizzleUpY(vector);
if (length(direction) == 0.0) {
direction = vec3(0.0, 1.0, 0.0);
} else {
direction = normalize(direction);
}
uv.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;
uv.x = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;
#if WORLD_NODES == 1
bias = -16.0;
#else
const float seamWidth = 0.15;
const float seamBiasFactor = -10.0;
float seam = max(0.0, 1.0 - abs (direction.z) / seamWidth) *
clamp (1.0 - direction.x / seamWidth, 0.0, 1.0);
bias = seamBiasFactor * seam;
#endif
} else {
vec3 normal = normalize(vector);
normal.y -= 1.0;
normal /= (2.0 * sqrt(max(-0.5 * normal.y, 0.0)));
uv = clamp(0.5 * normal.xz + 0.5, 0.0, 1.0);
bias = 0.0;
}
uv.y = 1.0 - uv.y;
outColor = texture2D(tex, uv, bias);
outColor = nodeTexelToLinear(outColor, encoding);
}`,nC=`void node_tex_environment_none(vec3 vector, out vec4 outColor) {
outColor = vec4(1.0, 0.0, 1.0, 1.0);
}`,iC=`#define TEX_GRAD_LINEAR 0
#define TEX_GRAD_QUADRATIC 1
#define TEX_GRAD_EASING 2
#define TEX_GRAD_DIAGONAL 3
#define TEX_GRAD_SPHERICAL 4
#define TEX_GRAD_QUADRATIC_SPHERE 5
#define TEX_GRAD_RADIAL 6
void node_tex_gradient(const int type, vec3 vector, out vec4 outColor, out float outFac)
{
float x, y, z, r;
x = vector.x;
y = vector.y;
z = vector.z;
if (type == TEX_GRAD_LINEAR) {
outFac = x;
} else if (type == TEX_GRAD_QUADRATIC) {
r = max(x, 0.0);
outFac = pow2(r);
} else if (type == TEX_GRAD_EASING) {
r = min(max(x, 0.0), 1.0);
outFac = (3.0 * pow2(r) - 2.0 * pow3(r));
} else if (type == TEX_GRAD_DIAGONAL) {
outFac = (x + y) * 0.5;
} else if (type == TEX_GRAD_RADIAL) {
outFac = atan(y, x) / PI2 + 0.5;
} else {
r = max(0.99999 - sqrt(x * x + y * y + z * z), 0.0);
if (type == TEX_GRAD_QUADRATIC_SPHERE) {
outFac = pow2(r);
} else if (type == TEX_GRAD_SPHERICAL) {
outFac = r;
}
}
outFac = clamp(outFac, 0.0, 1.0);
outColor = vec4(outFac, outFac, outFac, 1.0);
}`,oC=`void node_tex_ies(vec3 vector, float strength, out float fac) {
fac = 0.0;
}`,rC=`#define TEX_PROJ_FLAT 0
#define TEX_PROJ_BOX 1
#define TEX_PROJ_SPHERE 2
#define TEX_PROJ_TUBE 3
#define TEX_ALPHA_CLEAR 0
#define TEX_ALPHA_PREMUL 1
#define TEX_ALPHA_UNPREMUL 2
#define TEX_ALPHA_ONE 3
vec4 applyAlphaMode(vec4 color, const int alphaMode) {
if (alphaMode == TEX_ALPHA_CLEAR) {
} else if (alphaMode == TEX_ALPHA_PREMUL) {
color.rgb = color.rgb * color.a;
} else if (alphaMode == TEX_ALPHA_UNPREMUL) {
float alpha = color.a;
color.rgb = clamp(color.rgb, 0.0, alpha);
if (alpha == 0.0)
color.rgb = vec3(0.0);
else
color.rgb /= alpha;
}
return color;
}
void node_tex_image(sampler2D ima, const int encoding, const int alphaMode, vec3 viewNorm,
const int projection, const float projectionBlend, const bool clampToEdgeNoExtend,
vec3 vector,
out vec4 outColor, out float outAlpha) {
if (projection == TEX_PROJ_FLAT) {
vec2 uv = vector.xy;
uv.y = 1.0 - uv.y;
if (clampToEdgeNoExtend && (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)) {
outColor = vec4(0.0);
outAlpha = 0.0;
} else {
outColor = texture2D(ima, uv);
outAlpha = outColor.a;
}
outColor = nodeTexelToLinear(outColor, encoding);
} else if (projection == TEX_PROJ_BOX) {
vec3 norm = normalize(viewNorm * normalMatrix);
vector = swizzleUpY(vector);
vec2 uvX = vec2(-sign(norm.x) * vector.z, -vector.y);
vec2 uvY = vec2(sign(norm.y) * vector.z, -vector.x);
vec2 uvZ = vec2(sign(norm.z) * vector.x, -vector.y);
vec4 colX = nodeTexelToLinear(texture2D(ima, uvX), encoding);
vec4 colY = nodeTexelToLinear(texture2D(ima, uvY), encoding);
vec4 colZ = nodeTexelToLinear(texture2D(ima, uvZ), encoding);
vec3 barycentric = abs(norm);
barycentric /= barycentric.x + barycentric.y + barycentric.z;
vec3 edgeShape = min(min(barycentric.yzx, barycentric.zxy),
(projectionBlend - 1.0) / (projectionBlend - 3.0));
vec3 edgeValue = (1.0 - projectionBlend) * (1.0 - edgeShape) / 2.0;
vec3 weight = max((barycentric - edgeValue) / (1.0 - edgeValue), EPSILON);
weight /= (weight.x + weight.y + weight.z);
outColor = weight.x * colX + weight.y * colY + weight.z * colZ;
outAlpha = outColor.a;
} else if (projection == TEX_PROJ_SPHERE) {
vector = normalize(vector * 2.0 - 1.0);
vector = swizzleUpY(vector);
vec2 uv = vec2(atan(vector.x, vector.z) / PI2, acos(vector.y) / PI);
uv.x = mod(uv.x, 1.0);
outColor = texture2D(ima, uv);
outAlpha = outColor.a;
outColor = nodeTexelToLinear(outColor, encoding);
} else if (projection == TEX_PROJ_TUBE) {
vector = vector * 2.0 - 1.0;
vector = swizzleUpY(vector);
vec2 uv = vec2(atan(vector.x, vector.z) / PI2, (1.0 - vector.y) / 2.0);
uv.x = mod(uv.x, 1.0);
outColor = texture2D(ima, uv);
outAlpha = outColor.a;
outColor = nodeTexelToLinear(outColor, encoding);
}
outColor = applyAlphaMode(outColor, alphaMode);
if (alphaMode == TEX_ALPHA_ONE)
outAlpha = 1.0;
}`,aC=`void node_tex_image_none(vec3 vector, out vec4 color, out float alpha)
{
color = vec4(1.0, 0.0, 1.0, 1.0);
alpha = 1.0;
}`,sC=`void node_tex_magic(vec3 vector, float scale, float distortion,
out vec4 outColor, out float outFac)
{
outColor = vec4(0.0);
outFac = 0.0;
}`,lC=`void node_tex_musgrave(vec3 vector, float w, float scale, float detail,
float dimension, float lacunarity, float offset, float gain,
out float outFac) {
outFac = 0.0;
}`,cC=`#define TEX_NOISE_MULTIFRACTAL 0
#define TEX_NOISE_RIDGED_MULTIFRACTAL 1
#define TEX_NOISE_HYBRID_MULTIFRACTAL 2
#define TEX_NOISE_FBM 3
#define TEX_NOISE_HETERO_TERRAIN 4
void node_tex_noise(
int noiseType, float falloffFactor, float dispersionFactor,
vec3 vector, float w, float scale, float detail, float roughness,
float lacunarity, float offset, float gain, float distortion, out float outFac, out vec4 outColor) {
vec3 p = vector * scale;
vec3 dx = dFdx(p);
vec3 dy = dFdy(p);
float octaveLenPerPixel = (length(dx) + length(dy)) / 4.0;
if (distortion != 0.0) {
vec3 r, offset = vec3(13.5, 13.5, 13.5);
r.x = noiseSmooth(p + offset, octaveLenPerPixel, falloffFactor,
dispersionFactor) * distortion;
r.y = noiseSmooth(p, octaveLenPerPixel, falloffFactor,
dispersionFactor) * distortion;
r.z = noiseSmooth(p - offset, octaveLenPerPixel, falloffFactor,
dispersionFactor) * distortion;
p += r;
}
outFac = noiseTurbulence(p, detail, octaveLenPerPixel, falloffFactor,
dispersionFactor);
vec3 color = vec3(outFac,
noiseTurbulence(vec3(p.y, p.x, p.z), detail, octaveLenPerPixel,
falloffFactor, dispersionFactor),
noiseTurbulence(vec3(p.y, p.z, p.x), detail, octaveLenPerPixel,
falloffFactor, dispersionFactor)
);
outColor = vec4(color, 1.0);
}
void node_tex_noise(
float falloffFactor, float dispersionFactor,
vec3 vector, float w, float scale, float detail, float roughness,
float lacunarity, float distortion, out float outFac, out vec4 outColor) {
node_tex_noise(TEX_NOISE_FBM, falloffFactor, dispersionFactor, vector, w, scale, detail, roughness,
lacunarity, 0.0, 1.0, distortion, outFac, outColor);
}
void node_tex_noise(
float falloffFactor, float dispersionFactor,
vec3 vector, float w, float scale, float detail, float roughness,
float distortion, out float outFac, out vec4 outColor) {
node_tex_noise(falloffFactor, dispersionFactor, vector, w, scale, detail, roughness,
2.0, distortion, outFac, outColor);
}`,uC=`void node_tex_pointdensity(
vec3 vector,
out vec4 outColor, out float outDensity)
{
outColor = vec4(0.0);
outDensity = 0.0;
}`,dC=`
#define TEX_SKY_PREETHAM 0
#define TEX_SKY_HOSEK_WILKIE 1
#define TEX_SKY_NISHITA 2
#define Km 683.0
void node_tex_sky(const int skyType, vec3 param0, vec3 param1, vec3 param2,
vec3 param3, vec3 param4, vec3 param5, vec3 param6, vec3 param7,
vec3 param8, vec3 radiance, vec3 sunDirection, vec3 vectorIn,
out vec4 outColor) {
if (length(vectorIn) == 0.0) {
vectorIn = vec3(0.0, 1.0, 0.0);
} else {
vectorIn = normalize(vectorIn);
}
vectorIn = swizzleUpY(vectorIn);
sunDirection = swizzleUpY(sunDirection);
float cosGamma = clamp(dot(vectorIn, sunDirection), -1.0, 1.0);
float cosTheta = clamp(vectorIn.y, 0.0, 1.0);
if (skyType == TEX_SKY_PREETHAM) {
vec3 radInternal = (1.0 + param0 * exp(param1 / cosTheta)) * (
1.0 + param2 * exp(param3 * acos(cosGamma))
+ param4 * pow(cosGamma, 2.0)
);
vec3 XYZ = xyY_to_XYZ(radInternal.y * radiance.y,
radInternal.z * radiance.z, radInternal.x * radiance.x);
outColor = vec4(max(xyz_to_sRGB(XYZ), 0.0), 1.0);
} else if (skyType == TEX_SKY_HOSEK_WILKIE) {
float cosGammaSq = pow(cosGamma, 2.0);
vec3 chi = (1.0 + cosGammaSq) / pow(1.0 + pow(param8, vec3(2.0))
- 2.0 * param8 * cosGamma, vec3(1.5));
vec3 radInternal = (1.0 + param0 * exp(param1 / (cosTheta + 0.01))) * (
param2 + param3 * exp(param4 * acos(cosGamma))
+ param5 * cosGammaSq + param6 * chi + param7 * sqrt(cosTheta)
);
outColor = vec4(max(xyz_to_sRGB(radInternal * radiance), 0.0) * PI2/Km, 1.0);
} else {
outColor = vec4(0.0, 0.0, 0.0, 1.0);
}
}`,hC=`#define DISTANCE_EUCLIDEAN 0
#define DISTANCE_MANHATTAN 1
#define DISTANCE_CHEBYCHEV 2
#define DISTANCE_MINKOWSKI 3
#define FEATURE_F1 0
#define FEATURE_F2 1
#define FEATURE_SMOOTH_F1 2
#define FEATURE_DISTANCE_TO_EDGE 3
#define FEATURE_N_SPHERE_RADIUS 4
struct VoronoiGridData {
vec3 point;
vec3 randVec;
vec3 toClosest;
float dist;
};
highp vec3 rand3(const in vec3 v) {
const highp float c = 43758.5453;
const highp mat3 coeffs = mat3(
165.15, 253.34, 323.22,
241.49, 329.07, 147.79,
376.31, 143.45, 281.63
);
highp vec3 sn = mod(coeffs * v, PI);
return fract(sin(sn) * c);
}
float worleyLength(vec3 vec, int distance, float exponent) {
if (distance == DISTANCE_EUCLIDEAN) {
return length(vec);
} else if (distance == DISTANCE_MANHATTAN) {
return abs(vec.x) + abs(vec.y) + abs(vec.z);
} else if (distance == DISTANCE_CHEBYCHEV) {
return max(max(abs(vec.x), abs(vec.y)), abs(vec.z));
} else if (distance == DISTANCE_MINKOWSKI) {
return pow(pow(abs(vec.x), exponent)
+ pow(abs(vec.y), exponent)
+ pow(abs(vec.z), exponent), 1.0 / exponent);
}
return 0.0;
}
void worleyNoise(vec3 pos, int distance, float exponent, int feature,
float smoothness, float randomness, out float outDist, out vec4 outColor,
out vec3 outPosition, out float outW, out float outRadius) {
const highp float RAND_FIX_ZERO = 0.125;
vec3 posI = floor(pos);
vec3 posF = fract(pos);
VoronoiGridData vgd[27];
#pragma unroll_loop_start
for (int i = 0; i <= 2; i++) {
#pragma unroll_loop_start
for (int j = 0; j <= 2; j++) {
#pragma unroll_loop_start
for (int k = 0; k <= 2; k++) {
vec3 point = vec3((i), (j), (k)) - 1.0;
vec3 randVec = rand3(posI + point + RAND_FIX_ZERO);
vec3 toClosest = point + randomness * randVec - posF;
const int counter = (i) + (j) * 3 + (k) * 9;
vgd[counter].point = point;
vgd[counter].randVec = randVec;
vgd[counter].toClosest = toClosest;
vgd[counter].dist = worleyLength(toClosest, distance, exponent);
}
#pragma unroll_loop_end
}
#pragma unroll_loop_end
}
#pragma unroll_loop_end
float f1 = 1e10;
float f2 = 1e10;
vec3 edgeToClosest = vec3(0.0);
float distToEdge = 1e10;
vec3 randColF1 = vec3(0.0);
vec3 randColF2 = vec3(0.0);
vec3 toClosestF1 = vec3(0.0);
vec3 toClosestF2 = vec3(0.0);
vec3 radPoint = vec3(0.0);
vec3 radToClosest = vec3(0.0);
#pragma unroll_loop_start
for (int i = 0; i < 27; i++) {
if (feature == FEATURE_F1) {
if (vgd[i].dist < f1) {
f1 = vgd[i].dist;
randColF1 = vgd[i].randVec;
toClosestF1 = vgd[i].toClosest;
}
} else if (feature == FEATURE_F2) {
if (vgd[i].dist < f1) {
f2 = f1;
f1 = vgd[i].dist;
randColF2 = randColF1;
randColF1 = vgd[i].randVec;
toClosestF2 = toClosestF1;
toClosestF1 = vgd[i].toClosest;
} else if (vgd[i].dist < f2) {
f2 = vgd[i].dist;
randColF2 = vgd[i].randVec;
toClosestF2 = vgd[i].toClosest;
}
} else if (feature == FEATURE_SMOOTH_F1) {
f1 = smoothMin(f1, vgd[i].dist, smoothness);
} else if (feature == FEATURE_DISTANCE_TO_EDGE) {
float dist = worleyLength(vgd[i].toClosest, DISTANCE_EUCLIDEAN, exponent);
if (dist < f1) {
f1 = dist;
edgeToClosest = vgd[i].toClosest;
}
} else if (feature == FEATURE_N_SPHERE_RADIUS) {
float dist = worleyLength(vgd[i].toClosest, DISTANCE_EUCLIDEAN, exponent);
if (dist < f1) {
f1 = dist;
radPoint = vgd[i].point;
radToClosest = vgd[i].toClosest;
}
}
}
#pragma unroll_loop_end
if (feature == FEATURE_F1) {
outDist = f1;
outColor = vec4(randColF1, 1.0);
outPosition = pos + toClosestF1;
} else if (feature == FEATURE_F2) {
outDist = f2;
outColor = vec4(randColF2, 1.0);
outPosition = pos + toClosestF2;
} else if (feature == FEATURE_SMOOTH_F1) {
outDist = f1;
vec3 avgCol = vec3(0.0);
vec3 avgOff = vec3(0.0);
float sumWeightsCol = 0.0;
float sumWeightsOff = 0.0;
#pragma unroll_loop_start
for (int i = 0; i < 27; i++) {
float smoothFac = getSmoothFactor(f1, vgd[i].dist, smoothness);
float weightOff = smoothFac * smoothFac * smoothFac;
float weightCol = weightOff * smoothFac;
avgCol += vgd[i].randVec * weightCol;
avgOff += vgd[i].toClosest * weightOff;
sumWeightsCol += weightCol;
sumWeightsOff += weightOff;
}
#pragma unroll_loop_end
outColor = vec4(avgCol / sumWeightsCol, 1.0);
outPosition = pos + avgOff / sumWeightsOff;
} else if (feature == FEATURE_DISTANCE_TO_EDGE) {
#pragma unroll_loop_start
for (int i = 0; i < 27; i++) {
if (vgd[i].toClosest != edgeToClosest) {
float dist = dot(0.5 * (edgeToClosest + vgd[i].toClosest),
normalize(vgd[i].toClosest - edgeToClosest));
distToEdge = min(distToEdge, dist);
}
}
#pragma unroll_loop_end
outDist = distToEdge;
} else if (feature == FEATURE_N_SPHERE_RADIUS) {
float diam = 1e10;
#pragma unroll_loop_start
for (int i = 0; i <= 2; i++) {
#pragma unroll_loop_start
for (int j = 0; j <= 2; j++) {
#pragma unroll_loop_start
for (int k = 0; k <= 2; k++) {
vec3 localPoint = vec3((i), (j), (k)) - 1.0;
if (length(localPoint) > 0.0) {
vec3 point = localPoint + radPoint;
vec3 randVec = rand3(posI + point + RAND_FIX_ZERO);
vec3 toClosest = point + randomness * randVec - posF;
diam = min(diam, length(toClosest - radToClosest));
}
}
#pragma unroll_loop_end
}
#pragma unroll_loop_end
}
#pragma unroll_loop_end
outRadius = diam / 2.0;
}
}
#define VORONOI_SMOOTH_COEFF 0.74
void node_tex_voronoi(
int distance, int feature,
vec3 vector, float w, float scale, float detail, float roughness, float lacunarity,
float smoothness, float exponent, float randomness,
out float outDistance, out vec4 outColor, out vec3 outPosition,
out float outW, out float outRadius) {
vector = scale * (vector - 0.0001);
smoothness = clamp(smoothness, 1e-3, 1.0);
smoothness *= VORONOI_SMOOTH_COEFF;
worleyNoise(vector, distance, exponent, feature, smoothness, randomness,
outDistance, outColor, outPosition, outW, outRadius);
outPosition /= scale;
}
void node_tex_voronoi(
int distance, int feature,
vec3 vector, float w, float scale,
float smoothness, float exponent, float randomness,
out float outDistance, out vec4 outColor, out vec3 outPosition,
out float outW, out float outRadius) {
node_tex_voronoi(
distance, feature, vector, w, scale, 0.0, 0.5, 2.0, smoothness, exponent, randomness,
outDistance, outColor, outPosition, outW, outRadius);
}
#define FEATURE_F3 5
#define FEATURE_F4 6
#define FEATURE_F2F1 7
#define COLORING_INTENSITY 0
#define COLORING_CELLS 1
struct VoronoiClosest {
vec4 closestDists;
vec4 closestInds;
};
void updateVoronoiClosest(inout VoronoiClosest vf, vec3 newDistances,
vec3 newIndices) {
#pragma unroll_loop_start
for (int i = 0; i < 3; i++) {
float currDist = newDistances[i];
float currIdx = newIndices[i];
#pragma unroll_loop_start
for (int j = 0; j < 4; j++) {
if (currDist < vf.closestDists[j]) {
float tmp = vf.closestDists[j];
vf.closestDists[j] = currDist;
currDist = tmp;
tmp = vf.closestInds[j];
vf.closestInds[j] = currIdx;
currIdx = tmp;
}
}
#pragma unroll_loop_end
}
#pragma unroll_loop_end
}
vec3 worleyPermute(vec3 x) {
return mod((34.0 * x + 1.0) * x, 289.0);
}
vec3 worleyDist(vec3 x, vec3 y, vec3 z, int distance, float exponent) {
if (distance == DISTANCE_EUCLIDEAN) {
return x * x + y * y + z * z;
} else if (distance == DISTANCE_MANHATTAN) {
return abs(x) + abs(y) + abs(z);
} else if (distance == DISTANCE_CHEBYCHEV) {
return max(max(abs(x), abs(y)), abs(z));
} else if (distance == DISTANCE_MINKOWSKI) {
vec3 expVec = vec3(exponent);
return pow(pow(abs(x), expVec)
+ pow(abs(y), expVec)
+ pow(abs(z), expVec), 1.0 / expVec);
}
return vec3(0.0);
}
VoronoiClosest worleyClosest(vec3 P, float jitter, int distance, float exponent) {
float K = 0.142857142857;
float Ko = 0.428571428571;
float K2 = 0.020408163265306;
float Kz = 0.166666666667;
float Kzo = 0.416666666667;
vec3 Pi = mod(floor(P), 289.0);
vec3 Pf = fract(P) - 0.5;
vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);
vec3 p = worleyPermute(Pi.x + vec3(-1.0, 0.0, 1.0));
vec3 p1 = worleyPermute(p + Pi.y - 1.0);
vec3 p2 = worleyPermute(p + Pi.y);
vec3 p3 = worleyPermute(p + Pi.y + 1.0);
vec3 p11 = worleyPermute(p1 + Pi.z - 1.0);
vec3 p12 = worleyPermute(p1 + Pi.z);
vec3 p13 = worleyPermute(p1 + Pi.z + 1.0);
vec3 p21 = worleyPermute(p2 + Pi.z - 1.0);
vec3 p22 = worleyPermute(p2 + Pi.z);
vec3 p23 = worleyPermute(p2 + Pi.z + 1.0);
vec3 p31 = worleyPermute(p3 + Pi.z - 1.0);
vec3 p32 = worleyPermute(p3 + Pi.z);
vec3 p33 = worleyPermute(p3 + Pi.z + 1.0);
vec3 ox11 = fract(p11*K) - Ko;
vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;
vec3 oz11 = floor(p11*K2)*Kz - Kzo;
vec3 ox12 = fract(p12*K) - Ko;
vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;
vec3 oz12 = floor(p12*K2)*Kz - Kzo;
vec3 ox13 = fract(p13*K) - Ko;
vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;
vec3 oz13 = floor(p13*K2)*Kz - Kzo;
vec3 ox21 = fract(p21*K) - Ko;
vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;
vec3 oz21 = floor(p21*K2)*Kz - Kzo;
vec3 ox22 = fract(p22*K) - Ko;
vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;
vec3 oz22 = floor(p22*K2)*Kz - Kzo;
vec3 ox23 = fract(p23*K) - Ko;
vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;
vec3 oz23 = floor(p23*K2)*Kz - Kzo;
vec3 ox31 = fract(p31*K) - Ko;
vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;
vec3 oz31 = floor(p31*K2)*Kz - Kzo;
vec3 ox32 = fract(p32*K) - Ko;
vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;
vec3 oz32 = floor(p32*K2)*Kz - Kzo;
vec3 ox33 = fract(p33*K) - Ko;
vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;
vec3 oz33 = floor(p33*K2)*Kz - Kzo;
vec3 dx11 = Pfx + jitter*ox11;
vec3 dy11 = Pfy.x + jitter*oy11;
vec3 dz11 = Pfz.x + jitter*oz11;
vec3 dx12 = Pfx + jitter*ox12;
vec3 dy12 = Pfy.x + jitter*oy12;
vec3 dz12 = Pfz.y + jitter*oz12;
vec3 dx13 = Pfx + jitter*ox13;
vec3 dy13 = Pfy.x + jitter*oy13;
vec3 dz13 = Pfz.z + jitter*oz13;
vec3 dx21 = Pfx + jitter*ox21;
vec3 dy21 = Pfy.y + jitter*oy21;
vec3 dz21 = Pfz.x + jitter*oz21;
vec3 dx22 = Pfx + jitter*ox22;
vec3 dy22 = Pfy.y + jitter*oy22;
vec3 dz22 = Pfz.y + jitter*oz22;
vec3 dx23 = Pfx + jitter*ox23;
vec3 dy23 = Pfy.y + jitter*oy23;
vec3 dz23 = Pfz.z + jitter*oz23;
vec3 dx31 = Pfx + jitter*ox31;
vec3 dy31 = Pfy.z + jitter*oy31;
vec3 dz31 = Pfz.x + jitter*oz31;
vec3 dx32 = Pfx + jitter*ox32;
vec3 dy32 = Pfy.z + jitter*oy32;
vec3 dz32 = Pfz.y + jitter*oz32;
vec3 dx33 = Pfx + jitter*ox33;
vec3 dy33 = Pfy.z + jitter*oy33;
vec3 dz33 = Pfz.z + jitter*oz33;
vec3 d11 = worleyDist(dx11, dy11, dz11, distance, exponent);
vec3 d12 = worleyDist(dx12, dy12, dz12, distance, exponent);
vec3 d13 = worleyDist(dx13, dy13, dz13, distance, exponent);
vec3 d21 = worleyDist(dx21, dy21, dz21, distance, exponent);
vec3 d22 = worleyDist(dx22, dy22, dz22, distance, exponent);
vec3 d23 = worleyDist(dx23, dy23, dz23, distance, exponent);
vec3 d31 = worleyDist(dx31, dy31, dz31, distance, exponent);
vec3 d32 = worleyDist(dx32, dy32, dz32, distance, exponent);
vec3 d33 = worleyDist(dx33, dy33, dz33, distance, exponent);
VoronoiClosest vf = VoronoiClosest(vec4(1e10), vec4(0.0));
updateVoronoiClosest(vf, d11, p11);
updateVoronoiClosest(vf, d12, p12);
updateVoronoiClosest(vf, d13, p13);
updateVoronoiClosest(vf, d21, p21);
updateVoronoiClosest(vf, d22, p22);
updateVoronoiClosest(vf, d23, p23);
updateVoronoiClosest(vf, d31, p31);
updateVoronoiClosest(vf, d32, p32);
updateVoronoiClosest(vf, d33, p33);
return vf;
}
void node_tex_voronoi(int coloring, int distance, int feature, vec3 vector,
float scale, float exponent, out vec4 outColor, out float outFac) {
vector = scale * (vector - 0.0001);
VoronoiClosest vf = worleyClosest(vector, 1.0, distance, exponent);
vec4 vorColorData;
if (coloring == COLORING_INTENSITY) {
vorColorData = vf.closestDists;
} else if (coloring == COLORING_CELLS) {
vorColorData = vf.closestInds;
}
float vorColorFac;
if (feature == FEATURE_F1) {
vorColorFac = vorColorData.x;
} else if (feature == FEATURE_F2) {
vorColorFac = vorColorData.y;
} else if (feature == FEATURE_F3) {
vorColorFac = vorColorData.z;
} else if (feature == FEATURE_F4) {
vorColorFac = vorColorData.w;
} else if (feature == FEATURE_F2F1) {
vorColorFac = vorColorData.y - vorColorData.x;
}
if (coloring == COLORING_INTENSITY) {
outFac = vorColorFac;
outColor = vec4(vec3(outFac), 1.0);
} else if (coloring == COLORING_CELLS) {
vorColorFac += 1e-3;
float r = rand(vec2(vorColorFac / 289.0));
float g = rand(vec2(vorColorFac / 23535.0));
float b = rand(vec2(vorColorFac / 4353.0));
outFac = (r + g + b) / 3.0;
outColor = vec4(r, g, b, 1.0);
}
}`,pC=`#define TEX_WAVE_TYPE_BANDS 0
#define TEX_WAVE_TYPE_RINGS 1
#define TEX_WAVE_PROFILE_SIN 0
#define TEX_WAVE_PROFILE_SAW 1
#define TEX_WAVE_PROFILE_TRI 2
#define TEX_WAVE_BANDS_DIR_X 0
#define TEX_WAVE_BANDS_DIR_Y 1
#define TEX_WAVE_BANDS_DIR_Z 2
#define TEX_WAVE_BANDS_DIR_DIAGONAL 3
#define TEX_WAVE_RINGS_DIR_X 0
#define TEX_WAVE_RINGS_DIR_Y 1
#define TEX_WAVE_RINGS_DIR_Z 2
#define TEX_WAVE_RINGS_DIR_SPHERICAL 3
void node_tex_wave(
int waveType, int waveProfile, int bandsDirection, int ringsDirection,
vec3 vector, float scale, float distortion, float detail, float detailScale,
float detailRoughness, float phaseOffset,
out vec4 outColor, out float outFac) {
vec3 coScaled = vector * scale;
float waveFac;
vec3 waveVec = coScaled;
if (waveType == TEX_WAVE_TYPE_BANDS) {
const float BANDS_AXIS_SCALE = 2.0 / 3.0;
if (bandsDirection == TEX_WAVE_BANDS_DIR_X) {
waveVec = waveVec.xxx * BANDS_AXIS_SCALE;
} else if (bandsDirection == TEX_WAVE_BANDS_DIR_Y) {
waveVec = waveVec.yyy * BANDS_AXIS_SCALE;
} else if (bandsDirection == TEX_WAVE_BANDS_DIR_Z) {
waveVec = waveVec.zzz * BANDS_AXIS_SCALE;
} else if (bandsDirection == TEX_WAVE_BANDS_DIR_DIAGONAL) {
}
waveFac = (waveVec.x + waveVec.y + waveVec.z) * 10.0;
} else {
if (ringsDirection == TEX_WAVE_RINGS_DIR_X) {
waveVec.x = 0.0;
} else if (ringsDirection == TEX_WAVE_RINGS_DIR_Y) {
waveVec.y = 0.0;
} else if (ringsDirection == TEX_WAVE_RINGS_DIR_Z) {
waveVec.z = 0.0;
} else if (ringsDirection == TEX_WAVE_RINGS_DIR_SPHERICAL) {
}
waveFac = length(waveVec) * 20.0;
}
if (distortion != 0.0) {
waveFac += distortion * noiseTurbulence(coScaled * detailScale, detail,
0.0, 0.0, 1.0);
}
if (waveProfile == TEX_WAVE_PROFILE_SIN) {
waveFac = 0.5 + 0.5 * sin(waveFac - PI_HALF + phaseOffset);
} else if (waveProfile == TEX_WAVE_PROFILE_SAW) {
waveFac = fract((waveFac + phaseOffset + 1e-4) / PI2);
} else if (waveProfile == TEX_WAVE_PROFILE_TRI) {
waveFac = abs(2.0 * fract((waveFac + PI + phaseOffset) / PI2) - 1.0);
}
outColor = vec4(waveFac, waveFac, waveFac, 1.0);
outFac = waveFac;
}`,fC=`#if __VERSION__ == 300
#define rot_uint_32(x, k) (((x) << (k)) | ((x) >> (32 - (k))))
#define mix_uint_32(a, b, c) { a -= c; a ^= rot_uint_32(c, 4); c += b; b -= a; b ^= rot_uint_32(a, 6); a += c; c -= b; c ^= rot_uint_32(b, 8); b += a; a -= c; a ^= rot_uint_32(c, 16); c += b; b -= a; b ^= rot_uint_32(a, 19); a += c; c -= b; c ^= rot_uint_32(b, 4); b += a; }
#define final_uint_32(a, b, c) { c ^= b; c -= rot_uint_32(b, 14); a ^= c; a -= rot_uint_32(c, 11); b ^= a; b -= rot_uint_32(a, 25); c ^= b; c -= rot_uint_32(b, 16); a ^= c; a -= rot_uint_32(c, 4); b ^= a; b -= rot_uint_32(a, 14); c ^= b; c -= rot_uint_32(b, 24); }
uint hash_uint(uint x) {
uint a = 0xdeadbeefu + 17u + x;
uint b = 0xdeadbeefu + 17u;
uint c = 0xdeadbeefu + 17u;
final_uint_32(a, b, c);
return c;
}
uint hash_uint2(uvec2 vec) {
uvec3 abc = uvec3(0xdeadbeefu + 21u) + uvec3(vec, 0u);
final_uint_32(abc.x, abc.y, abc.z);
return abc.z;
}
uint hash_uint3(uvec3 vec) {
uvec3 abc = uvec3(0xdeadbeefu + 25u) + vec;
final_uint_32(abc.x, abc.y, abc.z);
return abc.z;
}
uint hash_uint4(uvec4 vec) {
uvec3 abc = uvec3(0xdeadbeefu + 29u) + vec.xyz;
mix_uint_32(abc.x, abc.y, abc.z);
abc.x += vec.w;
final_uint_32(abc.x, abc.y, abc.z);
return abc.z;
}
#undef rot_uint_32
#undef mix_uint_32
#undef final_uint_32
float uint_to_float(uint value) {
return float(value) / float(0xFFFFFFFFu);
}
float hash_float_to_float(float value) {
return uint_to_float(hash_uint(floatBitsToUint(value)));
}
float hash_vec2_to_float(vec2 vec) {
return uint_to_float(hash_uint2(floatBitsToUint(vec)));
}
float hash_vec3_to_float(vec3 vec) {
return uint_to_float(hash_uint3(floatBitsToUint(vec)));
}
float hash_vec4_to_float(vec4 vec) {
return uint_to_float(hash_uint4(floatBitsToUint(vec)));
}
vec3 hash_float_to_vec3(float val) {
return vec3(hash_float_to_float(val), hash_vec2_to_float(vec2(val, 1.0)),
hash_vec2_to_float(vec2(val, 2.0)));
}
vec3 hash_vec2_to_vec3(vec2 vec) {
return vec3(hash_vec2_to_float(vec), hash_vec3_to_float(vec3(vec, 1.0)),
hash_vec3_to_float(vec3(vec, 2.0)));
}
vec3 hash_vec3_to_vec3(vec3 vec) {
return vec3(hash_vec3_to_float(vec), hash_vec4_to_float(vec4(vec, 1.0)),
hash_vec4_to_float(vec4(vec, 2.0)));
}
vec3 hash_vec4_to_vec3(vec4 vec) {
return vec3(hash_vec4_to_float(vec.xyzw), hash_vec4_to_float(vec.zxwy),
hash_vec4_to_float(vec.wzyx));
}
void node_tex_white_noise_1d(vec3 vector, float w, out float outValue,
out vec4 outColor)
{
outValue = hash_float_to_float(w);
outColor = vec4(hash_float_to_vec3(w), 1.0);
}
void node_tex_white_noise_2d(vec3 vector, float w, out float outValue,
out vec4 outColor)
{
outValue = hash_vec2_to_float(vector.xy);
outColor = vec4(hash_vec2_to_vec3(vector.xy), 1.0);
}
void node_tex_white_noise_3d(vec3 vector, float w, out float outValue,
out vec4 outColor)
{
outValue = hash_vec3_to_float(vector);
outColor = vec4(hash_vec3_to_vec3(vector), 1.0);
}
void node_tex_white_noise_4d(vec3 vector, float w, out float outValue,
out vec4 outColor)
{
outValue = hash_vec4_to_float(vec4(vector, w));
outColor = vec4(hash_vec4_to_vec3(vec4(vector, w)), 1.0);
}
#else
void node_tex_white_noise_1d(vec3 vector, float w, out float outValue,
out vec4 outColor)
{
outValue = 0.0;
outColor = vec4(0.0);
}
void node_tex_white_noise_2d(vec3 vector, float w, out float outValue,
out vec4 outColor)
{
outValue = 0.0;
outColor = vec4(0.0);
}
void node_tex_white_noise_3d(vec3 vector, float w, out float outValue,
out vec4 outColor)
{
outValue = 0.0;
outColor = vec4(0.0);
}
void node_tex_white_noise_4d(vec3 vector, float w, out float outValue,
out vec4 outColor)
{
outValue = 0.0;
outColor = vec4(0.0);
}
#endif`,mC=`void node_uvmap(vec2 uv, out vec3 outUV) {
#if WORLD_NODES == 1
outUV = vec3(0.0);
#else
uv.y = 1.0 - uv.y;
outUV = vec3(uv, 0.0);
#endif
}`,gC=`void node_valtorgb(sampler2D colormap, float fac, out vec4 colOut, out float alphaOut)
{
colOut = texture2D(colormap, vec2(fac, 0.0));
alphaOut = colOut.a;
}`,vC=`uniform float nodeValue[NODE_VALUE_NUM];
void node_value(float val, out float outVal)
{
outVal = val;
}`,_C=`void node_vect_math_add(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec = v1 + v2;
}
void node_vect_math_subtract(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec = v1 - v2;
}
void node_vect_math_multiply(vec3 v1, vec3 v2, vec3 v3, float val,
out vec3 outVec, out float outVal) {
outVec = v1 * v2;
}
void node_vect_math_divide(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec.x = v2.x == 0.0 ? 0.0 : v1.x / v2.x;
outVec.y = v2.y == 0.0 ? 0.0 : v1.y / v2.y;
outVec.z = v2.z == 0.0 ? 0.0 : v1.z / v2.z;
}
void node_vect_math_cross_product(vec3 v1, vec3 v2, vec3 v3, float val,
out vec3 outVec, out float outVal) {
outVec = cross(v1, v2);
}
void node_vect_math_project(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
float d = dot(v2, v2);
outVec = (d != 0.0) ? (dot(v1, v2) / d) * v2 : vec3(0.0);
}
void node_vect_math_reflect(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
if (v2 != vec3(0.0)) {
v2 = normalize(v2);
}
outVec = reflect(v1, v2);
}
void node_vect_math_dot_product(vec3 v1, vec3 v2, vec3 v3, float val,
out vec3 outVec, out float outVal) {
outVal = dot(v1, v2);
}
void node_vect_math_distance(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVal = distance(v1, v2);
}
void node_vect_math_length(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVal = length(v1);
}
void node_vect_math_scale(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec = v1 * val;
}
void node_vect_math_normalize(vec3 v1, vec3 v2, vec3 v3, float val,
out vec3 outVec, out float outVal) {
if (v1 != vec3(0.0)) {
v1 = normalize(v1);
}
outVec = v1;
}
void node_vect_math_snap(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec.x = v2.x == 0.0 ? 0.0 : floor(v1.x / v2.x) * v2.x;
outVec.y = v2.y == 0.0 ? 0.0 : floor(v1.y / v2.y) * v2.y;
outVec.z = v2.z == 0.0 ? 0.0 : floor(v1.z / v2.z) * v2.z;
}
void node_vect_math_floor(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec = floor(v1);
}
void node_vect_math_ceil(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec = ceil(v1);
}
void node_vect_math_modulo(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
vec3 signProduct = sign(v1) * sign(v2);
v1 += 1e-5 * signProduct;
outVec.x = signProduct.x > 0.0 ? mod(v1.x, abs(v2.x)) : 0.0;
outVec.y = signProduct.y > 0.0 ? mod(v1.y, abs(v2.y)) : 0.0;
outVec.z = signProduct.z > 0.0 ? mod(v1.z, abs(v2.z)) : 0.0;
}
void node_vect_math_fraction(vec3 v1, vec3 v2, vec3 v3, float val,
out vec3 outVec, out float outVal) {
outVec = fract(v1);
}
void node_vect_math_absolute(vec3 v1, vec3 v2, vec3 v3, float val,
out vec3 outVec, out float outVal) {
outVec = abs(v1);
}
void node_vect_math_minimum(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec = min(v1, v2);
}
void node_vect_math_maximum(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec = max(v1, v2);
}
void node_vect_math_cosine(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec = cos(v1);
}
void node_vect_math_sine(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec = sin(v1);
}
void node_vect_math_tangent(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
outVec = tan(v1);
}
void node_vect_math_wrap(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,
out float outVal) {
v1 += 1e-5;
outVec.x = v2.x == v3.x ? v2.x : mod(v1.x - v3.x, v2.x - v3.x) + v3.x;
outVec.y = v2.y == v3.y ? v2.y : mod(v1.y - v3.y, v2.y - v3.y) + v3.y;
outVec.z = v2.z == v3.z ? v2.z : mod(v1.z - v3.z, v2.z - v3.z) + v3.z;
}
void node_vect_math_faceforward(vec3 v1, vec3 v2, vec3 v3, float val,
out vec3 outVec, out float outVal) {
outVec = dot(v2, v3) < 0.0 ? v1 : -v1;
}
void node_vect_math_multiply_add(vec3 v1, vec3 v2, vec3 v3, float val,
out vec3 outVec, out float outVal) {
outVec = v1 * v2 + v3;
}
void node_vect_math_refract(vec3 v1, vec3 v2, vec3 v3, float val,
out vec3 outVec, out float outVal) {
if (v2 != vec3(0.0)) {
v2 = normalize(v2);
}
outVec = refract(v1, v2, val);
}`,AC=`#define VEC_TRANS_NONE 0
#define VEC_TRANS_W_O 1
#define VEC_TRANS_W_C 2
#define VEC_TRANS_O_W 3
#define VEC_TRANS_O_C 4
#define VEC_TRANS_C_W 5
#define VEC_TRANS_C_O 6
#define VEC_TRANS_W_O_DIR 7
#define VEC_TRANS_W_C_DIR 8
#define VEC_TRANS_O_W_DIR 9
#define VEC_TRANS_O_C_DIR 10
#define VEC_TRANS_C_W_DIR 11
#define VEC_TRANS_C_O_DIR 12
void node_vect_transform(const int vecTransType, const bool invCamZ, vec3 vIn, out vec3 vOut)
{
if (vecTransType == VEC_TRANS_NONE)
vOut = vIn;
else {
vec4 vec;
if (vecTransType < VEC_TRANS_W_O_DIR)
vec = vec4(vIn.xyz, 1.0);
else
vec = vec4(vIn.xyz, 0.0);
if (vecTransType == VEC_TRANS_W_O || vecTransType == VEC_TRANS_W_O_DIR) {
vec = vec4(vec.x, vec.z, -vec.y, vec.w);
vec = invModelMatrix * vec;
vec = vec4(vec.x, -vec.z, vec.y, vec.w);
} else if (vecTransType == VEC_TRANS_W_C || vecTransType == VEC_TRANS_W_C_DIR) {
vec = vec4(vec.x, vec.z, -vec.y, vec.w);
vec = viewMatrix * vec;
if (invCamZ)
vec[2] = -vec[2];
} else if (vecTransType == VEC_TRANS_O_W || vecTransType == VEC_TRANS_O_W_DIR) {
vec = vec4(vec.x, vec.z, -vec.y, vec.w);
vec = modelMatrix * vec;
vec = vec4(vec.x, -vec.z, vec.y, vec.w);
} else if (vecTransType == VEC_TRANS_O_C || vecTransType == VEC_TRANS_O_C_DIR) {
vec = vec4(vec.x, vec.z, -vec.y, vec.w);
vec = modelViewMatrix * vec;
if (invCamZ)
vec[2] = -vec[2];
} else if (vecTransType == VEC_TRANS_C_W || vecTransType == VEC_TRANS_C_W_DIR) {
if (invCamZ)
vec[2] = -vec[2];
vec = invViewMatrix * vec;
vec = vec4(vec.x, -vec.z, vec.y, vec.w);
} else if (vecTransType == VEC_TRANS_C_O || vecTransType == VEC_TRANS_C_O_DIR) {
if (invCamZ)
vec[2] = -vec[2];
vec = invModelMatrix * invViewMatrix * vec;
vec = vec4(vec.x, -vec.z, vec.y, vec.w);
}
vOut = vec.xyz;
}
}`,xC=`void node_vector_displacement(vec4 vector, float midLevel, float scale,
out vec3 displacement) {
displacement = vec3(0.0);
}`,yC=`void node_vector_rotate_axis_angle(float invert, vec3 vector, vec3 center,
vec3 axis, float angle, vec3 rotation, out vec3 outVector) {
if (length(axis) > 0.0) {
vector -= center;
outVector = vec3RotateAxisAngle(vector, axis, invert * angle);
outVector += center;
} else {
outVector = vector;
}
}
void node_vector_rotate_euler_xyz(float invert, vec3 vector, vec3 center,
vec3 axis, float angle, vec3 rotation, out vec3 outVector) {
vec4 axisAngle = eulerToAxisAngle(rotation);
vector -= center;
outVector = vec3RotateAxisAngle(vector, axisAngle.xyz, invert * axisAngle.w);
outVector += center;
}
void node_vector_rotate_x_axis(float invert, vec3 vector, vec3 center,
vec3 axis, float angle, vec3 rotation, out vec3 outVector) {
vector -= center;
outVector = vec3RotateXAngle(vector, invert * angle);
outVector += center;
}
void node_vector_rotate_y_axis(float invert, vec3 vector, vec3 center,
vec3 axis, float angle, vec3 rotation, out vec3 outVector) {
vector -= center;
outVector = vec3RotateYAngle(vector, invert * angle);
outVector += center;
}
void node_vector_rotate_z_axis(float invert, vec3 vector, vec3 center,
vec3 axis, float angle, vec3 rotation, out vec3 outVector) {
vector -= center;
outVector = vec3RotateZAngle(vector, invert * angle);
outVector += center;
}`,bC=`void node_vertex_color(vec4 color, out vec4 outColor, out float outAlpha) {
outColor = color;
outAlpha = color.a;
}`,CC=`void node_volume_absorption(vec4 color, float density, out vec4 outColor)
{
outColor = color;
}`,SC=`void node_volume_info(out vec4 color, out float density, out float flame,
out float temperature) {
color = vec4(vec3(0.0), 1.0);
density = 0.0;
flame = 0.0;
temperature = 0.0;
}`,MC=`void node_volume_scatter(vec4 color, float density, float anisotropy, out vec4 outColor)
{
outColor = vec4(color);
}`,EC=`void node_wavelength(float wavelength, out vec4 outColor)
{
outColor = vec4(0.0, 0.0, 0.0, 1.0);
#if __VERSION__ == 300
vec3 xyz = vec3(0.0);
float ii = (wavelength - 380.0) / 5.0;
int i = int(ii);
if (i < 0 || i >= 80) {
return;
}
ii -= float(i);
vec3 c1 = cieColorMatch[i];
vec3 c2 = cieColorMatch[i+1];
xyz = mix(c1, c2, ii);
outColor = vec4(xyz_to_sRGB(xyz), 1.0);
#endif
}`,wC=`void node_wireframe(float size, out float outFac)
{
outFac = 0.0;
}`,TC=`void node_bitmap_none(out vec4 color)
{
color = vec4(1.0);
}`,IC=`void node_bitmap_env(sampler2D envMap, int reflectMode, float IOR,
const int encoding, const bool alphaAsMono, const bool alphaAsRGB,
float uOffset, float vOffset, float uTiling, float vTiling, float wAngle, vec3 normal,
out vec4 color, out float value)
{
vec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);
vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);
vec3 reflectVec;
#if WORLD_NODES
reflectVec = normalize(cameraToVertex);
#else
if (reflectMode == MAX_ENV_COORDS_REFLECT)
reflectVec = reflect(cameraToVertex, worldNormal);
else {
float refrRatio = 1.0 / IOR;
reflectVec = refract(cameraToVertex, worldNormal, refrRatio);
}
#endif
mat3 uvTransform = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle);
color = sampleEquirectangular(envMap, reflectVec, uvTransform, encoding);
if (alphaAsMono)
value = color.a;
else
value = average(color.rgb);
if (alphaAsRGB)
color = vec4(color.a);
}`,RC=`void node_bitmap(sampler2D map, const vec2 uvIn, const int mapping, const int axis,
const ivec2 clampToEdgeNoExtend,
const int encoding, const bool alphaAsMono, const bool alphaAsRGB,
float uOffset, float vOffset, float uTiling, float vTiling, float wAngle,
out vec4 color, out float value)
{
vec3 coordsIn;
if (mapping == MAPPING_EXPLICIT_MAP_CHANNEL) {
coordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 0.0);
} else if (mapping == MAPPING_VERTEX_COLOR_CHANNEL) {
coordsIn = vec3(0.0);
} else if (mapping == MAPPING_PLANAR_OBJECT_XYZ) {
coordsIn = swizzleUpZ((invModelMatrix * invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);
} else {
coordsIn = swizzleUpZ((invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);
}
if (axis == AXIS_XY)
coordsIn = vec3(coordsIn.x, coordsIn.y, 1.0);
else if (axis == AXIS_YZ)
coordsIn = vec3(coordsIn.y, coordsIn.z, 1.0);
else if (axis == AXIS_ZX)
coordsIn = vec3(coordsIn.z, coordsIn.x, 1.0);
vec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;
vec2 uv = vec2(coordsOut.x, 1.0 - coordsOut.y);
if ((clampToEdgeNoExtend[0] == 1 && (uvIn.x < 0.0 || uvIn.x > 1.0)) ||
(clampToEdgeNoExtend[1] == 1 && (uvIn.y < 0.0 || uvIn.y > 1.0))) {
color = vec4(0.0, 0.0, 0.0, 1.0);
} else {
color = texture2D(map, uv);
color = nodeTexelToLinear(color, encoding);
}
if (alphaAsMono)
value = color.a;
else
value = average(color.rgb);
if (alphaAsRGB)
color = vec4(color.a);
}`,LC=`void node_bump(sampler2D bumpMap, const vec3 eyePos, const vec3 normal, const vec2 uvIn,
float uOffset, float vOffset, float uTiling, float vTiling, float wAngle,
out vec3 normalOut)
{
vec3 coordsIn;
coordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 1.0);
vec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;
vec2 uv = vec2(coordsOut.x, 1.0 - coordsOut.y);
vec2 dSTdx = dFdx(uv);
vec2 dSTdy = dFdy(uv);
if (any(equal(dSTdx, vec2(0.0))) || any(equal(dSTdy, vec2(0.0)))) {
normalOut = normal;
} else {
const float bumpScale = 1.0;
vec3 vSigmaX = vec3(dFdx(eyePos.x), dFdx(eyePos.y), dFdx(eyePos.z));
vec3 vSigmaY = vec3(dFdy(eyePos.x), dFdy(eyePos.y), dFdy(eyePos.z));
vec3 vN = normal;
vec3 R1 = cross(vSigmaY, vN);
vec3 R2 = cross(vN, vSigmaX);
float fDet = dot(vSigmaX, R1);
float Hll = bumpScale * texture2D(bumpMap, uv).x;
float dBx = bumpScale * texture2D(bumpMap, uv + dSTdx).x - Hll;
float dBy = bumpScale * texture2D(bumpMap, uv + dSTdy).x - Hll;
vec2 dHdxy = vec2(dBx, dBy);
vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);
normalOut = normalize(abs(fDet) * normal - vGrad);
}
}`,PC=`void node_blend(
const bool useCurve, const float curveLower, const float curveUpper,
const vec4 color1, const vec4 color2, float mask,
out vec4 color)
{
if (useCurve)
mask = smoothstep(curveLower, curveUpper, mask);
else
mask = clamp(mask, 0.0, 1.0);
color = mix(color1, color2, mask);
}`,BC=`#define REWIRE_RED 0
#define REWIRE_GREEN 1
#define REWIRE_BLUE 2
#define REWIRE_ALPHA 3
#define REWIRE_RED_INV 4
#define REWIRE_GREEN_INV 5
#define REWIRE_BLUE_INV 6
#define REWIRE_ALPHA_INV 7
#define REWIRE_MONOCHROME 8
#define REWIRE_ONE 9
#define REWIRE_ZERO 10
float rewireChannel(int type, vec4 color)
{
if (type == REWIRE_RED)
return color.r;
else if (type == REWIRE_GREEN)
return color.g;
else if (type == REWIRE_BLUE)
return color.b;
else if (type == REWIRE_ALPHA)
return color.a;
else if (type == REWIRE_RED_INV)
return 1.0-color.r;
else if (type == REWIRE_GREEN_INV)
return 1.0-color.g;
else if (type == REWIRE_BLUE_INV)
return 1.0-color.b;
else if (type == REWIRE_ALPHA_INV)
return 1.0-color.a;
else if (type == REWIRE_MONOCHROME)
return average(color.rgb);
else if (type == REWIRE_ONE)
return 1.0;
else
return 0.0;
}
vec3 gainPivotGammaLift(vec3 color, float gain, float pivot, float gamma, float lift, int exposureMode, float printerLights)
{
gain = gain / 100.0;
if (exposureMode == 0) {
color = color * gain / pivot;
} else if (exposureMode == 1) {
color = color * pow(2.0, gain) / pivot;
} else {
color = color * pow(printerLights, gain) / pivot;
}
vec3 tmp = pivot * pow(color, vec3(1.0 / gamma));
return step(0.00001, color) * tmp + lift;
}
float gainPivotGammaLift(float value, float gain, float pivot, float gamma, float lift, int exposureMode, float printerLights)
{
gain = gain / 100.0;
if (exposureMode == 0) {
value = value * gain / pivot;
} else if (exposureMode == 1) {
value = value * pow(2.0, gain) / pivot;
} else {
value = value * pow(printerLights, gain) / pivot;
}
float tmp = pivot * pow(value, 1.0 / gamma);
return step(0.00001, value) * tmp + lift;
}
void node_color_correction(const ivec4 rewire,
const vec4 color, const float hueShift, const float saturation,
const vec4 tint, const float tintStrength,
const float brightness, const float contrast,
out vec4 outColor)
{
if (all(equal(rewire, ivec4(REWIRE_RED, REWIRE_GREEN, REWIRE_BLUE, REWIRE_ALPHA)))) {
outColor = color;
} else {
outColor.r = rewireChannel(rewire.x, color);
outColor.g = rewireChannel(rewire.y, color);
outColor.b = rewireChannel(rewire.z, color);
outColor.a = rewireChannel(rewire.w, color);
}
vec4 hsv;
rgbToHSV(outColor, hsv);
hsv[0] += hueShift / 360.0;
if (hsv[0] > 1.0)
hsv[0] -= 1.0;
else if (hsv[0] < 0.0)
hsv[0] += 1.0;
hsv[1] *= (saturation / 100.0 + 1.0);
hsv[1] = saturate(hsv[1]);
if (tintStrength > 0.0) {
vec4 hsvTint;
rgbToHSV(tint, hsvTint);
hsv[0] = hsv[0] + (hsvTint[0] - hsv[0]) * tintStrength / 100.0;
}
hsvToRGB(hsv, outColor);
outColor = (outColor - 0.5) * (contrast / 100.0 + 1.0) + 0.5 + brightness / 100.0;
outColor = max(outColor, 0.0);
}
void node_color_correction(const ivec4 rewire, const mat4 params,
bool enableR, bool enableG, bool enableB, int exposureMode, float printerLights,
const vec4 color, const float hueShift, const float saturation,
const vec4 tint, const float tintStrength,
out vec4 outColor)
{
if (all(equal(rewire, ivec4(REWIRE_RED, REWIRE_GREEN, REWIRE_BLUE, REWIRE_ALPHA)))) {
outColor = color;
} else {
outColor.r = rewireChannel(rewire.x, color);
outColor.g = rewireChannel(rewire.y, color);
outColor.b = rewireChannel(rewire.z, color);
outColor.a = rewireChannel(rewire.w, color);
}
vec4 hsv;
rgbToHSV(outColor, hsv);
hsv[0] += hueShift / 360.0;
if (hsv[0] > 1.0)
hsv[0] -= 1.0;
else if (hsv[0] < 0.0)
hsv[0] += 1.0;
hsv[1] *= (saturation / 100.0 + 1.0);
hsv[1] = saturate(hsv[1]);
if (tintStrength > 0.0) {
vec4 hsvTint;
rgbToHSV(tint, hsvTint);
hsv[0] = hsv[0] + (hsvTint[0] - hsv[0]) * tintStrength / 100.0;
}
hsvToRGB(hsv, outColor);
outColor.rgb = gainPivotGammaLift(outColor.rgb, params[0][0], params[0][1], params[0][2], params[0][3],
exposureMode, printerLights);
if (enableR)
outColor.r = gainPivotGammaLift(outColor.r, params[1][0], params[1][1], params[1][2], params[1][3],
exposureMode, printerLights);
if (enableG)
outColor.g = gainPivotGammaLift(outColor.g, params[2][0], params[2][1], params[2][2], params[2][3],
exposureMode, printerLights);
if (enableB)
outColor.b = gainPivotGammaLift(outColor.b, params[3][0], params[3][1], params[3][2], params[3][3],
exposureMode, printerLights);
outColor = max(outColor, 0.0);
}`,DC=`void node_color_map(const bool reverseGamma,
const vec4 color, const float gamma, const float gain,
out vec4 outColor)
{
float p = reverseGamma ? gamma : 1.0 / gamma;
float g = reverseGamma ? (gain > EPSILON ? 1.0 / gain : 1.0) : gain;
outColor = vec4(g * pow(abs(color.rgb), vec3(p)), color.a);
}`,NC=`#define COMP_BLEND_NORMAL 0
#define COMP_BLEND_AVERAGE 1
#define COMP_BLEND_ADD 2
#define COMP_BLEND_SUBTRACT 3
#define COMP_BLEND_DARKEN 4
#define COMP_BLEND_MULTIPLY 5
#define COMP_BLEND_COLORBURN 6
#define COMP_BLEND_LINEARBURN 7
#define COMP_BLEND_LIGHTEN 8
#define COMP_BLEND_SCREEN 9
#define COMP_BLEND_COLORDODGE 10
#define COMP_BLEND_LINEARDODGE 11
#define COMP_BLEND_SPOT 12
#define COMP_BLEND_SPOTBLEND 13
#define COMP_BLEND_OVERLAY 14
#define COMP_BLEND_SOFTLIGHT 15
#define COMP_BLEND_HARDLIGHT 16
#define COMP_BLEND_PINLIGHT 17
#define COMP_BLEND_HARDMIX 18
#define COMP_BLEND_DIFFERENCE 19
#define COMP_BLEND_EXCLUSION 20
#define COMP_BLEND_HUE 21
#define COMP_BLEND_SATURATION 22
#define COMP_BLEND_COLOR 23
#define COMP_BLEND_VALUE 24
vec4 calcBlending(const vec4 colorBG, const vec4 colorFG, const int blendMode) {
if (blendMode == COMP_BLEND_NORMAL)
return colorFG;
else if (blendMode == COMP_BLEND_AVERAGE)
return (colorFG + colorBG) / 2.0;
else if (blendMode == COMP_BLEND_ADD)
return colorBG + colorFG;
else if (blendMode == COMP_BLEND_SUBTRACT)
return colorBG - colorFG;
else if (blendMode == COMP_BLEND_DARKEN)
return min(colorFG, colorBG);
else if (blendMode == COMP_BLEND_MULTIPLY)
return colorBG * colorFG;
else if (blendMode == COMP_BLEND_COLORBURN) {
if (colorFG.r == 0.0 && colorFG.g == 0.0 && colorFG.b == 0.0)
return vec4(0.0, 0.0, 0.0, 1.0);
else
return max(1.0 - (1.0 - colorBG) / colorFG, 0.0);
} else if (blendMode == COMP_BLEND_LINEARBURN)
return max(colorFG + colorBG - 1.0, 0.0);
else if (blendMode == COMP_BLEND_LIGHTEN)
return max(colorFG, colorBG);
else if (blendMode == COMP_BLEND_SCREEN)
return colorFG + colorBG - colorFG * colorBG;
else if (blendMode == COMP_BLEND_COLORDODGE) {
if (colorFG.r == 1.0 && colorFG.g == 1.0 && colorFG.b == 1.0)
return vec4(1.0);
else
return min(colorBG / (1.0 - colorFG), 1.0);
} else if (blendMode == COMP_BLEND_LINEARDODGE)
return min(colorFG + colorBG, 1.0);
else if (blendMode == COMP_BLEND_SPOT)
return min(2.0 * colorFG * colorBG, 1.0);
else if (blendMode == COMP_BLEND_SPOTBLEND)
return min(colorFG * colorBG + colorBG, 1.0);
else if (blendMode == COMP_BLEND_OVERLAY) {
if (colorBG.r <= 0.5 && colorBG.g <= 0.5 && colorBG.b <= 0.5)
return saturate(2.0 * colorFG * colorBG);
else
return saturate(1.0 - 2.0 * (1.0-colorFG) * (1.0-colorBG));
} else if (blendMode == COMP_BLEND_SOFTLIGHT) {
if (colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5)
return saturate(colorBG * (colorBG + 2.0 * colorFG * (1.0 - colorBG)));
else
return saturate(colorBG + (2.0 * colorFG - 1.0) * (sqrt(colorBG) - colorBG));
} else if (blendMode == COMP_BLEND_HARDLIGHT) {
if (colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5)
return saturate(2.0 * colorFG * colorBG);
else
return saturate(1.0 - 2.0*(1.0 - colorFG)*(1.0 - colorBG));
} else if (blendMode == COMP_BLEND_PINLIGHT) {
if (((colorFG.r > 0.5 && colorFG.g > 0.5 && colorFG.b > 0.5) && all(greaterThan(colorFG, colorBG))) ||
((colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5) && all(lessThan(colorFG, colorBG))))
return colorFG;
else
return colorBG;
} else if (blendMode == COMP_BLEND_HARDMIX) {
if (colorFG.r + colorBG.r <= 1.0 && colorFG.g + colorBG.g <= 1.0 && colorFG.b + colorBG.b <= 1.0)
return vec4(0.0, 0.0, 0.0, 1.0);
else
return vec4(1.0);
} else if (blendMode == COMP_BLEND_DIFFERENCE)
return abs(colorFG - colorBG);
else if (blendMode == COMP_BLEND_EXCLUSION)
return colorFG + colorBG - 2.0 * colorFG * colorBG;
}
vec4 calcBlendingHSV(const vec4 colorBG, const vec4 colorFG, const int blendMode)
{
vec4 hsvBG, hsvFG;
vec4 outColor;
if (blendMode == COMP_BLEND_HUE) {
rgbToHSV(colorBG, hsvBG);
rgbToHSV(colorFG, hsvFG);
hsvToRGB(vec4(hsvFG[0], hsvBG[1], hsvBG[2], 1.0), outColor);
} else if (blendMode == COMP_BLEND_SATURATION) {
rgbToHSV(colorBG, hsvBG);
rgbToHSV(colorFG, hsvFG);
hsvToRGB(vec4(hsvBG[0], hsvFG[1], hsvBG[2], 1.0), outColor);
} else if (blendMode == COMP_BLEND_COLOR) {
rgbToHSV(colorBG, hsvBG);
rgbToHSV(colorFG, hsvFG);
hsvToRGB(vec4(hsvFG[0], hsvFG[1], hsvBG[2], 1.0), outColor);
} else if (blendMode == COMP_BLEND_VALUE) {
rgbToHSV(colorBG, hsvBG);
rgbToHSV(colorFG, hsvFG);
hsvToRGB(vec4(hsvBG[0], hsvBG[1], hsvFG[2], 1.0), outColor);
}
return outColor;
}
void node_composite_layer(const int blendMode, const float opacity, 
const vec4 colorBG, const vec4 colorFG, const vec4 mask,
out vec4 outColor)
{
float fac = saturate(opacity * average(mask.rgb));
if (blendMode < COMP_BLEND_HUE)
outColor = calcBlending(colorBG, colorFG, blendMode);
else
outColor = calcBlendingHSV(colorBG, colorFG, blendMode);
outColor = mix(colorBG, outColor, fac);
}`,OC=`#define FALLOFF_TYPE_TOWARDS_AWAY 0
#define FALLOFF_TYPE_PERP_PARALL 1
#define FALLOFF_TYPE_FRESHNEL 2
#define FALLOFF_TYPE_SHADOW_LIGHT 3
#define FALLOFF_TYPE_DIST_BLEND 4
void node_falloff(const vec3 viewPos, const float IOR, const int falloffType,
const vec4 color1, const vec4 color2, const vec3 normal, out vec4 color)
{
vec3 dir = normalize(viewPos);
float fac;
if (falloffType == FALLOFF_TYPE_TOWARDS_AWAY) {
fac = 1.0 - (0.5 * (abs(dot(dir, normal)) + 1.0));
} else if (falloffType == FALLOFF_TYPE_PERP_PARALL) {
fac = 1.0 - abs(dot(dir, normal));
} else if (falloffType == FALLOFF_TYPE_FRESHNEL) {
float eta = max(IOR, 0.00001);
fac = fresnelReflection(dir, normal, (gl_FrontFacing) ? eta : 1.0 / eta);
} else {
fac = 0.0;
}
color = mix(color1, color2, fac);
}
void node_falloff(const vec3 viewPos, bool extrapolateOn, float nearDistance, float farDistance,
const vec4 color1, const vec4 color2, const vec3 normal, out vec4 color)
{
float dist = length(viewPos);
float fac;
if (!extrapolateOn && dist <= nearDistance) {
fac = 1.0;
} else if (!extrapolateOn && dist > farDistance) {
fac = 0.0;
} else {
fac = ((farDistance - nearDistance) != 0.0) ? ((farDistance - dist) / (farDistance - nearDistance)) : 10000.0;
}
color = mix(color1, color2, fac);
}`,FC=`#define GRAD_TYPE_LINEAR 0
#define GRAD_TYPE_RADIAL 1
void node_gradient(
float color2Pos, int gradientType, vec2 uvIn, vec3 viewPos, int mapping, int axis, ivec2 clampToEdgeNoExtend,
vec3 color1, vec3 color2, vec3 color3, float uOffset, float vOffset, float uTiling, float vTiling, float wAngle,
out vec4 outCol)
{
vec3 coordsIn;
if (mapping == MAPPING_EXPLICIT_MAP_CHANNEL) {
coordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 0.0);
} else if (mapping == MAPPING_VERTEX_COLOR_CHANNEL) {
coordsIn = vec3(0.0);
} else if (mapping == MAPPING_PLANAR_OBJECT_XYZ) {
coordsIn = swizzleUpZ((invModelMatrix * invViewMatrix * vec4(-viewPos, 1.0)).xyz);
} else {
coordsIn = swizzleUpZ((invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);
}
if (axis == AXIS_XY)
coordsIn = vec3(coordsIn.x, coordsIn.y, 1.0);
else if (axis == AXIS_YZ)
coordsIn = vec3(coordsIn.y, coordsIn.z, 1.0);
else if (axis == AXIS_ZX)
coordsIn = vec3(coordsIn.z, coordsIn.x, 1.0);
vec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;
float coord = uvIn.x;
uvIn = coordsOut.xy;
if ((clampToEdgeNoExtend[0] == 1 && (uvIn.x < 0.0 || uvIn.x > 1.0)) ||
(clampToEdgeNoExtend[1] == 1 && (uvIn.y < 0.0 || uvIn.y > 1.0))) {
outCol = vec4(0.0, 0.0, 0.0, 1.0);
return;
}
uvIn = fract(uvIn);
if (gradientType == GRAD_TYPE_LINEAR) {
coord = uvIn.y;
} else {
coord = length(uvIn - vec2(0.5)) * 2.0;
if (coord > 1.0)
coord = 1.0;
}
if (coord < color2Pos) {
coord = coord / color2Pos;
outCol = vec4(color3 * (1.0 - coord) + color2 * coord, 1.0);
} else if (coord > color2Pos) {
coord = (coord - color2Pos) / (1.0 - color2Pos);
outCol = vec4(color2 * (1.0 - coord) + color1 * coord, 1.0);
} else {
outCol = vec4(color2, 1.0);
}
}`,UC=`#define GRAD_TYPE_4_CORNER 0
#define GRAD_TYPE_BOX 1
#define GRAD_TYPE_DIAGONAL 2
#define GRAD_TYPE_LIGHTING 3
#define GRAD_TYPE_LINEAR 4
#define GRAD_TYPE_MAPPED 5
#define GRAD_TYPE_NORMAL 6
#define GRAD_TYPE_PONG 7
#define GRAD_TYPE_RADIAL 8
#define GRAD_TYPE_SPIRAL 9
#define GRAD_TYPE_SWEEP 10
#define GRAD_TYPE_TARTAN 11
void node_gradient_ramp(
sampler2D gradientData, int gradientType, vec2 uvIn, vec3 geometryNormal,
vec3 viewPos, int mapping, int axis, ivec2 clampToEdgeNoExtend,
vec4 sourceMap, float uOffset, float vOffset, float uTiling, float vTiling, float wAngle,
out vec4 outCol)
{
vec3 coordsIn;
if (mapping == MAPPING_EXPLICIT_MAP_CHANNEL) {
coordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 0.0);
} else if (mapping == MAPPING_VERTEX_COLOR_CHANNEL) {
coordsIn = vec3(0.0);
} else if (mapping == MAPPING_PLANAR_OBJECT_XYZ) {
coordsIn = swizzleUpZ((invModelMatrix * invViewMatrix * vec4(-viewPos, 1.0)).xyz);
} else {
coordsIn = swizzleUpZ((invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);
}
if (axis == AXIS_XY)
coordsIn = vec3(coordsIn.x, coordsIn.y, 1.0);
else if (axis == AXIS_YZ)
coordsIn = vec3(coordsIn.y, coordsIn.z, 1.0);
else if (axis == AXIS_ZX)
coordsIn = vec3(coordsIn.z, coordsIn.x, 1.0);
vec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;
float coord = uvIn.x;
uvIn = coordsOut.xy;
if ((clampToEdgeNoExtend[0] == 1 && (uvIn.x < 0.0 || uvIn.x > 1.0)) ||
(clampToEdgeNoExtend[1] == 1 && (uvIn.y < 0.0 || uvIn.y > 1.0))) {
outCol = vec4(0.0, 0.0, 0.0, 1.0);
return;
}
uvIn = fract(uvIn);
if (gradientType == GRAD_TYPE_4_CORNER) {
coord = pow(uvIn.x, 2.0);
} else if (gradientType == GRAD_TYPE_BOX) {
vec2 boxUv = abs(uvIn - vec2(0.5)) * 2.0;
coord = max(boxUv.x, boxUv.y);
} else if (gradientType == GRAD_TYPE_DIAGONAL) {
coord = abs(uvIn.x - uvIn.y) * sqrt(2.0);
} else if (gradientType == GRAD_TYPE_LIGHTING) {
IncidentLight directLight;
GeometricContext geometry;
geometry.position = -viewPos;
vec3 irr = vec3(0.0);
#if (NUM_POINT_LIGHTS > 0)
#pragma unroll_loop_start
for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
getPointLightInfo(pointLights[i], geometry, directLight);
float dotNL = saturate(dot(geometryNormal, directLight.direction));
irr += dotNL * directLight.color;
}
#pragma unroll_loop_end
#endif
#if (NUM_SPOT_LIGHTS > 0)
#pragma unroll_loop_start
for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
getSpotLightInfo(spotLights[i], geometry, directLight);
float dotNL = saturate(dot(geometryNormal, directLight.direction));
irr += dotNL * directLight.color;
}
#pragma unroll_loop_end
#endif
#if (NUM_DIR_LIGHTS > 0)
#pragma unroll_loop_start
for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
getDirectionalLightInfo(directionalLights[i], geometry, directLight);
float dotNL = saturate(dot(geometryNormal, directLight.direction));
irr += dotNL * directLight.color;
}
#pragma unroll_loop_end
#endif
#if defined(PHYSICALLY_CORRECT_LIGHTS)
irr /= PI;
#endif
vec3 ambIrr = getAmbientLightIrradiance(ambientLightColor);
#if !defined(PHYSICALLY_CORRECT_LIGHTS)
ambIrr /= PI;
#endif
irr += ambIrr;
coord = (irr.x + irr.y + irr.z) / 3.0;
} else if (gradientType == GRAD_TYPE_LINEAR) {
coord = uvIn.x;
} else if (gradientType == GRAD_TYPE_MAPPED) {
coord = (sourceMap.x + sourceMap.y + sourceMap.z) / 3.0;
} else if (gradientType == GRAD_TYPE_NORMAL) {
float angle = acos(clamp(dot(geometryNormal, normalize(viewPos)), -1.0, 1.0));
float k = 100.0;
coord = 1.0 - sin(pow2(k) - k * sqrt(pow2(k) - pow2(angle)));
} else if (gradientType == GRAD_TYPE_PONG) {
float y = min(uvIn.y, uvIn.x);
float x = max(uvIn.y, uvIn.x);
coord = y / x;
} else if (gradientType == GRAD_TYPE_RADIAL) {
coord = length(uvIn - vec2(0.5)) * 2.0;
} else if (gradientType == GRAD_TYPE_SPIRAL) {
vec2 uvSpiral = mat2(0.0, 1.0, -1.0, 0.0) * (uvIn - vec2(0.5));
coord = atan(uvSpiral.y, uvSpiral.x) / PI2 + 0.5;
} else if (gradientType == GRAD_TYPE_SWEEP) {
coord = atan(uvIn.x, uvIn.y) / PI_HALF;
} else if (gradientType == GRAD_TYPE_TARTAN) {
vec2 uvTartan = abs(uvIn - vec2(0.5));
coord = 1.0 - min(uvTartan.x, uvTartan.y) * 2.0;
}
outCol = texture2D(gradientData, vec2(coord, 0.0));
}`,zC=`
void node_map(const vec4 colorIn, out vec4 color)
{
color = colorIn;
}`,VC=`void node_mask(const bool maskInverted,
const vec4 color, vec4 mask,
out vec4 outColor)
{
mask = maskInverted ? vec4(vec3(1.0) - mask.rgb, mask.a) : mask;
outColor = color * mask;
}`,GC=`void node_material(
float reflectionRatio, const float refractionRatio,
const bool selfIllumColorOn,
const vec4 ambientColor, const vec4 diffuseColor, const vec4 specularColor,
const float glossiness, const float specularLevel, const vec4 selfIllum,
const float opacity, const vec4 filterColor, const vec3 normal,
const vec4 reflection, const vec4 refraction, const float displacement,
out vec4 outColor)
{
vec3 diffuse, specular;
NodeMaterial material;
float ior = 1.5;
float facing = pow2((1.0 - ior) / (1.0 + ior));
float edge = 1.0;
float slope = 5.0;
float cosTheta = saturate(dot(normal, normalize(vViewPosition)));
float fresnelRefl = (facing + (edge - facing) * pow(1.0 - cosTheta, slope)) * saturate(specularLevel);
float kd = 1.0 - fresnelRefl;
material.diffuseColor = diffuseColor.rgb * kd;
material.specularColor = mix(vec3(0.0), specularColor.rgb, fresnelRefl);
material.roughness = 1.0 - glossiness;
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
diffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
if (selfIllumColorOn) {
diffuse += selfIllum.rgb;
} else {
diffuse = mix(diffuse, material.diffuseColor, selfIllum[0]);
}
specular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
outColor = vec4(saturate(diffuse + specular), 1.0);
float alpha = opacity - saturate(maxFromRGB(specular)) * (opacity - 1.0);
outColor += reflection * specularColor * reflectionRatio;
outColor += refraction * refractionRatio;
alpha += saturate(maxFromRGB(reflection.rgb) * maxFromRGB(specularColor.rgb)) * reflectionRatio;
alpha += saturate(maxFromRGB(refraction.rgb)) * refractionRatio;
outColor.a = alpha;
}`,kC=`#include <shadowmask_pars_fragment>
void node_matte_shadow(
vec3 normal, bool receiveShadow, float shadowBrightness, vec3 color,
out vec4 outColor) {
float shadow = getShadowMask();
outColor = vec4(color, 1.0 - (shadowBrightness + (1.0 - shadowBrightness) * shadow));
}`,QC=`void node_mix(const vec4 color1, const vec4 color2, const float amount, out vec4 color)
{
color = mix(color1, color2, clamp(amount, 0.0, 1.0));
}`,WC=`#define NOISE_REGULAR 0
#define NOISE_FRACTAL 1
#define NOISE_TURBULENCE 2
float noise(vec3 vec, const int noiseType, const float size, const float thresholdLow, const float thresholdHigh, const float levels, float phase) {
vec /= size;
float n = 0.0;
if (noiseType == NOISE_REGULAR) {
n = (1.0 + snoise(vec4(vec, phase))) * 0.5;
} else if (noiseType == NOISE_FRACTAL) {
float l, f = 1.0;
#if __VERSION__ == 100
for (float l = 3.0; l >= 1.0; l-=1.0) {
#else
for (l = levels; l >= 1.0; l-=1.0) {
#endif
n += snoise(vec4(vec * f, phase)) / f;
f *= 2.0;
}
if (l > 0.0)
n += l * snoise(vec4(vec * f, phase)) / f;
n = 0.5 * (n + 1.0);
} else {
float l, f = 1.0;
float ml = levels;
#if __VERSION__ == 100
for (float l = 3.0; l >= 1.0; l-=1.0) {
#else
for (l = levels; l >= 1.0; l-=1.0, ml-=1.0) {
#endif
n += abs(snoise(vec4(vec * f, phase))) / f;
f *= 2.0;
}
if (l > 0.0)
n += l * abs(snoise(vec4(vec * f, phase))) / f;
}
return clamp(smoothstep(thresholdLow, thresholdHigh, n), 0.0, 1.0);
}
void node_noise(const vec2 uv, const int noiseType, const int coordType,
const vec3 color1, const vec3 color2, const float size,
const float thresholdLow, const float thresholdHigh, const float levels,
const float phase, const vec3 offset, const vec3 tiling, const vec3 angle,
out vec4 color) {
vec3 vec = (calcXYZTransform(offset, tiling, angle) * vec4(uv.x, 1.0 - uv.y, 1.0, 1.0)).xyz;
color = vec4(mix(color1, color2, noise(vec, noiseType, size, thresholdLow, thresholdHigh, levels, phase)), 1.0);
}
void node_noise(const vec3 viewPos, const int noiseType, const int coordType,
const vec3 color1, const vec3 color2, const float size,
const float thresholdLow, const float thresholdHigh, const float levels,
const float phase, const vec3 offset, const vec3 tiling, const vec3 angle,
out vec4 color) {
vec4 posWorld = invViewMatrix * vec4(-viewPos, 1.0);
vec3 vec;
if (coordType == 0)
vec = (invModelMatrix * posWorld).xyz;
else
vec = posWorld.xyz;
vec = (calcXYZTransform(offset, tiling, angle) * vec4(swizzleUpZ(vec), 1.0)).xyz;
color = vec4(mix(color1, color2, noise(vec, noiseType, size, thresholdLow, thresholdHigh, levels, phase)), 1.0);
}`,HC=`void node_normal_bump(const vec4 tangent, const vec3 normal, ivec2 flip,
vec4 normalColor, vec3 additionalBump, float normalMult, float addBumpMult,
out vec3 normalOut)
{
if (flip[0] == 1)
normalColor.x = 1.0 - normalColor.x;
if (flip[1] == 0)
normalColor.y = 1.0 - normalColor.y;
vec3 normalTex = (normalColor.xyz * 2.0 - 1.0);
vec4 viewTangent = vec4(normalize(modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz, tangent.w);
vec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);
normalOut = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent 
+ normalTex.z * normal);
normalOut = mix(normal, normalOut, normalMult);
additionalBump = mix(normal, additionalBump, addBumpMult);
normalOut = normalize(normalOut + additionalBump);
}`,XC=`vec4 processOutputColor(vec4 color, const bool invert, const bool clampColor, const bool alphaFromRGB,
const float rgbLevel, const float rgbOffset, const float outputAmount)
{
vec3 color3 = color.rgb;
color3 = clampColor ? saturate(color3) : color3;
color3 = color3 * rgbLevel + vec3(rgbOffset);
color3 = invert ? (vec3(1.0) - color3) : color3;
color = outputAmount * vec4(color3, color.a);
color.a = alphaFromRGB ? average(color.rgb) : color.a;
return color;
}
void node_output_map(
const bool invert, const bool clampColor, const bool alphaFromRGB,
const vec4 color, const float rgbLevel, const float rgbOffset,
const float outputAmount, const float bumpAmount,
out vec4 outColor)
{
outColor = processOutputColor(color, invert, clampColor, alphaFromRGB, rgbLevel, rgbOffset, outputAmount);
}
void node_output_map(
const bool invert, const bool clampColor, const bool alphaFromRGB, sampler2D colormap,
vec4 color, const float rgbLevel, const float rgbOffset,
const float outputAmount, const float bumpAmount,
out vec4 outColor)
{
float r = texture2D(colormap, vec2(color.r, 0.0)).r;
float g = texture2D(colormap, vec2(color.g, 0.0)).g;
float b = texture2D(colormap, vec2(color.b, 0.0)).b;
outColor = processOutputColor(vec4(r, g, b, color.a),
invert, clampColor, alphaFromRGB, rgbLevel, rgbOffset, outputAmount);
}`,YC=`void node_output(vec4 color, out vec4 outgoingLight)
{
outgoingLight = color;
}`,jC=`#define DEFAULT_REFLECTION_EDGE 1.0
#define DEFAULT_REFLECTION_SLOPE 5.0
void node_physical(
vec3 geometryNormal, const float emitLuminance, const bool useCustomReflCurve,
const float reflFacing, const float reflEdge, const float reflSlope,
const bool roughnessInv, const bool transRoughnessLock, const bool transRoughnessInv,
const bool thinWalled,
const float baseWeight, const vec4 baseColor, const float reflectivity,
const vec4 reflColor, const float roughness, const float metalness,
const float diffRoughness, const float anisotropy, const float anisoangle,
const float transparency, const vec4 transColor, const float transRoughness,
const float ior, const float scattering, const vec4 sssColor,
const float sssScale, const float emission, const vec4 emitColor,
const float coating, const vec4 coatColor, const float coatRoughness,
const vec3 normal, const vec3 clearcoatNormal, const float displacement,
const float opacity,
out vec4 outColor)
{
NodeMaterial material;
vec3 baseColorWeighted = baseWeight * baseColor.rgb;
material.diffuseColor = baseColorWeighted * (1.0 - transparency);
#ifdef USE_CLEARCOAT
material.clearcoat = saturate(coating);
material.clearcoatRoughness = clamp(coatRoughness, 0.0, 1.0);
material.clearcoatF0 = vec3(0.04);
material.clearcoatF90 = 1.0;
#endif
float facing, edge, slope;
if (useCustomReflCurve) {
facing = reflFacing;
edge = reflEdge;
slope = reflSlope;
} else {
facing = pow2((1.0 - ior) / (1.0 + ior));
edge = DEFAULT_REFLECTION_EDGE;
slope = DEFAULT_REFLECTION_SLOPE;
}
float cosTheta = saturate(dot(normal, normalize(vViewPosition)));
float fresnelRefl = (facing + (edge - facing) * pow(1.0 - cosTheta, slope))
* saturate(reflectivity + metalness);
float kd = 1.0 - (metalness * (1.0 - fresnelRefl) + fresnelRefl);
material.specularColor = mix(metalness * baseColorWeighted, reflColor.rgb, fresnelRefl);
material.diffuseColor *= kd;
material.specularF90 = 1.0;
material.roughness = clamp(roughnessInv ? (1.0 - roughness) : roughness, 0.0, 1.0);
material.refractionColor = pow(transparency * (1.0 - metalness) * transColor.rgb, vec3(2.0));
material.refractionIOR = ior;
float tRough;
if (transRoughnessLock) {
tRough = roughnessInv ? 1.0 - roughness : roughness;
} else {
tRough = transRoughnessInv ? 1.0 - transRoughness : transRoughness;
}
material.refractionRoughness = pow2(tRough);
#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)
float geomRoughness = calcGeometryRoughness(geometryNormal);
material.roughness = calcCubeUVAdjustedRoughness(
material.roughness, geomRoughness);
material.refractionRoughness = calcCubeUVAdjustedRoughness(
material.refractionRoughness, geomRoughness);
#ifdef USE_CLEARCOAT
material.clearcoatRoughness = calcCubeUVAdjustedRoughness(
material.clearcoatRoughness, geomRoughness);
#endif
#endif
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
vec3 refractedLight = vec3(0.0);
#ifdef USE_GTAO
vec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,
gl_FragCoord.xy / currResolution);
vec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));
#define PROBE_NORMAL bentNormal
#endif
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#define RE_Refraction RE_Refraction_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
#undef RE_Refraction
#ifdef PROBE_NORMAL
#undef PROBE_NORMAL
#endif
#ifdef USE_GTAO
reflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;
float gtaoVisibility = gtaoVisibilityBentNormal.r;
vec3 gtaoBentNormal = bentNormal;
vec3 gtaoViewDir = geometry.viewDir;
vec3 gtaoNormal = normal;
float gtaoRoughness = material.roughness;
#endif
#include <lights_fragment_gtso>
vec3 totalEmissiveRadiance = emitLuminance / LUMENS_PER_WATT * emission * emitColor.rgb;
vec3 specular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
vec3 outColor3 = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +
specular + totalEmissiveRadiance;
#ifdef USE_CLEARCOAT
float dotNVcc = saturate(dot(geometry.normal, geometry.viewDir));
vec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);
outColor3 = outColor3 * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;
#endif
float alpha = 1.0;
if (thinWalled) {
alpha = 1.0 - saturate(transparency) + maxFromRGB(specular) * saturate(transparency);
} else {
outColor3 += refractedLight;
}
outColor = vec4(outColor3, saturate(alpha) * opacity);
}`,KC=`vec3 perezSky(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE,
vec3 radiance, vec3 sunDirection, vec3 direction)
{
float cosGamma = clamp(dot(direction, sunDirection), -1.0, 1.0);
float cosTheta = clamp(direction.y, 0.0, 1.0);
vec3 radInternal = (1.0 + paramA * exp(paramB / cosTheta)) * (
1.0 + paramC * exp(paramD * acos(cosGamma))
+ paramE * pow(cosGamma, 2.0)
);
float ciex = radInternal.y * radiance.y;
float ciey = radInternal.z * radiance.z;
float cieY = clamp(radInternal.x * radiance.x, 0.0, 1000000.0);
vec3 XYZ = xyY_to_XYZ(ciex, ciey, cieY);
return max(xyz_to_sRGB(XYZ), 0.0);
}
#define GROUND_SKY_SAMPLES 16
vec3 groundSky(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE, vec3 radiance, vec3 sunDirection, vec3 sunIlluminance)
{
const int horizSamples = GROUND_SKY_SAMPLES;
const int vertSamples = GROUND_SKY_SAMPLES / 2;
vec3 result = vec3(0.0);
for (int horizSampleIdx = 0; horizSampleIdx < horizSamples; horizSampleIdx++) {
float horizSample = float(horizSampleIdx) / float(horizSamples);
float horizAngle = PI2 * horizSample;
for (int vertSampleIdx = 0; vertSampleIdx < vertSamples; vertSampleIdx++) {
float vertSample = float(vertSampleIdx) / float(vertSamples);
float y = 1.0 - vertSample;
float x = sqrt(1.0 - y*y) * cos(horizAngle);
float z = -sqrt(1.0 - y*y) * sin(horizAngle);
vec3 direction = vec3(x, y, z);
vec3 sampleColor = perezSky(paramA, paramB, paramC, paramD, paramE,
radiance, sunDirection, direction);

result += direction.y * sampleColor;
}
}
result /= float(horizSamples * vertSamples);
result += (sunIlluminance * sunDirection.y) / PI;
return result;
}
void node_phy_sun_sky_env(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE,
vec3 radiance, vec3 sunDirection, vec3 sunIlluminance, vec3 sunLuminance, 
float globalIntensity, vec4 groundColor,
out vec4 outColor) 
{
vec3 dir = vWorldPosition;
if (length(dir) == 0.0) {
dir = vec3(0.0, 0.0, -1.0);
} else {
dir = normalize(dir);
}
if (dir.y < 0.0) {
outColor = groundColor * vec4(groundSky(paramA, paramB, paramC, paramD, paramE, radiance, sunDirection, sunIlluminance), 1.0);
} else {
outColor = vec4(perezSky(paramA, paramB, paramC, paramD, paramE,
radiance, sunDirection, dir), 1.0);
}
outColor = globalIntensity * outColor;
}`,qC=`void node_reflect_refract(sampler2D envMap,
int reflectMode, const float IOR, const int encoding,
vec3 normal, out vec4 color)
{
vec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);
vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);
vec3 reflectVec;
if (reflectMode == MAX_ENV_COORDS_REFLECT)
reflectVec = reflect(cameraToVertex, worldNormal);
else {
float refrRatio = 1.0 / IOR;
reflectVec = refract(cameraToVertex, worldNormal, refrRatio);
}
reflectVec = normalize(reflectVec);
color = sampleEquirectangular(envMap, reflectVec, mat3(1.0), encoding);
}`,ZC=`void node_reflect_refract_color(const vec4 colorIn, out vec4 color)
{
color = vec4(colorIn);
}`,JC=`void node_rgb_multiply(const vec4 color1, const vec4 color2, out vec4 color)
{
color = color1 * color2;
}`,$C=`void node_rgb_tint(const vec4 color, const vec4 red, const vec4 green, const vec4 blue,
out vec4 outColor)
{
mat3 tintMatrix = mat3(red.rgb, green.rgb, blue.rgb);
outColor = vec4(tintMatrix * color.rgb, color.a);
}`,eS=`uniform vec4 nodeRGB[NODE_RGB_NUM];
void node_rgb(vec4 color, out vec4 outColor)
{
outColor = color;
}`,tS=`void node_shellac(const vec4 color1, const vec4 color2, const float amount,
out vec4 color)
{
color = mix(color1, color2, clamp(amount, 0.0, 1.0));
}`,nS=`uniform float nodeValue[NODE_VALUE_NUM];
void node_value(float val, out float outVal)
{
outVal = val;
}`,iS=`void node_vertex_color(vec3 color, out vec4 outColor)
{
outColor = vec4(color, 1.0);
}`,oS=`void node_add_double_linear(
float input1, float input2,
out float outValue) {
outValue = input1 + input2;
}`,rS=`void node_add_matrix(
mat4 matrixIn1,
out mat4 matrixSum)
{
matrixSum = matrixIn1;
}
void node_add_matrix(
mat4 matrixIn1, mat4 matrixIn2,
out mat4 matrixSum)
{
matrixSum = matrixIn1 + matrixIn2;
}
void node_add_matrix(
mat4 matrixIn1, mat4 matrixIn2, mat4 matrixIn3,
out mat4 matrixSum)
{
matrixSum = matrixIn1 + matrixIn2 + matrixIn3;
}`,aS=`#ifndef NODE_VALUE
uniform float nodeValue[NODE_VALUE_NUM];
#endif
void node_anim_curve_ta(float val, out float outVal)
{
outVal = val;
}`,sS=`#ifndef NODE_VALUE
uniform float nodeValue[NODE_VALUE_NUM];
#endif
void node_anim_curve_tu(float val, out float outVal)
{
outVal = val;
}`,lS=`void node_blend_colors(float blender, vec3 color1, vec3 color2, out vec3 outColor)
{
blender = clamp(blender, 0.0, 1.0);
outColor = mix(color1, color2, 1.0 - blender);
}
void node_blend_colors(float blender, vec4 color1, vec4 color2, out vec4 outColor)
{
blender = clamp(blender, 0.0, 1.0);
outColor = mix(color1, color2, 1.0 - blender);
}`,cS=`void node_blinn(
vec3 geometryNormal,
vec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,
float diffuse, vec3 normal, float reflectivity, vec3 reflectedColor,
float eccentricity, vec3 specularColor, float specularRollOff, float translucence,
vec3 transparency,
out vec4 outColor) {
NodeMaterial material;
material.diffuseColor = diffuse * color;
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
vec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));
float geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
material.roughness = max(eccentricity, 0.0525);
material.roughness += geometryRoughness;
material.roughness = min(material.roughness, 1.0);
material.specularColor = specularColor;
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
float alpha = 1.0 - average(transparency);
outColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +
reflectedLight.directSpecular + reflectedLight.indirectSpecular + incandescence, alpha);
}`,uS=`void node_bulge(
float uWidth, float vWidth, vec2 uvCoord,
out float outAlpha, out vec3 outColor) {
uvCoord = 2.0 * fract(uvCoord); 
float bulge = 0.0;
if (uvCoord.x > uWidth && uvCoord.x < 2.0 - uWidth &&
uvCoord.y > vWidth && uvCoord.y < 2.0 - vWidth) {
uvCoord.x = (uvCoord.x - uWidth) / (1.0 - uWidth);
uvCoord.y = (uvCoord.y - vWidth) / (1.0 - vWidth);
bulge = uvCoord.x * (2.0 - uvCoord.x) * uvCoord.y * (2.0 - uvCoord.y);
}
outAlpha = bulge; 
outColor = vec3(bulge, bulge, bulge); 
}`,dS=`void node_bump_2d(
vec3 normal,
float bumpDepth, float bumpValue,
out vec3 outNormal) {
vec3 position = vViewPosition;
vec3 dPdx = dFdx(position);
vec3 dPdy = dFdy(position);
float dHdx = dFdx(bumpValue);
float dHdy = dFdy(bumpValue);
vec3 tanX = cross(dPdy, normal);
vec3 tanY = cross(normal, dPdx);
vec3 surfaceGrad = dHdx * tanX + dHdy * tanY;
float dotPosTanX = dot(dPdx, tanX);
outNormal = normalize(normal * abs(dotPosTanX) - surfaceGrad * sign(dotPosTanX));
outNormal = normalize(mix(normal, outNormal, max(0.0, bumpDepth)));
}
void node_bump_2d(
vec3 normal, vec4 tangent,
float bumpDepth, vec3 bumpValue,
out vec3 outNormal) {
#ifdef DOUBLE_SIDED
normal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);
#endif
if (length(tangent.xyz) == 0.0)
tangent.x = 1.0;
vec3 normalTex = (bumpValue.xyz * 2.0 - 1.0);
vec4 viewTangent = vec4(normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz), tangent.w);
vec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);
outNormal = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent
+ normalTex.z * normal);
outNormal = mix(normal, outNormal, bumpDepth);
}`,hS=`void node_channels(
int channelR, int channelG, int channelB, int channelA,
float inAlpha, vec3 inColor,
out float outAlpha, out vec3 outColor) {
outAlpha = 1.0;
outColor = vec3(1.0);
if (channelR == 0)
outColor.r = inColor.r;
else if (channelR == 1)
outColor.r = inColor.g;
else if (channelR == 2)
outColor.r = inColor.b;
else
outColor.r = inAlpha;
if (channelG == 0)
outColor.g = inColor.r;
else if (channelG == 1)
outColor.g = inColor.g;
else if (channelG == 2)
outColor.g = inColor.b;
else
outColor.g = inAlpha;
if (channelB == 0)
outColor.b = inColor.r;
else if (channelB == 1)
outColor.b = inColor.g;
else if (channelB == 2)
outColor.b = inColor.b;
else
outColor.b = inAlpha;
if (channelA == 0)
outAlpha = inColor.r;
else if (channelA == 1)
outAlpha = inColor.g;
else if (channelA == 2)
outAlpha = inColor.b;
else
outAlpha = inAlpha;
}`,pS=`void node_checker(
vec3 color1, vec3 color2, float contrast, vec2 uvCoord,
out float outAlpha, out vec3 outColor) {
uvCoord -= floor(uvCoord); 
vec3 deltaColor = color2 - color1;
color1 += (1.0 - contrast) * 0.5 * deltaColor;
color2 -= (1.0 - contrast) * 0.5 * deltaColor;
if ((uvCoord.x < 0.5 && uvCoord.y >= 0.5) || (uvCoord.x >= 0.5 && uvCoord.y < 0.5)) { 
outColor = color2; 
outAlpha = 1.0; 
} else {
outColor = color1; 
outAlpha = 0.0; 
}
}`,fS=`void node_clamp(
vec3 inputValue, vec3 maxValue, vec3 minValue,
out vec3 outputValue) {
outputValue = clamp(inputValue, minValue, maxValue);
}`,mS=`void node_cloth(
float brightSpread, vec3 gapColor, float randomness, vec3 uColor, float uWave, float uWidth,
vec3 vColor, float vWave, float vWidth, float widthSpread, vec2 uvCoord,
out float outAlpha, out vec3 outColor) {
if (abs(uWave) > -EPSILON || abs(vWave) > -EPSILON) {
uvCoord.x += - uWave * sin(PI2 * uvCoord.y);
uvCoord.y += vWave * sin(PI2 * uvCoord.x);
}
uvCoord = fract(uvCoord);
int thread = 0;
if ((uvCoord.x >= 0.5 && uvCoord.y < 0.5) || (uvCoord.x < 0.5 && uvCoord.y >= 0.5)) {
float flippedCoord;
flippedCoord = uvCoord.x;
uvCoord.x = uvCoord.y;
uvCoord.y = flippedCoord;
flippedCoord = uWidth;
uWidth = vWidth;
vWidth = flippedCoord;
thread = 1;
}
uvCoord = fract(2.0 * uvCoord);
float cloth = 1.0;
if (uvCoord.y <= vWidth) {
float clothU = uvCoord.x - 0.5 * uWidth;
float clothV = 2.0 * uvCoord.y / vWidth - 1.0;
cloth = 0.75 * (clothU * clothU + clothV * clothV);
} else if (uvCoord.x <= uWidth) {
float clothU = 2.0 * uvCoord.x / uWidth - 1.0;
float clothV = uvCoord.y - 0.5 * vWidth - 1.0;
cloth = 0.75 * (clothU * clothU + clothV * clothV);
thread = 1 - thread;
}
outColor = gapColor;
if (cloth < 1.0) {
cloth = 1.0 - cloth;
cloth = min(cloth, 1.0);
outColor *= (1.0 - cloth);
vec3 threadColor = uColor;
if (thread == 0)
threadColor = vColor;
outColor += threadColor * cloth;
}
outAlpha = dot(outColor, LUM_WEIGHTS_MAYA);
}`,gS=`void node_color_condition(
float alphaA, float alphaB, vec3 colorA, vec3 colorB, bool condition,
out float outAlpha, out vec3 outColor) {
outAlpha = condition ? alphaA : alphaB;
outColor = condition ? colorA : colorB;
}`,vS=`void node_color_composite(int operation,
vec3 colorA, float alphaA, vec3 colorB, float alphaB, float factor,
out vec3 outColor, out float outAlpha)
{
if (factor <= 0.0) {
outColor = colorA;
outAlpha = alphaA;
return;
}
if (operation == 0) {
outColor[0] = colorA[0] + (colorB[0] * factor);
outColor[1] = colorA[1] + (colorB[1] * factor);
outColor[2] = colorA[2] + (colorB[2] * factor);
outAlpha = alphaA + (alphaB * factor);
} else if (operation == 1) {
outColor[0] = colorA[0] + ((colorB[0] - 1.0) * factor);
outColor[1] = colorA[1] + ((colorB[1] - 1.0) * factor);
outColor[2] = colorA[2] + ((colorB[2] - 1.0) * factor);
outAlpha = alphaA + ((alphaB - 1.0) * factor);
} else if (operation == 2) {
if (factor >= 1.0) {
outColor = colorB;
outAlpha = alphaB;
return;
}
outColor[0] = mix(colorA[0], colorB[0], factor);
outColor[1] = mix(colorA[1], colorB[1], factor);
outColor[2] = mix(colorA[2], colorB[2], factor);
outAlpha = mix(alphaA, alphaB, factor);
} else if (operation == 3) {
outColor[0] = colorA[0] * (colorB[0] * factor + (1.0 - factor));
outColor[1] = colorA[1] * (colorB[1] * factor + (1.0 - factor));
outColor[2] = colorA[2] * (colorB[2] * factor + (1.0 - factor));
outAlpha = alphaA * (alphaB * factor + (1.0 - factor));
} else if (operation == 4) {
outColor[0] = 1.0 - ((1.0 - colorA[0]) * (1.0 - colorB[0] * factor));
outColor[1] = 1.0 - ((1.0 - colorA[1]) * (1.0 - colorB[1] * factor));
outColor[2] = 1.0 - ((1.0 - colorA[2]) * (1.0 - colorB[2] * factor));
outAlpha = 1.0 - ((1.0 - alphaA) * (1.0 - alphaB * factor));
} else if (operation == 5) {
outColor[0] = colorB[0] > 0.5 ? (2.0 * colorA[0] * colorB[0] * factor) + colorA[0] * (1.0 - factor) :
1.0 - ((1.0 - colorA[0]) * (1.0 - colorB[0] * factor)) * (2.0 - (1.0 - factor));
outColor[1] = colorB[1] > 0.5 ? (2.0 * colorA[1] * colorB[1] * factor) + colorA[1] * (1.0 - factor) :
1.0 - ((1.0 - colorA[1]) * (1.0 - colorB[1] * factor)) * (2.0 - (1.0 - factor));
outColor[2] = colorB[2] > 0.5 ? (2.0 * colorA[2] * colorB[2] * factor) + colorA[2] * (1.0 - factor) :
1.0 - ((1.0 - colorA[2]) * (1.0 - colorB[2] * factor)) * (2.0 - (1.0 - factor));
outAlpha = alphaB > 0.5 ? (2.0 * alphaA * alphaB * factor) + alphaA * (1.0 - factor) :
1.0 - ((1.0 - alphaA) * (1.0 - alphaB * factor)) * (2.0 - (1.0 - factor));
} else if (operation == 6) {
outColor[0] = abs(colorA[0] - (colorB[0] * factor));
outColor[1] = abs(colorA[1] - (colorB[1] * factor));
outColor[2] = abs(colorA[2] - (colorB[2] * factor));
outAlpha = abs(alphaA - (alphaB * factor));
} else if (operation == 7) {
outColor[0] = clamp(mix(colorA[0], colorA[0] / max(1.0 - colorB[0], 0.00001), factor), colorA[0], colorB[0]);
outColor[1] = clamp(mix(colorA[1], colorA[1] / max(1.0 - colorB[1], 0.00001), factor), colorA[1], colorB[1]);
outColor[2] = clamp(mix(colorA[2], colorA[2] / max(1.0 - colorB[2], 0.00001), factor), colorA[2], colorB[2]);
outAlpha = clamp(mix(alphaA, alphaA / max(1.0 - alphaB, 0.00001), factor), alphaA, alphaB);
} else if (operation == 8) {
outColor[0] = clamp(mix(colorA[0], 1.0 - (colorA[0] / max(1.0 - colorB[0], 0.00001)), factor), colorA[0], colorB[0]);
outColor[1] = clamp(mix(colorA[1], 1.0 - (colorA[1] / max(1.0 - colorB[1], 0.00001)), factor), colorA[1], colorB[1]);
outColor[2] = clamp(mix(colorA[2], 1.0 - (colorA[2] / max(1.0 - colorB[2], 0.00001)), factor), colorA[2], colorB[2]);
outAlpha = clamp(mix(alphaA, 1.0 - (alphaA / max(1.0 - alphaB, 0.00001)), factor), alphaA, alphaB);
}
}`,_S=`void node_color_constant(vec3 inColor, float inAlpha, out vec3 outColor, out float outAlpha)
{
outColor = inColor;
outAlpha = inAlpha;
}`,AS=`void node_color_correct(
bool colClamp, vec3 colClampMin, vec3 colClampMax,
bool alphaClamp, float alphaClampMin, float alphaClampMax,
bool unpremultInput, bool premultResult,
float alphaGain, float alphaGamma, float alphaOffset,
vec3 colGain, vec3 colGamma, vec3 colOffset, float hueShift,
float inAlpha, vec3 inColor, float satGain, float valGain,
out float outAlpha, out vec3 outColor)
{
outColor = unpremultInput ? inColor/inAlpha : inColor;
if (hueShift != 0.0 || satGain != 1.0 || valGain != 1.0) {
vec4 color = vec4(outColor, 1.0);
rgbToHSV(vec4(inColor, 1.0), color);
color.r += hueShift / 360.0;
if (color.r > 1.0)
color.r -= 1.0;
else if (color.r < 0.0)
color.r += 1.0;
color.g *= satGain;
color.b *= valGain;
hsvToRGB(color, color);
outColor = color.rgb;
}
outColor *= colGain;
outColor += colOffset;
if (any(notEqual(colGamma, vec3(1.0))))
outColor = pow(outColor, 1.0 / colGamma);
if (colClamp)
outColor = clamp(outColor, colClampMin, colClampMax);
outAlpha = inAlpha * alphaGain;
outAlpha += alphaOffset;
if (alphaGamma != 1.0)
outAlpha = pow(outAlpha, 1.0 / alphaGamma);
if (alphaClamp)
outAlpha = clamp(outAlpha, alphaClampMin, alphaClampMax);
if (premultResult)
outColor *= outAlpha;
}`,xS=`void node_color_logic(
int operation,
vec3 colorA, vec3 colorB,
out bool outBool) {
if (operation == 0) {
outBool = all(equal(colorA, colorB));
} else if (operation == 1) {
outBool = any(notEqual(colorA, colorB));
} else if (operation == 2) {
outBool = ((colorA.x + colorA.y + colorA.z) < (colorB.x + colorB.y + colorB.z));
} else if (operation == 3) {
outBool = ((colorA.x + colorA.y + colorA.z) > (colorB.x + colorB.y + colorB.z));
} else if (operation == 4) {
outBool = ((colorA.x + colorA.y + colorA.z) <= (colorB.x + colorB.y + colorB.z));
} else {
outBool = ((colorA.x + colorA.y + colorA.z) >= (colorB.x + colorB.y + colorB.z));
}
}`,yS=`void node_color_mask(
bool maskAlphaIsLuminance,
float inAlpha, vec3 inColor, vec3 mask, float maskAlpha,
out float outAlpha, out vec3 outColor) {
if (maskAlphaIsLuminance)
maskAlpha = 1.0 - dot(mask, LUM_WEIGHTS_MAYA);
outColor = inColor * (1.0 - maskAlpha);
}`,bS=`void node_color_math(
int operation,
float alphaA, float alphaB, vec3 colorA, vec3 colorB,
out float outAlpha, out vec3 outColor) {
if (operation == 0) {
outColor = colorA + colorB;
outAlpha = alphaA + alphaB;
} else if (operation == 1) {
outColor = colorA - colorB;
outAlpha = alphaA - alphaB;
} else if (operation == 2) {
outColor = colorA * colorB;
outAlpha = alphaA * alphaB;
} else if (operation == 3) {
outColor = colorA / colorB;
outAlpha = alphaA / alphaB;
} else if (operation == 4) {
outColor = min(colorA, colorB);
outAlpha = min(alphaA, alphaB);
} else {
outColor = max(colorA, colorB);
outAlpha = max(alphaA, alphaB);
}
}`,CS=`mat3 quatToMat3(vec4 quat) {
float x = quat.x,
y = quat.y,
z = quat.z,
w = quat.w;
float x2 = x + x;
float y2 = y + y;
float z2 = z + z;

float xx = x * x2;
float yx = y * x2;
float yy = y * y2;
float zx = z * x2;
float zy = z * y2;
float zz = z * z2;
float wx = w * x2;
float wy = w * y2;
float wz = w * z2;

mat3 mat;

mat[0][0] = 1.0 - yy - zz;
mat[1][0] = yx - wz;
mat[2][0] = zx + wy;

mat[0][1] = yx + wz;
mat[1][1] = 1.0 - xx - zz;
mat[2][1] = zy - wx;

mat[0][2] = zx - wy;
mat[1][2] = zy + wx;
mat[2][2] = 1.0 - xx - yy;
return mat;
}
void node_compose_matrix(
bool useEulerRotation, int inputRotateOrder,
vec4 inputQuat, vec3 inputRotate, vec3 inputScale, vec3 inputShear, vec3 inputTranslate,
out mat4 outputMatrix)
{
mat4 rotateMatrix;
inputRotate = radians(inputRotate);
if (useEulerRotation)
rotateMatrix = toMat4(mat3RotateX(inputRotate.x) * mat3RotateY(inputRotate.y) * mat3RotateZ(inputRotate.z));
else
rotateMatrix = toMat4(quatToMat3(normalize(inputQuat)));
mat4 scaleMatrix = mat4(inputScale.x, 0.0, 0.0, 0.0,
0.0, inputScale.y, 0.0, 0.0,
0.0, 0.0, inputScale.z, 0.0,
0.0, 0.0, 0.0, 1.0);
mat4 shearMatrix = mat4(1.0, 0.0, 0.0, 0.0,
inputShear.x, 1.0, 0.0, 0.0,
inputShear.y, inputShear.z, 1.0, 0.0,
0.0, 0.0, 0.0, 1.0);
mat4 transMatrix = mat4(1.0, 0.0, 0.0, 0.0,
0.0, 1.0, 0.0, 0.0,
0.0, 0.0, 1.0, 0.0,
inputTranslate.x, inputTranslate.y, inputTranslate.z, 1.0);
outputMatrix = scaleMatrix * shearMatrix * rotateMatrix * transMatrix;
}`,SS=`void node_condition(
int operation,
vec3 colorIfFalse, vec3 colorIfTrue, float firstTerm, float secondTerm,
out vec3 outColor) {
if (operation == 0) {
if (firstTerm == secondTerm)
outColor = colorIfTrue;
else
outColor = colorIfFalse;
} else if (operation == 1) {
if (firstTerm != secondTerm)
outColor = colorIfTrue;
else
outColor = colorIfFalse;
} else if (operation == 2) {
if (firstTerm > secondTerm)
outColor = colorIfTrue;
else
outColor = colorIfFalse;
} else if (operation == 3) {
if (firstTerm >= secondTerm)
outColor = colorIfTrue;
else
outColor = colorIfFalse;
} else if (operation == 4) {
if (firstTerm < secondTerm)
outColor = colorIfTrue;
else
outColor = colorIfFalse;
} else if (operation == 5) {
if (firstTerm <= secondTerm)
outColor = colorIfTrue;
else
outColor = colorIfFalse;
}
}`,MS=`vec4 mat3ToQuat(mat3 m) {
float trace = m[0][0] + m[1][1] + m[2][2];
vec4 q = vec4(0.0, 0.0, 0.0, 0.0);
if (trace > 0.0) {
float s = sqrt(trace + 1.0) * 2.0;
q.w = 0.25 * s;
q.x = (m[2][1] - m[1][2]) / s;
q.y = (m[0][2] - m[2][0]) / s;
q.z = (m[1][0] - m[0][1]) / s;
} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {
float s = sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]) * 2.0;
q.w = (m[2][1] - m[1][2]) / s;
q.x = 0.25 * s;
q.y = (m[0][1] + m[1][0]) / s;
q.z = (m[0][2] + m[2][0]) / s;
} else if (m[1][1] > m[2][2]) {
float s = sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]) * 2.0;
q.w = (m[0][2] - m[2][0]) / s;
q.x = (m[0][1] + m[1][0]) / s;
q.y = 0.25 * s;
q.z = (m[1][2] + m[2][1]) / s;
} else {
float s = sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]) * 2.0;
q.w = (m[1][0] - m[0][1]) / s;
q.x = (m[0][2] + m[2][0]) / s;
q.y = (m[1][2] + m[2][1]) / s;
q.z = 0.25 * s;
}
return q;
}
vec3 mat3ToEuler(mat3 m) {
float m11 = m[0][0], m12 = m[1][0], m13 = m[2][0];
float m21 = m[0][1], m22 = m[1][1], m23 = m[2][1];
float m31 = m[0][2], m32 = m[1][2], m33 = m[2][2];
vec3 euler;
euler.y = asin(clamp(m13, -1.0, 1.0));
if (abs(m13) < 0.9999999) {
euler.x = atan(-m23, m33);
euler.z = atan(-m12, m11);
} else {
euler.x = atan(m32, m22);
euler.z = 0.0;
}
return euler;
}
void decomposeMat4(mat4 m, out vec3 position, out vec4 quat, out vec3 euler, out vec3 scale) {
float sx = length(vec3(m[0][0], m[0][1], m[0][2]));
float sy = length(vec3(m[1][0], m[1][1], m[1][2]));
float sz = length(vec3(m[2][0], m[2][1], m[2][2]));
float det = mat3GetDeterminant(toMat3(m));
if (det < 0.0)
sx = -sx;
position.x = m[3][0];
position.y = m[3][1];
position.z = m[3][2];
float invSX = 1.0 / sx;
float invSY = 1.0 / sy;
float invSZ = 1.0 / sz;
m[0][0] *= invSX;
m[0][1] *= invSX;
m[0][2] *= invSX;
m[1][0] *= invSY;
m[1][1] *= invSY;
m[1][2] *= invSY;
m[2][0] *= invSZ;
m[2][1] *= invSZ;
m[2][2] *= invSZ;
quat = mat3ToQuat(toMat3(m));
euler = mat3ToEuler(toMat3(m));
scale.x = sx;
scale.y = sy;
scale.z = sz;
}
void node_decompose_matrix(
mat4 inputMatrix,
out vec4 outputQuat, out vec3 outputRotate, out vec3 outputScale, out vec3 outputShear, out vec3 outputTranslate)
{
decomposeMat4(inputMatrix, outputTranslate, outputQuat, outputRotate, outputScale);
outputShear = vec3(0.0, 0.0, 0.0);
}`,ES=`void node_env_sphere(sampler2D envMap, int encoding, vec3 normal,
mat4 placementMatrix,
out float outAlpha, out vec3 outColor)
{
vec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);
vec3 reflectVec;
#if WORLD_NODES
reflectVec = normalize(cameraToVertex);
#else
vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);
reflectVec = reflect(cameraToVertex, worldNormal);
#endif
mat3 uvTransform = mat3(1.0);
reflectVec = toMat3(placementMatrix) * reflectVec;
vec4 tex = sampleEquirectangular(envMap, reflectVec, uvTransform, encoding);
outAlpha = tex.a;
outColor = tex.rgb;
}`,wS=`void node_file(sampler2D ima, const int encoding, const bool rgbToAlpha,
vec2 uvCoord,
out float outAlpha, out vec3 outColor, out vec2 outSize, out vec3 outTransparency) {
vec2 uv = vec2(uvCoord.x, 1.0 - uvCoord.y);
vec4 tex = texture2D(ima, uv);
outColor = nodeTexelToLinear(tex, encoding).rgb;
if (rgbToAlpha)
outAlpha = dot(tex.rgb, LUM_WEIGHTS_MAYA);
else
outAlpha = tex.a;
outSize = vec2(0.0);
outTransparency = vec3(1.0 - outAlpha, 1.0 - outAlpha, 1.0 - outAlpha);
}`,TS=`void node_float_condition(
bool condition, float floatA, float floatB, 
out float outFloat) {
outFloat = condition ? floatA : floatB;
}`,IS=`void node_float_composite(int operation,
float floatA, float floatB, float factor,
out float outFloat)
{
if (factor <= 0.0) {
outFloat = floatA;
return;
}
if (operation == 0) {
outFloat = floatA + (floatB * factor);
} else if (operation == 1) {
outFloat = floatA + ((floatB - 1.0) * factor);
} else if (operation == 2) {
if (factor >= 1.0) {
outFloat = floatB;
return;
}
outFloat = mix(floatA, floatB, factor);
} else if (operation == 3) {
outFloat = floatA * (floatB * factor + (1.0 - factor));
} else if (operation == 4) {
outFloat = 1.0 - ((1.0 - floatA) * (1.0 - floatB * factor));
} else if (operation == 5) {
outFloat = floatB > 0.5 ? (2.0 * floatA * floatB * factor) + floatA * (1.0 - factor) :
1.0 - ((1.0 - floatA) * (1.0 - floatB * factor)) * (2.0 - (1.0 - factor));
} else if (operation == 6) {
outFloat = abs(floatA - (floatB * factor));
} else if (operation == 7) {
outFloat = clamp(mix(floatA, floatA / max(1.0 - floatB, 0.00001), factor), floatA, floatB);
} else if (operation == 8) {
outFloat = clamp(mix(floatA, 1.0 - (floatA / max(1.0 - floatB, 0.00001)), factor), floatA, floatB);
}
}`,RS=`void node_float_constant(float inFloat, out float outFloat)
{
outFloat = inFloat;
}`,LS=`void node_float_logic(
int operation,
float floatA, float floatB,
out bool outBool) {
if (operation == 0) {
outBool = (floatA == floatB);
} else if (operation == 1) {
outBool = (floatA != floatB);
} else if (operation == 2) {
outBool = (floatA < floatB);
} else if (operation == 3) {
outBool = (floatA > floatB);
} else if (operation == 4) {
outBool = (floatA <= floatB);
} else {
outBool = (floatA >= floatB);
}
}`,PS=`void node_float_mask(
float inFloat, float mask,
out float outFloat) {
outFloat = inFloat - mask;
}`,BS=`void node_float_math(
int operation,
float floatA, float floatB,
out float outFloat) {
if (operation == 0) {
outFloat = floatA + floatB;
} else if (operation == 1) {
outFloat = floatA - floatB;
} else if (operation == 2) {
outFloat = floatA * floatB;
} else if (operation == 3) {
outFloat = floatA / floatB;
} else if (operation == 4) {
outFloat = min(floatA, floatB);
} else if (operation == 5) {
outFloat = max(floatA, floatB);
} else {
outFloat = pow(floatA, floatB);
}
}`,DS=`void node_four_by_four_matrix(
float in00, float in01, float in02, float in03,
float in10, float in11, float in12, float in13,
float in20, float in21, float in22, float in23,
float in30, float in31, float in32, float in33,
out mat4 outMatrix)
{
outMatrix = mat4(in00, in01, in02, in03,
in10, in11, in12, in13,
in20, in21, in22, in23,
in30, in31, in32, in33);
}`,NS=`void node_gamma_correct(
vec3 gamma, vec3 value,
out vec3 outValue) {
outValue = pow(value, 1.0 / gamma);
}`,OS=`void node_grid(
float contrast, vec3 fillerColor, vec3 lineColor, float uWidth, float vWidth, vec2 uvCoord,
out float outAlpha, out vec3 outColor) {
uvCoord = fract(uvCoord); 
float v0 = max(uvCoord.y, 0.5 * vWidth);
float v1 = min(uvCoord.y, 1.0 - 0.5 * vWidth);
float u0 = max(uvCoord.x, 0.5 * uWidth);
float u1 = min(uvCoord.x, 1.0 - 0.5 * uWidth);
float gridFactor = (v0 <= v1 && u0 <= u1) ? 1.0 : 0.0;
gridFactor = 0.5 - contrast * (gridFactor - 0.5);
gridFactor = max(gridFactor, 0.0);
vec3 gridColor = mix(fillerColor, lineColor, gridFactor); 
gridColor.r = max(gridColor.r, 0.0);
gridColor.g = max(gridColor.g, 0.0);
gridColor.b = max(gridColor.b, 0.0);
outAlpha = saturate(gridFactor); 
outColor = gridColor; 
}`,FS=`
mat4 inverseMat4(mat4 m) {
float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];
float b00 = a00 * a11 - a01 * a10,
b01 = a00 * a12 - a02 * a10,
b02 = a00 * a13 - a03 * a10,
b03 = a01 * a12 - a02 * a11,
b04 = a01 * a13 - a03 * a11,
b05 = a02 * a13 - a03 * a12,
b06 = a20 * a31 - a21 * a30,
b07 = a20 * a32 - a22 * a30,
b08 = a20 * a33 - a23 * a30,
b09 = a21 * a32 - a22 * a31,
b10 = a21 * a33 - a23 * a31,
b11 = a22 * a33 - a23 * a32;
float det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
return mat4(a11 * b11 - a12 * b10 + a13 * b09,
a02 * b10 - a01 * b11 - a03 * b09,
a31 * b05 - a32 * b04 + a33 * b03,
a22 * b04 - a21 * b05 - a23 * b03,
a12 * b08 - a10 * b11 - a13 * b07,
a00 * b11 - a02 * b08 + a03 * b07,
a32 * b02 - a30 * b05 - a33 * b01,
a20 * b05 - a22 * b02 + a23 * b01,
a10 * b10 - a11 * b08 + a13 * b06,
a01 * b08 - a00 * b10 - a03 * b06,
a30 * b04 - a31 * b02 + a33 * b00,
a21 * b02 - a20 * b04 - a23 * b00,
a11 * b07 - a10 * b09 - a12 * b06,
a00 * b09 - a01 * b07 + a02 * b06,
a31 * b01 - a30 * b03 - a32 * b00,
a20 * b03 - a21 * b01 + a22 * b00) / det;
}
void node_inverse_matrix(
mat4 inputMatrix,
out mat4 outputMatrix)
{
outputMatrix = inverseMat4(inputMatrix);
}`,US=`void node_lambert(
vec3 geometryNormal,
vec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,
float diffuse, vec3 normal, float translucence, vec3 transparency,
out vec4 outColor) {
NodeMaterial material;
material.diffuseColor = diffuse * color.rgb;
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
#define RE_Direct RE_DirectDiffuseOnly_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
float alpha = 1.0 - average(transparency);
outColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + incandescence, alpha);
}`,zS=`#define LAYER_BLEND_MODE_NONE 0.0
#define LAYER_BLEND_MODE_OVER 1.0
#define LAYER_BLEND_MODE_IN 2.0
#define LAYER_BLEND_MODE_OUT 3.0
#define LAYER_BLEND_MODE_ADD 4.0
#define LAYER_BLEND_MODE_SUBTRACT 5.0
#define LAYER_BLEND_MODE_MULTIPLY 6.0
#define LAYER_BLEND_MODE_DIFFERENCE 7.0
#define LAYER_BLEND_MODE_LIGHTEN 8.0
#define LAYER_BLEND_MODE_DARKEN 9.0
#define LAYER_BLEND_MODE_SATURATE 10.0
#define LAYER_BLEND_MODE_DESATURATE 11.0
#define LAYER_BLEND_MODE_ILLUMINATE 12.0
void node_layered_texture_layer(
const float alphaBG, const vec3 colorBG, 
const vec3 color, const float alpha, const float blendMode, const bool isVisible,
out float outAlpha, out vec3 outColor)
{
outAlpha = alphaBG;
outColor = colorBG;
if (!isVisible)
return;
if (blendMode == LAYER_BLEND_MODE_NONE) {
outColor = color;
} else if (blendMode == LAYER_BLEND_MODE_OVER) {
outColor = mix(colorBG, color, alpha);
} else if (blendMode == LAYER_BLEND_MODE_IN) {
outColor = alpha * colorBG;
} else if (blendMode == LAYER_BLEND_MODE_OUT) {
outColor = (1.0 - alpha) * colorBG;
} else if (blendMode == LAYER_BLEND_MODE_ADD) {
outColor = mix(colorBG, colorBG + color, alpha);
} else if (blendMode == LAYER_BLEND_MODE_SUBTRACT) {
outColor = mix(colorBG, colorBG - color, alpha);
} else if (blendMode == LAYER_BLEND_MODE_MULTIPLY) {
outColor = mix(colorBG, colorBG * color, alpha);
} else {
outColor = mix(colorBG, color, alpha);
}
}`,VS=`void node_light_path(out float isCameraRay)
{
#if LIGHT_PATH_IS_CAM_RAY
isCameraRay = 1.0;
#else
isCameraRay = 0.0;
#endif
}`,GS=`void node_luminance(
vec3 value,
out float outValue) {
outValue = dot(value, LUM_WEIGHTS_MAYA);
}`,kS=`void node_multiply_divide(
int operation,
vec3 input1, vec3 input2,
out vec3 outValue) {
if (operation == 0) {
outValue = input1;
} else if (operation == 1) {
outValue = input1 * input2;
} else if (operation == 2) {

outValue = input1 / input2;
} else {
outValue = pow(input1, input2);
}
}`,QS=`void node_mult_double_linear(
float input1, float input2,
out float outValue) {
outValue = input1 * input2;
}`,WS=`
void node_mult_matrix(
mat4 matrixIn1,
out mat4 matrixSum)
{
matrixSum = matrixIn1;
}
void node_mult_matrix(
mat4 matrixIn1, mat4 matrixIn2,
out mat4 matrixSum)
{
matrixSum = matrixIn2 * matrixIn1;
}
void node_mult_matrix(
mat4 matrixIn1, mat4 matrixIn2, mat4 matrixIn3,
out mat4 matrixSum)
{
matrixSum = matrixIn3 * matrixIn2 * matrixIn1;
}`,HS=`vec2 calcNoiseImplode(float implode, vec2 implodeCenter, vec2 uv) {
if (abs(implode) >= EPSILON) {
uv -= implodeCenter;
float len = length(uv);
if (len > EPSILON) {
float factor = pow(len, 1.0-implode) / len;
uv *= factor;
}
uv += implodeCenter;
}
return uv;
}
void node_noise(
float amplitude, int depthMax, float frequency, float frequencyRatio, float implode,
vec2 implodeCenter, bool inflection, float ratio, float threshold, float time, vec2 uvCoord,
out float outAlpha, out vec3 outColor) {
uvCoord = calcNoiseImplode(implode, implodeCenter, uvCoord);
frequency *= 0.6;
amplitude *= 0.9;
uvCoord *= frequency;
float noiseAccum = 0.0;
vec2 freqOffset = vec2(0.02, 0.3);
#if __VERSION__ == 300
for (int depthId = 0; depthId < depthMax; depthId++) {
#else
for (int depthId = 0; depthId < 3; depthId++) {
#endif
int stepVal = depthId;
float noise = noisePerlin(vec3(uvCoord + freqOffset, time + 0.5 * float(stepVal)));
if (inflection)
noise = abs(noise);
noiseAccum += amplitude * noise;
uvCoord *= frequencyRatio;
time *= sqrt(frequencyRatio);
amplitude *= ratio;
freqOffset += vec2(0.02, 0.3);
}
if (!inflection)
noiseAccum = 0.5 * noiseAccum + 0.5;
noiseAccum += threshold;
outAlpha = min(1.0, noiseAccum);
outColor = vec3(outAlpha, outAlpha, outAlpha);
}`,XS=`void node_output(vec4 rgb, out vec4 outgoingLight)
{
outgoingLight = rgb;
}`,YS=`void node_phong(
vec3 geometryNormal,
vec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,
float diffuse, vec3 normal, float reflectivity, vec3 reflectedColor,
float cosinePower, vec3 specularColor, float translucence, vec3 transparency,
out vec4 outColor) {
NodeMaterial material;
material.diffuseColor = diffuse * color;
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
vec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));
float geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
float roughness = sqrt(1.0 / (0.454 * cosinePower + 3.357));
material.roughness = max(roughness, 0.0525);
material.roughness += geometryRoughness;
material.roughness = min(material.roughness, 1.0);
material.specularColor = specularColor;
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
float alpha = 1.0 - average(transparency);
outColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +
reflectedLight.directSpecular + reflectedLight.indirectSpecular + incandescence, alpha);
}`,jS=`void node_phong_e(
vec3 geometryNormal,
vec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,
float diffuse, vec3 normal, float reflectivity, vec3 reflectedColor,
float highlightSize, float roughness, vec3 specularColor, float translucence, vec3 transparency,
out vec4 outColor) {
NodeMaterial material;
material.diffuseColor = diffuse * color;
#ifdef USE_CLEARCOAT
#undef USE_CLEARCOAT
#define _CLEARCOAT_RESTORE
#endif
vec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));
float geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
material.roughness = max(roughness, 0.0525);
material.roughness += geometryRoughness;
material.roughness = min(material.roughness, 1.0);
material.specularColor = specularColor;
ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
#define RE_Direct RE_Direct_Node
#define RE_IndirectDiffuse RE_IndirectDiffuse_Node
#define RE_IndirectSpecular RE_IndirectSpecular_Node
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#undef RE_Direct
#undef RE_IndirectDiffuse
#undef RE_IndirectSpecular
#ifdef _CLEARCOAT_RESTORE
#undef _CLEARCOAT_RESTORE
#define USE_CLEARCOAT
#endif
float alpha = 1.0 - average(transparency);
outColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +
reflectedLight.directSpecular + reflectedLight.indirectSpecular + incandescence, alpha);
}`,KS=`void node_place_2d_texture(const vec2 inUv,
vec2 offset, vec2 repeatUv, float rotateUv,
out vec2 outUv)
{
outUv = (calcUvTransform(offset.x, offset.y, repeatUv.x, repeatUv.y, rotateUv) * vec3(inUv, 1.0)).xy;
outUv.y = 1.0 - outUv.y;
}`,qS=`void node_premultiply(
float inAlpha, vec3 inColor,
out float outAlpha, out vec3 outColor) {
outColor = inColor * inAlpha;
outAlpha = inAlpha;
}`,ZS=`void node_ramp(
sampler2D rampData, int rampType,
vec2 uvCoord,
out float outAlpha, out vec3 outColor)
{
float coord;
if (rampType == 0) {
coord = uvCoord.y;
} else if (rampType == 1) {
coord = uvCoord.x;
} else if (rampType == 2) {
coord = abs(uvCoord.x + uvCoord.y) / 2.0;
} else if (rampType == 3) {
vec2 uvSpiral = mat2(0.0, 1.0, 1.0, 0.0) * (uvCoord - vec2(0.5));
coord = atan(uvSpiral.y, uvSpiral.x) / PI2 + 0.5;
} else if (rampType == 4) {
coord = length(uvCoord - vec2(0.5)) * sqrt(2.0);
} else if (rampType == 5) {
vec2 boxUv = abs(uvCoord - vec2(0.5)) * 2.0;
coord = max(boxUv.x, boxUv.y);
} else if (rampType == 6) {
uvCoord = abs((uvCoord - vec2(0.5)) * 2.0);
coord = uvCoord.y;
} else if (rampType == 7) {
coord = uvCoord.y;
} else {
coord = uvCoord.y;
}
vec4 tex = texture2D(rampData, vec2(coord, 0.0));
outAlpha = average(tex.xyz);
outColor = tex.xyz;
}`,JS=`void node_remap_hsv(vec3 color, out vec3 outColor)
{
outColor = color;
}`,$S=`void node_reverse(
vec3 inValue,
out vec3 outValue) {
outValue = 1.0 - inValue;
}`,eM=`void node_sampler_info(
float frontFacing, vec4 tangent, vec2 uv,
vec3 viewNorm,
out float facingRatio, out bool flippedNormal, out mat4 matrixEyeToWorld,
out vec3 normalCamera, out vec2 pixelCenter, out vec3 pointCamera,
out vec3 pointObj, out vec3 pointWorld,
out vec3 tangentUCamera, out vec3 tangentVCamera, out vec2 uvCoord)
{
vec4 worldPos = invViewMatrix * vec4(-vViewPosition, 1.0);
facingRatio = dot(normalize(viewNorm), normalize(vViewPosition));
flippedNormal = (frontFacing > 0.0);
matrixEyeToWorld = invViewMatrix;
normalCamera = viewNorm;
pixelCenter = vec2(1.0);
pointCamera = -vViewPosition;
pointObj = (invModelMatrix * worldPos).xyz;
pointWorld = worldPos.xyz;
tangentUCamera = normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz);
tangentVCamera = tangent.w * cross(viewNorm, tangentUCamera);
uvCoord = vec2(uv.x, 1.0-uv.y);
}`,tM=`void node_set_range(
vec3 maxValue, vec3 minValue, vec3 oldMax, vec3 oldMin, vec3 value,
out vec3 outValue) {
outValue = minValue + (((value - oldMin) / (oldMax - oldMin)) * (maxValue - minValue));
}`,nM=`void node_shading_engine(vec4 surface, vec4 volume, vec3 displacement, out vec4 outgoingLight) {
outgoingLight = surface + volume;
}`,iM=`void node_surface_shader(
vec3 color, vec3 glowColor, vec3 matteOpacity, vec3 transparency,
out vec3 outColor, out vec3 outGlowColor, out vec3 outMatteOpacity, out vec3 outTransparency)
{
outColor = color;
outGlowColor = glowColor;
outMatteOpacity = matteOpacity;
outTransparency = transparency;
}`,oM=`void node_transform(
out vec3 center, out mat4 inverseMatrix, out mat4 matrix,
out mat4 parentInverseMatrix, out mat4 parentMatrix, out mat4 worldInverseMatrix,
out mat4 worldMatrix, out mat4 xformMatrix)
{
center = modelMatrix[3].xyz;
inverseMatrix = invModelMatrix;
matrix = modelMatrix;
parentInverseMatrix = mat4(1.0);
parentMatrix = mat4(1.0);
worldInverseMatrix = invModelMatrix;
worldMatrix = modelMatrix;
xformMatrix = matrix;
}`,rM=`mat4 transposeMat4(mat4 m) {
return mat4(vec4(m[0].x, m[1].x, m[2].x, m[3].x),
vec4(m[0].y, m[1].y, m[2].y, m[3].y),
vec4(m[0].z, m[1].z, m[2].z, m[3].z),
vec4(m[0].w, m[1].w, m[2].w, m[3].w));
}
void node_transpose_matrix(
mat4 inputMatrix,
out mat4 outputMatrix)
{
outputMatrix = transposeMat4(inputMatrix);
}`,aM=`void node_unit_conversion(float conversionFactor, float inInput, out float outOutput)
{
outOutput = conversionFactor * inInput;
}
void node_unit_conversion(float conversionFactor, vec3 inInput, out vec3 outOutput)
{
outOutput = conversionFactor * inInput;
}`,sM=`void node_unpremultiply(
float inAlpha, vec3 inColor,
out float outAlpha, out vec3 outColor) {
outColor = inColor / inAlpha;
outAlpha = inAlpha;
}`,lM=`void node_vector_product(
const int operation, const bool normalizeOutput,
vec3 input1, vec3 input2, mat4 matrix,
out vec3 outVector) {
if (operation == 0) {
outVector = input1;
} else if (operation == 1) {
if (normalizeOutput) {
input1 = normalize(input1);
input2 = normalize(input2);
}
outVector = vec3(dot(input1, input2));
} else if (operation == 2) {
outVector = cross(input1, input2);
} else if (operation == 3) {
outVector = (matrix * vec4(input1, 0.0)).xyz;
} else {
outVector = (matrix * vec4(input1, 1.0)).xyz;
}

if (operation > 1 && normalizeOutput)
outVector = normalize(outVector);
}`,cM=`void node_wt_add_matrix(
mat4 matrixIn1, float weightIn1,
out mat4 matrixSum)
{
matrixSum = weightIn1 * matrixIn1;
}
void node_wt_add_matrix(
mat4 matrixIn1, float weightIn1, mat4 matrixIn2, float weightIn2,
out mat4 matrixSum)
{
matrixSum = weightIn1 * matrixIn1 + weightIn2 * matrixIn2;
}
void node_wt_add_matrix(
mat4 matrixIn1, float weightIn1, mat4 matrixIn2, float weightIn2, mat4 matrixIn3, float weightIn3,
out mat4 matrixSum)
{
matrixSum = weightIn1 * matrixIn1 + weightIn2 * matrixIn2 + weightIn3 * matrixIn3;
}`,uM=`varying vec2 vUv;
void main() {
vUv = uv;
gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`,dM=`varying vec2 vUv;
uniform sampler2D tRGBABuffer;
uniform sampler2D tFloatBuffer;
void main() {
vec4 color = texture2D(tRGBABuffer, vUv);
vec3 colorSum = color.rgb;
float alphaProduct = color.a;
float alphaSum = texture2D(tFloatBuffer, vUv).r;
gl_FragColor = vec4(colorSum.rgb / max(alphaSum, 1e-5), 1.0 - alphaProduct);
}`,hM=`uniform float damp;
uniform sampler2D tOld;
uniform sampler2D tNew;
varying vec2 vUv;
vec4 when_gt(vec4 x, float y) {
return max(sign(x - y), 0.0);
}
void main() {
vec4 texelOld = texture2D(tOld, vUv);
vec4 texelNew = texture2D(tNew, vUv);

texelOld *= damp * when_gt(texelOld, 0.1);
gl_FragColor = max(texelNew, texelOld);
}`,pM=`varying vec2 vUv;
uniform sampler2D blurTexture1;
uniform sampler2D blurTexture2;
uniform sampler2D blurTexture3;
uniform sampler2D blurTexture4;
uniform sampler2D blurTexture5;
uniform sampler2D dirtTexture;
uniform float bloomStrength;
uniform float bloomRadius;
uniform float bloomFactors[NUM_MIPS];
uniform vec3 bloomTintColors[NUM_MIPS];
float lerpBloomFactor(const in float factor) {
float mirrorFactor = 1.2 - factor;
return mix(factor, mirrorFactor, bloomRadius);
}
void main() {
gl_FragColor = bloomStrength * (
lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv)
);
}`,fM=`uniform sampler2D tDiffuse;
uniform vec3 defaultColor;
uniform float defaultOpacity;
uniform float luminosityThreshold;
uniform float smoothWidth;
varying vec2 vUv;
void main() {
vec4 texel = texture2D(tDiffuse, vUv);
vec3 luma = vec3(0.299, 0.587, 0.114);
float v = dot(texel.xyz, luma);
vec4 outputColor = vec4(defaultColor.rgb, defaultOpacity);
float alpha = smoothstep(luminosityThreshold, luminosityThreshold + smoothWidth, v);
gl_FragColor = mix(outputColor, texel, alpha);
gl_FragColor = clamp(gl_FragColor, 0.0, 10.0);
}`,mM=`#include <common>
varying vec2 vUv;
uniform sampler2D colorTexture;
uniform vec2 texSize;
uniform vec2 direction;
float gaussianPdf(in float x, in float sigma) {
return 0.39894 * exp(-0.5 * x * x/(sigma * sigma)) / sigma;
}
void main() {
vec2 invSize = 1.0 / texSize;
float fSigma = float(SIGMA);
float weightSum = gaussianPdf(0.0, fSigma);
vec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;
for (int i = 1; i < KERNEL_RADIUS; i++) {
float x = float(i);
float w = gaussianPdf(x, fSigma);
vec2 uvOffset = direction * invSize * x;
vec3 sample1 = texture2D(colorTexture, vUv + uvOffset).rgb;
vec3 sample2 = texture2D(colorTexture, vUv - uvOffset).rgb;
diffuseSum += (sample1 + sample2) * w;
weightSum += 2.0 * w;
}
gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
}`,gM=`#include <common>
varying vec2 vUv;
uniform sampler2D colorTexture;
uniform vec2 texSize;
uniform vec2 direction;
uniform float kernelRadius;
float gaussianPdf(in float x, in float sigma) {
return 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;
}
void main() {
vec2 invSize = 1.0 / texSize;
float weightSum = gaussianPdf(0.0, kernelRadius);
#if LOG_SPACE == 1
float origDiffuse = texture2D(colorTexture, vUv).r;
float diffuseSum = weightSum;
#else
float diffuseSum = texture2D(colorTexture, vUv).r * weightSum;
#endif
vec2 delta = direction * invSize * kernelRadius/float(MAX_SAMPLE_RADIUS);
vec2 uvOffset = delta;
#if OCTAHEDRAL_MAP == 1
vec3 cubeDir = normalize(octUVToCubeVec(vUv, invSize));
vec3 dirX = normalize(abs(cubeDir.y) < 0.99999 ? vec3(cubeDir.z, 0.0, -cubeDir.x)
: vec3(0.0, -cubeDir.z, cubeDir.y));
vec3 dirY = cross(cubeDir, dirX);
#endif
#pragma unroll_loop_start
for (int i = 1; i <= MAX_SAMPLE_RADIUS; i++) {
float w = gaussianPdf(uvOffset.x, kernelRadius);
#if OCTAHEDRAL_MAP == 1
vec3 cubeOffset = uvOffset.x * dirX + uvOffset.y * dirY;
vec2 uv1 = cubeVecToOctUV(cubeDir + cubeOffset, invSize);
vec2 uv2 = cubeVecToOctUV(cubeDir - cubeOffset, invSize);
#else
vec2 uv1 = vUv + uvOffset;
vec2 uv2 = vUv - uvOffset;
#endif
float sample1 = texture2D(colorTexture, uv1).r;
float sample2 = texture2D(colorTexture, uv2).r;
#if LOG_SPACE == 1
diffuseSum += (
clamp(exp(sample1 - origDiffuse), 0.0, 1e38) +
clamp(exp(sample2 - origDiffuse), 0.0, 1e38)
) * w;
#else
diffuseSum += ((sample1 + sample2) * w);
#endif
weightSum += 2.0 * w;
uvOffset += delta;
}
#pragma unroll_loop_end
#if LOG_SPACE == 1
gl_FragColor = vec4(origDiffuse + log(diffuseSum/weightSum), 0.0, 0.0, 1.0);
#else
gl_FragColor = vec4(diffuseSum/weightSum, 0.0, 0.0, 1.0);
#endif
}`,vM=`#include <common>
varying vec2 vUv;
uniform sampler2D tColor;
uniform sampler2D tDepth;
uniform float maxblur;
uniform float aperture;
uniform float nearClip;
uniform float farClip;
uniform float focus;
uniform float aspect;
uniform float depthLeakThreshold;
#include <packing>
float getDepth(const in vec2 screenPosition) {
#if DEPTH_PACKING == 1
return unpackRGBAToDepth(texture2D(tDepth, screenPosition));
#else
return texture2D(tDepth, screenPosition).x;
#endif
}
float getViewZ(const in float depth) {
#if PERSPECTIVE_CAMERA == 1
return perspectiveDepthToViewZ(depth, nearClip, farClip);
#else
return orthoDepthToViewZ(depth, nearClip, farClip);
#endif
}
vec4 blurSample(vec2 uvOffset, vec4 centerCol, float viewZCenter) {
float viewZ = -getViewZ(getDepth(vUv + uvOffset));
float blurFactor = (viewZ >= viewZCenter) ? 1.0 : 
min(depthLeakThreshold * abs((focus - viewZ) / aperture), 1.0);
return mix(centerCol, texture2D(tColor, vUv + uvOffset), blurFactor);
}
void main() {
vec2 aspectcorrect = vec2(1.0, aspect);
float viewZ = -getViewZ(getDepth(vUv));
float factor = abs(focus - viewZ);

float dofblur = maxblur * min(factor / aperture, 1.0);
float dofblur9 = dofblur * 0.9;
float dofblur7 = dofblur * 0.7;
float dofblur4 = dofblur * 0.4;
vec4 centerCol = texture2D(tColor, vUv);
vec4 col = centerCol;
col += blurSample((vec2( 0.0, 0.4 ) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2( 0.15, 0.37) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2( 0.29, 0.29) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2(-0.37, 0.15) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2( 0.40, 0.0 ) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2( 0.37, -0.15) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2(-0.15, -0.37) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2( 0.0, -0.4 ) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2(-0.15, 0.37) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2(-0.29, 0.29) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2( 0.37, 0.15) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2(-0.4, 0.0 ) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2(-0.37, -0.15) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur, centerCol, viewZ);
col += blurSample((vec2( 0.15, -0.37) * aspectcorrect) * dofblur, centerCol, viewZ);

col += blurSample((vec2( 0.15, 0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);
col += blurSample((vec2(-0.37, 0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);
col += blurSample((vec2( 0.37, -0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);
col += blurSample((vec2(-0.15, -0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);
col += blurSample((vec2(-0.15, 0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);
col += blurSample((vec2( 0.37, 0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);
col += blurSample((vec2(-0.37, -0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);
col += blurSample((vec2( 0.15, -0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);

col += blurSample((vec2( 0.29, 0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);
col += blurSample((vec2( 0.40, 0.0 ) * aspectcorrect) * dofblur7, centerCol, viewZ);
col += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);
col += blurSample((vec2( 0.0, -0.4 ) * aspectcorrect) * dofblur7, centerCol, viewZ);
col += blurSample((vec2(-0.29, 0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);
col += blurSample((vec2(-0.4, 0.0 ) * aspectcorrect) * dofblur7, centerCol, viewZ);
col += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);
col += blurSample((vec2( 0.0, 0.4 ) * aspectcorrect) * dofblur7, centerCol, viewZ);

col += blurSample((vec2( 0.29, 0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);
col += blurSample((vec2( 0.4, 0.0 ) * aspectcorrect) * dofblur4, centerCol, viewZ);
col += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);
col += blurSample((vec2( 0.0, -0.4 ) * aspectcorrect) * dofblur4, centerCol, viewZ);
col += blurSample((vec2(-0.29, 0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);
col += blurSample((vec2(-0.4, 0.0 ) * aspectcorrect) * dofblur4, centerCol, viewZ);
col += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);
col += blurSample((vec2( 0.0, 0.4 ) * aspectcorrect) * dofblur4, centerCol, viewZ);
gl_FragColor = col / 41.0;
gl_FragColor.a = centerCol.a;
}`,_M=`
uniform sampler2D tDiffuse;
uniform float brightness;
uniform float contrast;
varying vec2 vUv;
void main() {
vec4 texel = texture2D(tDiffuse, vUv);
texel.rgb += brightness;
if (contrast > 0.0)
texel.rgb = (texel.rgb - 0.5) / (1.0 - contrast) + 0.5;
else
texel.rgb = (texel.rgb - 0.5) * (1.0 + contrast) + 0.5;
gl_FragColor = texel;
}`,AM=`uniform sampler2D tDiffuse;
uniform float opacity;
varying vec2 vUv;
void main() {
vec4 texel = (texture2D(tDiffuse, vUv));
gl_FragColor = opacity * texel;
}`,xM=`#include <common>
uniform samplerCube tCube;
uniform vec2 texelSize;
varying vec2 vUv;
void main() {
gl_FragColor = textureCube(tCube, octUVToCubeVec(gl_FragCoord.xy * texelSize,
texelSize));
}`,yM=`precision highp float;
uniform sampler2D tDiffuse;
uniform vec2 resolution;
varying vec2 vUv;
#ifndef FXAA_GLSL_120
#define FXAA_GLSL_120 0
#endif
#ifndef FXAA_GLSL_130
#define FXAA_GLSL_130 0
#endif
#ifndef FXAA_GREEN_AS_LUMA
#define FXAA_GREEN_AS_LUMA 0
#endif
#ifndef FXAA_EARLY_EXIT
#define FXAA_EARLY_EXIT 1
#endif
#ifndef FXAA_DISCARD
#define FXAA_DISCARD 1
#endif
#ifndef FXAA_FAST_PIXEL_OFFSET
#ifdef GL_EXT_gpu_shader4
#define FXAA_FAST_PIXEL_OFFSET 1
#endif
#ifdef GL_NV_gpu_shader5
#define FXAA_FAST_PIXEL_OFFSET 1
#endif
#ifdef GL_ARB_gpu_shader5
#define FXAA_FAST_PIXEL_OFFSET 1
#endif
#ifndef FXAA_FAST_PIXEL_OFFSET
#define FXAA_FAST_PIXEL_OFFSET 0
#endif
#endif
#ifndef FXAA_QUALITY_PRESET
#define FXAA_QUALITY_PRESET 12
#endif
#if (FXAA_QUALITY_PRESET == 10)
#define FXAA_QUALITY_PS 3
#define FXAA_QUALITY_P0 1.5
#define FXAA_QUALITY_P1 3.0
#define FXAA_QUALITY_P2 12.0
#endif
#if (FXAA_QUALITY_PRESET == 11)
#define FXAA_QUALITY_PS 4
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 3.0
#define FXAA_QUALITY_P3 12.0
#endif
#if (FXAA_QUALITY_PRESET == 12)
#define FXAA_QUALITY_PS 5
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 4.0
#define FXAA_QUALITY_P4 12.0
#endif
#if (FXAA_QUALITY_PRESET == 13)
#define FXAA_QUALITY_PS 6
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 4.0
#define FXAA_QUALITY_P5 12.0
#endif
#if (FXAA_QUALITY_PRESET == 14)
#define FXAA_QUALITY_PS 7
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 4.0
#define FXAA_QUALITY_P6 12.0
#endif
#if (FXAA_QUALITY_PRESET == 15)
#define FXAA_QUALITY_PS 8
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 4.0
#define FXAA_QUALITY_P7 12.0
#endif
#if (FXAA_QUALITY_PRESET == 20)
#define FXAA_QUALITY_PS 3
#define FXAA_QUALITY_P0 1.5
#define FXAA_QUALITY_P1 2.0
#define FXAA_QUALITY_P2 8.0
#endif
#if (FXAA_QUALITY_PRESET == 21)
#define FXAA_QUALITY_PS 4
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 8.0
#endif
#if (FXAA_QUALITY_PRESET == 22)
#define FXAA_QUALITY_PS 5
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 8.0
#endif
#if (FXAA_QUALITY_PRESET == 23)
#define FXAA_QUALITY_PS 6
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 8.0
#endif
#if (FXAA_QUALITY_PRESET == 24)
#define FXAA_QUALITY_PS 7
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 3.0
#define FXAA_QUALITY_P6 8.0
#endif
#if (FXAA_QUALITY_PRESET == 25)
#define FXAA_QUALITY_PS 8
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 4.0
#define FXAA_QUALITY_P7 8.0
#endif
#if (FXAA_QUALITY_PRESET == 26)
#define FXAA_QUALITY_PS 9
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 2.0
#define FXAA_QUALITY_P7 4.0
#define FXAA_QUALITY_P8 8.0
#endif
#if (FXAA_QUALITY_PRESET == 27)
#define FXAA_QUALITY_PS 10
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 2.0
#define FXAA_QUALITY_P7 2.0
#define FXAA_QUALITY_P8 4.0
#define FXAA_QUALITY_P9 8.0
#endif
#if (FXAA_QUALITY_PRESET == 28)
#define FXAA_QUALITY_PS 11
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 2.0
#define FXAA_QUALITY_P7 2.0
#define FXAA_QUALITY_P8 2.0
#define FXAA_QUALITY_P9 4.0
#define FXAA_QUALITY_P10 8.0
#endif
#if (FXAA_QUALITY_PRESET == 29)
#define FXAA_QUALITY_PS 12
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 2.0
#define FXAA_QUALITY_P7 2.0
#define FXAA_QUALITY_P8 2.0
#define FXAA_QUALITY_P9 2.0
#define FXAA_QUALITY_P10 4.0
#define FXAA_QUALITY_P11 8.0
#endif
#if (FXAA_QUALITY_PRESET == 39)
#define FXAA_QUALITY_PS 12
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.0
#define FXAA_QUALITY_P2 1.0
#define FXAA_QUALITY_P3 1.0
#define FXAA_QUALITY_P4 1.0
#define FXAA_QUALITY_P5 1.5
#define FXAA_QUALITY_P6 2.0
#define FXAA_QUALITY_P7 2.0
#define FXAA_QUALITY_P8 2.0
#define FXAA_QUALITY_P9 2.0
#define FXAA_QUALITY_P10 4.0
#define FXAA_QUALITY_P11 8.0
#endif
#if 1
#define FxaaBool bool
#define FxaaDiscard discard
#define FxaaFloat float
#define FxaaFloat2 vec2
#define FxaaFloat3 vec3
#define FxaaFloat4 vec4
#define FxaaHalf float
#define FxaaHalf2 vec2
#define FxaaHalf3 vec3
#define FxaaHalf4 vec4
#define FxaaInt2 ivec2
#define FxaaSat(x) clamp(x, 0.0, 1.0)
#define FxaaTex sampler2D
#endif
#if (FXAA_GLSL_100 == 1)
#define FxaaTexTop(t, p) texture2D(t, p, 0.0)
#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)
#endif
#if (FXAA_GLSL_120 == 1)
#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)
#if (FXAA_FAST_PIXEL_OFFSET == 1)
#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)
#else
#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)
#endif
#endif
#if (FXAA_GLSL_130 == 1)
#define FxaaTexTop(t, p) textureLod(t, p, 0.0)
#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
#endif
#if (FXAA_GREEN_AS_LUMA == 0)
FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }
#else
FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }
#endif
FxaaFloat4 FxaaPixelShader(
FxaaFloat2 pos,
FxaaFloat4 fxaaConsolePosPos,
FxaaTex tex,
FxaaTex fxaaConsole360TexExpBiasNegOne,
FxaaTex fxaaConsole360TexExpBiasNegTwo,
FxaaFloat2 fxaaQualityRcpFrame,
FxaaFloat4 fxaaConsoleRcpFrameOpt,
FxaaFloat4 fxaaConsoleRcpFrameOpt2,
FxaaFloat4 fxaaConsole360RcpFrameOpt2,
FxaaFloat fxaaQualitySubpix,
FxaaFloat fxaaQualityEdgeThreshold,
FxaaFloat fxaaQualityEdgeThresholdMin
) {
FxaaFloat2 posM;
posM.x = pos.x;
posM.y = pos.y;
#if 1
FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
#if (FXAA_GREEN_AS_LUMA == 0)
#define lumaM rgbyM.w
#else
#define lumaM rgbyM.y
#endif
#if (FXAA_GLSL_100 == 1)
FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, 1.0), fxaaQualityRcpFrame.xy));
FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 0.0), fxaaQualityRcpFrame.xy));
FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0,-1.0), fxaaQualityRcpFrame.xy));
FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));
#else
FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, 1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 0), fxaaQualityRcpFrame.xy));
FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0,-1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
#endif
#endif
FxaaFloat maxSM = max(lumaS, lumaM);
FxaaFloat minSM = min(lumaS, lumaM);
FxaaFloat maxESM = max(lumaE, maxSM);
FxaaFloat minESM = min(lumaE, minSM);
FxaaFloat maxWN = max(lumaN, lumaW);
FxaaFloat minWN = min(lumaN, lumaW);
FxaaFloat rangeMax = max(maxWN, maxESM);
FxaaFloat rangeMin = min(minWN, minESM);
FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
FxaaFloat range = rangeMax - rangeMin;
FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
FxaaBool earlyExit = range < rangeMaxClamped;
if(earlyExit)
#if (FXAA_DISCARD == 1)
return rgbyM;
#else
return rgbyM;
#endif
#if 1
#if (FXAA_GLSL_100 == 1)
FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));
FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 1.0), fxaaQualityRcpFrame.xy));
FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0,-1.0), fxaaQualityRcpFrame.xy));
FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));
#else
FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1,-1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
#endif
#else
FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
#endif
FxaaFloat lumaNS = lumaN + lumaS;
FxaaFloat lumaWE = lumaW + lumaE;
FxaaFloat subpixRcpRange = 1.0/range;
FxaaFloat subpixNSWE = lumaNS + lumaWE;
FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
FxaaFloat lumaNESE = lumaNE + lumaSE;
FxaaFloat lumaNWNE = lumaNW + lumaNE;
FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
FxaaFloat lumaNWSW = lumaNW + lumaSW;
FxaaFloat lumaSWSE = lumaSW + lumaSE;
FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
FxaaBool horzSpan = edgeHorz >= edgeVert;
FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
if(!horzSpan) lumaN = lumaW;
if(!horzSpan) lumaS = lumaE;
if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
FxaaFloat gradientN = lumaN - lumaM;
FxaaFloat gradientS = lumaS - lumaM;
FxaaFloat lumaNN = lumaN + lumaM;
FxaaFloat lumaSS = lumaS + lumaM;
FxaaBool pairN = abs(gradientN) >= abs(gradientS);
FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
if(pairN) lengthSign = -lengthSign;
FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
FxaaFloat2 posB;
posB.x = posM.x;
posB.y = posM.y;
FxaaFloat2 offNP;
offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
offNP.y = (horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
if(!horzSpan) posB.x += lengthSign * 0.5;
if(horzSpan) posB.y += lengthSign * 0.5;
FxaaFloat2 posN;
posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
FxaaFloat2 posP;
posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
FxaaFloat subpixE = subpixC * subpixC;
FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
if(!pairN) lumaNN = lumaSS;
FxaaFloat gradientScaled = gradient * 1.0/4.0;
FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
FxaaFloat subpixF = subpixD * subpixE;
FxaaBool lumaMLTZero = lumaMM < 0.0;
lumaEndN -= lumaNN * 0.5;
lumaEndP -= lumaNN * 0.5;
FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
FxaaBool doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
#if (FXAA_QUALITY_PS > 3)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
#if (FXAA_QUALITY_PS > 4)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
#if (FXAA_QUALITY_PS > 5)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
#if (FXAA_QUALITY_PS > 6)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
#if (FXAA_QUALITY_PS > 7)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
#if (FXAA_QUALITY_PS > 8)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
#if (FXAA_QUALITY_PS > 9)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
#if (FXAA_QUALITY_PS > 10)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
#if (FXAA_QUALITY_PS > 11)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
#if (FXAA_QUALITY_PS > 12)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
FxaaFloat dstN = posM.x - posN.x;
FxaaFloat dstP = posP.x - posM.x;
if(!horzSpan) dstN = posM.y - posN.y;
if(!horzSpan) dstP = posP.y - posM.y;
FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
FxaaFloat spanLength = (dstP + dstN);
FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
FxaaFloat spanLengthRcp = 1.0/spanLength;
FxaaBool directionN = dstN < dstP;
FxaaFloat dst = min(dstN, dstP);
FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
FxaaFloat subpixG = subpixF * subpixF;
FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
if(horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
#if (FXAA_DISCARD == 1)
return FxaaTexTop(tex, posM);
#else
return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
#endif
}
void main() {
gl_FragColor = FxaaPixelShader(
vUv,
vec4(0.0),
tDiffuse,
tDiffuse,
tDiffuse,
resolution,
vec4(0.0),
vec4(0.0),
vec4(0.0),
0.75,
0.166,
0.0833
);
}`,bM=`uniform sampler2D tDiffuse;
varying vec2 vUv;
void main() {
vec4 texel = texture2D(tDiffuse, vUv);
float bw = texel.r * 0.35 + texel.g * 0.45 + texel.b * 0.2;
texel = vec4(bw, bw, bw, texel.a);
gl_FragColor = texel;
}`,CM=`uniform sampler2D tDiffuse;
uniform sampler2D tNormal;
uniform vec2 direction;
uniform vec2 resolution;
varying vec2 vUv;
#include <packing>
const float SIGMA_SPATIAL = 1.5;
const float SIGMA_INTENSITY = 0.01;
float gaussianPdf(float x, float sigma) {
return 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;
}
void main() {
float weightSum = gaussianPdf(0.0, SIGMA_SPATIAL)
* gaussianPdf(0.0, SIGMA_INTENSITY);
vec4 diffSample = texture2D(tDiffuse, vUv);
vec4 gtaoDataSum = vec4(diffSample.r, unpackRGBToNormal(diffSample.gba)) * weightSum;
vec3 normCenter = unpackRGBToNormal(texture2D(tNormal, vUv).xyz);
vec2 delta = direction / resolution;
vec2 offset = delta;
#pragma unroll_loop_start
for (int i = 1; i <= BLUR_RADIUS_PX; i++) {
vec2 uvCoords0 = vUv + offset;
vec2 uvCoords1 = vUv - offset;
vec4 diffSample0 = texture2D(tDiffuse, uvCoords0);
vec4 diffSample1 = texture2D(tDiffuse, uvCoords1);
vec4 gtaoData0 = vec4(diffSample0.r, unpackRGBToNormal(diffSample0.gba));
vec4 gtaoData1 = vec4(diffSample1.r, unpackRGBToNormal(diffSample1.gba));
vec3 normSample0 = unpackRGBToNormal(texture2D(tNormal, uvCoords0).xyz);
vec3 normSample1 = unpackRGBToNormal(texture2D(tNormal, uvCoords1).xyz);
float weightSpatial = gaussianPdf(float(i), SIGMA_SPATIAL);
float weight0 = weightSpatial * gaussianPdf(1.0 - max(0.0,
dot(normCenter, normSample0)), SIGMA_INTENSITY);
float weight1 = weightSpatial * gaussianPdf(1.0 - max(0.0,
dot(normCenter, normSample1)), SIGMA_INTENSITY);
weightSum += weight0 + weight1;
gtaoDataSum += weight0 * gtaoData0 + weight1 * gtaoData1;
offset += delta;
}
#pragma unroll_loop_end
float visibility = gtaoDataSum.r / weightSum;
vec3 bentNormal = normalize(gtaoDataSum.gba);
gl_FragColor = vec4(visibility, packNormalToRGB(bentNormal));
}`,SM=`uniform sampler2D tNormal;
uniform sampler2D tDepth;
uniform sampler2D tNoise;
uniform float occlDistance;
uniform float factor;
uniform float occlPrecision;
uniform bool bounceApprox;
uniform mat4 mainCameraProjMat;
uniform vec2 resolution;
varying vec2 vUv;
#include <common>
#include <packing>
const vec3 AXIS_Z = vec3(0.0, 0.0, 1.0);
const float NUM_SAMPLES_HALF_MIN = 4.0;
const float NUM_SAMPLES_HALF_MAX = 8.0;
const float NOISE_TEX_SIZE = 32.0;
const float NEAR_FIELD_COEFF = 0.5;
const float SELF_OCCL_BIAS = -1e-5;
const float NORMAL_RENDER_GEOM_MAX_DIFF_ANGLE = 0.85 * PI_HALF;
float integrateArc(vec2 horizonAngles, float normalAngle) {
vec2 visCoeffs = (-cos(2.0 * horizonAngles - normalAngle) + cos(normalAngle)
+ 2.0 * horizonAngles * sin(normalAngle)) / 4.0;
return visCoeffs.x + visCoeffs.y;
}
vec3 calcViewFromUVDepth(vec2 uv, float depth, float zBias) {
vec3 ndcCo = 2.0 * vec3(uv, depth) - 1.0;
#if ORTHO_CAMERA == 1
float viewZ = (ndcCo.z - mainCameraProjMat[3][2]) / mainCameraProjMat[2][2] + zBias;
vec2 _00_11 = vec2(mainCameraProjMat[0][0], mainCameraProjMat[1][1]);
vec2 _30_31 = vec2(mainCameraProjMat[3][0], mainCameraProjMat[3][1]);
return vec3((ndcCo.xy - _30_31) / _00_11, viewZ);
#else
float viewZ = -mainCameraProjMat[3][2] / (mainCameraProjMat[2][2] + ndcCo.z) + zBias;
vec2 _00_11 = vec2(mainCameraProjMat[0][0], mainCameraProjMat[1][1]);
vec2 _20_21 = vec2(mainCameraProjMat[2][0], mainCameraProjMat[2][1]);
return vec3(-viewZ * (ndcCo.xy + _20_21) / _00_11, viewZ);
#endif
}
vec2 calcSliceRadiusUV(float viewZ) {
vec4 distView = vec4(occlDistance, occlDistance, viewZ, 1.0);
vec4 distClip = mainCameraProjMat * distView;
vec2 xyNDC = distClip.xy / distClip.w;
return clamp(0.5 * xyNDC, 0.0, 0.5);
}
vec2 calcHorizonAngles(vec3 viewPos, vec3 viewVec, vec2 sliceDir,
float offsetNoise) {
vec2 maxHorizonCos = vec2(-1.0);
vec2 sliceRadius = calcSliceRadiusUV(viewPos.z);
vec2 pxSize = 1.0 / resolution;
int NUM_SAMPLES_HALF = int(occlPrecision
* (NUM_SAMPLES_HALF_MAX - NUM_SAMPLES_HALF_MIN) + NUM_SAMPLES_HALF_MIN);
#if __VERSION__ == 300
for (int i = 0; i < NUM_SAMPLES_HALF; i++) {
#else
for (int i = 0; i < int(NUM_SAMPLES_HALF_MAX); i++) {
if (i >= NUM_SAMPLES_HALF) continue;
#endif
vec2 offset = sliceDir * (pxSize * (1.0 + float(i))
+ sliceRadius * pow((float(i) + offsetNoise) / float(NUM_SAMPLES_HALF), 2.0));
vec2 uvs = vUv - offset;
vec3 ps = calcViewFromUVDepth(uvs, texture2D(tDepth, uvs).x, SELF_OCCL_BIAS);
vec3 ds = normalize(ps - viewPos);
vec2 uvt = vUv + offset;
vec3 pt = calcViewFromUVDepth(uvt, texture2D(tDepth, uvt).x, SELF_OCCL_BIAS);
vec3 dt = normalize(pt - viewPos);
vec2 sampleLen = vec2(length(ps - viewPos), length(pt - viewPos));
vec2 blendWeight = (sampleLen / occlDistance - 1.0) / (NEAR_FIELD_COEFF - 1.0);
blendWeight = clamp(blendWeight, 0.0, 1.0);
vec2 maxHorizonCosNoBlending = max(maxHorizonCos, vec2(dot(ds, viewVec),
dot(dt, viewVec)));
maxHorizonCos = mix(maxHorizonCos, maxHorizonCosNoBlending, blendWeight);
}
vec2 horizons = acos(maxHorizonCos);
return vec2(-horizons.x, horizons.y);
}
vec2 calcNormalAngleAndProjLen(vec3 viewVec, vec3 normal, vec2 sliceDir) {
vec3 sliceVec = vec3(sliceDir, 0.0);
sliceVec = sliceVec - dot(sliceVec, viewVec) * viewVec;
vec3 sliceOrthoVec = cross(sliceVec, viewVec);
vec3 normalProj = normal - dot(normal, sliceOrthoVec) * sliceOrthoVec;
float normalProjLen = length(normalProj);
float normalAngle = acos(clamp(dot(normalProj / normalProjLen, viewVec), 0.0, 1.0));
normalAngle *= sign(dot(normalProj, sliceVec));
return vec2(normalAngle, normalProjLen);
}
#if CALC_BENT_NORMALS == 1
vec3 calcSliceBentNormal(vec2 sliceDir, vec2 h, float n) {
vec2 t = vec2(
6.0 * sin(h[0] - n) - sin(3.0 * h[0] - n) + 6.0 * sin(h[1] - n)
- sin(3.0 * h[1] - n) + 16.0 * sin(n) - 3.0 * (sin(h[0] + n) + sin(h[1] + n)),
-cos(3.0 * h[0] - n) - cos(3.0 * h[1] - n) + 8.0 * cos(n)
- 3.0 * (cos(h[0] + n) + cos(h[1] + n))
) / 12.0;
return vec3(sliceDir * t[0], t[1]);
}
#endif
vec2 clampHorizonAnglesAroundNormal(vec2 horizonAngles, float normalAngle,
float geomNormalAngle) {
horizonAngles = normalAngle + clamp(horizonAngles - normalAngle, -PI_HALF, PI_HALF);
if (abs(normalAngle - geomNormalAngle) < NORMAL_RENDER_GEOM_MAX_DIFF_ANGLE) {
horizonAngles = geomNormalAngle + clamp(horizonAngles - geomNormalAngle, -PI_HALF, PI_HALF);
}
return horizonAngles;
}
void main() {
float depth = texture2D(tDepth, vUv).x;
#ifndef GTAO_DISABLE_BKG_FIX
if (depth == 1.0) {
gl_FragColor = vec4(vec3(1.0), 1.0);
} else {
#endif
vec3 viewPos = calcViewFromUVDepth(vUv, depth, 0.0);
#if ORTHO_CAMERA == 1
vec3 viewVec = vec3(0.0, 0.0, 1.0);
#else
vec3 viewVec = normalize(-viewPos);
#endif
vec3 viewNormal = unpackRGBToNormal(texture2D(tNormal, vUv).xyz);
vec3 geomViewNormal = normalize(cross(dFdx(viewPos), dFdy(viewPos)));
vec2 noiseScale = resolution / NOISE_TEX_SIZE;
vec4 noiseData = texture2D(tNoise, vUv * noiseScale);
float randAngle = noiseData.r * PI_HALF;
float visibility = 0.0;
vec3 bentNormalAvg = viewNormal;
float normalAngle, normalProjLen, geomNormalAngle;
vec2 horizonAngles, _vec2Tmp;
vec3 sliceBentNormal;
#if CALC_BENT_NORMALS == 1
bentNormalAvg = vec3(0.0);
#if ORTHO_CAMERA == 0
vec3 bentRotAxis = cross(AXIS_Z, viewVec);
float bentRotAngle = acos(clamp(dot(AXIS_Z, viewVec), -1.0, 1.0));
#endif
#endif
vec2 sliceDir = vec2(cos(randAngle), sin(randAngle));
#pragma unroll_loop_start
for (int i = 0; i < 2; i++) {
_vec2Tmp = calcNormalAngleAndProjLen(viewVec, viewNormal, sliceDir);
normalAngle = _vec2Tmp[0], normalProjLen = _vec2Tmp[1];
_vec2Tmp = calcNormalAngleAndProjLen(viewVec, geomViewNormal, sliceDir);
geomNormalAngle = _vec2Tmp[0];
horizonAngles = calcHorizonAngles(viewPos, viewVec, sliceDir, noiseData.g);
horizonAngles = clampHorizonAnglesAroundNormal(horizonAngles,
normalAngle, geomNormalAngle);
visibility += normalProjLen * integrateArc(horizonAngles, normalAngle);
#if CALC_BENT_NORMALS == 1
sliceBentNormal = calcSliceBentNormal(sliceDir, horizonAngles, normalAngle);
#if ORTHO_CAMERA == 0
sliceBentNormal = vec3RotateAxisAngle(sliceBentNormal,
bentRotAxis, bentRotAngle);
#endif
bentNormalAvg += sliceBentNormal * normalProjLen;
#endif
sliceDir = vec2(-sliceDir.y, sliceDir.x);
}
#pragma unroll_loop_end
visibility /= 2.0;
#if CALC_BENT_NORMALS == 1
float mixFactor = clamp((1.0 - 2.0 * visibility) / (3.0 * visibility - 4.0), 0.0, 1.0);
bentNormalAvg = normalize(mix(bentNormalAvg, viewNormal, mixFactor));
#endif
gl_FragColor = vec4(pow(visibility, factor), packNormalToRGB(bentNormalAvg));
#ifndef GTAO_DISABLE_BKG_FIX
}
#endif
}`,MM=`varying vec2 vUv;
uniform sampler2D maskTexture;
uniform vec2 texSize;
uniform vec4 visibleEdgeColor;
uniform vec4 hiddenEdgeColor;
void main() {
vec2 invSize = 1.0 / texSize;
vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
vec4 c1 = texture2D(maskTexture, vUv + uvOffset.xy);
vec4 c2 = texture2D(maskTexture, vUv - uvOffset.xy);
vec4 c3 = texture2D(maskTexture, vUv + uvOffset.yw);
vec4 c4 = texture2D(maskTexture, vUv - uvOffset.yw);
float diff1 = (c1.r - c2.r) * 0.5;
float diff2 = (c3.r - c4.r) * 0.5;
float d = length(vec2(diff1, diff2));
float a1 = min(c1.g, c2.g);
float a2 = min(c3.g, c4.g);
float visibilityFactor = min(a1, a2);
vec4 edgeColor = (1.0 - visibilityFactor > 0.001) ? visibleEdgeColor : hiddenEdgeColor;
gl_FragColor = edgeColor * vec4(d);
}`,EM=`#include <common>
varying vec2 vUv;
uniform sampler2D colorTexture;
uniform vec2 texSize;
uniform vec2 direction;
uniform float kernelRadius;
float gaussianPdf(in float x, in float sigma) {
return 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;
}
void main() {
vec2 invSize = 1.0 / texSize;
float weightSum = gaussianPdf(0.0, kernelRadius);
vec4 diffuseSum = texture2D(colorTexture, vUv);
#if defined(LOG_SPACE)
diffuseSum = exp(diffuseSum);
#endif
diffuseSum *= weightSum;
vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
vec2 uvOffset = delta;
for (int i = 1; i <= MAX_RADIUS; i++) {
float w = gaussianPdf(uvOffset.x, kernelRadius);
vec4 sample1 = texture2D(colorTexture, vUv + uvOffset);
vec4 sample2 = texture2D(colorTexture, vUv - uvOffset);
#if defined(LOG_SPACE)
sample1 = exp(sample1);
sample2 = exp(sample2);
#endif
diffuseSum += ((sample1 + sample2) * w);
weightSum += (2.0 * w);
uvOffset += delta;
}
vec4 finalCol = diffuseSum / weightSum;
#if defined(LOG_SPACE)
finalCol = log(finalCol);
#endif
gl_FragColor = finalCol;
}`,wM=`varying vec2 vUv;
uniform sampler2D maskTexture;
uniform sampler2D edgeTexture1;
uniform sampler2D edgeTexture2;
uniform sampler2D patternTexture;
uniform float edgeStrength;
uniform float edgeGlow;
uniform bool usePatternTexture;
void main() {
vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
vec4 maskColor = texture2D(maskTexture, vUv);
vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
if (usePatternTexture)
finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
float maxChannel = max(finalColor.r, max(finalColor.g, finalColor.b));
if (maxChannel != 0.0) {
finalColor.rgb /= maxChannel;
}
gl_FragColor = finalColor;
}`,TM=`#include <common>
uniform sampler2D tDiffuse;
varying vec2 vUv;
void main() {
vec4 texel = texture2D(tDiffuse, vUv);
float alpha = clamp(texel.a, 0.0, 1.0);
gl_FragColor = texel;
gl_FragColor.rgb /= alpha;
#include <tonemapping_fragment>
gl_FragColor = LinearTosRGB(gl_FragColor);
gl_FragColor.rgb *= alpha;
#if ALPHA_AS_LUMA == 1
gl_FragColor.a = linearToRelativeLuminance(gl_FragColor.rgb);
#endif
}`;const IM=`precision highp float;
attribute vec3 position;
attribute vec3 previous;
attribute vec3 next;
attribute float side;
attribute float width;
attribute vec2 uv;
attribute float counters;
uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform vec2 resolution;
uniform float lineWidth;
uniform float sizeAttenuation;
varying float vCounters;
varying vec2 vUV;
const float EQ_EPS = 0.000001;
vec2 fix(vec4 i, float aspect) {
vec2 res = i.xy / i.w;
res.x *= aspect;
return res;
}
bool posEqual(vec2 pos0, vec2 pos1) {
return length(pos0 - pos1) < EQ_EPS;
}
void main() {
float aspect = resolution.x / resolution.y;
vCounters = counters;
vUV = uv;
mat4 m = projectionMatrix * modelViewMatrix;
vec4 finalPosition = m * vec4(position, 1.0);
vec4 prevPos = m * vec4(previous, 1.0);
vec4 nextPos = m * vec4(next, 1.0);
vec2 currentP = fix(finalPosition, aspect);
vec2 prevP = fix(prevPos, aspect);
vec2 nextP = fix(nextPos, aspect);
float w = lineWidth * width;
if (sizeAttenuation == 0.0) {
w *= finalPosition.w / resolution.x;
}
vec2 dir;
if (posEqual(nextP, currentP)) {
dir = normalize(currentP - prevP);
} else if (posEqual(prevP, currentP)) {
dir = normalize(nextP - currentP);
} else {
vec2 dir1 = normalize(currentP - prevP);
vec2 dir2 = normalize(nextP - currentP);
dir = normalize(dir1 + dir2);
}
vec2 offset = vec2(-dir.y, dir.x);
offset.y *= aspect;
offset *= w;
finalPosition.xy += offset * side;
gl_Position = finalPosition;
}`,RM=`precision mediump float;
uniform sampler2D map;
uniform sampler2D alphaMap;
uniform float useMap;
uniform float useAlphaMap;
uniform float visibility;
uniform float alphaTest;
uniform vec2 repeat;
uniform vec3 color;
uniform float opacity;
varying vec2 vUV;
varying float vCounters;
#include <encodings_pars_fragment>
void main() {
vec4 c = vec4(color, opacity);
if (useMap == 1.0) {
c *= texture2D(map, vUV * repeat);
}
if (useAlphaMap == 1.0) {
c.a *= texture2D(alphaMap, vUV * repeat).a;
}
if (c.a < alphaTest) {
discard;
}
gl_FragColor = c;
gl_FragColor.a *= step(vCounters, visibility);
gl_FragColor = LinearTosRGB(gl_FragColor);
}`,Me={alphamap_fragment:FA,alphamap_pars_fragment:UA,alphatest_fragment:zA,alphatest_pars_fragment:VA,aomap_fragment:GA,aomap_pars_fragment:kA,begin_vertex:QA,beginnormal_vertex:WA,bsdfs:HA,iridescence_fragment:XA,bumpmap_pars_fragment:YA,clipping_planes_fragment:jA,clipping_planes_pars_fragment:KA,clipping_planes_pars_vertex:qA,clipping_planes_vertex:ZA,color_fragment:JA,color_pars_fragment:$A,color_pars_vertex:ex,color_vertex:tx,common:nx,cube_uv_reflection_fragment:ix,defaultnormal_vertex:ox,displacementmap_pars_vertex:rx,displacementmap_vertex:ax,emissivemap_fragment:sx,emissivemap_pars_fragment:lx,encodings_fragment:cx,encodings_pars_fragment:ux,envmap_fragment:dx,envmap_common_pars_fragment:hx,envmap_pars_fragment:px,envmap_pars_vertex:fx,envmap_physical_pars_fragment:Ex,envmap_vertex:mx,fog_vertex:gx,fog_pars_vertex:vx,fog_fragment:_x,fog_pars_fragment:Ax,gradientmap_pars_fragment:xx,lightmap_fragment:yx,lightmap_pars_fragment:bx,lights_lambert_fragment:Cx,lights_lambert_pars_fragment:Sx,lights_pars_begin:Mx,lights_toon_fragment:wx,lights_toon_pars_fragment:Tx,lights_phong_fragment:Ix,lights_phong_pars_fragment:Rx,lights_physical_fragment:Lx,lights_physical_pars_fragment:Px,lights_fragment_begin:Bx,lights_fragment_maps:Dx,lights_fragment_end:Nx,logdepthbuf_fragment:Ox,logdepthbuf_pars_fragment:Fx,logdepthbuf_pars_vertex:Ux,logdepthbuf_vertex:zx,map_fragment:Vx,map_pars_fragment:Gx,map_particle_fragment:kx,map_particle_pars_fragment:Qx,metalnessmap_fragment:Wx,metalnessmap_pars_fragment:Hx,morphcolor_vertex:Xx,morphnormal_vertex:Yx,morphtarget_pars_vertex:jx,morphtarget_vertex:Kx,normal_fragment_begin:qx,normal_fragment_maps:Zx,normal_pars_fragment:Jx,normal_pars_vertex:$x,normal_vertex:e2,normalmap_pars_fragment:t2,clearcoat_normal_fragment_begin:n2,clearcoat_normal_fragment_maps:i2,clearcoat_pars_fragment:o2,iridescence_pars_fragment:r2,output_fragment:a2,packing:s2,premultiplied_alpha_fragment:l2,project_vertex:c2,dithering_fragment:u2,dithering_pars_fragment:d2,roughnessmap_fragment:h2,roughnessmap_pars_fragment:p2,shadowmap_pars_fragment:f2,shadowmap_pars_vertex:m2,shadowmap_vertex:g2,shadowmask_pars_fragment:v2,skinbase_vertex:_2,skinning_pars_vertex:A2,skinning_vertex:x2,skinnormal_vertex:y2,specularmap_fragment:b2,specularmap_pars_fragment:C2,tonemapping_fragment:S2,tonemapping_pars_fragment:M2,transmission_fragment:E2,transmission_pars_fragment:w2,uv_pars_fragment:T2,uv_pars_vertex:I2,uv_vertex:R2,uv2_pars_fragment:L2,uv2_pars_vertex:P2,uv2_vertex:B2,worldpos_vertex:D2,background_vert:N2,background_frag:O2,backgroundCube_vert:F2,backgroundCube_frag:U2,cube_vert:z2,cube_frag:V2,depth_vert:G2,depth_frag:k2,distanceRGBA_vert:Q2,distanceRGBA_frag:W2,equirect_vert:H2,equirect_frag:X2,linedashed_vert:Y2,linedashed_frag:j2,meshbasic_vert:K2,meshbasic_frag:q2,meshlambert_vert:Z2,meshlambert_frag:J2,meshmatcap_vert:$2,meshmatcap_frag:e3,meshnormal_vert:t3,meshnormal_frag:n3,meshphong_vert:i3,meshphong_frag:o3,meshphysical_vert:r3,meshphysical_frag:a3,meshtoon_vert:s3,meshtoon_frag:l3,points_vert:c3,points_frag:u3,shadow_vert:d3,shadow_frag:h3,sprite_vert:p3,sprite_frag:f3,mask_vert:m3,mask_frag:g3,meshnode_vert:v3,meshnode_frag:_3,lights_node_pars_fragment:A3,lights_node_gtao_pars_fragment:x3,lights_fragment_gtso:y3,normal_output_fragment:b3,ssr_pars_fragment:C3,plane_reflection_pars_vertex:S3,plane_reflection_pars_fragment:M3,plane_reflection_vertex:E3,oit_weighted_pars_fragment:w3,oit_weighted_fragment:T3,node_common_frag:I3,node_osl_frag:R3,node_incident_frag:L3,node_normal_frag:P3,node_position_frag:B3,node_rgb_alpha_frag:D3,node_value_frag:N3,node_u_float_frag:O3,node_abs_ar_frag:F3,node_add_ar_frag:U3,node_atan_ar_frag:z3,node_checkerboard_ar_frag:V3,node_clamp_ar_frag:G3,node_color_convert_ar_frag:Q3,node_color_correct_ar_frag:W3,node_color_to_float_ar_frag:k3,node_compare_ar_frag:H3,node_complement_ar_frag:X3,node_composite_ar_frag:Y3,node_cross_ar_frag:j3,node_divide_ar_frag:K3,node_dot_ar_frag:q3,node_exp_ar_frag:Z3,node_facing_ratio_ar_frag:J3,node_flat_ar_frag:$3,node_float_to_int_ar_frag:ey,node_float_to_matrix_ar_frag:ty,node_float_to_rgba_ar_frag:ny,node_float_to_rgb_ar_frag:iy,node_fraction_ar_frag:oy,node_is_finite_ar_frag:ry,node_image_ar_frag:ay,node_lambert_ar_frag:sy,node_length_ar_frag:ly,node_log_ar_frag:cy,node_map_to_mtl_ar_frag:uy,node_max_ar_frag:dy,node_min_ar_frag:hy,node_mix_shader_ar_frag:py,node_modulo_ar_frag:fy,node_multiply_ar_frag:my,node_negate_ar_frag:gy,node_normalize_ar_frag:vy,node_normal_map_ar_frag:_y,node_pow_ar_frag:Ay,node_random_ar_frag:xy,node_range_ar_frag:yy,node_ray_switch_ar_frag:by,node_reciprocal_ar_frag:Cy,node_rgba_to_float_ar_frag:Sy,node_rgb_to_float_ar_frag:My,node_rgb_to_vector_ar_frag:Ey,node_shadow_matte_ar_frag:wy,node_shuffle_ar_frag:Ty,node_sign_ar_frag:Iy,node_skydome_light_ar_frag:Ry,node_sqrt_ar_frag:Ly,node_standard_surface_ar_frag:Py,node_subtract_ar_frag:By,node_trigo_ar_frag:Dy,node_two_sided_ar_frag:Ny,node_user_data_color_ar_frag:Oy,node_vector_to_rgb_ar_frag:Fy,node_add_shader_bl_frag:Uy,node_ambient_occlusion_bl_frag:zy,node_attribute_bl_frag:Vy,node_background_bl_frag:Gy,node_bevel_bl_frag:ky,node_blackbody_bl_frag:Qy,node_brightcontrast_bl_frag:Wy,node_bsdf_anisotropic_bl_frag:Hy,node_bsdf_diffuse_bl_frag:Xy,node_bsdf_glass_bl_frag:Yy,node_bsdf_glossy_bl_frag:jy,node_bsdf_hair_bl_frag:Ky,node_bsdf_principled_bl_frag:qy,node_bsdf_refraction_bl_frag:Zy,node_bsdf_sheen_bl_frag:Jy,node_bsdf_toon_bl_frag:$y,node_bsdf_translucent_bl_frag:eb,node_bsdf_transparent_bl_frag:tb,node_bsdf_velvet_bl_frag:nb,node_bump_bl_frag:ib,node_camera_bl_frag:ob,node_clamp_bl_frag:rb,node_combhsv_bl_frag:ab,node_combine_color_bl_frag:sb,node_combrgb_bl_frag:lb,node_combxyz_bl_frag:cb,node_curve_float_bl_frag:ub,node_curve_rgb_bl_frag:db,node_curve_vec_bl_frag:hb,node_displacement_bl_frag:pb,node_eevee_specular_bl_frag:fb,node_emission_bl_frag:mb,node_fresnel_bl_frag:gb,node_gamma_bl_frag:vb,node_hair_info_bl_frag:_b,node_holdout_bl_frag:Ab,node_hue_sat_bl_frag:xb,node_invert_bl_frag:yb,node_layer_weight_bl_frag:bb,node_light_falloff_bl_frag:Cb,node_light_path_bl_frag:Sb,node_mapping_bl_frag:Mb,node_map_range_bl_frag:Eb,node_math_bl_frag:wb,node_mix_bl_frag:Tb,node_mix_rgb_bl_frag:Ib,node_mix_shader_bl_frag:Rb,node_new_geometry_bl_frag:Lb,node_normal_bl_frag:Pb,node_normal_map_bl_frag:Bb,node_object_info_bl_frag:Db,node_output_lamp_bl_frag:Nb,node_output_material_bl_frag:Ob,node_output_world_bl_frag:Fb,node_particle_info_bl_frag:Ub,node_point_info_bl_frag:zb,node_principled_volume_bl_frag:Vb,node_rgb_bl_frag:Gb,node_rgbtobw_bl_frag:kb,node_script_bl_frag:Qb,node_sephsv_bl_frag:Wb,node_separate_color_bl_frag:Hb,node_seprgb_bl_frag:Xb,node_sepxyz_bl_frag:Yb,node_shadertorgb_bl_frag:jb,node_squeeze_bl_frag:Kb,node_subsurface_scattering_bl_frag:qb,node_tangent_bl_frag:Zb,node_tex_brick_bl_frag:Jb,node_tex_checker_bl_frag:$b,node_tex_coord_bl_frag:eC,node_tex_environment_bl_frag:tC,node_tex_environment_none_bl_frag:nC,node_tex_gradient_bl_frag:iC,node_tex_ies_bl_frag:oC,node_tex_image_bl_frag:rC,node_tex_image_none_bl_frag:aC,node_tex_magic_bl_frag:sC,node_tex_musgrave_bl_frag:lC,node_tex_noise_bl_frag:cC,node_tex_pointdensity_bl_frag:uC,node_tex_sky_bl_frag:dC,node_tex_voronoi_bl_frag:hC,node_tex_wave_bl_frag:pC,node_tex_white_noise_bl_frag:fC,node_uvmap_bl_frag:mC,node_valtorgb_bl_frag:gC,node_value_bl_frag:vC,node_vect_math_bl_frag:_C,node_vect_transform_bl_frag:AC,node_vector_displacement_bl_frag:xC,node_vector_rotate_bl_frag:yC,node_vertex_color_bl_frag:bC,node_volume_absorption_bl_frag:CC,node_volume_info_bl_frag:SC,node_volume_scatter_bl_frag:MC,node_wavelength_bl_frag:EC,node_wireframe_bl_frag:wC,node_bitmap_none_mx_frag:TC,node_bitmap_env_mx_frag:IC,node_bitmap_mx_frag:RC,node_bump_mx_frag:LC,node_blend_mx_frag:PC,node_color_correction_mx_frag:BC,node_color_map_mx_frag:DC,node_composite_layer_mx_frag:NC,node_falloff_mx_frag:OC,node_gradient_mx_frag:FC,node_gradient_ramp_mx_frag:UC,node_map_mx_frag:zC,node_mask_mx_frag:VC,node_material_mx_frag:GC,node_matte_shadow_mx_frag:kC,node_mix_mx_frag:QC,node_noise_mx_frag:WC,node_normal_bump_mx_frag:HC,node_output_map_mx_frag:XC,node_output_mx_frag:YC,node_physical_mx_frag:jC,node_phy_sun_sky_env_mx_frag:KC,node_reflect_refract_mx_frag:qC,node_reflect_refract_color_mx_frag:ZC,node_rgb_multiply_mx_frag:JC,node_rgb_tint_mx_frag:$C,node_rgb_mx_frag:eS,node_shellac_mx_frag:tS,node_value_mx_frag:nS,node_vertex_color_mx_frag:iS,node_add_double_linear_my_frag:oS,node_add_matrix_my_frag:rS,node_anim_curve_ta_my_frag:aS,node_anim_curve_tu_my_frag:sS,node_blend_colors_my_frag:lS,node_bulge_my_frag:uS,node_blinn_my_frag:cS,node_bump_2d_my_frag:dS,node_channels_my_frag:hS,node_checker_my_frag:pS,node_clamp_my_frag:fS,node_cloth_my_frag:mS,node_color_condition_my_frag:gS,node_color_composite_my_frag:vS,node_color_constant_my_frag:_S,node_color_correct_my_frag:AS,node_color_logic_my_frag:xS,node_color_mask_my_frag:yS,node_color_math_my_frag:bS,node_compose_matrix_my_frag:CS,node_condition_my_frag:SS,node_decompose_matrix_my_frag:MS,node_env_sphere_my_frag:ES,node_file_my_frag:wS,node_float_condition_my_frag:TS,node_float_composite_my_frag:IS,node_float_constant_my_frag:RS,node_float_logic_my_frag:LS,node_float_mask_my_frag:PS,node_float_math_my_frag:BS,node_four_by_four_matrix_my_frag:DS,node_gamma_correct_my_frag:NS,node_grid_my_frag:OS,node_inverse_matrix_my_frag:FS,node_lambert_my_frag:US,node_layered_texture_layer_my_frag:zS,node_light_path_my_frag:VS,node_luminance_my_frag:GS,node_multiply_divide_my_frag:kS,node_mult_double_linear_my_frag:QS,node_mult_matrix_my_frag:WS,node_noise_my_frag:HS,node_output_my_frag:XS,node_place_2d_texture_my_frag:KS,node_phong_my_frag:YS,node_phong_e_my_frag:jS,node_premultiply_my_frag:qS,node_ramp_my_frag:ZS,node_remap_hsv_my_frag:JS,node_reverse_my_frag:$S,node_sampler_info_my_frag:eM,node_set_range_my_frag:tM,node_shading_engine_my_frag:nM,node_surface_shader_my_frag:iM,node_transform_my_frag:oM,node_transpose_matrix_my_frag:rM,node_unit_conversion_my_frag:aM,node_unpremultiply_my_frag:sM,node_vector_product_my_frag:lM,node_wt_add_matrix_my_frag:cM,pp_plane_vert:uM,pp_afterimage_frag:hM,pp_bloom_composite_frag:pM,pp_bloom_lum_high_pass_frag:fM,pp_bloom_separable_blur_frag:mM,pp_blur_frag:gM,pp_brightness_contrast_frag:_M,pp_bokeh_frag:vM,pp_copy_frag:AM,pp_cube_octahedral_proj_frag:xM,pp_fxaa_frag:yM,pp_grayscale_frag:bM,pp_gtao_blur_frag:CM,pp_gtao_frag:SM,pp_outline_edge_frag:MM,pp_outline_blur_frag:EM,pp_outline_overlay_frag:wM,pp_tonemap_frag:TM,pp_oit_weighted_frag:dM,raw_meshline_vert:IM,raw_meshline_frag:RM},xe={common:{diffuse:{value:new me(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new ln},uv2Transform:{value:new ln},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new te(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new me(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadowsCSM:{value:[],properties:{cascadeIdxEnd:{},cameraNear:{},shadowFar:{},fade:{}}},directionalLightShadowsCSMCascade:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{},cascade:{},expBias:{},position:{},csmIdx:{}}},directionalShadowCSMMap:{value:[]},directionalShadowCSMMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadow:{},shadowCameraNear:{},shadowCameraFar:{},expBias:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{},expBias:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},rectAreaLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{},expBias:{}}},rectAreaShadowMap:{value:[]},rectAreaShadowMatrix:{value:[]},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new me(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ln}},sprite:{diffuse:{value:new me(16777215)},opacity:{value:1},center:{value:new te(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ln}},mask:{depthTexture:{value:null},cameraNearFar:{value:new te(.5,.5)},textureMatrix:{value:new Ae}},node:{nodeRGB:{value:[]},nodeValue:{value:[]},flipCubeMap:{value:-1},materialIndex:{value:0}},nodeGTAO:{gtaoMap:{value:null}},ssr:{invProjectionMatrix:{value:new Ae},ssrSourceBuffer:{value:null},ssrDepthBuffer:{value:null},ssrBackfaceDepthBuffer:{value:null},ssrStride:{value:20},ssrResolution:{value:new te},ssrThickness:{value:.01},ssrJitter:{value:1},ssrMaxDistance:{value:100}},planeReflectionProbe:{planeReflTexture:{value:null},planeReflTextureMatrix:{value:new Ae},planeReflDir:{value:new b},planeReflBoundingBoxMin:{value:new b},planeReflBoundingBoxMax:{value:new b},planeReflInvModelMatrix:{value:new Ae},planeReflFalloff:{value:0}}},De={basic:{uniforms:an([xe.common,xe.specularmap,xe.envmap,xe.aomap,xe.lightmap,xe.fog]),vertexShader:Me.meshbasic_vert,fragmentShader:Me.meshbasic_frag},lambert:{uniforms:an([xe.common,xe.specularmap,xe.envmap,xe.aomap,xe.lightmap,xe.emissivemap,xe.bumpmap,xe.normalmap,xe.displacementmap,xe.fog,xe.lights,{emissive:{value:new me(0)}}]),vertexShader:Me.meshlambert_vert,fragmentShader:Me.meshlambert_frag},phong:{uniforms:an([xe.common,xe.specularmap,xe.envmap,xe.aomap,xe.lightmap,xe.emissivemap,xe.bumpmap,xe.normalmap,xe.displacementmap,xe.fog,xe.lights,{emissive:{value:new me(0)},specular:{value:new me(1118481)},shininess:{value:30}}]),vertexShader:Me.meshphong_vert,fragmentShader:Me.meshphong_frag},standard:{uniforms:an([xe.common,xe.envmap,xe.aomap,xe.lightmap,xe.emissivemap,xe.bumpmap,xe.normalmap,xe.displacementmap,xe.roughnessmap,xe.metalnessmap,xe.fog,xe.lights,xe.planeReflectionProbe,{emissive:{value:new me(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1},envMapParallaxType:{value:0},envMapParallaxMatrix:{value:new Ae},envMapParallaxMatrixInv:{value:new Ae}}]),vertexShader:Me.meshphysical_vert,fragmentShader:Me.meshphysical_frag},toon:{uniforms:an([xe.common,xe.aomap,xe.lightmap,xe.emissivemap,xe.bumpmap,xe.normalmap,xe.displacementmap,xe.gradientmap,xe.fog,xe.lights,{emissive:{value:new me(0)}}]),vertexShader:Me.meshtoon_vert,fragmentShader:Me.meshtoon_frag},matcap:{uniforms:an([xe.common,xe.bumpmap,xe.normalmap,xe.displacementmap,xe.fog,{matcap:{value:null}}]),vertexShader:Me.meshmatcap_vert,fragmentShader:Me.meshmatcap_frag},points:{uniforms:an([xe.points,xe.fog]),vertexShader:Me.points_vert,fragmentShader:Me.points_frag},dashed:{uniforms:an([xe.common,xe.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Me.linedashed_vert,fragmentShader:Me.linedashed_frag},depth:{uniforms:an([xe.common,xe.displacementmap,{slopeScaledBias:{value:0}}]),vertexShader:Me.depth_vert,fragmentShader:Me.depth_frag},normal:{uniforms:an([xe.common,xe.bumpmap,xe.normalmap,xe.displacementmap,{opacity:{value:1}}]),vertexShader:Me.meshnormal_vert,fragmentShader:Me.meshnormal_frag},sprite:{uniforms:an([xe.sprite,xe.fog]),vertexShader:Me.sprite_vert,fragmentShader:Me.sprite_frag},background:{uniforms:{uvTransform:{value:new ln},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Me.background_vert,fragmentShader:Me.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:Me.backgroundCube_vert,fragmentShader:Me.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Me.cube_vert,fragmentShader:Me.cube_frag},equirect:{uniforms:{tEquirect:{value:null},invertU:{value:!1},offsetU:{value:0}},vertexShader:Me.equirect_vert,fragmentShader:Me.equirect_frag},distanceRGBA:{uniforms:an([xe.common,xe.displacementmap,{referencePosition:{value:new b},nearDistance:{value:1},farDistance:{value:1e3},slopeScaledBias:{value:0}}]),vertexShader:Me.distanceRGBA_vert,fragmentShader:Me.distanceRGBA_frag},shadow:{uniforms:an([xe.lights,xe.fog,{color:{value:new me(0)},opacity:{value:1}}]),vertexShader:Me.shadow_vert,fragmentShader:Me.shadow_frag},mask:{uniforms:an([xe.common,xe.displacementmap,xe.mask]),vertexShader:Me.mask_vert,fragmentShader:Me.mask_frag},node:{uniforms:an([xe.common,xe.displacementmap,xe.envmap,xe.fog,xe.lights,xe.ssr,xe.planeReflectionProbe,xe.node,xe.nodeGTAO,{envMapIntensity:{value:1},envMapParallaxType:{value:0},envMapParallaxMatrix:{value:new Ae},envMapParallaxMatrixInv:{value:new Ae}}]),vertexShader:Me.meshnode_vert,fragmentShader:Me.meshnode_frag},cubeOctahedral:{uniforms:{tCube:{value:null},texelSize:{value:new te(.5,.5)}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_cube_octahedral_proj_frag}};De.physical={uniforms:an([De.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new te(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new me(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new te},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new me(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new me(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Me.meshphysical_vert,fragmentShader:Me.meshphysical_frag},De.copy={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_copy_frag},De.bokeh={defines:{DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tColor:{value:null},tDepth:{value:null},focus:{value:1},aspect:{value:1},aperture:{value:.025},maxblur:{value:1},nearClip:{value:1},farClip:{value:1e3},depthLeakThreshold:{value:.2}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_bokeh_frag},De.fxaa={defines:{FXAA_GLSL_100:1,FXAA_GLSL_130:0,FXAA_QUALITY_PRESET:12,FXAA_GREEN_AS_LUMA:1},uniforms:{tDiffuse:{value:null},resolution:{value:new te(1/1024,1/512)}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_fxaa_frag},De.grayscale={uniforms:{tDiffuse:{value:null}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_grayscale_frag},De.brightness_contrast={uniforms:{tDiffuse:{value:null},brightness:{value:0},contrast:{value:0}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_brightness_contrast_frag},De.bloomLumHighPass={uniforms:{tDiffuse:{type:"t",value:null},luminosityThreshold:{type:"f",value:1},smoothWidth:{type:"f",value:1},defaultColor:{type:"c",value:new me(0)},defaultOpacity:{type:"f",value:0}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_bloom_lum_high_pass_frag},De.blur={defines:{LOG_SPACE:0,OCTAHEDRAL_MAP:0},uniforms:{colorTexture:{value:null},texSize:{value:new te(.5,.5)},direction:{value:new te(.5,.5)},kernelRadius:{value:1}},customPrepTokens:{MAX_SAMPLE_RADIUS:4},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_blur_frag},De.tonemap={defines:{ALPHA_AS_LUMA:0},uniforms:{tDiffuse:{value:null}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_tonemap_frag},De.afterimage={uniforms:{damp:{value:.96},tOld:{value:null},tNew:{value:null}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_afterimage_frag},De.oitWeighted={uniforms:{tRGBABuffer:{value:null},tFloatBuffer:{value:null}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_oit_weighted_frag};const gl={r:0,b:0,g:0};function LM(a,e,t,n,i,o,r){const s=new me(0);let l,c,d=o===!0?0:1,u=null,h=0,p=null;function m(f,g){f.getRGB(gl,zg(a)),n.buffers.color.setClear(gl.r,gl.g,gl.b,g,r)}return{getClearColor:function(){return s},setClearColor:function(f,g=1){s.set(f),d=g,m(s,d)},getClearAlpha:function(){return d},setClearAlpha:function(f){d=f,m(s,d)},dispose:function(){l&&(l.geometry.dispose(),l.material.dispose()),l=void 0,c&&(c.geometry.dispose(),c.material.dispose()),c=void 0},render:function(f,g){let _=!1,A=g.isScene===!0?g.background:null;A&&A.isTexture&&(A=(g.backgroundBlurriness>0?t:e).get(A));const x=a.xr,S=x.getSession&&x.getSession();S&&S.environmentBlendMode==="additive"&&(A=null),A===null?m(s,d):A&&A.isColor&&(m(A,1),_=!0),(a.autoClear||_)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil),A&&(A.isCubeTexture||A.mapping===xa)?(c===void 0&&(c=new Ue(new ao(1,1,1),new vt({name:"BackgroundCubeMaterial",uniforms:ha(De.backgroundCube.uniforms),vertexShader:De.backgroundCube.vertexShader,fragmentShader:De.backgroundCube.fragmentShader,side:nn,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(M,T,L){const z=L.far;this.matrixWorld.makeScale(z,z,z),this.matrixWorld.copyPosition(L.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),c.material.uniforms.envMap.value=A,c.material.uniforms.flipEnvMap.value=A.isCubeTexture&&A.isRenderTargetTexture===!1?-1:1,c.material.uniforms.backgroundBlurriness.value=g.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=g.backgroundIntensity,c.material.toneMapped=g.backgroundToneMapped,u===A&&h===A.version&&p===a.toneMapping||(c.material.needsUpdate=!0,u=A,h=A.version,p=a.toneMapping),c.layers.enableAll(),f.unshift(c,c.geometry,c.material,0,0,null)):A&&A.isTexture&&(l===void 0&&(l=new Ue(new ni(2,2),new vt({name:"BackgroundMaterial",uniforms:ha(De.background.uniforms),vertexShader:De.background.vertexShader,fragmentShader:De.background.fragmentShader,side:kn,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(l)),l.material.uniforms.t2D.value=A,l.material.uniforms.backgroundIntensity.value=g.backgroundIntensity,l.material.toneMapped=g.backgroundToneMapped,A.matrixAutoUpdate===!0&&A.updateMatrix(),l.material.uniforms.uvTransform.value.copy(A.matrix),u===A&&h===A.version&&p===a.toneMapping||(l.material.needsUpdate=!0,u=A,h=A.version,p=a.toneMapping),l.layers.enableAll(),f.unshift(l,l.geometry,l.material,0,0,null))}}}function PM(a,e,t,n){const i=a.getParameter(34921),o=n.isWebGL2?null:e.get("OES_vertex_array_object"),r=n.isWebGL2||o!==null,s={},l=p(null);let c=l,d=!1;function u(M){return n.isWebGL2?a.bindVertexArray(M):o.bindVertexArrayOES(M)}function h(M){return n.isWebGL2?a.deleteVertexArray(M):o.deleteVertexArrayOES(M)}function p(M){const T=[],L=[],z=[];for(let W=0;W<i;W++)T[W]=0,L[W]=0,z[W]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:T,enabledAttributes:L,attributeDivisors:z,object:M,attributes:{},index:null}}function m(){const M=c.newAttributes;for(let T=0,L=M.length;T<L;T++)M[T]=0}function f(M){g(M,0)}function g(M,T){const L=c.newAttributes,z=c.enabledAttributes,W=c.attributeDivisors;L[M]=1,z[M]===0&&(a.enableVertexAttribArray(M),z[M]=1),W[M]!==T&&((n.isWebGL2?a:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](M,T),W[M]=T)}function _(){const M=c.newAttributes,T=c.enabledAttributes;for(let L=0,z=T.length;L<z;L++)T[L]!==M[L]&&(a.disableVertexAttribArray(L),T[L]=0)}function A(M,T,L,z,W,V){n.isWebGL2!==!0||L!==5124&&L!==5125?a.vertexAttribPointer(M,T,L,z,W,V):a.vertexAttribIPointer(M,T,L,W,V)}function x(){S(),d=!0,c!==l&&(c=l,u(c.object))}function S(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(M,T,L,z,W){let V=!1;if(r){const N=function(j,oe,H){const ne=H.wireframe===!0;let le=s[j.id];le===void 0&&(le={},s[j.id]=le);let re=le[oe.id];re===void 0&&(re={},le[oe.id]=re);let ae=re[ne];return ae===void 0&&(ae=p(n.isWebGL2?a.createVertexArray():o.createVertexArrayOES()),re[ne]=ae),ae}(z,L,T);c!==N&&(c=N,u(c.object)),V=function(j,oe,H,ne){const le=c.attributes,re=oe.attributes;let ae=0;const E=H.getAttributes();for(const F in E)if(E[F].location>=0){const U=le[F];let B=re[F];if(B===void 0&&(F==="instanceMatrix"&&j.instanceMatrix&&(B=j.instanceMatrix),F==="instanceColor"&&j.instanceColor&&(B=j.instanceColor)),U===void 0||U.attribute!==B||B&&U.data!==B.data)return!0;ae++}return c.attributesNum!==ae||c.index!==ne}(M,z,L,W),V&&function(j,oe,H,ne){const le={},re=oe.attributes;let ae=0;const E=H.getAttributes();for(const F in E)if(E[F].location>=0){let U=re[F];U===void 0&&(F==="instanceMatrix"&&j.instanceMatrix&&(U=j.instanceMatrix),F==="instanceColor"&&j.instanceColor&&(U=j.instanceColor));const B={};B.attribute=U,U&&U.data&&(B.data=U.data),le[F]=B,ae++}c.attributes=le,c.attributesNum=ae,c.index=ne}(M,z,L,W)}else{const N=T.wireframe===!0;c.geometry===z.id&&c.program===L.id&&c.wireframe===N||(c.geometry=z.id,c.program=L.id,c.wireframe=N,V=!0)}W!==null&&t.update(W,34963),(V||d)&&(d=!1,function(N,j,oe,H){if(n.isWebGL2===!1&&(N.isInstancedMesh||H.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;m();const ne=H.attributes,le=oe.getAttributes(),re=j.defaultAttributeValues;for(const ae in le){const E=le[ae];if(E.location>=0){let F=ne[ae];if(F===void 0&&(ae==="instanceMatrix"&&N.instanceMatrix&&(F=N.instanceMatrix),ae==="instanceColor"&&N.instanceColor&&(F=N.instanceColor)),F!==void 0){const U=F.normalized,B=F.itemSize,Z=t.get(F);if(Z===void 0)continue;const k=Z.buffer,X=Z.type,P=Z.bytesPerElement;if(F.isInterleavedBufferAttribute){const v=F.data,y=v.stride,R=F.offset;if(v.isInstancedInterleavedBuffer){for(let w=0;w<E.locationSize;w++)g(E.location+w,v.meshPerAttribute);N.isInstancedMesh!==!0&&H._maxInstanceCount===void 0&&(H._maxInstanceCount=v.meshPerAttribute*v.count)}else for(let w=0;w<E.locationSize;w++)f(E.location+w);a.bindBuffer(34962,k);for(let w=0;w<E.locationSize;w++)A(E.location+w,B/E.locationSize,X,U,y*P,(R+B/E.locationSize*w)*P)}else{if(F.isInstancedBufferAttribute){for(let v=0;v<E.locationSize;v++)g(E.location+v,F.meshPerAttribute);N.isInstancedMesh!==!0&&H._maxInstanceCount===void 0&&(H._maxInstanceCount=F.meshPerAttribute*F.count)}else for(let v=0;v<E.locationSize;v++)f(E.location+v);a.bindBuffer(34962,k);for(let v=0;v<E.locationSize;v++)A(E.location+v,B/E.locationSize,X,U,B*P,B/E.locationSize*v*P)}}else if(re!==void 0){const U=re[ae];if(U!==void 0)switch(U.length){case 2:a.vertexAttrib2fv(E.location,U);break;case 3:a.vertexAttrib3fv(E.location,U);break;case 4:a.vertexAttrib4fv(E.location,U);break;default:a.vertexAttrib1fv(E.location,U)}}}}_()}(M,T,L,z),W!==null&&a.bindBuffer(34963,t.get(W).buffer))},reset:x,resetDefaultState:S,dispose:function(){x();for(const M in s){const T=s[M];for(const L in T){const z=T[L];for(const W in z)h(z[W].object),delete z[W];delete T[L]}delete s[M]}},releaseStatesOfGeometry:function(M){if(s[M.id]===void 0)return;const T=s[M.id];for(const L in T){const z=T[L];for(const W in z)h(z[W].object),delete z[W];delete T[L]}delete s[M.id]},releaseStatesOfProgram:function(M){for(const T in s){const L=s[T];if(L[M.id]===void 0)continue;const z=L[M.id];for(const W in z)h(z[W].object),delete z[W];delete L[M.id]}},initAttributes:m,enableAttribute:f,disableUnusedAttributes:_}}function BM(a,e,t,n){const i=n.isWebGL2;let o;this.setMode=function(r){o=r},this.render=function(r,s){a.drawArrays(o,r,s),t.update(s,o,1)},this.renderInstances=function(r,s,l){if(l===0)return;let c,d;if(i)c=a,d="drawArraysInstanced";else if(c=e.get("ANGLE_instanced_arrays"),d="drawArraysInstancedANGLE",c===null)return void console.error("v3d.WebGLBufferRenderer: using v3d.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[d](o,r,s,l),t.update(s,o,l)}}function DM(a,e,t){let n;function i(S){if(S==="highp"){if(a.getShaderPrecisionFormat(35633,36338).precision>0&&a.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";S="mediump"}return S==="mediump"&&a.getShaderPrecisionFormat(35633,36337).precision>0&&a.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&a instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&a instanceof WebGL2ComputeRenderingContext;let r=t.precision!==void 0?t.precision:"highp";const s=i(r);s!==r&&(console.warn("v3d.WebGLRenderer:",r,"not supported, using",s,"instead."),r=s);const l=o||e.has("WEBGL_draw_buffers"),c=t.logarithmicDepthBuffer===!0,d=a.getParameter(34930),u=a.getParameter(35660),h=a.getParameter(3379),p=a.getParameter(34076),m=a.getParameter(34921),f=a.getParameter(36347),g=a.getParameter(36348),_=a.getParameter(36349),A=u>0,x=o||e.has("OES_texture_float");return{isWebGL2:o,drawBuffers:l,getMaxAnisotropy:function(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const S=e.get("EXT_texture_filter_anisotropic");n=a.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n},getMaxPrecision:i,precision:r,logarithmicDepthBuffer:c,maxTextures:d,maxVertexTextures:u,maxTextureSize:h,maxCubemapSize:p,maxAttributes:m,maxVertexUniforms:f,maxVaryings:g,maxFragmentUniforms:_,vertexTextures:A,floatFragmentTextures:x,floatVertexTextures:A&&x,maxSamples:o?a.getParameter(36183):0}}function NM(a){const e=this;let t=null,n=0,i=!1,o=!1;const r=new Gn,s=new ln,l={value:null,needsUpdate:!1};function c(){l.value!==t&&(l.value=t,l.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function d(u,h,p,m){const f=u!==null?u.length:0;let g=null;if(f!==0){if(g=l.value,m!==!0||g===null){const _=p+4*f,A=h.matrixWorldInverse;s.getNormalMatrix(A),(g===null||g.length<_)&&(g=new Float32Array(_));for(let x=0,S=p;x!==f;++x,S+=4)r.copy(u[x]).applyMatrix4(A,s),r.normal.toArray(g,S),g[S+3]=r.constant}l.value=g,l.needsUpdate=!0}return e.numPlanes=f,e.numIntersection=0,g}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,h,p){const m=u.length!==0||h||n!==0||i;return i=h,t=d(u,p,0),n=u.length,m},this.beginShadows=function(){o=!0,d(null)},this.endShadows=function(){o=!1,c()},this.setState=function(u,h,p){const m=u.clippingPlanes,f=u.clipIntersection,g=u.clipShadows,_=a.get(u);if(!i||m===null||m.length===0||o&&!g)o?d(null):c();else{const A=o?0:n,x=4*A;let S=_.clippingState||null;l.value=S,S=d(m,h,x,p);for(let M=0;M!==x;++M)S[M]=t[M];_.clippingState=S,this.numIntersection=f?this.numPlanes:0,this.numPlanes+=A}}}function OM(a){let e=new WeakMap;function t(i,o){return o===as?i.mapping=_a:o===ss&&(i.mapping=Aa),i}function n(i){const o=i.target;o.removeEventListener("dispose",n);const r=e.get(o);r!==void 0&&(e.delete(o),r.dispose())}return{get:function(i){if(i&&i.isTexture&&i.isRenderTargetTexture===!1){const o=i.mapping;if(o===as||o===ss){if(e.has(i))return t(e.get(i).texture,i.mapping);{const r=i.image;if(r&&r.height>0){const s=new Us(r.height/2);return s.fromEquirectangularTexture(a,i),e.set(i,s),i.addEventListener("dispose",n),t(s.texture,i.mapping)}return null}}}return i},dispose:function(){e=new WeakMap}}}class fi extends Os{constructor(e=-1,t=1,n=1,i=-1,o=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=o,this.far=r,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,o,r){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=o,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let o=n-e,r=n+e,s=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,d=(this.top-this.bottom)/this.view.fullHeight/this.zoom;o+=c*this.view.offsetX,r=o+c*this.view.width,s-=d*this.view.offsetY,l=s-d*this.view.height}this.projectionMatrix.makeOrthographic(o,r,s,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}class Ca extends vt{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class vn extends ze{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,this.backgroundToneMapped=!0,this.postprocessing=[],this.worldMaterial=null,this.worldEnvMapProbe=null,typeof __V3D_DEVTOOLS__<"u"&&__V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundToneMapped=e.backgroundToneMapped,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.backgroundIntensity=this.backgroundIntensity),this.backgroundToneMapped===!1&&(t.backgroundToneMapped=!1),t}get autoUpdate(){return console.warn("v3d.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate}set autoUpdate(e){console.warn("v3d.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=e}dispose(){this.dispatchEvent({type:"dispose"})}}let Rc=256;const aa=[{relSize:1,sigma:0,origin:[0,0]},{relSize:.5,sigma:.025,origin:[0,2/3]},{relSize:1/4,sigma:.07,origin:[.5,2/3]},{relSize:1/8,sigma:.18,origin:[.75,2/3]},{relSize:1/16,sigma:.24,origin:[.875,2/3]},{relSize:1/16,sigma:.3,origin:[.875,17/24]},{relSize:1/16,sigma:.36,origin:[.875,.75]},{relSize:1/16,sigma:.42,origin:[.875,19/24]},{relSize:1/16,sigma:.48,origin:[.875,20/24]},{relSize:1/16,sigma:.54,origin:[.875,.875]},{relSize:1/16,sigma:.6,origin:[.875,22/24]}];function Eo(a){return aa[a].relSize*Rc}function FM(a){return aa[a].origin.map(function(e){return e*Rc*3})}const vl=new fi,Dr=UM(),xf=new me;let Gu=null;const $o=(1+Math.sqrt(5))/2,Nr=1/$o,yf=[new b(1,1,1),new b(-1,1,1),new b(1,1,-1),new b(-1,1,-1),new b(0,$o,Nr),new b(0,$o,-Nr),new b(Nr,0,$o),new b(-Nr,0,$o),new b($o,Nr,0),new b(-$o,Nr,0)];class As{constructor(e,t){this._renderer=e,this._pingPongRenderTarget=null,this._equirectShader=null,this._cubemapShader=null,this.flipCubemapX=!0,Object.defineProperties(this,{maxTileSize:{get:function(){return Rc},set:function(n){Rc=n}}}),t!==void 0&&(this.maxTileSize=t),this._blurMaterial=zM(20,this.maxTileSize),this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){Gu=this._renderer.getRenderTarget();const o=this._allocateTargets();return this._sceneToCubeUV(e,n,i,o),t>0&&this._blur(o,0,0,t),this._applyPMREM(o),this._cleanup(o),o}fromEquirectangular(e){return e.magFilter=Le,e.minFilter=Le,e.generateMipmaps=!1,this.fromCubemap(e)}fromCubemap(e){Gu=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t,this.flipCubemapX),this._applyPMREM(t),this._cleanup(t),t}fromCubeRenderTarget(e,t){const n=this._allocateTargets(e.texture,t);return this._cubeRTToCubeUV(e,n,this.flipCubemapX),this._applyPMREM(n),this._cleanup(n),n}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=ku(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=Cf(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<Dr.length;e++)Dr[e].dispose();this._renderer=null}_cleanup(e){this._renderer.setRenderTarget(Gu),e.scissorTest=!1,e.setSize(e.width,e.height)}_allocateTargets(e,t){const n={magFilter:Le,minFilter:Le,generateMipmaps:!1,type:e?e.type:_t,format:e?e.format:Qe,encoding:e?e.encoding:_n,depthBuffer:!1,stencilBuffer:!1};t!==void 0&&Object.assign(n,t);const i=bf(n);return i.depthBuffer=!e,this._pingPongRenderTarget===null&&(this._pingPongRenderTarget=bf(n)),i}_compileMaterial(e){const t=new vn;t.add(new Ue(Dr[0],e)),this._renderer.compile(t,vl)}_sceneToCubeUV(e,t,n,i){const o=new Qt(90,1,t,n),r=[1,1,1,1,-1,1],s=[1,1,-1,-1,-1,1],l=this._renderer,c=l.outputEncoding,d=l.toneMapping,u=l.toneMappingExposure;l.getClearColor(xf);const h=l.getClearAlpha();l.toneMapping=Gc,l.toneMappingExposure=1,l.outputEncoding=_n,e.scale.z*=-1;let p=e.background;if(p&&p.isColor){p.convertSRGBToLinear();const m=Math.max(p.r,p.g,p.b),f=Math.min(Math.max(Math.ceil(Math.log2(m)),-128),127);p=p.multiplyScalar(Math.pow(2,-f));const g=(f+128)/255;l.setClearColor(p,g),e.background=null}for(let m=0;m<6;m++){const f=m%3;f===0?(o.up.set(0,r[m],0),o.lookAt(s[m],0,0)):f===1?(o.up.set(0,0,r[m]),o.lookAt(0,s[m],0)):(o.up.set(0,r[m],0),o.lookAt(0,0,s[m]));const g=Eo(0);_l(i,f*g,m>2?g:0,g,g),l.setRenderTarget(i),l.render(e,o)}l.toneMapping=d,l.toneMappingExposure=u,l.outputEncoding=c,l.setClearColor(xf,h),e.scale.z*=-1}_textureToCubeUV(e,t,n){const i=this._renderer,o=new vn;e.isCubeTexture?this._cubemapShader===null&&(this._cubemapShader=ku()):this._equirectShader===null&&(this._equirectShader=Cf());const r=e.isCubeTexture?this._cubemapShader:this._equirectShader;o.add(new Ue(Dr[0],r));const s=r.uniforms;s.envMap.value=e,e.isCubeTexture?s.flipCubemapX.value=n||!1:s.texelSize.value.set(1/e.image.width,1/e.image.height);const l=Eo(0);_l(t,0,0,3*l,2*l),i.setRenderTarget(t),i.render(o,vl)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let i=1;i<aa.length;i++){const o=aa[i].sigma,r=aa[i-1].sigma,s=Math.sqrt(o*o-r*r),l=yf[(i-1)%yf.length];this._blur(e,i-1,i,s,l)}t.autoClear=n}_blur(e,t,n,i,o){const r=this._pingPongRenderTarget;this._halfBlur(e,r,t,n,i,"latitudinal",o),this._halfBlur(r,e,n,n,i,"longitudinal",o)}_halfBlur(e,t,n,i,o,r,s){const l=this._renderer,c=this._blurMaterial;r!=="latitudinal"&&r!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const d=new vn;d.add(new Ue(Dr[i],c));const u=c.uniforms,h=Eo(n)-1;let p=isFinite(o)?Math.PI/(2*h):2*Math.PI/39,m=o/p,f=isFinite(o)?1+Math.floor(3*m):20;f>20&&(f=20,m=19/3,p=o/m);const g=[];let _=0;for(let M=0;M<20;++M){const T=M/m,L=Math.exp(-T*T/2);g.push(L),M===0?_+=L:M<f&&(_+=2*L)}for(let M=0;M<g.length;M++)g[M]=g[M]/_;u.envMap.value=e.texture,u.samples.value=f,u.weights.value=g,u.latitudinal.value=r==="latitudinal",s&&(u.poleAxis.value=s),u.dTheta.value=p,u.lodIdx.value=n,c.defines.cubeUV_maxTileSize=Do(Eo(0));const[A,x]=FM(i),S=Eo(i);_l(t,A,x,3*S,2*S),l.setRenderTarget(t),l.render(d,vl)}_cubeRTToCubeUV(e,t,n){const i=this._renderer,o=new vn;this._cubemapShader==null&&(this._cubemapShader=ku());const r=this._cubemapShader;o.add(new Ue(Dr[0],r));const s=r.uniforms;s.envMap.value=e.texture,s.flipCubemapX.value=n||!1;const l=Eo(0);_l(t,0,0,3*l,2*l),i.setRenderTarget(t),i.render(o,vl)}}function UM(){return aa.map(function(a,e){const t=1/(Eo(e)-1),n=-t/2,i=1+t/2,o=[n,n,i,n,i,i,n,n,i,i,n,i],r=new Float32Array(108),s=new Float32Array(72),l=new Float32Array(36);for(let d=0;d<6;d++){const u=d%3*2/3-1,h=d>2?0:-1,p=[u,h,0,u+2/3,h,0,u+2/3,h+1,0,u,h,0,u+2/3,h+1,0,u,h+1,0];r.set(p,18*d),s.set(o,12*d);const m=[d,d,d,d,d,d];l.set(m,6*d)}const c=new Pe;return c.setAttribute("position",new Te(r,3)),c.setAttribute("uv",new Te(s,2)),c.setAttribute("faceIndex",new Te(l,1)),c})}function bf(a){const e=Eo(0),t=new et(3*e,3*e,a);return t.texture.mapping=xa,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function _l(a,e,t,n,i){a.viewport.set(e,t,n,i),a.scissor.set(e,t,n,i)}function zM(a,e){const t=new Float32Array(a),n=new b(0,1,0),i=new Ca({defines:{n:a,cubeUV_maxTileSize:Do(e)},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},lodIdx:{value:0},poleAxis:{value:n}},vertexShader:Wh(),fragmentShader:`

            precision highp float;
            precision highp int;

            varying vec3 vOutputDirection;

            uniform sampler2D envMap;
            uniform int samples;
            uniform float weights[n];
            uniform bool latitudinal;
            uniform float dTheta;
            uniform float lodIdx;
            uniform vec3 poleAxis;

            #define ENVMAP_TYPE_CUBE_UV
            #include <cube_uv_reflection_fragment>

            vec3 getSample(float theta, vec3 axis) {

                float cosTheta = cos(theta);
                // Rodrigues' axis-angle rotation
                vec3 sampleDirection = vOutputDirection * cosTheta
                    + cross(axis, vOutputDirection) * sin(theta)
                    + axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);

                return bilinearCubeUV(envMap, sampleDirection, lodIdx);

            }

            void main() {

                vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);

                if (all(equal(axis, vec3(0.0)))) {

                    axis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);

                }

                axis = normalize(axis);

                gl_FragColor = vec4(0.0);
                gl_FragColor.rgb += weights[0] * getSample(0.0, axis);

                for (int i = 1; i < n; i++) {

                    if (i >= samples) {

                        break;

                    }

                    float theta = dTheta * float(i);
                    gl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);
                    gl_FragColor.rgb += weights[i] * getSample(theta, axis);

                }

            }
        `,blending:En,depthTest:!1,depthWrite:!1});return i.type="SphericalGaussianBlur",i}function Cf(){const a=new te(1,1),e=new Ca({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:a}},vertexShader:Wh(),fragmentShader:`

            precision mediump float;
            precision mediump int;

            varying vec3 vOutputDirection;

            uniform sampler2D envMap;
            uniform vec2 texelSize;

            #define RECIPROCAL_PI 0.31830988618
            #define RECIPROCAL_PI2 0.15915494

            void main() {

                gl_FragColor = vec4(0.0);

                vec3 outputDirection = normalize(vOutputDirection);
                vec2 uv;
                uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;
                uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;

                vec2 f = fract(uv / texelSize - 0.5);
                uv -= f * texelSize;
                vec3 tl = texture2D(envMap, uv).rgb;
                uv.x += texelSize.x;
                vec3 tr = texture2D(envMap, uv).rgb;
                uv.y += texelSize.y;
                vec3 br = texture2D(envMap, uv).rgb;
                uv.x -= texelSize.x;
                vec3 bl = texture2D(envMap, uv).rgb;

                vec3 tm = mix(tl, tr, f.x);
                vec3 bm = mix(bl, br, f.x);
                gl_FragColor.rgb = mix(tm, bm, f.y);

            }
        `,blending:En,depthTest:!1,depthWrite:!1});return e.type="EquirectangularToCubeUV",e}function ku(){const a=new Ca({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipCubemapX:{value:!0}},vertexShader:Wh(),fragmentShader:`

            precision mediump float;
            precision mediump int;

            uniform bool flipCubemapX;

            varying vec3 vOutputDirection;

            uniform samplerCube envMap;

            void main() {

                gl_FragColor = textureCube(envMap, vec3(vOutputDirection.x * (flipCubemapX ? -1.0 : 1.0), vOutputDirection.yz));

            }
        `,blending:En,depthTest:!1,depthWrite:!1});return a.type="CubemapToCubeUV",a}function Wh(){return`

        precision mediump float;
        precision mediump int;

        attribute vec3 position;
        attribute vec2 uv;
        attribute float faceIndex;

        varying vec3 vOutputDirection;

        // RH coordinate system; PMREM face-indexing convention
        vec3 getDirection(vec2 uv, float face) {

            uv = 2.0 * uv - 1.0;

            vec3 direction = vec3(uv, 1.0);

            if (face == 0.0) {

                direction = direction.zyx;
                direction.z *= -1.0;

            } else if (face == 1.0) {

                direction = direction.xzy;
                direction.z *= -1.0;

            } else if (face == 3.0) {

                direction = direction.zyx;
                direction.x *= -1.0;

            } else if (face == 4.0) {

                direction = direction.xzy;
                direction.y *= -1.0;

            } else if (face == 5.0) {

                direction.xz *= -1.0;

            }

            return direction;

        }

        void main() {

            vOutputDirection = getDirection(uv, faceIndex);
            gl_Position = vec4(position, 1.0);

        }
    `}function VM(a){let e=new WeakMap,t=null;function n(i){const o=i.target;o.removeEventListener("dispose",n);const r=e.get(o);r!==void 0&&(e.delete(o),r.dispose())}return{get:function(i){if(i&&i.isTexture){const o=i.mapping,r=o===as||o===ss,s=o===_a||o===Aa;if(r||s){if(i.isRenderTargetTexture&&i.needsPMREMUpdate===!0){i.needsPMREMUpdate=!1;let l=e.get(i);return t===null&&(t=new As(a)),l=r?t.fromEquirectangular(i,l):t.fromCubemap(i,l),e.set(i,l),l.texture}if(e.has(i))return e.get(i).texture;{const l=i.image;if(r&&l&&l.height>0||s&&l&&function(c){let d=0;const u=6;for(let h=0;h<u;h++)c[h]!==void 0&&d++;return d===u}(l)){t===null&&(t=new As(a));const c=r?t.fromEquirectangular(i):t.fromCubemap(i);return e.set(i,c),i.addEventListener("dispose",n),c.texture}return null}}}return i},dispose:function(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}}}function GM(a){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=a.getExtension("WEBGL_depth_texture")||a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=a.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const i=t(n);return i===null&&console.warn("v3d.WebGLRenderer: "+n+" extension not supported."),i}}}function kM(a,e,t,n){const i={},o=new WeakMap;function r(l){const c=l.target;c.index!==null&&e.remove(c.index);for(const u in c.attributes)e.remove(c.attributes[u]);c.removeEventListener("dispose",r),delete i[c.id];const d=o.get(c);d&&(e.remove(d),o.delete(c)),n.releaseStatesOfGeometry(c),c.isInstancedBufferGeometry===!0&&delete c._maxInstanceCount,t.memory.geometries--}function s(l){const c=[],d=l.index,u=l.attributes.position;let h=0;if(d!==null){const f=d.array;h=d.version;for(let g=0,_=f.length;g<_;g+=3){const A=f[g+0],x=f[g+1],S=f[g+2];c.push(A,x,x,S,S,A)}}else{const f=u.array;h=u.version;for(let g=0,_=f.length/3-1;g<_;g+=3){const A=g+0,x=g+1,S=g+2;c.push(A,x,x,S,S,A)}}const p=new(Dg(c)?Qh:kh)(c,1);p.version=h;const m=o.get(l);m&&e.remove(m),o.set(l,p)}return{get:function(l,c){return i[c.id]===!0||(c.addEventListener("dispose",r),i[c.id]=!0,t.memory.geometries++),c},update:function(l){const c=l.attributes;for(const u in c)e.update(c[u],34962);const d=l.morphAttributes;for(const u in d){const h=d[u];for(let p=0,m=h.length;p<m;p++)e.update(h[p],34962)}},getWireframeAttribute:function(l){const c=o.get(l);if(c){const d=l.index;d!==null&&c.version<d.version&&s(l)}else s(l);return o.get(l)}}}function QM(a,e,t,n){const i=n.isWebGL2;let o,r,s;this.setMode=function(l){o=l},this.setIndex=function(l){r=l.type,s=l.bytesPerElement},this.render=function(l,c){a.drawElements(o,c,r,l*s),t.update(c,o,1)},this.renderInstances=function(l,c,d){if(d===0)return;let u,h;if(i)u=a,h="drawElementsInstanced";else if(u=e.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",u===null)return void console.error("v3d.WebGLIndexedBufferRenderer: using v3d.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[h](o,c,r,l*s,d),t.update(c,o,d)}}function WM(a){const e={geometries:0,textures:0,textureSpecs:new Map},t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:e,render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(n,i,o){switch(t.calls++,i){case 4:t.triangles+=o*(n/3);break;case 1:t.lines+=o*(n/2);break;case 3:t.lines+=o*(n-1);break;case 2:t.lines+=o*n;break;case 0:t.points+=o*n;break;default:console.error("v3d.WebGLInfo: Unknown draw mode:",i)}},addTextureSpec:function(n){let i,o,r,s,l;n.isWebGLRenderTarget?(i=n.texture.name,o="RenderTarget",r=n.width,s=n.height,l=n.texture.format):(i=n.name,o="Texture",r=n.image.width,s=n.image.height,l=n.format),e.textureSpecs.set(n,{name:i,type:o,width:r,height:s,format:l})},removeTextureSpec:function(n){e.textureSpecs.delete(n)}}}function HM(a,e){return a[0]-e[0]}function XM(a,e){return Math.abs(e[1])-Math.abs(a[1])}function YM(a,e,t){const n={},i=new Float32Array(12),o=new WeakMap,r=new Re,s=[];for(let l=0;l<12;l++)s[l]=[l,0];return{update:function(l,c,d,u){const h=l.morphTargetInfluences;if(e.isWebGL2===!0){const p=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,m=p!==void 0?p.length:0;let f=o.get(c);if(f===void 0||f.count!==m){f!==void 0&&f.texture.dispose();const A=c.morphAttributes.position!==void 0,x=c.morphAttributes.normal!==void 0,S=c.morphAttributes.color!==void 0,M=c.morphAttributes.position||[],T=c.morphAttributes.normal||[],L=c.morphAttributes.color||[];let z=0;A===!0&&(z=1),x===!0&&(z=2),S===!0&&(z=3);let W=c.attributes.position.count*z,V=1;W>e.maxTextureSize&&(V=Math.ceil(W/e.maxTextureSize),W=e.maxTextureSize);const N=new Float32Array(W*V*4*m),j=new Ns(N,W,V,m);j.type=Ct,j.needsUpdate=!0;const oe=4*z;for(let H=0;H<m;H++){const ne=M[H],le=T[H],re=L[H],ae=W*V*4*H;for(let E=0;E<ne.count;E++){const F=E*oe;A===!0&&(r.fromBufferAttribute(ne,E),N[ae+F+0]=r.x,N[ae+F+1]=r.y,N[ae+F+2]=r.z,N[ae+F+3]=0),x===!0&&(r.fromBufferAttribute(le,E),N[ae+F+4]=r.x,N[ae+F+5]=r.y,N[ae+F+6]=r.z,N[ae+F+7]=0),S===!0&&(r.fromBufferAttribute(re,E),N[ae+F+8]=r.x,N[ae+F+9]=r.y,N[ae+F+10]=r.z,N[ae+F+11]=re.itemSize===4?r.w:1)}}f={count:m,texture:j,size:new te(W,V)},o.set(c,f),c.addEventListener("dispose",function H(){j.dispose(),o.delete(c),c.removeEventListener("dispose",H)})}let g=0;for(let A=0;A<h.length;A++)g+=h[A];const _=c.morphTargetsRelative?1:1-g;u.getUniforms().setValue(a,"morphTargetBaseInfluence",_),u.getUniforms().setValue(a,"morphTargetInfluences",h),u.getUniforms().setValue(a,"morphTargetsTexture",f.texture,t),u.getUniforms().setValue(a,"morphTargetsTextureSize",f.size)}else{const p=h===void 0?0:h.length;let m=n[c.id];if(m===void 0||m.length!==p){m=[];for(let x=0;x<p;x++)m[x]=[x,0];n[c.id]=m}for(let x=0;x<p;x++){const S=m[x];S[0]=x,S[1]=h[x]}m.sort(XM);for(let x=0;x<12;x++)x<p&&m[x][1]?(s[x][0]=m[x][0],s[x][1]=m[x][1]):(s[x][0]=Number.MAX_SAFE_INTEGER,s[x][1]=0);s.sort(HM);const f=c.morphAttributes.position,g=c.morphAttributes.normal;let _=0;for(let x=0;x<12;x++){const S=s[x],M=S[0],T=S[1];M!==Number.MAX_SAFE_INTEGER&&T?(f&&c.getAttribute("morphTarget"+x)!==f[M]&&c.setAttribute("morphTarget"+x,f[M]),g&&c.getAttribute("morphNormal"+x)!==g[M]&&c.setAttribute("morphNormal"+x,g[M]),i[x]=T,_+=T):(f&&c.hasAttribute("morphTarget"+x)===!0&&c.deleteAttribute("morphTarget"+x),g&&c.hasAttribute("morphNormal"+x)===!0&&c.deleteAttribute("morphNormal"+x),i[x]=0)}const A=c.morphTargetsRelative?1:1-_;u.getUniforms().setValue(a,"morphTargetBaseInfluence",A),u.getUniforms().setValue(a,"morphTargetInfluences",i)}}}}function jM(a,e,t,n){let i=new WeakMap;function o(r){const s=r.target;s.removeEventListener("dispose",o),t.remove(s.instanceMatrix),s.instanceColor!==null&&t.remove(s.instanceColor)}return{update:function(r){const s=n.render.frame,l=r.geometry,c=e.get(r,l);return i.get(c)!==s&&(e.update(c),i.set(c,s)),r.isInstancedMesh&&(r.hasEventListener("dispose",o)===!1&&r.addEventListener("dispose",o),t.update(r.instanceMatrix,34962),r.instanceColor!==null&&t.update(r.instanceColor,34962)),c},dispose:function(){i=new WeakMap}}}const Gg=new yt,kg=new Ns,Qg=new jc,Wg=new Fs,Sf=[],Mf=[],Ef=new Float32Array(16),wf=new Float32Array(9),Tf=new Float32Array(4);function Sa(a,e,t){const n=a[0];if(n<=0||n>0)return a;const i=e*t;let o=Sf[i];if(o===void 0&&(o=new Float32Array(i),Sf[i]=o),e!==0){n.toArray(o,0);for(let r=1,s=0;r!==e;++r)s+=t,a[r].toArray(o,s)}return o}function Yt(a,e){if(a.length!==e.length)return!1;for(let t=0,n=a.length;t<n;t++)if(a[t]!==e[t])return!1;return!0}function jt(a,e){for(let t=0,n=e.length;t<n;t++)a[t]=e[t]}function qc(a,e){let t=Mf[e];t===void 0&&(t=new Int32Array(e),Mf[e]=t);for(let n=0;n!==e;++n)t[n]=a.allocateTextureUnit();return t}function KM(a,e){const t=this.cache;t[0]!==e&&(a.uniform1f(this.addr,e),t[0]=e)}function qM(a,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y||(a.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yt(t,e))return;a.uniform2fv(this.addr,e),jt(t,e)}}function ZM(a,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(a.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)t[0]===e.r&&t[1]===e.g&&t[2]===e.b||(a.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Yt(t,e))return;a.uniform3fv(this.addr,e),jt(t,e)}}function JM(a,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(a.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yt(t,e))return;a.uniform4fv(this.addr,e),jt(t,e)}}function $M(a,e){const t=this.cache,n=e.elements;if(n===void 0){if(Yt(t,e))return;a.uniformMatrix2fv(this.addr,!1,e),jt(t,e)}else{if(Yt(t,n))return;Tf.set(n),a.uniformMatrix2fv(this.addr,!1,Tf),jt(t,n)}}function eE(a,e){const t=this.cache,n=e.elements;if(n===void 0){if(Yt(t,e))return;a.uniformMatrix3fv(this.addr,!1,e),jt(t,e)}else{if(Yt(t,n))return;wf.set(n),a.uniformMatrix3fv(this.addr,!1,wf),jt(t,n)}}function tE(a,e){const t=this.cache,n=e.elements;if(n===void 0){if(Yt(t,e))return;a.uniformMatrix4fv(this.addr,!1,e),jt(t,e)}else{if(Yt(t,n))return;Ef.set(n),a.uniformMatrix4fv(this.addr,!1,Ef),jt(t,n)}}function nE(a,e){const t=this.cache;t[0]!==e&&(a.uniform1i(this.addr,e),t[0]=e)}function iE(a,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y||(a.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yt(t,e))return;a.uniform2iv(this.addr,e),jt(t,e)}}function oE(a,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(a.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Yt(t,e))return;a.uniform3iv(this.addr,e),jt(t,e)}}function rE(a,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(a.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yt(t,e))return;a.uniform4iv(this.addr,e),jt(t,e)}}function aE(a,e){const t=this.cache;t[0]!==e&&(a.uniform1ui(this.addr,e),t[0]=e)}function sE(a,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y||(a.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yt(t,e))return;a.uniform2uiv(this.addr,e),jt(t,e)}}function lE(a,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(a.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Yt(t,e))return;a.uniform3uiv(this.addr,e),jt(t,e)}}function cE(a,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(a.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yt(t,e))return;a.uniform4uiv(this.addr,e),jt(t,e)}}function uE(a,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),t.setTexture2D(e||Gg,i)}function dE(a,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||Qg,i)}function hE(a,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),t.setTextureCube(e||Wg,i)}function pE(a,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||kg,i)}function fE(a){switch(a){case 5126:return KM;case 35664:return qM;case 35665:return ZM;case 35666:return JM;case 35674:return $M;case 35675:return eE;case 35676:return tE;case 5124:case 35670:return nE;case 35667:case 35671:return iE;case 35668:case 35672:return oE;case 35669:case 35673:return rE;case 5125:return aE;case 36294:return sE;case 36295:return lE;case 36296:return cE;case 35678:case 36198:case 36298:case 36306:case 35682:return uE;case 35679:case 36299:case 36307:return dE;case 35680:case 36300:case 36308:case 36293:return hE;case 36289:case 36303:case 36311:case 36292:return pE}}function mE(a,e){a.uniform1fv(this.addr,e)}function gE(a,e){const t=Sa(e,this.size,2);a.uniform2fv(this.addr,t)}function vE(a,e){const t=Sa(e,this.size,3);a.uniform3fv(this.addr,t)}function _E(a,e){const t=Sa(e,this.size,4);a.uniform4fv(this.addr,t)}function AE(a,e){const t=Sa(e,this.size,4);a.uniformMatrix2fv(this.addr,!1,t)}function xE(a,e){const t=Sa(e,this.size,9);a.uniformMatrix3fv(this.addr,!1,t)}function yE(a,e){const t=Sa(e,this.size,16);a.uniformMatrix4fv(this.addr,!1,t)}function bE(a,e){a.uniform1iv(this.addr,e)}function CE(a,e){a.uniform2iv(this.addr,e)}function SE(a,e){a.uniform3iv(this.addr,e)}function ME(a,e){a.uniform4iv(this.addr,e)}function EE(a,e){a.uniform1uiv(this.addr,e)}function wE(a,e){a.uniform2uiv(this.addr,e)}function TE(a,e){a.uniform3uiv(this.addr,e)}function IE(a,e){a.uniform4uiv(this.addr,e)}function RE(a,e,t){const n=this.cache,i=e.length,o=qc(t,i);Yt(n,o)||(a.uniform1iv(this.addr,o),jt(n,o));for(let r=0;r!==i;++r)t.setTexture2D(e[r]||Gg,o[r])}function LE(a,e,t){const n=this.cache,i=e.length,o=qc(t,i);Yt(n,o)||(a.uniform1iv(this.addr,o),jt(n,o));for(let r=0;r!==i;++r)t.setTexture3D(e[r]||Qg,o[r])}function PE(a,e,t){const n=this.cache,i=e.length,o=qc(t,i);Yt(n,o)||(a.uniform1iv(this.addr,o),jt(n,o));for(let r=0;r!==i;++r)t.setTextureCube(e[r]||Wg,o[r])}function BE(a,e,t){const n=this.cache,i=e.length,o=qc(t,i);Yt(n,o)||(a.uniform1iv(this.addr,o),jt(n,o));for(let r=0;r!==i;++r)t.setTexture2DArray(e[r]||kg,o[r])}function DE(a){switch(a){case 5126:return mE;case 35664:return gE;case 35665:return vE;case 35666:return _E;case 35674:return AE;case 35675:return xE;case 35676:return yE;case 5124:case 35670:return bE;case 35667:case 35671:return CE;case 35668:case 35672:return SE;case 35669:case 35673:return ME;case 5125:return EE;case 36294:return wE;case 36295:return TE;case 36296:return IE;case 35678:case 36198:case 36298:case 36306:case 35682:return RE;case 35679:case 36299:case 36307:return LE;case 35680:case 36300:case 36308:case 36293:return PE;case 36289:case 36303:case 36311:case 36292:return BE}}class NE{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=fE(t.type)}}class OE{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=DE(t.type)}}class FE{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const i=this.seq;for(let o=0,r=i.length;o!==r;++o){const s=i[o];s.setValue(e,t[s.id],n)}}}const Qu=/(\w+)(\])?(\[|\.)?/g;function If(a,e){a.seq.push(e),a.map[e.id]=e}function UE(a,e,t){const n=a.name,i=n.length;for(Qu.lastIndex=0;;){const o=Qu.exec(n),r=Qu.lastIndex;let s=o[1];const l=o[2]==="]",c=o[3];if(l&&(s|=0),c===void 0||c==="["&&r+2===i){If(t,c===void 0?new NE(s,a,e):new OE(s,a,e));break}{let d=t.map[s];d===void 0&&(d=new FE(s),If(t,d)),t=d}}}class vc{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let i=0;i<n;++i){const o=e.getActiveUniform(t,i);UE(o,e.getUniformLocation(t,o.name),this)}}setValue(e,t,n,i){const o=this.map[t];o!==void 0&&o.setValue(e,n,i)}setOptional(e,t,n){const i=t[n];i!==void 0&&this.setValue(e,n,i)}static upload(e,t,n,i){for(let o=0,r=t.length;o!==r;++o){const s=t[o],l=n[s.id];l.needsUpdate!==!1&&s.setValue(e,l.value,i)}}static seqWithValue(e,t){const n=[];for(let i=0,o=e.length;i!==o;++i){const r=e[i];r.id in t&&n.push(r)}return n}}function Rf(a,e,t){const n=a.createShader(e);return a.shaderSource(n,t),a.compileShader(n),n}let zE=0;function VE(a,e){const t=a.split(`
`),n=[],i=Math.max(e-6,0),o=Math.min(e+6,t.length);for(let r=i;r<o;r++){const s=r+1;n.push(`${s===e?">":" "} ${s}: ${t[r]}`)}return n.join(`
`)}function GE(a){switch(a){case _n:return["Linear","(value)"];case Ke:return["sRGB","(value)"];default:return console.warn("v3d.WebGLProgram: Unsupported encoding:",a),["Linear","(value)"]}}function Lf(a,e,t){const n=a.getShaderParameter(e,35713),i=a.getShaderInfoLog(e).trim();if(n&&i==="")return"";const o=/ERROR: 0:(\d+)/.exec(i);if(o){const r=parseInt(o[1]);return t.toUpperCase()+`

`+i+`

`+VE(a.getShaderSource(e),r)}return i}function kE(a,e){const t=GE(e);return"vec4 "+a+"(vec4 value) { return LinearTo"+t[0]+t[1]+"; }"}function QE(a,e){let t;switch(e){case Gc:t="Linear";break;case ug:t="Reinhard";break;case dg:t="OptimizedCineon";break;case hg:t="ACESFilmic";break;case pg:t="Custom";break;case kc:t="LogarithmicMax";break;case Qc:t="PhysicalMax";break;case Ph:t="FilmicBlender";break;case Bh:t="AgX";break;default:console.warn("v3d.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+a+"(vec3 color) { return "+t+"ToneMapping(color); }"}function WE(a){let e="TONE_MAPPING_LOOK_NONE";return a===Dh&&(e="TONE_MAPPING_LOOK_AGX_PUNCHY"),e}function HE(a){return[a.extensionDerivatives||a.envMapCubeUVHeight||a.bumpMap||a.tangentSpaceNormalMap||a.clearcoatNormalMap||a.flatShading||a.shaderID==="physical"||a.useSlopeScaledBias?"#extension GL_OES_standard_derivatives : enable":"",(a.extensionFragDepth||a.logarithmicDepthBuffer)&&a.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",a.extensionDrawBuffers&&a.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(a.extensionShaderTextureLOD||a.envMap||a.transmission)&&a.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(ja).join(`
`)}function Pf(a,e=[]){const t=[];for(const n in a){const i=a[n];i===!1||e.indexOf(n)>-1||t.push("#define "+n+" "+i)}return t.join(`
`)}function XE(a,e){const t={},n=a.getProgramParameter(e,35721);for(let i=0;i<n;i++){const o=a.getActiveAttrib(e,i),r=o.name;let s=1;o.type===35674&&(s=2),o.type===35675&&(s=3),o.type===35676&&(s=4),t[r]={type:o.type,location:a.getAttribLocation(e,r),locationSize:s}}return t}function ja(a){return a!==""}function Bf(a,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return a.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows).replace(/NUM_RECT_AREA_LIGHT_SHADOWS/g,e.numRectAreaLightShadows).replace(/NUM_DIR_LIGHT_SHADOWS_CSM_WITH_FADE/g,e.numDirLightShadowsCSMWithFade).replace(/NUM_DIR_LIGHT_SHADOWS_CSM/g,e.numDirLightShadowsCSM).replace(/NUM_DIR_LIGHT_SHADOW_CASCADES_CSM/g,e.numDirLightShadowCSMCascades)}function Df(a,e){return a.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}function Nf(a,e){const t=Object.keys(e);if(t.length){const n=new RegExp(t.join("|"),"g");return a.replace(n,function(i){return e[i]})}return a}function YE(a){switch(a){case"blender":return"#define MT_BLENDER";case"max":return"#define MT_MAX";case"maya":return"#define MT_MAYA";default:return""}}function Of(a,e){for(const t in e){const n=typeof __V3D_DEVTOOLS__<"u"?`// included: "${t}"
`:"";a=a.replace(`#include <${t}>`,n+e[t])}return a}const jE=/^[ \t]*#include +<([\w\d./]+)>/gm;function ah(a){return a.replace(jE,KE)}function KE(a,e){const t=Me[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return ah((typeof __V3D_DEVTOOLS__<"u"?`// included: "${e}"
`:"")+t)}function Ff(a){const e=new RegExp("#pragma unroll_loop_start[\\s]+?for \\(int (\\w+) \\= (\\d+)\\; (\\w+) <(=?) (\\w+)\\; (\\w+)\\+\\+\\) \\{"),t=new RegExp("\\{|\\}","g");let n;for(;n=e.exec(a);){let i,o;i=o=t.lastIndex=n.index+n[0].length;let r,s=1;do(r=t.exec(a))&&(r[0]=="{"?s++:r[0]=="}"&&s--,o=r.index);while(r&&s>0);if(s==0){const l=a.substring(n.index,t.lastIndex),c=a.substring(i,o),d=new RegExp(`\\[${n[1]}\\]`,"g"),u=new RegExp(`\\(${n[1]}\\)`,"g");let h="";const p=parseInt(n[2]),m=parseInt(n[5])+(n[4]==="="?1:0);for(let f=p;f<m;f++)h+="{"+c.replace(d,`[${f}]`).replace(u,`(${f})`)+"}";a=a.replace(l,h)}}return a=a.replace(/#pragma unroll_loop_end/g,"")}function Uf(a){let e="precision "+a.precision+` float;
precision `+a.precision+" int;";return a.precision==="highp"?e+=`
#define HIGH_PRECISION`:a.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:a.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function qE(a){let e="SHADOWMAP_TYPE_BASIC";return a.shadowMapType===Io?e="SHADOWMAP_TYPE_PCF":a.shadowMapType===Po?e="SHADOWMAP_TYPE_PCF_SOFT":a.shadowMapType===Vn?e="SHADOWMAP_TYPE_ESM":a.shadowMapType===ar?e="SHADOWMAP_TYPE_PCF_POISSON_DISK":a.shadowMapType===sr&&(e="SHADOWMAP_TYPE_BILINEAR"),e}function ZE(a){let e="ENVMAP_TYPE_CUBE";if(a.envMap)switch(a.envMapMode){case _a:case Aa:e="ENVMAP_TYPE_CUBE";break;case xa:e="ENVMAP_TYPE_CUBE_UV"}return e}function JE(a){let e="ENVMAP_MODE_REFLECTION";return a.envMap&&a.envMapMode===Aa&&(e="ENVMAP_MODE_REFRACTION"),e}function $E(a){let e="ENVMAP_BLENDING_NONE";if(a.envMap)switch(a.combine){case Ps:e="ENVMAP_BLENDING_MULTIPLY";break;case lg:e="ENVMAP_BLENDING_MIX";break;case cg:e="ENVMAP_BLENDING_ADD"}return e}function ew(a){const e=a.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:n,maxMip:t}}function tw(a,e,t,n){const i=a.getContext(),o=t.defines;let r=t.vertexShader,s=t.fragmentShader;const l=qE(t),c=ZE(t),d=JE(t),u=$E(t),h=ew(t),p=t.unitsScaleFactor%1?String(t.unitsScaleFactor):String(t.unitsScaleFactor)+".0",m=t.isWebGL2?"":HE(t),f=Pf(o),g=Pf(o,t.definesFragOnly),_=i.createProgram(),A=this;let x,S,M=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(x=[g].filter(ja).join(`
`),x.length>0&&(x+=`
`),S=[m,f].filter(ja).join(`
`),S.length>0&&(S+=`
`)):(x=[Uf(t),"#define SHADER_NAME "+t.shaderName,a.compatSettings.saturateSpecEnvBlenderApprox?"#define COMPAT_SATURATE_SPEC_ENV_BLENDER_APPROX":"",a.compatSettings.useSpecEnvBlenderApprox?"#define COMPAT_USE_SPEC_ENV_BLENDER_APPROX":"",g,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+d:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",t.planeReflProbe?"#define USE_PLANE_REFLECTION":"",`
            uniform mat4 modelMatrix;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform mat3 normalMatrix;
            uniform vec3 cameraPosition;
            uniform bool isOrthographic;

            #ifdef USE_INSTANCING
                attribute mat4 instanceMatrix;
            #endif

            #ifdef USE_INSTANCING_COLOR
                attribute vec3 instanceColor;
            #endif

            attribute vec3 position;
            attribute vec3 normal;
            attribute vec2 uv;

            #ifdef USE_TANGENT
                attribute vec4 tangent;
            #endif

            #if defined(USE_COLOR_ALPHA)
                attribute vec4 color;
            #elif defined(USE_COLOR)
                attribute vec3 color;
            #endif

            #if (defined(USE_MORPHTARGETS) && !defined(MORPHTARGETS_TEXTURE))
                #if MORPHTARGETS_COUNT > 0
                    attribute vec3 morphTarget0;
                #endif
                #if MORPHTARGETS_COUNT > 1
                    attribute vec3 morphTarget1;
                #endif
                #if MORPHTARGETS_COUNT > 2
                    attribute vec3 morphTarget2;
                #endif
                #if MORPHTARGETS_COUNT > 3
                    attribute vec3 morphTarget3;
                #endif
                #if MORPHTARGETS_COUNT > 4
                    attribute vec3 morphTarget4;
                #endif
                #if MORPHTARGETS_COUNT > 5
                    attribute vec3 morphTarget5;
                #endif

                #ifdef USE_MORPHNORMALS
                    #if MORPHTARGETS_COUNT > 0
                        attribute vec3 morphNormal0;
                    #endif
                    #if MORPHTARGETS_COUNT > 1
                        attribute vec3 morphNormal1;
                    #endif
                    #if MORPHTARGETS_COUNT > 2
                        attribute vec3 morphNormal2;
                    #endif
                    #if MORPHTARGETS_COUNT > 3
                        attribute vec3 morphNormal3;
                    #endif
                    #if MORPHTARGETS_COUNT > 4
                        attribute vec3 morphNormal4;
                    #endif
                    #if MORPHTARGETS_COUNT > 5
                        attribute vec3 morphNormal5;
                    #endif
                #else
                    #if MORPHTARGETS_COUNT > 6
                        attribute vec3 morphTarget6;
                    #endif
                    #if MORPHTARGETS_COUNT > 7
                        attribute vec3 morphTarget7;
                    #endif
                    #if MORPHTARGETS_COUNT > 8
                        attribute vec3 morphTarget8;
                    #endif
                    #if MORPHTARGETS_COUNT > 9
                        attribute vec3 morphTarget9;
                    #endif
                    #if MORPHTARGETS_COUNT > 10
                        attribute vec3 morphTarget10;
                    #endif
                    #if MORPHTARGETS_COUNT > 11
                        attribute vec3 morphTarget11;
                    #endif
                #endif
            #endif

            #ifdef USE_SKINNING
                attribute vec4 skinIndex;
                attribute vec4 skinWeight;
            #endif
            `].filter(ja).join(`
`),S=[m,Uf(t),"#define SHADER_NAME "+t.shaderName,f,YE(t.materialProfile),a.compatSettings.saturateSpecEnvBlenderApprox?"#define COMPAT_SATURATE_SPEC_ENV_BLENDER_APPROX":"",a.compatSettings.useSpecEnvBlenderApprox?"#define COMPAT_USE_SPEC_ENV_BLENDER_APPROX":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+d:"",t.envMap?"#define "+u:"",h?"#define CUBEUV_TEXEL_WIDTH "+h.texelWidth:"",h?"#define CUBEUV_TEXEL_HEIGHT "+h.texelHeight:"",h?"#define CUBEUV_MAX_MIP "+h.maxMip+".0":"",t.envMapCubeUVTileSize!==0?`#define cubeUV_maxTileSize ${Do(t.envMapCubeUVTileSize)}`:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"",t.physicallyCorrectLights?"#define UNITS_SCALE_FACTOR "+p:"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==ci?"#define TONE_MAPPING":"",t.toneMapping!==ci?"#define TONE_MAPPING_LOOK "+WE(t.toneMappingLook):"",t.toneMapping!==ci?Me.tonemapping_pars_fragment:"",t.toneMapping!==ci?QE("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque&&!t.alphaToCoverage?"#define OPAQUE":"",Me.encodings_pars_fragment,kE("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",t.distancePacking?"#define DISTANCE_PACKING "+t.distancePacking:"",t.useSlopeScaledBias?"#define USE_SLOPE_SCALED_BIAS":"",`#define ESM_DISTANCE_SCALE ${Do(t.esmDistanceScale)}`,t.planeReflProbe?"#define USE_PLANE_REFLECTION":"",t.useGTAO?"#define USE_GTAO":"",a.compatSettings.gtaoDisableBkgFix?"#define GTAO_DISABLE_BKG_FIX":"",t.dirLightShadowsCSMLUT&&t.isWebGL2?`#define LUT_DIR_LIGHT_SHADOWS_CSM int[](${t.dirLightShadowsCSMLUT})`:"",`
`].filter(ja).join(`
`)),t.isMeshNodeMaterial&&(r=Of(r,t.nodeChunks),s=Of(s,t.nodeChunks)),r=ah(r),r=Bf(r,t),r=Df(r,t),t.customPrepTokens&&(r=Nf(r,t.customPrepTokens)),s=ah(s),s=Bf(s,t),s=Df(s,t),t.customPrepTokens&&(s=Nf(s,t.customPrepTokens)),r=Ff(r),s=Ff(s),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(M=`#version 300 es
`,x=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+x,S=["#define varying in",t.glslVersion===nh?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===nh?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+S);let T=M+x+r,L=M+S+s;a.debug.disableCompiledShaderCache&&(T+=`
const float ANTI_CACHE = `+Math.random()+";",L+=`
const float ANTI_CACHE = `+Math.random()+";");const z=Rf(i,35633,T),W=Rf(i,35632,L);typeof __V3D_DEVTOOLS__<"u"&&__V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:{shaderName:t.shaderName,materialName:t.materialName,vertex:T,fragment:L}})),i.attachShader(_,z),i.attachShader(_,W),t.index0AttributeName!==void 0?i.bindAttribLocation(_,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(_,0,"position"),i.linkProgram(_);let V,N,j=!0;function oe(){if(j=!1,a.debug.checkShaderErrors){const H=i.getProgramInfoLog(_).trim(),ne=i.getShaderInfoLog(z).trim(),le=i.getShaderInfoLog(W).trim();let re=!0,ae=!0;if(i.getProgramParameter(_,35714)===!1){re=!1;const E=Lf(i,z,"vertex"),F=Lf(i,W,"fragment");console.error("v3d.WebGLProgram: shader error: ",i.getError(),"35715",i.getProgramParameter(_,35715),"gl.getProgramInfoLog",H,E,F)}else H!==""?console.warn("v3d.WebGLProgram: gl.getProgramInfoLog()",H):ne!==""&&le!==""||(ae=!1);ae&&(A.diagnostics={runnable:re,programLog:H,vertexShader:{log:ne,prefix:x},fragmentShader:{log:le,prefix:S}})}i.deleteShader(z),i.deleteShader(W)}return this.getUniforms=function(){return V===void 0&&(j&&oe(),V=new vc(i,_)),V},this.getAttributes=function(){return N===void 0&&(j&&oe(),N=XE(i,_)),N},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(_),this.program=void 0},this.name=t.shaderName,this.id=zE++,this.cacheKey=e,this.usedTimes=1,this.program=_,this.vertexShader=z,this.fragmentShader=W,this.profile={calcRenderTime:!1,renderTime:0,timerQueries:[],materials:[]},this.getTexUniformCount=function(){return this.getUniforms().seq.reduce(function(H,ne){if(ne.info)switch(ne.info.type){case 35678:case 35679:case 35680:case 35682:case 36289:case 36292:case 36293:case 36298:case 36299:case 36300:case 36303:case 36306:case 36307:case 36308:case 36311:H+=ne.info.size}return H},0)},this.beginTimerQuery=function(H,ne){if(!this.profile.calcRenderTime)return;const le=H.getExtension(ne?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query");if(!le)return;let re;ne?(re=H.createQuery(),H.beginQuery(le.TIME_ELAPSED_EXT,re)):(re=le.createQueryEXT(),le.beginQueryEXT(le.TIME_ELAPSED_EXT,re)),this.profile.timerQueries.push(re)},this.endTimerQuery=function(H,ne){if(!this.profile.calcRenderTime)return;const le=H.getExtension(ne?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query");if(!le)return;ne?H.endQuery(le.TIME_ELAPSED_EXT):le.endQueryEXT(le.TIME_ELAPSED_EXT);const re=this.profile.timerQueries;for(let ae=re.length-1;ae>=0;ae--){const E=re[ae],F=ne?H.getQueryParameter(E,34919):le.getQueryObjectEXT(E,le.QUERY_RESULT_AVAILABLE_EXT),U=H.getParameter(le.GPU_DISJOINT_EXT);if(F&&!U){const B=ne?H.getQueryParameter(E,34918):le.getQueryObjectEXT(E,le.QUERY_RESULT_EXT);this.profile.renderTime+=B/1e6,re.splice(ae,1)}}},this}let nw=0;class iw{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,i=this._getShaderStage(t),o=this._getShaderStage(n),r=this._getShaderCacheForMaterial(e);return r.has(i)===!1&&(r.add(i),i.usedTimes++),r.has(o)===!1&&(r.add(o),o.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const n of t)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return n===void 0&&(n=new Set,t.set(e,n)),n}_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return n===void 0&&(n=new ow(e),t.set(e,n)),n}}class ow{constructor(e){this.id=nw++,this.code=e,this.usedTimes=0}}function rw(a,e,t,n,i,o,r){const s=new ba,l=new iw,c=[],d=i.isWebGL2,u=i.logarithmicDepthBuffer,h=i.vertexTextures;let p=i.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite",MeshMaskMaterial:"mask",MeshNodeMaterial:"node"};return this.programs=c,{getParameters:function(f,g,_,A,x,S){const M=A.fog,T=x.geometry,L=f.isMeshStandardMaterial||f.isMeshNodeMaterial?A.environment:null,z=(f.isMeshStandardMaterial||f.isMeshNodeMaterial?t:e).get(f.envMap||L),W=z&&z.mapping===xa?z.image.height:null,V=m[f.type];f.precision!==null&&(p=i.getMaxPrecision(f.precision),p!==f.precision&&console.warn("v3d.WebGLProgram.getParameters:",f.precision,"not supported, using",p,"instead."));const N=T.morphAttributes.position||T.morphAttributes.normal||T.morphAttributes.color,j=N!==void 0?N.length:0;let oe,H,ne,le,re=0;if(T.morphAttributes.position!==void 0&&(re=1),T.morphAttributes.normal!==void 0&&(re=2),T.morphAttributes.color!==void 0&&(re=3),V){const B=De[V];oe=B.vertexShader,H=B.fragmentShader}else oe=f.vertexShader,H=f.fragmentShader,l.update(f),ne=l.getVertexShaderID(f),le=l.getFragmentShaderID(f);const ae=a.getRenderTarget(),E=f.alphaTest>0,F=f.clearcoat>0,U=f.iridescence>0;return{isWebGL2:d,shaderID:V,shaderName:f.type,vertexShader:oe,fragmentShader:H,defines:f.defines,customVertexShaderID:ne,customFragmentShaderID:le,isRawShaderMaterial:f.isRawShaderMaterial===!0,glslVersion:f.glslVersion,precision:p,instancing:x.isInstancedMesh===!0,instancingColor:x.isInstancedMesh===!0&&x.instanceColor!==null,supportsVertexTextures:h,outputEncoding:ae===null?a.outputEncoding:ae.isXRRenderTarget===!0?ae.texture.encoding:_n,map:!!f.map,matcap:!!f.matcap,envMap:!!z,envMapMode:z&&z.mapping,envMapCubeUVHeight:W,lightMap:!!f.lightMap,aoMap:!!f.aoMap,emissiveMap:!!f.emissiveMap,bumpMap:!!f.bumpMap,normalMap:!!f.normalMap,objectSpaceNormalMap:f.normalMapType===Ig,tangentSpaceNormalMap:f.normalMapType===Uo,decodeVideoTexture:!!f.map&&f.map.isVideoTexture===!0&&f.map.encoding===Ke,clearcoat:F,clearcoatMap:F&&!!f.clearcoatMap,clearcoatRoughnessMap:F&&!!f.clearcoatRoughnessMap,clearcoatNormalMap:F&&!!f.clearcoatNormalMap,iridescence:U,iridescenceMap:U&&!!f.iridescenceMap,iridescenceThicknessMap:U&&!!f.iridescenceThicknessMap,displacementMap:!!f.displacementMap,roughnessMap:!!f.roughnessMap,metalnessMap:!!f.metalnessMap,specularMap:!!f.specularMap,specularIntensityMap:!!f.specularIntensityMap,specularColorMap:!!f.specularColorMap,opaque:f.transparent===!1&&f.blending===lr,alphaMap:!!f.alphaMap,alphaTest:E,gradientMap:!!f.gradientMap,sheen:f.sheen>0,sheenColorMap:!!f.sheenColorMap,sheenRoughnessMap:!!f.sheenRoughnessMap,transmission:f.transmission>0,transmissionMap:!!f.transmissionMap,thicknessMap:!!f.thicknessMap,combine:f.combine,vertexTangents:!!f.normalMap&&!!T.attributes.tangent,vertexColors:f.vertexColors,vertexAlphas:f.vertexColors===!0&&!!T.attributes.color&&T.attributes.color.itemSize===4,vertexUvs:!!(f.map||f.bumpMap||f.normalMap||f.specularMap||f.alphaMap||f.emissiveMap||f.roughnessMap||f.metalnessMap||f.clearcoatMap||f.clearcoatRoughnessMap||f.clearcoatNormalMap||f.iridescenceMap||f.iridescenceThicknessMap||f.displacementMap||f.transmissionMap||f.thicknessMap||f.specularIntensityMap||f.specularColorMap||f.sheenColorMap||f.sheenRoughnessMap),uvsVertexOnly:!(f.map||f.bumpMap||f.normalMap||f.specularMap||f.alphaMap||f.emissiveMap||f.roughnessMap||f.metalnessMap||f.clearcoatNormalMap||f.iridescenceMap||f.iridescenceThicknessMap||f.transmission>0||f.transmissionMap||f.thicknessMap||f.specularIntensityMap||f.specularColorMap||f.sheen>0||f.sheenColorMap||f.sheenRoughnessMap||!f.displacementMap),fog:!!M,useFog:f.fog===!0,fogExp2:M&&M.isFogExp2,flatShading:!!f.flatShading,sizeAttenuation:f.sizeAttenuation,logarithmicDepthBuffer:u,skinning:x.isSkinnedMesh===!0,morphTargets:T.morphAttributes.position!==void 0,morphNormals:T.morphAttributes.normal!==void 0,morphColors:T.morphAttributes.color!==void 0,morphTargetsCount:j,morphTextureStride:re,numDirLights:g.directional.length,numPointLights:g.point.length,numSpotLights:g.spot.length,numSpotLightMaps:g.spotLightMap.length,numRectAreaLights:g.rectArea.length,numHemiLights:g.hemi.length,numPointLightShadows:g.pointShadowMap.length,numSpotLightShadows:g.spotShadowMap.length,numSpotLightShadowsWithMaps:g.numSpotLightShadowsWithMaps,numClippingPlanes:r.numPlanes,numClipIntersection:r.numIntersection,dithering:f.dithering,shadowMapEnabled:a.shadowMap.enabled&&_.length>0,shadowMapType:a.shadowMap.type,toneMapping:f.toneMapped?a.toneMapping:ci,toneMappingLook:f.toneMapped?a.toneMappingLook:rs,physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:f.premultipliedAlpha,doubleSided:f.side===Tn,flipSided:f.side===nn,useDepthPacking:!!f.depthPacking,depthPacking:f.depthPacking||0,envMapCubeUVTileSize:W&&z.image!==void 0?z.image.width/3:0,distancePacking:f.distancePacking!==void 0&&f.distancePacking,useSlopeScaledBias:f.useSlopeScaledBias!==void 0&&f.useSlopeScaledBias,esmDistanceScale:a.shadowMap.esmDistanceScale,numRectAreaLightShadows:g.rectAreaShadowMap.length,numDirLightShadowsCSM:g.directionalShadowCSM.length,numDirLightShadowCSMCascades:g.directionalShadowCSMCascade.length,numDirLightShadowsCSMWithFade:g.numDirectionalShadowsCSMWithFade,dirLightShadowsCSMLUT:g.directionalShadowCSMLUT,planeReflProbe:!!S,materialName:f.name,materialProfile:f.profile,unitsScaleFactor:a.unitsScaleFactor,alphaToCoverage:!!f.alphaToCoverage,customPrepTokens:f.customPrepTokens,definesFragOnly:f.definesFragOnly,isMeshNodeMaterial:f.isMeshNodeMaterial,nodeChunks:f.nodeChunks,nodeChunksHash:f.nodeChunksHash,useGTAO:f.isMeshNodeMaterial&&f.canUseGTAO()&&a.canUseGTAO(),index0AttributeName:f.index0AttributeName,extensionDerivatives:f.extensions&&f.extensions.derivatives,extensionFragDepth:f.extensions&&f.extensions.fragDepth,extensionDrawBuffers:f.extensions&&f.extensions.drawBuffers,extensionShaderTextureLOD:f.extensions&&f.extensions.shaderTextureLOD,rendererExtensionFragDepth:d||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:d||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:d||n.has("EXT_shader_texture_lod"),customProgramCacheKey:f.customProgramCacheKey()}},getProgramCacheKey:function(f){const g=[];if(f.shaderID?g.push(f.shaderID):(g.push(f.customVertexShaderID),g.push(f.customFragmentShaderID)),f.defines!==void 0)for(const _ in f.defines)g.push(_),g.push(f.defines[_]);if(f.customPrepTokens!==void 0)for(const _ in f.customPrepTokens)g.push(_),g.push(f.customPrepTokens[_]);return f.definesFragOnly!==void 0&&g.push(f.definesFragOnly.join()),f.isRawShaderMaterial===!1&&(function(_,A){_.push(A.precision),_.push(A.outputEncoding),_.push(A.envMapMode),_.push(A.envMapCubeUVHeight),_.push(A.combine),_.push(A.vertexUvs),_.push(A.fogExp2),_.push(A.sizeAttenuation),_.push(A.morphTargetsCount),_.push(A.morphAttributeCount),_.push(A.numDirLights),_.push(A.numPointLights),_.push(A.numSpotLights),_.push(A.numSpotLightMaps),_.push(A.numHemiLights),_.push(A.numRectAreaLights),_.push(A.numPointLightShadows),_.push(A.numSpotLightShadows),_.push(A.numSpotLightShadowsWithMaps),_.push(A.shadowMapType),_.push(A.toneMapping),_.push(A.toneMappingLook),_.push(A.numClippingPlanes),_.push(A.numClipIntersection),_.push(A.depthPacking),_.push(A.unitsScaleFactor),_.push(A.esmDistanceScale),_.push(A.numRectAreaLightShadows),_.push(A.numDirLightShadowsCSM),_.push(A.numDirLightShadowCSMCascades),_.push(A.numDirLightShadowsCSMWithFade),_.push(A.dirLightShadowsCSMLUT)}(g,f),function(_,A){s.disableAll(),A.isWebGL2&&s.enable(0),A.supportsVertexTextures&&s.enable(1),A.instancing&&s.enable(2),A.instancingColor&&s.enable(3),A.map&&s.enable(4),A.matcap&&s.enable(5),A.envMap&&s.enable(6),A.lightMap&&s.enable(7),A.aoMap&&s.enable(8),A.emissiveMap&&s.enable(9),A.bumpMap&&s.enable(10),A.normalMap&&s.enable(11),A.objectSpaceNormalMap&&s.enable(12),A.tangentSpaceNormalMap&&s.enable(13),A.clearcoat&&s.enable(14),A.clearcoatMap&&s.enable(15),A.clearcoatRoughnessMap&&s.enable(16),A.clearcoatNormalMap&&s.enable(17),A.iridescence&&s.enable(18),A.iridescenceMap&&s.enable(19),A.iridescenceThicknessMap&&s.enable(20),A.displacementMap&&s.enable(21),A.specularMap&&s.enable(22),A.roughnessMap&&s.enable(23),A.metalnessMap&&s.enable(24),A.gradientMap&&s.enable(25),A.alphaMap&&s.enable(26),A.alphaTest&&s.enable(27),A.vertexColors&&s.enable(28),A.vertexAlphas&&s.enable(29),A.vertexUvs&&s.enable(30),A.vertexTangents&&s.enable(31),A.uvsVertexOnly&&s.enable(32),_.push(s.mask),s.disableAll(),A.fog&&s.enable(0),A.useFog&&s.enable(1),A.flatShading&&s.enable(2),A.logarithmicDepthBuffer&&s.enable(3),A.skinning&&s.enable(4),A.morphTargets&&s.enable(5),A.morphNormals&&s.enable(6),A.morphColors&&s.enable(7),A.premultipliedAlpha&&s.enable(8),A.shadowMapEnabled&&s.enable(9),A.physicallyCorrectLights&&s.enable(10),A.doubleSided&&s.enable(11),A.flipSided&&s.enable(12),A.useDepthPacking&&s.enable(13),A.dithering&&s.enable(14),A.specularIntensityMap&&s.enable(15),A.specularColorMap&&s.enable(16),A.transmission&&s.enable(17),A.transmissionMap&&s.enable(18),A.thicknessMap&&s.enable(19),A.sheen&&s.enable(20),A.sheenColorMap&&s.enable(21),A.sheenRoughnessMap&&s.enable(22),A.decodeVideoTexture&&s.enable(23),A.opaque&&s.enable(24),_.push(s.mask),s.disableAll(),A.distancePacking&&s.enable(0),A.useSlopeScaledBias&&s.enable(1),A.useGTAO&&s.enable(2),A.planeReflProbe&&s.enable(3),A.alphaToCoverage&&s.enable(4),_.push(s.mask)}(g,f),g.push(a.outputEncoding)),g.push(f.customProgramCacheKey),f.nodeChunksHash!==void 0&&g.push(f.nodeChunksHash),g.join()},getUniforms:function(f){const g=m[f.type];let _;if(g){const A=De[g];_=hn.clone(A.uniforms)}else _=f.uniforms;return _},acquireProgram:function(f,g){let _;for(let x=0,S=c.length;x<S;x++){const M=c[x];if(M.cacheKey===g){_=M,++_.usedTimes;break}}_===void 0&&(_=new tw(a,g,f,o),c.push(_));const A=_.profile.materials;return f.materialName&&A.indexOf(f.materialName)<0&&A.push(f.materialName),_},releaseProgram:function(f){if(--f.usedTimes==0){const g=c.indexOf(f);c[g]=c[c.length-1],c.pop(),f.destroy()}},releaseShaderCache:function(f){l.remove(f)},programs:c,dispose:function(){l.dispose()}}}function aw(){let a=new WeakMap;return{get:function(e){let t=a.get(e);return t===void 0&&(t={},a.set(e,t)),t},remove:function(e){a.delete(e)},update:function(e,t,n){a.get(e)[t]=n},dispose:function(){a=new WeakMap}}}function sw(a,e){return a.groupOrder!==e.groupOrder?a.groupOrder-e.groupOrder:a.renderOrder!==e.renderOrder?a.renderOrder-e.renderOrder:a.material.id!==e.material.id?a.material.id-e.material.id:a.z!==e.z?a.z-e.z:a.id-e.id}function zf(a,e){return a.groupOrder!==e.groupOrder?a.groupOrder-e.groupOrder:a.renderOrder!==e.renderOrder?a.renderOrder-e.renderOrder:a.z!==e.z?e.z-a.z:a.id-e.id}function Vf(){const a=[];let e=0;const t=[],n=[],i=[];function o(r,s,l,c,d,u){let h=a[e];return h===void 0?(h={id:r.id,object:r,geometry:s,material:l,groupOrder:c,renderOrder:r.renderOrder,z:d,group:u},a[e]=h):(h.id=r.id,h.object=r,h.geometry=s,h.material=l,h.groupOrder=c,h.renderOrder=r.renderOrder,h.z=d,h.group=u),e++,h}return{opaque:t,transmissive:n,transparent:i,init:function(){e=0,t.length=0,n.length=0,i.length=0},push:function(r,s,l,c,d,u){const h=o(r,s,l,c,d,u);l.transmission>0?n.push(h):l.transparent===!0?i.push(h):t.push(h)},unshift:function(r,s,l,c,d,u){const h=o(r,s,l,c,d,u);l.transmission>0?n.unshift(h):l.transparent===!0?i.unshift(h):t.unshift(h)},finish:function(){for(let r=e,s=a.length;r<s;r++){const l=a[r];if(l.id===null)break;l.id=null,l.object=null,l.geometry=null,l.material=null,l.group=null}},sort:function(r,s){t.length>1&&t.sort(r||sw),n.length>1&&n.sort(s||zf),i.length>1&&i.sort(s||zf)}}}function lw(){let a=new WeakMap;return{get:function(e,t){const n=a.get(e);let i;return n===void 0?(i=new Vf,a.set(e,[i])):t>=n.length?(i=new Vf,n.push(i)):i=n[t],i},dispose:function(){a=new WeakMap}}}function cw(){const a={};return{get:function(e){if(a[e.id]!==void 0)return a[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new b,color:new me};break;case"SpotLight":t={position:new b,direction:new b,color:new me,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new b,color:new me,distance:0,decay:0};break;case"HemisphereLight":t={direction:new b,skyColor:new me,groundColor:new me};break;case"RectAreaLight":t={color:new me,position:new b,halfWidth:new b,halfHeight:new b}}return a[e.id]=t,t}}}function uw(){const a={};return{get:function(e){if(a[e.id]!==void 0)return a[e.id];let t;switch(e.type){case"DirectionalLight":t={cascadeIdxEnd:1,cameraNear:1,shadowFar:0,fade:.25};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new te,shadow:0,shadowCameraNear:1,shadowCameraFar:1e3,expBias:1};break;case"PointLight":case"RectAreaLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new te,shadowCameraNear:1,shadowCameraFar:1e3,expBias:1}}return a[e.id]=t,t}}}let dw=0;function hw(a,e){const t=a.shadow,n=e.shadow;let i=0;return t&&t.isDirectionalLightShadowCSM&&n&&n.isDirectionalLightShadowCSM&&(i+=(n.fade!=0?1:0)-(t.fade!=0?1:0)),(e.castShadow?4:0)-(a.castShadow?4:0)+(e.map?2:0)-(a.map?2:0)+i}function pw(a,e){const t=new cw,n=uw(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numRectAreaShadows:-1,numDirectionalShadowsCSM:-1,numDirectionalShadowsCSMCascade:-1,numDirectionalShadowsCSMWithFade:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,rectAreaShadow:[],rectAreaShadowMap:[],rectAreaShadowMatrix:[],directionalShadowCSM:[],directionalShadowCSMMap:[],directionalShadowCSMMatrix:[],directionalShadowCSMCascade:[],directionalShadowCSMLUT:[],numDirectionalShadowsCSMWithFade:0};for(let l=0;l<9;l++)i.probe.push(new b);const o=new b,r=new Ae,s=new Ae;return{setup:function(l,c){let d=0,u=0,h=0;for(let j=0;j<9;j++)i.probe[j].set(0,0,0);let p=0,m=0,f=0,g=0,_=0,A=0,x=0,S=0,M=0,T=0,L=0,z=0,W=0;l.sort(hw);const V=c!==!0?Math.PI:1;for(let j=0,oe=l.length;j<oe;j++){const H=l[j],ne=H.color,le=H.intensity,re=H.distance,ae=H.shadow&&H.shadow.map?H.shadow.map.texture:null;if(H.isAmbientLight)d+=ne.r*le*V,u+=ne.g*le*V,h+=ne.b*le*V;else if(H.isLightProbe)for(let E=0;E<9;E++)i.probe[E].addScaledVector(H.sh.coefficients[E],le);else if(H.isDirectionalLight){const E=t.get(H);if(E.color.copy(H.color).multiplyScalar(H.intensity*V),H.castShadow){const F=H.shadow,U=n.get(H);U.cascadeIdxEnd=W+F.numCascades,U.fade=F.fade,z+=F.fade!=0?F.numCascades:0;for(let B=0;B<F.numCascades;B++){let Z=W+B;i.directionalShadowCSMCascade[Z]||(i.directionalShadowCSMCascade[Z]={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new te,shadowCameraNear:1,shadowCameraFar:1,cascade:new te,expBias:1,position:new b,csmIdx:0},i.directionalShadowCSMMap[Z]=null,i.directionalShadowCSMMatrix[Z]=F.matrix)}for(let B=0;B<F.numCascades;B++){const Z=W+B,k=i.directionalShadowCSMCascade[Z],X=F._cascades[B],P=X.map?X.map.texture:null;i.directionalShadowCSMMap[Z]=P,i.directionalShadowCSMMatrix[Z]=X.matrix,k.shadowBias=X.bias,k.shadowNormalBias=X.normalBias,k.shadowRadius=X.radius,k.shadowMapSize=X.mapSize,k.position.setFromMatrixPosition(X.camera.matrixWorld),k.shadowCameraNear=X.camera.near,k.shadowCameraFar=X.camera.far,F.getCascadeRange(k.cascade,B),k.expBias=X.expBias,k.csmIdx=L,i.directionalShadowCSMLUT[Z]=L}W+=F.numCascades,i.directionalShadowCSM[L]=U,L++}i.directional[p]=E,p++}else if(H.isSpotLight){const E=t.get(H);E.position.setFromMatrixPosition(H.matrixWorld),E.color.copy(ne).multiplyScalar(le*V),E.distance=re,E.coneCos=Math.cos(H.angle),E.penumbraCos=Math.cos(H.angle*(1-H.penumbra)),E.decay=H.decay,i.spot[f]=E;const F=H.shadow;if(H.map&&(i.spotLightMap[S]=H.map,S++,F.updateMatrices(H),H.castShadow&&M++),i.spotLightMatrix[f]=F.matrix,H.castShadow){const U=n.get(H);U.shadowBias=F.bias,U.shadowNormalBias=F.normalBias,U.shadowRadius=F.radius,U.shadowMapSize=F.mapSize,i.spotShadow[f]=U,i.spotShadowMap[f]=ae,U.shadow=H.castShadow?F.calcUseOmniMaps(H.angle)?2:1:0,U.shadowCameraNear=F.camera.near,U.shadowCameraFar=F.camera.far,U.expBias=F.expBias,x++}f++}else if(H.isRectAreaLight){const E=t.get(H);if(E.color.copy(ne).multiplyScalar(le),E.halfWidth.set(.5*H.width,0,0),E.halfHeight.set(0,.5*H.height,0),H.castShadow){const F=H.shadow,U=n.get(H);U.shadowBias=F.bias,U.shadowNormalBias=F.normalBias,U.shadowRadius=F.radius,U.shadowMapSize=F.mapSize,U.shadowCameraNear=F.camera.near,U.shadowCameraFar=F.camera.far,U.expBias=F.expBias,i.rectAreaShadow[g]=U,i.rectAreaShadowMap[g]=ae,i.rectAreaShadowMatrix[g]=H.shadow.matrix,T++}i.rectArea[g]=E,g++}else if(H.isPointLight){const E=t.get(H);if(E.color.copy(H.color).multiplyScalar(H.intensity*V),E.distance=H.distance,E.decay=H.decay,H.castShadow){const F=H.shadow,U=n.get(H);U.shadowBias=F.bias,U.shadowNormalBias=F.normalBias,U.shadowRadius=F.radius,U.shadowMapSize=F.mapSize,U.shadowCameraNear=F.camera.near,U.shadowCameraFar=F.camera.far,U.expBias=F.expBias,i.pointShadow[m]=U,i.pointShadowMap[m]=ae,i.pointShadowMatrix[m]=H.shadow.matrix,A++}i.point[m]=E,m++}else if(H.isHemisphereLight){const E=t.get(H);E.skyColor.copy(H.color).multiplyScalar(le*V),E.groundColor.copy(H.groundColor).multiplyScalar(le*V),i.hemi[_]=E,_++}}g>0&&(e.isWebGL2||a.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=xe.LTC_FLOAT_1,i.rectAreaLTC2=xe.LTC_FLOAT_2):a.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=xe.LTC_HALF_1,i.rectAreaLTC2=xe.LTC_HALF_2):console.error("v3d.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=u,i.ambient[2]=h;const N=i.hash;N.directionalLength===p&&N.pointLength===m&&N.spotLength===f&&N.rectAreaLength===g&&N.hemiLength===_&&N.numPointShadows===A&&N.numSpotShadows===x&&N.numSpotMaps===S&&N.numRectAreaShadows===T&&N.numDirectionalShadowsCSM===L&&N.numDirectionalShadowsCSMCascade===W&&N.numDirectionalShadowsCSMWithFade===z||(i.directional.length=p,i.spot.length=f,i.rectArea.length=g,i.point.length=m,i.hemi.length=_,i.pointShadow.length=A,i.pointShadowMap.length=A,i.spotShadow.length=x,i.spotShadowMap.length=x,i.pointShadowMatrix.length=A,i.spotLightMatrix.length=x+S-M,i.spotLightMap.length=S,i.numSpotLightShadowsWithMaps=M,N.directionalLength=p,N.pointLength=m,N.spotLength=f,N.rectAreaLength=g,N.hemiLength=_,N.numPointShadows=A,N.numSpotShadows=x,N.numSpotMaps=S,i.rectAreaShadow.length=T,i.rectAreaShadowMap.length=T,i.rectAreaShadowMatrix.length=T,i.directionalShadowCSM.length=L,i.directionalShadowCSMMap.length=W,i.directionalShadowCSMMatrix.length=W,i.directionalShadowCSMCascade.length=W,i.directionalShadowCSMLUT.length=W,i.numDirectionalShadowsCSMWithFade=z,N.numRectAreaShadows=T,N.numDirectionalShadowsCSM=L,N.numDirectionalShadowsCSMCascade=W,N.numDirectionalShadowsCSMWithFade=z,i.version=dw++)},setupView:function(l,c){let d=0,u=0,h=0,p=0,m=0,f=0;const g=c.matrixWorldInverse;for(let _=0,A=l.length;_<A;_++){const x=l[_];if(x.isDirectionalLight){const S=i.directional[d];if(S.direction.setFromMatrixPosition(x.matrixWorld),o.setFromMatrixPosition(x.target.matrixWorld),S.direction.sub(o),S.direction.transformDirection(g),x.castShadow){const M=x.shadow,T=n.get(x);T.cameraNear=Math.min(M.maxDistance,c.near),T.shadowFar=Math.min(M.maxDistance,c.far);for(let L=0;L<M.numCascades;L++){const z=f+L,W=i.directionalShadowCSMCascade[z],V=M._cascades[L];W.shadowCameraFar=V.camera.far,W.position.setFromMatrixPosition(V.camera.matrixWorld),W.position.applyMatrix4(g)}f+=M.numCascades}d++}else if(x.isSpotLight){const S=i.spot[h];S.position.setFromMatrixPosition(x.matrixWorld),S.position.applyMatrix4(g),S.direction.setFromMatrixPosition(x.matrixWorld),o.setFromMatrixPosition(x.target.matrixWorld),S.direction.sub(o),S.direction.transformDirection(g),h++}else if(x.isRectAreaLight){const S=i.rectArea[p];S.position.setFromMatrixPosition(x.matrixWorld),S.position.applyMatrix4(g),s.identity(),r.copy(x.matrixWorld),r.premultiply(g),s.extractRotation(r),S.halfWidth.set(.5*x.width,0,0),S.halfHeight.set(0,.5*x.height,0),S.halfWidth.applyMatrix4(s),S.halfHeight.applyMatrix4(s),p++}else if(x.isPointLight){const S=i.point[u];S.position.setFromMatrixPosition(x.matrixWorld),S.position.applyMatrix4(g),u++}else if(x.isHemisphereLight){const S=i.hemi[m];S.direction.setFromMatrixPosition(x.matrixWorld),S.direction.transformDirection(g),m++}}},state:i}}function sh(a,e){const t=new pw(a,e),n=[],i=[],o=[],r=[];return{init:function(){n.length=0,i.length=0,o.length=0,r.length=0},state:{lightsArray:n,shadowsArray:i,envMapProbeArray:o,planeReflProbeArray:r,lights:t},setupLights:function(s){t.setup(n,s)},setupLightsView:function(s){t.setupView(n,s)},pushLight:function(s){n.push(s)},pushShadow:function(s){i.push(s)},pushEnvMapProbe:function(s){o.push(s)},sortEnvMapProbes:function(){o.sort((s,l)=>s.influenceDistance-l.influenceDistance)},pushPlaneReflProbe:function(s){r.push(s)}}}function fw(a,e){let t=new WeakMap;return{get:function(n,i=0){const o=t.get(n);let r;return o===void 0?(r=new sh(a,e),t.set(n,[r])):i>=o.length?(r=new sh(a,e),o.push(r)):r=o[i],r},dispose:function(){t=new WeakMap}}}class vr extends Ut{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.useSlopeScaledBias=!1,this.slopeScaledBias=0,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.useSlopeScaledBias=e.useSlopeScaledBias,this.slopeScaledBias=e.slopeScaledBias,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class Hh extends Ut{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new b,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.defines={DISTANCE_SCALE:"1.0"},this.distancePacking=Uh,this.useSlopeScaledBias=!1,this.slopeScaledBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.distancePacking=e.distancePacking,this.useSlopeScaledBias=e.useSlopeScaledBias,this.slopeScaledBias=e.slopeScaledBias,this}}const Wu=new Ae,Gf=new b,kf=new b;class Zc{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new te(512,512),this.map=null,this.mapPass=null,this.matrix=new Ae,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Kc,this._frameExtents=new te(1,1),this._viewportCount=1,this._viewports=[new Re(0,0,1,1)],this.expBias=1,this.slopeScaledBias=0,this._additionalMap2D=null,this._additionalMapCube=null,this.isLightShadow=!0}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;Gf.setFromMatrixPosition(e.matrixWorld),t.position.copy(Gf),kf.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(kf),t.updateMatrixWorld(),Wu.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Wu),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(Wu)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose(),this._additionalMap2D!==null&&this._additionalMap2D.dispose(),this._additionalMapCube!==null&&this._additionalMapCube.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this.expBias=e.expBias,this.slopeScaledBias=e.slopeScaledBias,this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),this.mapSize.x===512&&this.mapSize.y===512||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}const mw=Math.PI/4,Qf=new Ae,Na=new b,Hu=new b;class gw extends Zc{constructor(){super(new Qt(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.useOmniMaps=!1,this.useMinFov90=!1,this._frameExtentsOmni=new te(4,2),this._viewportCountOmni=6,this._viewportsOmni=[new Re(2,1,1,1),new Re(0,1,1,1),new Re(3,1,1,1),new Re(1,1,1,1),new Re(3,0,1,1),new Re(1,0,1,1)],this._cubeDirections=[new b(1,0,0),new b(-1,0,0),new b(0,0,1),new b(0,0,-1),new b(0,1,0),new b(0,-1,0)],this._cubeUps=[new b(0,1,0),new b(0,1,0),new b(0,1,0),new b(0,1,0),new b(0,0,1),new b(0,0,-1)]}updateMatrices(e,t=0){if(this.useOmniMaps){const n=this.camera,i=this.matrix;Na.setFromMatrixPosition(e.matrixWorld),n.position.copy(Na),Hu.copy(n.position),Hu.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(Hu),n.updateMatrixWorld(),i.makeTranslation(-Na.x,-Na.y,-Na.z),Qf.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Qf)}else{const n=this.camera,i=2*ua*e.angle*this.focus,o=this.mapSize.width/this.mapSize.height,r=e.distance||n.far;i===n.fov&&o===n.aspect&&r===n.far||(n.fov=i,n.aspect=o,n.far=r,n.updateProjectionMatrix()),super.updateMatrices(e)}}getViewportCount(){return this.useOmniMaps?this._viewportCountOmni:super.getViewportCount()}getViewport(e){return this.useOmniMaps?this._viewportsOmni[e]:super.getViewport(e)}getFrameExtents(){return this.useOmniMaps?this._frameExtentsOmni:super.getFrameExtents()}calcUseOmniMaps(e){return this.useOmniMaps=e>mw,this.useOmniMaps}copy(e){return super.copy(e),this.focus=e.focus,this.useOmniMaps=e.useOmniMaps,this.useMinFov90=e.useMinFov90,this}}const vw=.8,_w=.2,Aw=.8,xw=50;function yw(a,e,t){let n=new Kc;const i=new te,o=new te,r=new Re,s=new vr({depthPacking:Hc}),l=new Hh,c={},d=t.maxTextureSize,u=t.isWebGL2,h={0:nn,1:kn,2:Tn},p=new Ae;new Ae;const m=new te(d,d),f=new b,g=new b;new b;const _=[new b(1,0,0),new b(-1,0,0),new b(0,1,0),new b(0,-1,0),new b(0,0,1),new b(0,0,-1)],A=[new b(0,1,0),new b(0,1,0),new b(0,0,1),new b(0,0,-1),new b(0,1,0),new b(0,1,0)];new Re,new Re,new Re,new Re,new Re,new Re,new Rn,new b,new b,new b,new b,new b,new b,new b,new b;const x=new Ue(new ni(1,1,1,1));x.name="esmFarPlane",x.castShadow=!0,x.material.shadowSide=kn;const S=0,M=1,T=0,L=new fi(-1,1,1,-1,0,10),z=new Ue(new ni(2,2)),W=new vt({type:"ShadowCubeOctahedral",defines:Object.assign({},De.cubeOctahedral.defines),uniforms:hn.clone(De.cubeOctahedral.uniforms),vertexShader:De.cubeOctahedral.vertexShader,fragmentShader:De.cubeOctahedral.fragmentShader}),V={},N={},j=this;function oe(F,U,B,Z,k,X,P,v,y){let R=null;const w=v||P===Vn?F.customDistanceMaterial:F.customDepthMaterial;if(R=w!==void 0?w:v||P===Vn?l:s,a.localClippingEnabled&&B.clipShadows===!0&&Array.isArray(B.clippingPlanes)&&B.clippingPlanes.length!==0||B.displacementMap&&B.displacementScale!==0||B.alphaMap&&B.alphaTest>0||B.map&&B.alphaTest>0){const I=R.uuid,C=B.uuid;let D=c[I];D===void 0&&(D={},c[I]=D);let O=D[C];O===void 0&&(O=R.clone(),D[C]=O),R=O}switch(R.visible=B.visible,R.wireframe=B.wireframe,R.side=B.shadowSide!==null?B.shadowSide:h[B.side],R.alphaMap=B.alphaMap,R.alphaTest=B.alphaTest,R.map=B.map,R.clipShadows=B.clipShadows,R.clippingPlanes=B.clippingPlanes,R.clipIntersection=B.clipIntersection,R.displacementMap=B.displacementMap,R.displacementScale=B.displacementScale,R.displacementBias=B.displacementBias,R.wireframeLinewidth=B.wireframeLinewidth,R.linewidth=B.linewidth,!v&&P!==Vn||R.isMeshDistanceMaterial!==!0||(R.referencePosition.copy(y),R.nearDistance=k,R.farDistance=X,R.distancePacking=P===Vn?Tg:Uh),P===Vn&&(R.defines.DISTANCE_SCALE=Do(j.esmDistanceScale)),Z.shadow.isDirectionalLightShadowCascade&&Z.shadow.pancakeDepth&&(R.defines.PANCAKE_DEPTH="",R.defines.CAM_WIDTH=Do(Z.shadow.camera.right),R.defines.CAM_HEIGHT=Do(Z.shadow.camera.top)),P){case na:case sr:case Io:case Po:case ar:R.useSlopeScaledBias=!0,R.slopeScaledBias=Z.shadow.slopeScaledBias;break;case Vn:R.useSlopeScaledBias=!0,R.slopeScaledBias=.5}return R}function H(F,U,B,Z,k,X){if(F.visible===!1)return;if((U.ignoreShadowLayers||F.layers.test(U.layers))&&(F.isMesh||F.isLine||F.isPoints)&&F.castShadow&&(!F.frustumCulled||n.intersectsObject(F))){F.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse,F.matrixWorld);const v=e.update(F),y=F.material;if(Array.isArray(y)){const R=v.groups;for(let w=0,I=R.length;w<I;w++){const C=R[w],D=y[C.materialIndex];if(D&&D.visible){const O=oe(F,0,D,Z,B.near,B.far,k,X,g);a.renderBufferDirect(B,null,v,O,F,C)}}}else if(y.visible){const R=oe(F,0,y,Z,B.near,B.far,k,X,g);a.renderBufferDirect(B,null,v,R,F,null)}}const P=F.children;for(let v=0,y=P.length;v<y;v++)H(P[v],U,B,Z,k,X)}function ne(F,U,B,Z){const k=B.shadow,X=k.camera;k.isDirectionalLightShadowCascade?g.setFromMatrixPosition(X.matrixWorld):g.setFromMatrixPosition(B.matrixWorld),i.copy(k.mapSize);const P=k.getFrameExtents();if(i.multiply(P),o.copy(k.mapSize),(i.x>d||i.y>d)&&(i.x>d&&(o.x=Math.floor(d/P.x),i.x=o.x*P.x,k.mapSize.x=o.x),i.y>d&&(o.y=Math.floor(d/P.y),i.y=o.y*P.y,k.mapSize.y=o.y)),B.isSpotLight&&k.map&&k.map.width/k.map.height!=2){const R=k.map;k.map=k._additionalMap2D,k._additionalMap2D=R}const v=B.isPointLight||B.isRectAreaLight||B.isSpotLight&&k.useOmniMaps;if(v?B.isSpotLight&&(X.fov=90,X.updateProjectionMatrix()):B.isSpotLight&&k.useMinFov90&&(X.fov=90,X.updateProjectionMatrix()),k.map===null){const R={minFilter:st,magFilter:st,format:Qe};k.map=new et(i.x,i.y,R),k.map.texture.name=B.name+".shadowMap",X.updateProjectionMatrix()}a.state.buffers.color.setClear(1,1,1,1),a.setRenderTarget(k.map),a.clear();const y=k.getViewportCount();for(let R=0;R<y;R++){const w=k.getViewport(R);r.set(o.x*w.x,o.y*w.y,o.x*w.z,o.y*w.w),a.state.viewport(r),k.updateMatrices(B,R),n.copy(k.getFrustum()),H(F,U,k.camera,B,Z,v)}}function le(F,U,B,Z){const k=B.shadow,X=k.camera,P=k.matrix,v=B.isPointLight||B.isRectAreaLight?2:1,y=i.copy(k.mapSize).multiplyScalar(v).min(m).multiplyScalar(1/v);k._additionalMapCube===null&&(k._additionalMapCube=new Us(y.x,{minFilter:Le,magFilter:Le,format:u?Ki:Qe,type:_t}),k._additionalMapCube.texture.name=B.name+".shadowMap.tmpCube"),k._additionalMap2D===null&&(k._additionalMap2D=new et(y.x*v,y.y*v,{minFilter:Le,magFilter:Le,format:u?Ki:Qe,type:_t}),k._additionalMap2D.texture.name=B.name+".shadowMap.tmp2D"),k.map===null&&(k.map=new et(y.x*v,y.y*v,{minFilter:Le,magFilter:Le,format:u?Ki:Qe,type:_t}),k.map.texture.name=B.name+".shadowMap"),g.setFromMatrixPosition(B.matrixWorld),X.position.copy(g),B.isSpotLight&&(X.fov=90,X.updateProjectionMatrix()),P.makeTranslation(-g.x,-g.y,-g.z);for(let I=0;I<6;I++)f.copy(X.position),f.add(_[I]),X.up.copy(A[I]),I!==2&&I!==3&&X.up.multiplyScalar(-1),X.lookAt(f),X.updateMatrixWorld(),p.multiplyMatrices(X.projectionMatrix,X.matrixWorldInverse),n.setFromProjectionMatrix(p),a.setRenderTarget(k._additionalMapCube,I),a.clearDepth(),E(U,X,B,Z),H(F,U,X,B,Z,!0);const R=Math.max(k.radius*v,.001),w=function(I){return Math.ceil(_w*I)}(R);(function(I,C,D){const O=z.material=W;O.uniforms.tCube.value=C.texture,O.uniforms.texelSize.value.set(1/D.width,1/D.height),O.uniformsNeedUpdate=!0,I.setRenderTarget(D),I.clear(),I.updateGeometry(z),I.renderBufferDirect(L,!1,z.geometry,O,z,null)})(a,k._additionalMapCube,k.map),re(a,k.map,k._additionalMap2D,w,R,M,T),re(a,k._additionalMap2D,k.map,w,R,S,T)}function re(F,U,B,Z,k,X,P){const v=z.material=P===T?function(y){return y in V||((V[y]=new vt({type:"ShadowBlur",defines:Object.assign({},De.blur.defines,{LOG_SPACE:1,OCTAHEDRAL_MAP:1}),uniforms:hn.clone(De.blur.uniforms),customPrepTokens:Object.assign({},De.blur.customPrepTokens),vertexShader:De.blur.vertexShader,fragmentShader:De.blur.fragmentShader})).customPrepTokens.MAX_SAMPLE_RADIUS=y),V[y]}(Z):function(y){return y in N||((N[y]=new vt({type:"ShadowBlur",defines:Object.assign({},De.blur.defines,{LOG_SPACE:1}),uniforms:hn.clone(De.blur.uniforms),customPrepTokens:Object.assign({},De.blur.customPrepTokens),vertexShader:De.blur.vertexShader,fragmentShader:De.blur.fragmentShader})).customPrepTokens.MAX_SAMPLE_RADIUS=y),N[y]}(Z);v.uniforms.direction.value.set(+(X===S),+(X===M)),v.uniforms.colorTexture.value=U.texture,v.uniforms.texSize.value.set(U.width,U.height),v.uniforms.kernelRadius.value=k,v.uniformsNeedUpdate=!0,F.setRenderTarget(B),F.clear(),F.updateGeometry(z),F.renderBufferDirect(L,!1,z.geometry,v,z,null)}function ae(F,U,B,Z){const k=B.shadow,X=k.camera,P=k.matrix,v=i.copy(k.mapSize).min(m);let y;k._additionalMap2D===null&&(k._additionalMap2D=new et(v.x,v.y,{minFilter:Le,magFilter:Le,format:u?Ki:Qe,type:_t}),k._additionalMap2D.texture.name=B.name+".shadowMap.tmp2D"),k.map===null&&(k.map=new et(v.x,v.y,{minFilter:Le,magFilter:Le,format:u?Ki:Qe,type:_t}),k.map.texture.name=B.name+".shadowMap"),k.isDirectionalLightShadowCascade?g.setFromMatrixPosition(X.matrixWorld):(g.setFromMatrixPosition(B.matrixWorld),X.position.copy(g),f.setFromMatrixPosition(B.target.matrixWorld),X.lookAt(f),X.updateMatrixWorld()),B.isSpotLight&&k.useMinFov90&&(X.fov=90,X.updateProjectionMatrix()),k.isDirectionalLightShadowCascade?(k.updateMatrices(B),n.copy(k.getFrustum())):(P.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),P.multiply(X.projectionMatrix),P.multiply(X.matrixWorldInverse),p.multiplyMatrices(X.projectionMatrix,X.matrixWorldInverse),n.setFromProjectionMatrix(p)),a.setRenderTarget(k.map),a.clearDepth(),E(U,X,B,Z),H(F,U,X,B,Z,!1),y=B.isDirectionalLight&&B.shadow.isDirectionalLightShadowCascade?xw*k.esmBlurRadius:B.isSpotLight?k.radius*Aw:k.radius,y=Math.max(y,.001);const R=function(w){return Math.ceil(vw*w)}(y);re(a,k.map,k._additionalMap2D,R,y,S,1),re(a,k._additionalMap2D,k.map,R,y,M,1)}function E(F,U,B,Z){let k,X,P,v,y,R;U.isPerspectiveCamera?(k=X=0,P=-.999*U.far,v=y=2*-P*Math.tan(Ds(U.fov)/2),R=1):U.isOrthographicCamera&&(k=(U.right+U.left)/2,X=(U.top+U.bottom)/2,P=-.999*U.far,v=U.right-U.left,y=U.top-U.bottom,R=1),U.add(x),x.scale.set(v,y,R),x.position.set(k,X,P),x.updateMatrixWorld(),H(x,F,U,B,Z,!0)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Io,this.esmDistanceScale=1,this.render=function(F,U,B){if(j.enabled===!1||j.autoUpdate===!1&&j.needsUpdate===!1||F.length===0)return;const Z=a.getRenderTarget(),k=a.getActiveCubeFace(),X=a.getActiveMipmapLevel(),P=a.state;P.setBlending(En),P.buffers.color.setClear(1,1,1,1),P.buffers.depth.setTest(!0),P.setScissorTest(!1);for(let v=0,y=F.length;v<y;v++){const R=F[v],w=R.shadow;if(w!==void 0){if(w.autoUpdate!==!1||w.needsUpdate!==!1){if(R.isSpotLight&&w.calcUseOmniMaps(R.angle),R.isPointLight||R.isRectAreaLight||R.isSpotLight&&w.useOmniMaps)switch(j.type){case na:case sr:case Io:case Po:case ar:ne(U,B,R,j.type);break;case Vn:le(U,B,R,j.type);break;default:continue}else{if(!R.isSpotLight&&!R.isDirectionalLight)continue;switch(j.type){case na:case sr:case Io:case Po:case ar:if(w.isDirectionalLightShadowCSM){w.update(B,R);const I=R.shadow;for(let C=0;C<I.numCascades;C++)R.shadow=I._cascades[C],ne(U,B,R,j.type);R.shadow=I}else ne(U,B,R,j.type);break;case Vn:if(w.isDirectionalLightShadowCSM){w.update(B,R);const I=R.shadow;for(let C=0;C<I.numCascades;C++)R.shadow=I._cascades[C],ae(U,B,R,j.type);R.shadow=I}else ae(U,B,R,j.type);break;default:continue}}w.needsUpdate=!1}}else console.warn("v3d.WebGLShadowMap:",R,"has no shadow.")}j.needsUpdate=!1,a.setRenderTarget(Z,k,X)}}function bw(a,e,t){const n=t.isWebGL2,i=new function(){let C=!1;const D=new Re;let O=null;const Y=new Re(0,0,0,0);return{setMask:function(J){O===J||C||(a.colorMask(J,J,J,J),O=J)},getMask:function(){return O},setLocked:function(J){C=J},setClear:function(J,G,K,ie,$){$===!0&&(J*=ie,G*=ie,K*=ie),D.set(J,G,K,ie),Y.equals(D)===!1&&(a.clearColor(J,G,K,ie),Y.copy(D))},reset:function(){C=!1,O=null,Y.set(-1,0,0,0)}}},o=new function(){let C=!1,D=null,O=null,Y=null,J=null;return{setTest:function(G){G!==J&&(G?k(2929):X(2929),J=G)},getTest:function(){return J},setMask:function(G){D===G||C||(a.depthMask(G),D=G)},setFunc:function(G){if(O!==G){switch(G){case tg:a.depthFunc(512);break;case ng:a.depthFunc(519);break;case ig:a.depthFunc(513);break;case Sc:a.depthFunc(515);break;case og:a.depthFunc(514);break;case rg:a.depthFunc(518);break;case ag:a.depthFunc(516);break;case sg:a.depthFunc(517);break;default:a.depthFunc(515)}O=G}},setLocked:function(G){C=G},setClear:function(G){Y!==G&&(a.clearDepth(G),Y=G)},reset:function(){C=!1,D=null,O=null,Y=null}}},r=new function(){let C=!1,D=null,O=null,Y=null,J=null,G=null,K=null,ie=null,$=null;return{setTest:function(se){C||(se?k(2960):X(2960))},setMask:function(se){D===se||C||(a.stencilMask(se),D=se)},setFunc:function(se,de,he){O===se&&Y===de&&J===he||(a.stencilFunc(se,de,he),O=se,Y=de,J=he)},setOp:function(se,de,he){G===se&&K===de&&ie===he||(a.stencilOp(se,de,he),G=se,K=de,ie=he)},setLocked:function(se){C=se},setClear:function(se){$!==se&&(a.clearStencil(se),$=se)},reset:function(){C=!1,D=null,O=null,Y=null,J=null,G=null,K=null,ie=null,$=null}}},s=new WeakMap,l=new WeakMap;let c={},d={},u=new WeakMap,h=[],p=null,m=!1,f=null,g=null,_=null,A=null,x=null,S=null,M=null,T=!1,L=null,z=null,W=null,V=null,N=null;const j=a.getParameter(35661);let oe=!1,H=0;const ne=a.getParameter(7938);ne.indexOf("WebGL")!==-1?(H=parseFloat(/^WebGL (\d)/.exec(ne)[1]),oe=H>=1):ne.indexOf("OpenGL ES")!==-1&&(H=parseFloat(/^OpenGL ES (\d)/.exec(ne)[1]),oe=H>=2);let le=null,re={};const ae=a.getParameter(3088),E=a.getParameter(2978),F=new Re().fromArray(ae),U=new Re().fromArray(E);function B(C,D,O){const Y=new Uint8Array(4),J=a.createTexture();a.bindTexture(C,J),a.texParameteri(C,10241,9728),a.texParameteri(C,10240,9728);for(let G=0;G<O;G++)a.texImage2D(D+G,0,6408,1,1,0,6408,5121,Y);return J}const Z={};function k(C){c[C]!==!0&&(a.enable(C),c[C]=!0)}function X(C){c[C]!==!1&&(a.disable(C),c[C]=!1)}Z[3553]=B(3553,3553,1),Z[34067]=B(34067,34069,6),i.setClear(0,0,0,1),o.setClear(1),r.setClear(0),k(2929),o.setFunc(Sc),R(!1),w(Nd),k(2884),y(En);const P={[tn]:32774,[Ch]:32778,[Sh]:32779};if(n)P[zd]=32775,P[Vd]=32776;else{const C=e.get("EXT_blend_minmax");C!==null&&(P[zd]=C.MIN_EXT,P[Vd]=C.MAX_EXT)}const v={[Ls]:0,[ei]:1,[Mh]:768,[xr]:770,[Lh]:776,[Ih]:774,[wh]:772,[Eh]:769,[Ri]:771,[Rh]:775,[Th]:773};function y(C,D,O,Y,J,G,K,ie){if(C!==En){if(m===!1&&(k(3042),m=!0),C===no)J=J||D,G=G||O,K=K||Y,D===g&&J===x||(a.blendEquationSeparate(P[D],P[J]),g=D,x=J),O===_&&Y===A&&G===S&&K===M||(a.blendFuncSeparate(v[O],v[Y],v[G],v[K]),_=O,A=Y,S=G,M=K),f=C,T=!1;else if(C!==f||ie!==T){if(g===tn&&x===tn||(a.blendEquation(32774),g=tn,x=tn),ie)switch(C){case lr:a.blendFuncSeparate(1,771,1,771);break;case os:a.blendFunc(1,1);break;case Fd:a.blendFuncSeparate(0,769,0,1);break;case Ud:a.blendFuncSeparate(0,768,0,770);break;default:console.error("v3d.WebGLState: Invalid blending: ",C)}else switch(C){case lr:a.blendFuncSeparate(770,771,1,771);break;case os:a.blendFunc(770,1);break;case Fd:a.blendFuncSeparate(0,769,0,1);break;case Ud:a.blendFunc(0,768);break;default:console.error("v3d.WebGLState: Invalid blending: ",C)}_=null,A=null,S=null,M=null,f=C,T=ie}}else m===!0&&(X(3042),m=!1)}function R(C){L!==C&&(C?a.frontFace(2304):a.frontFace(2305),L=C)}function w(C){C!==$0?(k(2884),C!==z&&(C===Nd?a.cullFace(1029):C===eg?a.cullFace(1028):a.cullFace(1032))):X(2884),z=C}function I(C,D,O){C?(k(32823),V===D&&N===O||(a.polygonOffset(D,O),V=D,N=O)):X(32823)}return{buffers:{color:i,depth:o,stencil:r},enable:k,disable:X,bindFramebuffer:function(C,D){return d[C]!==D&&(a.bindFramebuffer(C,D),d[C]=D,n&&(C===36009&&(d[36160]=D),C===36160&&(d[36009]=D)),!0)},drawBuffers:function(C,D){let O=h,Y=!1;if(C)if(O=u.get(D),O===void 0&&(O=[],u.set(D,O)),C.isWebGLMultipleRenderTargets){const J=C.texture;if(O.length!==J.length||O[0]!==36064){for(let G=0,K=J.length;G<K;G++)O[G]=36064+G;O.length=J.length,Y=!0}}else O[0]!==36064&&(O[0]=36064,Y=!0);else O[0]!==1029&&(O[0]=1029,Y=!0);Y&&(t.isWebGL2?a.drawBuffers(O):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(O))},useProgram:function(C){return p!==C&&(a.useProgram(C),p=C,!0)},setBlending:y,setMaterial:function(C,D){C.side===Tn?X(2884):k(2884);let O=C.side===nn;D&&(O=!O),R(O),C.blending===lr&&C.transparent===!1?y(En):y(C.blending,C.blendEquation,C.blendSrc,C.blendDst,C.blendEquationAlpha,C.blendSrcAlpha,C.blendDstAlpha,C.premultipliedAlpha),o.setFunc(C.depthFunc),o.setTest(C.depthTest),o.setMask(C.depthWrite),i.setMask(C.colorWrite);const Y=C.stencilWrite;r.setTest(Y),Y&&(r.setMask(C.stencilWriteMask),r.setFunc(C.stencilFunc,C.stencilRef,C.stencilFuncMask),r.setOp(C.stencilFail,C.stencilZFail,C.stencilZPass)),I(C.polygonOffset,C.polygonOffsetFactor,C.polygonOffsetUnits),C.alphaToCoverage===!0?k(32926):X(32926)},setFlipSided:R,setCullFace:w,setLineWidth:function(C){C!==W&&(oe&&a.lineWidth(C),W=C)},setPolygonOffset:I,setScissorTest:function(C){C?k(3089):X(3089)},activeTexture:function(C){C===void 0&&(C=33984+j-1),le!==C&&(a.activeTexture(C),le=C)},bindTexture:function(C,D,O){O===void 0&&(O=le===null?33984+j-1:le);let Y=re[O];Y===void 0&&(Y={type:void 0,texture:void 0},re[O]=Y),Y.type===C&&Y.texture===D||(le!==O&&(a.activeTexture(O),le=O),a.bindTexture(C,D||Z[C]),Y.type=C,Y.texture=D)},unbindTexture:function(){const C=re[le];C!==void 0&&C.type!==void 0&&(a.bindTexture(C.type,null),C.type=void 0,C.texture=void 0)},compressedTexImage2D:function(){try{a.compressedTexImage2D.apply(a,arguments)}catch(C){console.error("v3d.WebGLState:",C)}},compressedTexImage3D:function(){try{a.compressedTexImage3D.apply(a,arguments)}catch(C){console.error("v3d.WebGLState:",C)}},texImage2D:function(){try{a.texImage2D.apply(a,arguments)}catch(C){console.error("v3d.WebGLState:",C)}},texImage3D:function(){try{a.texImage3D.apply(a,arguments)}catch(C){console.error("v3d.WebGLState:",C)}},updateUBOMapping:function(C,D){let O=l.get(D);O===void 0&&(O=new WeakMap,l.set(D,O));let Y=O.get(C);Y===void 0&&(Y=a.getUniformBlockIndex(D,C.name),O.set(C,Y))},uniformBlockBinding:function(C,D){const O=l.get(D).get(C);s.get(C)!==O&&(a.uniformBlockBinding(D,O,C.__bindingPointIndex),s.set(C,O))},texStorage2D:function(){try{a.texStorage2D.apply(a,arguments)}catch(C){console.error("v3d.WebGLState:",C)}},texStorage3D:function(){try{a.texStorage3D.apply(a,arguments)}catch(C){console.error("v3d.WebGLState:",C)}},texSubImage2D:function(){try{a.texSubImage2D.apply(a,arguments)}catch(C){console.error("v3d.WebGLState:",C)}},texSubImage3D:function(){try{a.texSubImage3D.apply(a,arguments)}catch(C){console.error("v3d.WebGLState:",C)}},compressedTexSubImage2D:function(){try{a.compressedTexSubImage2D.apply(a,arguments)}catch(C){console.error("v3d.WebGLState:",C)}},compressedTexSubImage3D:function(){try{a.compressedTexSubImage3D.apply(a,arguments)}catch(C){console.error("v3d.WebGLState:",C)}},scissor:function(C){F.equals(C)===!1&&(a.scissor(C.x,C.y,C.z,C.w),F.copy(C))},viewport:function(C){U.equals(C)===!1&&(a.viewport(C.x,C.y,C.z,C.w),U.copy(C))},reset:function(){a.disable(3042),a.disable(2884),a.disable(2929),a.disable(32823),a.disable(3089),a.disable(2960),a.disable(32926),a.blendEquation(32774),a.blendFunc(1,0),a.blendFuncSeparate(1,0,1,0),a.colorMask(!0,!0,!0,!0),a.clearColor(0,0,0,0),a.depthMask(!0),a.depthFunc(513),a.clearDepth(1),a.stencilMask(4294967295),a.stencilFunc(519,0,4294967295),a.stencilOp(7680,7680,7680),a.clearStencil(0),a.cullFace(1029),a.frontFace(2305),a.polygonOffset(0,0),a.activeTexture(33984),a.bindFramebuffer(36160,null),n===!0&&(a.bindFramebuffer(36009,null),a.bindFramebuffer(36008,null)),a.useProgram(null),a.lineWidth(1),a.scissor(0,0,a.canvas.width,a.canvas.height),a.viewport(0,0,a.canvas.width,a.canvas.height),c={},le=null,re={},d={},u=new WeakMap,h=[],p=null,m=!1,f=null,g=null,_=null,A=null,x=null,S=null,M=null,T=!1,L=null,z=null,W=null,V=null,N=null,F.set(0,0,a.canvas.width,a.canvas.height),U.set(0,0,a.canvas.width,a.canvas.height),i.reset(),o.reset(),r.reset()}}}function Cw(a,e,t,n,i,o,r){const s=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,d=i.maxTextureSize,u=i.maxSamples,h=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,p=typeof navigator<"u"&&/OculusBrowser/g.test(navigator.userAgent),m=new WeakMap;let f;const g=new WeakMap;let _=!1;try{_=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function A(P,v){return _?new OffscreenCanvas(P,v):vs("canvas")}function x(P,v,y,R){let w=1;if((P.width>R||P.height>R)&&(w=R/Math.max(P.width,P.height)),w<1||v===!0){if(typeof HTMLImageElement<"u"&&P instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&P instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&P instanceof ImageBitmap){const I=v?Tc:Math.floor,C=I(w*P.width),D=I(w*P.height);f===void 0&&(f=A(C,D));const O=y?A(C,D):f;return O.width=C,O.height=D,O.getContext("2d").drawImage(P,0,0,C,D),console.warn("v3d.WebGLRenderer: Texture has been resized from ("+P.width+"x"+P.height+") to ("+C+"x"+D+")."),O}return"data"in P&&console.warn("v3d.WebGLRenderer: Image in DataTexture is too big ("+P.width+"x"+P.height+")."),P}return P}function S(P){return oh(P.width)&&oh(P.height)}function M(P,v){return P.generateMipmaps&&v&&P.minFilter!==st&&P.minFilter!==Le}function T(P){a.generateMipmap(P)}function L(P,v,y,R,w=!1){if(s===!1)return v;if(P!==null){if(a[P]!==void 0)return a[P];console.warn("v3d.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+P+"'")}let I=v;return v===6403&&(y===5126&&(I=33326),y===5131&&(I=33325),y===5121&&(I=33321)),v===33319&&(y===5126&&(I=33328),y===5131&&(I=33327),y===5121&&(I=33323)),v===6408&&(y===5126&&(I=34836),y===5131&&(I=34842),y===5121&&(I=R===Ke&&w===!1?35907:32856),y===32819&&(I=32854),y===32820&&(I=32855)),I!==33325&&I!==33326&&I!==33327&&I!==33328&&I!==34842&&I!==34836||e.get("EXT_color_buffer_float"),I}function z(P,v,y){return M(P,y)===!0||P.isFramebufferTexture&&P.minFilter!==st&&P.minFilter!==Le?Math.log2(Math.max(v.width,v.height))+1:P.mipmaps!==void 0&&P.mipmaps.length>0?P.mipmaps.length:P.isCompressedTexture&&Array.isArray(P.image)?v.mipmaps.length:1}function W(P){return P===st||P===ca||P===cr?9728:9729}function V(P){const v=P.target;v.removeEventListener("dispose",V),function(y){const R=n.get(y);if(R.__webglInit===void 0)return;const w=y.source,I=g.get(w);if(I){const C=I[R.__cacheKey];C.usedTimes--,C.usedTimes===0&&j(y),Object.keys(I).length===0&&g.delete(w)}n.remove(y)}(v),v.isVideoTexture&&m.delete(v)}function N(P){const v=P.target;v.removeEventListener("dispose",N),function(y){const R=y.texture,w=n.get(y),I=n.get(R);if(I.__webglTexture!==void 0&&(a.deleteTexture(I.__webglTexture),r.memory.textures--),y.depthTexture&&y.depthTexture.dispose(),y.isWebGLCubeRenderTarget)for(let C=0;C<6;C++)a.deleteFramebuffer(w.__webglFramebuffer[C]),w.__webglDepthbuffer&&a.deleteRenderbuffer(w.__webglDepthbuffer[C]);else{if(a.deleteFramebuffer(w.__webglFramebuffer),w.__webglDepthbuffer&&a.deleteRenderbuffer(w.__webglDepthbuffer),w.__webglMultisampledFramebuffer&&a.deleteFramebuffer(w.__webglMultisampledFramebuffer),w.__webglColorRenderbuffer)for(let C=0;C<w.__webglColorRenderbuffer.length;C++)w.__webglColorRenderbuffer[C]&&a.deleteRenderbuffer(w.__webglColorRenderbuffer[C]);w.__webglDepthRenderbuffer&&a.deleteRenderbuffer(w.__webglDepthRenderbuffer)}if(y.isWebGLMultipleRenderTargets)for(let C=0,D=R.length;C<D;C++){const O=n.get(R[C]);O.__webglTexture&&(a.deleteTexture(O.__webglTexture),r.memory.textures--),n.remove(R[C])}n.remove(R),n.remove(y)}(v),r.removeTextureSpec(v)}function j(P){const v=n.get(P);a.deleteTexture(v.__webglTexture);const y=P.source;delete g.get(y)[v.__cacheKey],r.memory.textures--,r.removeTextureSpec(P)}let oe=0;function H(P,v){const y=n.get(P);if(P.isVideoTexture&&function(R){const w=r.render.frame;m.get(R)!==w&&(m.set(R,w),R.update())}(P),P.isRenderTargetTexture===!1&&P.version>0&&y.__version!==P.version){const R=P.image;if(R===null)console.warn("v3d.WebGLRenderer: Texture marked for update but no image data found.");else{if(R.complete!==!1)return void E(y,P,v);console.warn("v3d.WebGLRenderer: Texture marked for update but image is incomplete")}}t.bindTexture(3553,y.__webglTexture,33984+v)}const ne={[Qn]:10497,[mt]:33071,[fr]:33648},le={[st]:9728,[ca]:9984,[cr]:9986,[Le]:9729,[Bs]:9985,[In]:9987};function re(P,v,y){if(y?(a.texParameteri(P,10242,ne[v.wrapS]),a.texParameteri(P,10243,ne[v.wrapT]),P!==32879&&P!==35866||a.texParameteri(P,32882,ne[v.wrapR]),a.texParameteri(P,10240,le[v.magFilter]),a.texParameteri(P,10241,le[v.minFilter])):(a.texParameteri(P,10242,33071),a.texParameteri(P,10243,33071),P!==32879&&P!==35866||a.texParameteri(P,32882,33071),v.wrapS===mt&&v.wrapT===mt||console.warn("v3d.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to v3d.ClampToEdgeWrapping."),a.texParameteri(P,10240,W(v.magFilter)),a.texParameteri(P,10241,W(v.minFilter)),v.minFilter!==st&&v.minFilter!==Le&&console.warn("v3d.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to v3d.NearestFilter or v3d.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const R=e.get("EXT_texture_filter_anisotropic");if(v.magFilter===st||v.minFilter!==cr&&v.minFilter!==In||v.type===Ct&&e.has("OES_texture_float_linear")===!1||s===!1&&v.type===_t&&e.has("OES_texture_half_float_linear")===!1)return;(v.anisotropy>1||n.get(v).__currentAnisotropy)&&(a.texParameterf(P,R.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(v.anisotropy,i.getMaxAnisotropy())),n.get(v).__currentAnisotropy=v.anisotropy)}}function ae(P,v){let y=!1;P.__webglInit===void 0&&(P.__webglInit=!0,v.addEventListener("dispose",V));const R=v.source;let w=g.get(R);w===void 0&&(w={},g.set(R,w));const I=function(C){const D=[];return D.push(C.wrapS),D.push(C.wrapT),D.push(C.wrapR||0),D.push(C.magFilter),D.push(C.minFilter),D.push(C.anisotropy),D.push(C.internalFormat),D.push(C.format),D.push(C.type),D.push(C.generateMipmaps),D.push(C.premultiplyAlpha),D.push(C.flipY),D.push(C.unpackAlignment),D.push(C.encoding),D.join()}(v);if(I!==P.__cacheKey){w[I]===void 0&&(w[I]={texture:a.createTexture(),usedTimes:0},r.memory.textures++,r.addTextureSpec(v),y=!0),w[I].usedTimes++;const C=w[P.__cacheKey];C!==void 0&&(w[P.__cacheKey].usedTimes--,C.usedTimes===0&&j(v)),P.__cacheKey=I,P.__webglTexture=w[I].texture}return y}function E(P,v,y){let R=3553;(v.isDataArrayTexture||v.isCompressedArrayTexture)&&(R=35866),v.isData3DTexture&&(R=32879);const w=ae(P,v),I=v.source;t.bindTexture(R,P.__webglTexture,33984+y);const C=n.get(I);if(I.version!==C.__version||w===!0){t.activeTexture(33984+y),a.pixelStorei(37440,v.flipY),a.pixelStorei(37441,v.premultiplyAlpha),a.pixelStorei(3317,v.unpackAlignment),a.pixelStorei(37443,0);const D=function(ee){return!s&&(ee.wrapS!==mt||ee.wrapT!==mt||ee.minFilter!==st&&ee.minFilter!==Le)}(v)&&S(v.image)===!1;let O=x(v.image,D,!1,d);O=X(v,O);const Y=S(O)||s,J=o.convert(v.format,v.encoding);let G,K=o.convert(v.type),ie=L(v.internalFormat,J,K,v.encoding,v.isVideoTexture);re(R,v,Y);const $=v.mipmaps,se=s&&v.isVideoTexture!==!0,de=C.__version===void 0||w===!0,he=z(v,O,Y);if(v.isDepthTexture)ie=6402,s?ie=v.type===Ct?36012:v.type===Zi?33190:v.type===ur?35056:33189:v.type===Ct&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),v.format===Bo&&ie===6402&&v.type!==Nh&&v.type!==Zi&&(console.warn("v3d.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),v.type=Zi,K=o.convert(v.type)),v.format===mr&&ie===6402&&(ie=34041,v.type!==ur&&(console.warn("v3d.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),v.type=ur,K=o.convert(v.type))),de&&(se?t.texStorage2D(3553,1,ie,O.width,O.height):t.texImage2D(3553,0,ie,O.width,O.height,0,J,K,null));else if(v.isDataTexture)if($.length>0&&Y){se&&de&&t.texStorage2D(3553,he,ie,$[0].width,$[0].height);for(let ee=0,ge=$.length;ee<ge;ee++)G=$[ee],se?t.texSubImage2D(3553,ee,0,0,G.width,G.height,J,K,G.data):t.texImage2D(3553,ee,ie,G.width,G.height,0,J,K,G.data);v.generateMipmaps=!1}else se?(de&&t.texStorage2D(3553,he,ie,O.width,O.height),t.texSubImage2D(3553,0,0,0,O.width,O.height,J,K,O.data)):t.texImage2D(3553,0,ie,O.width,O.height,0,J,K,O.data);else if(v.isCompressedTexture)if(v.isCompressedArrayTexture){se&&de&&t.texStorage3D(35866,he,ie,$[0].width,$[0].height,O.depth);for(let ee=0,ge=$.length;ee<ge;ee++)G=$[ee],v.format!==Qe?J!==null?se?t.compressedTexSubImage3D(35866,ee,0,0,0,G.width,G.height,O.depth,J,G.data,0,0):t.compressedTexImage3D(35866,ee,ie,G.width,G.height,O.depth,0,G.data,0,0):console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):se?t.texSubImage3D(35866,ee,0,0,0,G.width,G.height,O.depth,J,K,G.data):t.texImage3D(35866,ee,ie,G.width,G.height,O.depth,0,J,K,G.data)}else{se&&de&&t.texStorage2D(3553,he,ie,$[0].width,$[0].height);for(let ee=0,ge=$.length;ee<ge;ee++)G=$[ee],v.format!==Qe?J!==null?se?t.compressedTexSubImage2D(3553,ee,0,0,G.width,G.height,J,G.data):t.compressedTexImage2D(3553,ee,ie,G.width,G.height,0,G.data):console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):se?t.texSubImage2D(3553,ee,0,0,G.width,G.height,J,K,G.data):t.texImage2D(3553,ee,ie,G.width,G.height,0,J,K,G.data)}else if(v.isDataArrayTexture)se?(de&&t.texStorage3D(35866,he,ie,O.width,O.height,O.depth),t.texSubImage3D(35866,0,0,0,0,O.width,O.height,O.depth,J,K,O.data)):t.texImage3D(35866,0,ie,O.width,O.height,O.depth,0,J,K,O.data);else if(v.isData3DTexture)se?(de&&t.texStorage3D(32879,he,ie,O.width,O.height,O.depth),t.texSubImage3D(32879,0,0,0,0,O.width,O.height,O.depth,J,K,O.data)):t.texImage3D(32879,0,ie,O.width,O.height,O.depth,0,J,K,O.data);else if(v.isFramebufferTexture){if(de)if(se)t.texStorage2D(3553,he,ie,O.width,O.height);else{let ee=O.width,ge=O.height;for(let ve=0;ve<he;ve++)t.texImage2D(3553,ve,ie,ee,ge,0,J,K,null),ee>>=1,ge>>=1}}else if($.length>0&&Y){se&&de&&t.texStorage2D(3553,he,ie,$[0].width,$[0].height);for(let ee=0,ge=$.length;ee<ge;ee++)G=$[ee],se?t.texSubImage2D(3553,ee,0,0,J,K,G):t.texImage2D(3553,ee,ie,J,K,G);v.generateMipmaps=!1}else se?(de&&t.texStorage2D(3553,he,ie,O.width,O.height),t.texSubImage2D(3553,0,0,0,J,K,O)):t.texImage2D(3553,0,ie,J,K,O);M(v,Y)&&T(R),C.__version=I.version,v.onUpdate&&v.onUpdate(v)}P.__version=v.version}function F(P,v,y,R,w){const I=o.convert(y.format,y.encoding),C=o.convert(y.type),D=L(y.internalFormat,I,C,y.encoding);n.get(v).__hasExternalTextures||(w===32879||w===35866?t.texImage3D(w,0,D,v.width,v.height,v.depth,0,I,C,null):t.texImage2D(w,0,D,v.width,v.height,0,I,C,null)),t.bindFramebuffer(36160,P),k(v)?h.framebufferTexture2DMultisampleEXT(36160,R,w,n.get(y).__webglTexture,0,Z(v)):(w===3553||w>=34069&&w<=34074)&&a.framebufferTexture2D(36160,R,w,n.get(y).__webglTexture,0),t.bindFramebuffer(36160,null)}function U(P,v,y){if(a.bindRenderbuffer(36161,P),v.depthBuffer&&!v.stencilBuffer){let R=33189;if(s&&(R=33190),y||k(v)){const w=v.depthTexture;w&&w.isDepthTexture&&(w.type===Ct?R=36012:w.type===Zi&&(R=33190));const I=Z(v);k(v)?h.renderbufferStorageMultisampleEXT(36161,I,R,v.width,v.height):a.renderbufferStorageMultisample(36161,I,R,v.width,v.height)}else a.renderbufferStorage(36161,R,v.width,v.height);a.framebufferRenderbuffer(36160,36096,36161,P)}else if(v.depthBuffer&&v.stencilBuffer){const R=Z(v);y&&k(v)===!1?a.renderbufferStorageMultisample(36161,R,35056,v.width,v.height):k(v)?h.renderbufferStorageMultisampleEXT(36161,R,35056,v.width,v.height):a.renderbufferStorage(36161,34041,v.width,v.height),a.framebufferRenderbuffer(36160,33306,36161,P)}else{const R=v.isWebGLMultipleRenderTargets===!0?v.texture:[v.texture];for(let w=0;w<R.length;w++){const I=R[w],C=o.convert(I.format,I.encoding),D=o.convert(I.type),O=L(I.internalFormat,C,D,I.encoding),Y=Z(v);y&&k(v)===!1?a.renderbufferStorageMultisample(36161,Y,O,v.width,v.height):k(v)?h.renderbufferStorageMultisampleEXT(36161,Y,O,v.width,v.height):a.renderbufferStorage(36161,O,v.width,v.height)}}a.bindRenderbuffer(36161,null)}function B(P){const v=n.get(P),y=P.isWebGLCubeRenderTarget===!0;if(P.depthTexture&&!v.__autoAllocateDepthBuffer){if(y)throw new Error("target.depthTexture not supported in Cube render targets");(function(R,w){if(w&&w.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,R),!w.depthTexture||!w.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of v3d.DepthTexture");n.get(w.depthTexture).__webglTexture&&w.depthTexture.image.width===w.width&&w.depthTexture.image.height===w.height||(w.depthTexture.image.width=w.width,w.depthTexture.image.height=w.height,w.depthTexture.needsUpdate=!0),H(w.depthTexture,0);const I=n.get(w.depthTexture).__webglTexture,C=Z(w);if(w.depthTexture.format===Bo)k(w)?h.framebufferTexture2DMultisampleEXT(36160,36096,3553,I,0,C):a.framebufferTexture2D(36160,36096,3553,I,0);else{if(w.depthTexture.format!==mr)throw new Error("Unknown depthTexture format");k(w)?h.framebufferTexture2DMultisampleEXT(36160,33306,3553,I,0,C):a.framebufferTexture2D(36160,33306,3553,I,0)}})(v.__webglFramebuffer,P)}else if(y){v.__webglDepthbuffer=[];for(let R=0;R<6;R++)t.bindFramebuffer(36160,v.__webglFramebuffer[R]),v.__webglDepthbuffer[R]=a.createRenderbuffer(),U(v.__webglDepthbuffer[R],P,!1)}else t.bindFramebuffer(36160,v.__webglFramebuffer),v.__webglDepthbuffer=a.createRenderbuffer(),U(v.__webglDepthbuffer,P,!1);t.bindFramebuffer(36160,null)}function Z(P){return Math.min(u,P.samples)}function k(P){const v=n.get(P);return s&&P.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&v.__useRenderToTexture!==!1}function X(P,v){const y=P.encoding,R=P.format,w=P.type;return P.isCompressedTexture===!0||P.isVideoTexture===!0||P.format===Mc||y!==_n&&(y===Ke?s===!1?e.has("EXT_sRGB")===!0&&R===Qe?(P.format=Mc,P.minFilter=Le,P.generateMipmaps=!1):v=Gh.sRGBToLinear(v):R===Qe&&w===Ft||console.warn("v3d.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("v3d.WebGLTextures: Unsupported texture encoding:",y)),v}this.allocateTextureUnit=function(){const P=oe;return P>=l&&console.warn("v3d.WebGLTextures: Trying to use "+P+" texture units while this GPU supports only "+l),oe+=1,P},this.resetTextureUnits=function(){oe=0},this.setTexture2D=H,this.setTexture2DArray=function(P,v){const y=n.get(P);P.version>0&&y.__version!==P.version?E(y,P,v):t.bindTexture(35866,y.__webglTexture,33984+v)},this.setTexture3D=function(P,v){const y=n.get(P);P.version>0&&y.__version!==P.version?E(y,P,v):t.bindTexture(32879,y.__webglTexture,33984+v)},this.setTextureCube=function(P,v){const y=n.get(P);P.version>0&&y.__version!==P.version?function(R,w,I){if(w.image.length!==6)return;const C=ae(R,w),D=w.source;t.bindTexture(34067,R.__webglTexture,33984+I);const O=n.get(D);if(D.version!==O.__version||C===!0){t.activeTexture(33984+I),a.pixelStorei(37440,w.flipY),a.pixelStorei(37441,w.premultiplyAlpha),a.pixelStorei(3317,w.unpackAlignment),a.pixelStorei(37443,0);const Y=w.isCompressedTexture||w.image[0].isCompressedTexture,J=w.image[0]&&w.image[0].isDataTexture,G=[];for(let _e=0;_e<6;_e++)G[_e]=Y||J?J?w.image[_e].image:w.image[_e]:x(w.image[_e],!1,!0,c),G[_e]=X(w,G[_e]);const K=G[0],ie=S(K)||s,$=o.convert(w.format,w.encoding),se=o.convert(w.type),de=L(w.internalFormat,$,se,w.encoding),he=s&&w.isVideoTexture!==!0,ee=O.__version===void 0||C===!0;let ge,ve=z(w,K,ie);if(re(34067,w,ie),Y){he&&ee&&t.texStorage2D(34067,ve,de,K.width,K.height);for(let _e=0;_e<6;_e++){ge=G[_e].mipmaps;for(let we=0;we<ge.length;we++){const Be=ge[we];w.format!==Qe?$!==null?he?t.compressedTexSubImage2D(34069+_e,we,0,0,Be.width,Be.height,$,Be.data):t.compressedTexImage2D(34069+_e,we,de,Be.width,Be.height,0,Be.data):console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):he?t.texSubImage2D(34069+_e,we,0,0,Be.width,Be.height,$,se,Be.data):t.texImage2D(34069+_e,we,de,Be.width,Be.height,0,$,se,Be.data)}}}else{ge=w.mipmaps,he&&ee&&(ge.length>0&&ve++,t.texStorage2D(34067,ve,de,G[0].width,G[0].height));for(let _e=0;_e<6;_e++)if(J){he?t.texSubImage2D(34069+_e,0,0,0,G[_e].width,G[_e].height,$,se,G[_e].data):t.texImage2D(34069+_e,0,de,G[_e].width,G[_e].height,0,$,se,G[_e].data);for(let we=0;we<ge.length;we++){const Be=ge[we].image[_e].image;he?t.texSubImage2D(34069+_e,we+1,0,0,Be.width,Be.height,$,se,Be.data):t.texImage2D(34069+_e,we+1,de,Be.width,Be.height,0,$,se,Be.data)}}else{he?t.texSubImage2D(34069+_e,0,0,0,$,se,G[_e]):t.texImage2D(34069+_e,0,de,$,se,G[_e]);for(let we=0;we<ge.length;we++){const Be=ge[we];he?t.texSubImage2D(34069+_e,we+1,0,0,$,se,Be.image[_e]):t.texImage2D(34069+_e,we+1,de,$,se,Be.image[_e])}}}M(w,ie)&&T(34067),O.__version=D.version,w.onUpdate&&w.onUpdate(w)}R.__version=w.version}(y,P,v):t.bindTexture(34067,y.__webglTexture,33984+v)},this.rebindTextures=function(P,v,y){const R=n.get(P);v!==void 0&&F(R.__webglFramebuffer,P,P.texture,36064,3553),y!==void 0&&B(P)},this.setupRenderTarget=function(P){const v=P.texture,y=n.get(P),R=n.get(v);P.addEventListener("dispose",N),P.isWebGLMultipleRenderTargets!==!0&&(R.__webglTexture===void 0&&(R.__webglTexture=a.createTexture()),R.__version=v.version,r.memory.textures++),r.addTextureSpec(P);const w=P.isWebGLCubeRenderTarget===!0,I=P.isWebGLMultipleRenderTargets===!0,C=S(P)||s;if(w){y.__webglFramebuffer=[];for(let D=0;D<6;D++)y.__webglFramebuffer[D]=a.createFramebuffer()}else{if(y.__webglFramebuffer=a.createFramebuffer(),I)if(i.drawBuffers){const D=P.texture;for(let O=0,Y=D.length;O<Y;O++){const J=n.get(D[O]);J.__webglTexture===void 0&&(J.__webglTexture=a.createTexture(),r.memory.textures++)}}else console.warn("v3d.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(s&&P.samples>0&&k(P)===!1){const D=I?v:[v];y.__webglMultisampledFramebuffer=a.createFramebuffer(),y.__webglColorRenderbuffer=[],t.bindFramebuffer(36160,y.__webglMultisampledFramebuffer);for(let O=0;O<D.length;O++){const Y=D[O];y.__webglColorRenderbuffer[O]=a.createRenderbuffer(),a.bindRenderbuffer(36161,y.__webglColorRenderbuffer[O]);const J=o.convert(Y.format,Y.encoding),G=o.convert(Y.type),K=L(Y.internalFormat,J,G,Y.encoding,P.isXRRenderTarget===!0),ie=Z(P);a.renderbufferStorageMultisample(36161,ie,K,P.width,P.height),a.framebufferRenderbuffer(36160,36064+O,36161,y.__webglColorRenderbuffer[O])}a.bindRenderbuffer(36161,null),P.depthBuffer&&(y.__webglDepthRenderbuffer=a.createRenderbuffer(),U(y.__webglDepthRenderbuffer,P,!0)),t.bindFramebuffer(36160,null)}}if(w){t.bindTexture(34067,R.__webglTexture),re(34067,v,C);for(let D=0;D<6;D++)F(y.__webglFramebuffer[D],P,v,36064,34069+D);M(v,C)&&T(34067),t.unbindTexture()}else if(I){const D=P.texture;for(let O=0,Y=D.length;O<Y;O++){const J=D[O],G=n.get(J);t.bindTexture(3553,G.__webglTexture),re(3553,J,C),F(y.__webglFramebuffer,P,J,36064+O,3553),M(J,C)&&T(3553)}t.unbindTexture()}else{let D=3553;(P.isWebGL3DRenderTarget||P.isWebGLArrayRenderTarget)&&(s?D=P.isWebGL3DRenderTarget?32879:35866:console.error("v3d.WebGLTextures: v3d.Data3DTexture and v3d.DataArrayTexture only supported with WebGL2.")),t.bindTexture(D,R.__webglTexture),re(D,v,C),F(y.__webglFramebuffer,P,v,36064,D),M(v,C)&&T(D),t.unbindTexture()}P.depthBuffer&&B(P)},this.updateRenderTargetMipmap=function(P){const v=S(P)||s,y=P.isWebGLMultipleRenderTargets===!0?P.texture:[P.texture];for(let R=0,w=y.length;R<w;R++){const I=y[R];if(M(I,v)){const C=P.isWebGLCubeRenderTarget?34067:3553,D=n.get(I).__webglTexture;t.bindTexture(C,D),T(C),t.unbindTexture()}}},this.updateMultisampleRenderTarget=function(P){if(s&&P.samples>0&&k(P)===!1){const v=P.isWebGLMultipleRenderTargets?P.texture:[P.texture],y=P.width,R=P.height;let w=16384;const I=[],C=P.stencilBuffer?33306:36096,D=n.get(P),O=P.isWebGLMultipleRenderTargets===!0;if(O)for(let Y=0;Y<v.length;Y++)t.bindFramebuffer(36160,D.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(36160,36064+Y,36161,null),t.bindFramebuffer(36160,D.__webglFramebuffer),a.framebufferTexture2D(36009,36064+Y,3553,null,0);t.bindFramebuffer(36008,D.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,D.__webglFramebuffer);for(let Y=0;Y<v.length;Y++){I.push(36064+Y),P.depthBuffer&&I.push(C);const J=D.__ignoreDepthValues!==void 0&&D.__ignoreDepthValues;if(J===!1&&(P.depthBuffer&&(w|=256),P.stencilBuffer&&(w|=1024)),O&&a.framebufferRenderbuffer(36008,36064,36161,D.__webglColorRenderbuffer[Y]),J===!0&&(a.invalidateFramebuffer(36008,[C]),a.invalidateFramebuffer(36009,[C])),O){const G=n.get(v[Y]).__webglTexture;a.framebufferTexture2D(36009,36064,3553,G,0)}a.blitFramebuffer(0,0,y,R,0,0,y,R,w,9728),p&&a.invalidateFramebuffer(36008,I)}if(t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,null),O)for(let Y=0;Y<v.length;Y++){t.bindFramebuffer(36160,D.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(36160,36064+Y,36161,D.__webglColorRenderbuffer[Y]);const J=n.get(v[Y]).__webglTexture;t.bindFramebuffer(36160,D.__webglFramebuffer),a.framebufferTexture2D(36009,36064+Y,3553,J,0)}t.bindFramebuffer(36009,D.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=B,this.setupFrameBufferTexture=F,this.useMultisampledRTT=k}function Hg(a,e,t){const n=t.isWebGL2;return{convert:function(i,o=null){let r;if(i===Ft)return 5121;if(i===vg)return 32819;if(i===_g)return 32820;if(i===fg)return 5120;if(i===mg)return 5122;if(i===Nh)return 5123;if(i===gg)return 5124;if(i===Zi)return 5125;if(i===Ct)return 5126;if(i===_t)return n?5131:(r=e.get("OES_texture_half_float"),r!==null?r.HALF_FLOAT_OES:null);if(i===Ag)return 6406;if(i===Qe)return 6408;if(i===yg)return 6409;if(i===bg)return 6410;if(i===Bo)return 6402;if(i===mr)return 34041;if(i===xg)return console.warn("v3d.WebGLRenderer: v3d.RGBFormat has been removed. Use v3d.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(i===Mc)return r=e.get("EXT_sRGB"),r!==null?r.SRGB_ALPHA_EXT:null;if(i===Ki)return 6403;if(i===Cg)return 36244;if(i===Sg)return 33319;if(i===Mg)return 33320;if(i===Eg)return 36249;if(i===ia||i===pc||i===fc||i===oa)if(o===Ke){if(r=e.get("WEBGL_compressed_texture_s3tc_srgb"),r===null)return null;if(i===ia)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===pc)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===fc)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===oa)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(r=e.get("WEBGL_compressed_texture_s3tc"),r===null)return null;if(i===ia)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===pc)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===fc)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===oa)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(i===ls||i===Gd||i===cs||i===kd){if(r=e.get("WEBGL_compressed_texture_pvrtc"),r===null)return null;if(i===ls)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===Gd)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===cs)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===kd)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(i===Wc)return r=e.get("WEBGL_compressed_texture_etc1"),r!==null?r.COMPRESSED_RGB_ETC1_WEBGL:null;if(i===us||i===ds){if(r=e.get("WEBGL_compressed_texture_etc"),r===null)return null;if(i===us)return o===Ke?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(i===ds)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}if(i===hs||i===Qd||i===Wd||i===Hd||i===Xd||i===Yd||i===jd||i===Kd||i===qd||i===Zd||i===Jd||i===$d||i===eh||i===th){if(r=e.get("WEBGL_compressed_texture_astc"),r===null)return null;if(i===hs)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===Qd)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===Wd)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===Hd)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===Xd)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===Yd)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===jd)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===Kd)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===qd)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===Zd)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===Jd)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===$d)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===eh)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===th)return o===Ke?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}if(i===ps){if(r=e.get("EXT_texture_compression_bptc"),r===null)return null;if(i===ps)return o===Ke?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT}return i===ur?n?34042:(r=e.get("WEBGL_depth_texture"),r!==null?r.UNSIGNED_INT_24_8_WEBGL:null):a[i]!==void 0?a[i]:null}}}class Xg extends Qt{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class Zn extends ze{constructor(){super(),this.isGroup=!0,this.type="Group"}getWorldDirection(e){this.updateMatrixWorld(!0);var t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}}const Sw={type:"move"};class Xu{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Zn,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(e){return this._targetRay===null&&(this._targetRay=new Zn,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new b,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new b,this._targetRay.name="XR_CONTROLLER_"+String(e)),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Zn,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new b,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new b),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const n of e.hand.values())this._getHandJoint(t,n)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,o=null,r=null;const s=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){r=!0;for(const f of e.hand.values()){const g=t.getJointPose(f,n),_=this._getHandJoint(c,f);g!==null&&(_.matrix.fromArray(g.transform.matrix),_.matrix.decompose(_.position,_.rotation,_.scale),_.jointRadius=g.radius),_.visible=g!==null}const d=c.joints["index-finger-tip"],u=c.joints["thumb-tip"],h=d.position.distanceTo(u.position),p=.02,m=.005;c.inputState.pinching&&h>p+m?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&h<=p-m&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(o=t.getPose(e.gripSpace,n),o!==null&&(l.matrix.fromArray(o.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),o.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(o.linearVelocity)):l.hasLinearVelocity=!1,o.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(o.angularVelocity)):l.hasAngularVelocity=!1));s!==null&&(i=t.getPose(e.targetRaySpace,n),i===null&&o!==null&&(i=o),i!==null&&(s.matrix.fromArray(i.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),i.linearVelocity?(s.hasLinearVelocity=!0,s.linearVelocity.copy(i.linearVelocity)):s.hasLinearVelocity=!1,i.angularVelocity?(s.hasAngularVelocity=!0,s.angularVelocity.copy(i.angularVelocity)):s.hasAngularVelocity=!1,this.dispatchEvent(Sw)))}return s!==null&&(s.visible=i!==null),l!==null&&(l.visible=o!==null),c!==null&&(c.visible=r!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const n=new Zn;n.matrixAutoUpdate=!1,n.visible=!1,e.joints[t.jointName]=n,e.add(n)}return e.joints[t.jointName]}}class Xh extends yt{constructor(e,t,n,i,o,r,s,l,c,d){if((d=d!==void 0?d:Bo)!==Bo&&d!==mr)throw new Error("DepthTexture format must be either v3d.DepthFormat or v3d.DepthStencilFormat");n===void 0&&d===Bo&&(n=Zi),n===void 0&&d===mr&&(n=ur),super(null,i,o,r,s,l,d,n,c),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=s!==void 0?s:st,this.minFilter=l!==void 0?l:st,this.flipY=!1,this.generateMipmaps=!1}}class Jc{constructor(e,t,n=0,i=1/0){this.ray=new ya(e,t),this.near=n,this.far=i,this.camera=null,this.layers=new ba,this.params={Mesh:{omitGeometry:!1},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{},checkVisibility:!0},this.layers.enable(3),this.layers.enable(4),this.layers.enable(5),this.layers.enable(6),this.layers.enable(7)}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("v3d.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,n=[]){return lh(e,this,n,t,this.params.checkVisibility),n.sort(Wf),n}intersectObjects(e,t=!0,n=[]){for(let i=0,o=e.length;i<o;i++)lh(e[i],this,n,t,this.params.checkVisibility);return n.sort(Wf),n}}function Wf(a,e){return a.distance-e.distance}function lh(a,e,t,n,i){if(!(i&&(a.visible===!1||a.isMesh&&a.isMaterialGeneratedMesh&&a.parent&&!a.parent.visible)||(a.layers.test(e.layers)&&a.raycast(e,t),n!==!0))){const o=a.children;for(let r=0,s=o.length;r<s;r++)lh(o[r],e,t,!0,i)}}class Mw extends An{constructor(e,t){super();const n=this;let i=null,o=1,r=null,s="local-floor",l=null,c=null,d=null,u=null,h=null,p=null;const m=t.getContextAttributes();let f=null,g=null;const _=[],A=[],x=new Set,S=new Map,M=new Qt;M.layers.enable(1),M.viewport=new Re;const T=new Qt;T.layers.enable(2),T.viewport=new Re;const L=[M,T],z=new Xg;z.layers.enable(1),z.layers.enable(2);let W=null,V=null,N=null,j=null,oe=null,H=new Ae;const ne=new b,le=new b,re=new Ge;function ae(v){const y=A.indexOf(v.inputSource);if(y===-1)return;const R=_[y];R!==void 0&&R.dispatchEvent({type:v.type,data:v.inputSource})}function E(){i.removeEventListener("select",ae),i.removeEventListener("selectstart",ae),i.removeEventListener("selectend",ae),i.removeEventListener("squeeze",ae),i.removeEventListener("squeezestart",ae),i.removeEventListener("squeezeend",ae),i.removeEventListener("end",E),i.removeEventListener("inputsourceschange",F);for(let v=0;v<_.length;v++){const y=A[v];y!==null&&(A[v]=null,_[v].disconnect(y))}W=null,V=null,e.setRenderTarget(f),h=null,u=null,d=null,i=null,g=null,N=null,X.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function F(v){for(let y=0;y<v.removed.length;y++){const R=v.removed[y],w=A.indexOf(R);w>=0&&(A[w]=null,_[w].disconnect(R))}for(let y=0;y<v.added.length;y++){const R=v.added[y];let w=A.indexOf(R);if(w===-1){for(let C=0;C<_.length;C++){if(C>=A.length){A.push(R),w=C;break}if(A[C]===null){A[C]=R,w=C;break}}if(w===-1)break}const I=_[w];I&&I.connect(R)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(v){let y=_[v];return y===void 0&&(y=new Xu,_[v]=y),y.getTargetRaySpace(v)},this.getControllerGrip=function(v){let y=_[v];return y===void 0&&(y=new Xu,_[v]=y),y.getGripSpace()},this.getHand=function(v){let y=_[v];return y===void 0&&(y=new Xu,_[v]=y),y.getHandSpace()},this.setFramebufferScaleFactor=function(v){o=v,n.isPresenting===!0&&console.warn("v3d.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(v){s=v,n.isPresenting===!0&&console.warn("v3d.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||r},this.setReferenceSpace=function(v){l=v},this.getBaseLayer=function(){return u!==null?u:h},this.getBinding=function(){return d},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(v){if(i=v,i!==null){if(f=e.getRenderTarget(),i.addEventListener("select",ae),i.addEventListener("selectstart",ae),i.addEventListener("selectend",ae),i.addEventListener("squeeze",ae),i.addEventListener("squeezestart",ae),i.addEventListener("squeezeend",ae),i.addEventListener("end",E),i.addEventListener("inputsourceschange",F),m.xrCompatible!==!0&&await t.makeXRCompatible(),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const y={antialias:i.renderState.layers!==void 0||m.antialias,alpha:m.alpha,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:o};h=new XRWebGLLayer(i,t,y),i.updateRenderState({baseLayer:h}),g=new et(h.framebufferWidth,h.framebufferHeight,{format:Qe,type:Ft,encoding:e.outputEncoding,stencilBuffer:m.stencil})}else{let y=null,R=null,w=null;m.depth&&(w=m.stencil?35056:33190,y=m.stencil?mr:Bo,R=m.stencil?ur:Zi);const I={colorFormat:32856,depthFormat:w,scaleFactor:o};d=new XRWebGLBinding(i,t),u=d.createProjectionLayer(I),i.updateRenderState({layers:[u]}),g=new et(u.textureWidth,u.textureHeight,{format:Qe,type:Ft,depthTexture:new Xh(u.textureWidth,u.textureHeight,R,void 0,void 0,void 0,void 0,void 0,void 0,y),stencilBuffer:m.stencil,encoding:e.outputEncoding,samples:m.antialias?4:0}),e.properties.get(g).__ignoreDepthValues=u.ignoreDepthValues}g.isXRRenderTarget=!0,this.setFoveation(1),l=null,r=await i.requestReferenceSpace(s),X.setContext(i),X.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const U=new b,B=new b;function Z(v,y){if(y===null)v.matrixWorld.copy(v.matrix),H.identity(),l=null;else{v.matrixWorld.copy(v.matrix),H.copy(y.matrixWorld).invert().decompose(ne,re,le);var R=new XRRigidTransform({x:ne.x,y:ne.y,z:ne.z},{x:re.x,y:re.y,z:re.z,w:re.w});l=r.getOffsetReferenceSpace(R)}v.matrixWorldInverse.copy(v.matrixWorld).invert()}this.updateCamera=function(v){if(i===null)return;z.near=T.near=M.near=v.near,z.far=T.far=M.far=v.far,W===z.near&&V===z.far||(i.updateRenderState({depthNear:z.near,depthFar:z.far}),W=z.near,V=z.far);const y=v.parent,R=z.cameras;Z(z,y);for(let C=0;C<R.length;C++)Z(R[C],y);z.matrixWorld.decompose(z.position,z.quaternion,z.scale),v.matrixWorld.copy(z.matrixWorld),y===null?v.matrix.copy(v.matrixWorld):(v.matrix.copy(y.matrixWorld).invert(),v.matrix.multiply(v.matrixWorld)),v.matrix.decompose(v.position,v.quaternion,v.scale);const w=v.children;for(let C=0,D=w.length;C<D;C++)w[C].updateMatrixWorld(!0);R.length===2?function(C,D,O){U.setFromMatrixPosition(D.matrixWorld),B.setFromMatrixPosition(O.matrixWorld);const Y=U.distanceTo(B),J=D.projectionMatrix.elements,G=O.projectionMatrix.elements,K=J[14]/(J[10]-1),ie=J[14]/(J[10]+1),$=(J[9]+1)/J[5],se=(J[9]-1)/J[5],de=(J[8]-1)/J[0],he=(G[8]+1)/G[0],ee=K*de,ge=K*he,ve=Y/(-de+he),_e=ve*-de;D.matrixWorld.decompose(C.position,C.quaternion,C.scale),C.translateX(_e),C.translateZ(ve),C.matrixWorld.compose(C.position,C.quaternion,C.scale),C.matrixWorldInverse.copy(C.matrixWorld).invert();const we=K+ve,Be=ie+ve,ke=ee-_e,ht=ge+(Y-_e),tt=$*ie/Be*we,pt=se*ie/Be*we;C.projectionMatrix.makePerspective(ke,ht,tt,pt,we,Be)}(z,M,T):z.projectionMatrix.copy(M.projectionMatrix);const I=z.projectionMatrix.elements;z.fov=Xc(2*Math.atan(1/I[5])),z.aspect=I[5]/I[0],z.projectionMatrixInverse.copy(z.projectionMatrix).invert()},this.getCamera=function(){return z},this.getFoveation=function(){return u!==null?u.fixedFoveation:h!==null?h.fixedFoveation:void 0},this.setFoveation=function(v){u!==null&&(u.fixedFoveation=v),h!==null&&h.fixedFoveation!==void 0&&(h.fixedFoveation=v)},this.getPlanes=function(){return x};let k=null;const X=new Vg;function P(v){if(N){const y=v.getHitTestResults(N);if(y.length){const R=y[0].getPose(n.getReferenceSpace()),w=new Ae().fromArray(R.transform.matrix),I=new b;I.setFromMatrixPosition(w);const C=new b(0,1,0);C.applyNormalMatrix(new ln().setFromMatrix4(w)),j(I,C)}else oe()}}X.setAnimationLoop(function(v,y){if(c=y.getViewerPose(l||r),p=y,c!==null){const R=c.views;h!==null&&(e.setRenderTargetFramebuffer(g,h.framebuffer),e.setRenderTarget(g));let w=!1;R.length!==z.cameras.length&&(z.cameras.length=0,w=!0);for(let I=0;I<R.length;I++){const C=R[I];let D=null;if(h!==null)D=h.getViewport(C);else{const Y=d.getViewSubImage(u,C);D=Y.viewport,I===0&&(e.setRenderTargetTextures(g,Y.colorTexture,u.ignoreDepthValues?void 0:Y.depthStencilTexture),e.setRenderTarget(g))}let O=L[I];O===void 0&&(O=new Qt,O.layers.enable(I),O.viewport=new Re,L[I]=O),O.matrix.fromArray(C.transform.matrix),O.projectionMatrix.fromArray(C.projectionMatrix),O.viewport.set(D.x,D.y,D.width,D.height),I===0&&z.matrix.copy(O.matrix),w===!0&&z.cameras.push(O)}}for(let R=0;R<_.length;R++){const w=A[R],I=_[R];w!==null&&I!==void 0&&I.update(w,y,l||r),P(y)}if(k&&k(v,y),y.detectedPlanes){n.dispatchEvent({type:"planesdetected",data:y.detectedPlanes});let R=null;for(const w of x)y.detectedPlanes.has(w)||(R===null&&(R=[]),R.push(w));if(R!==null)for(const w of R)x.delete(w),S.delete(w),n.dispatchEvent({type:"planeremoved",data:w});for(const w of y.detectedPlanes)if(x.has(w)){const I=S.get(w);w.lastChangedTime>I&&(S.set(w,w.lastChangedTime),n.dispatchEvent({type:"planechanged",data:w}))}else x.add(w),S.set(w,y.lastChangedTime),n.dispatchEvent({type:"planeadded",data:w})}p=null}),this.setAnimationLoop=function(v){k=v},this.dispose=function(){},this.arHitTest=function(v,y,R,w){if(!i||!XRSession.prototype.requestHitTestSource)return;j=R||function(){},oe=w||function(){},this.raycaster=this.raycaster||new Jc,this.raycaster.setFromCamera({x:v,y},L[0]);const I=this.raycaster.ray;new XRRay(I.origin,I.direction),i.requestReferenceSpace("viewer").then(function(C){const D={space:C};i.requestHitTestSource(D).then(function(O){N=O})})}}}function Ew(a,e){function t(n,i){n.opacity.value=i.opacity,i.color&&n.diffuse.value.copy(i.color),i.emissive&&n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),i.map&&(n.map.value=i.map),i.alphaMap&&(n.alphaMap.value=i.alphaMap),i.bumpMap&&(n.bumpMap.value=i.bumpMap,n.bumpScale.value=i.bumpScale,i.side===nn&&(n.bumpScale.value*=-1)),i.displacementMap&&(n.displacementMap.value=i.displacementMap,n.displacementScale.value=i.displacementScale,n.displacementBias.value=i.displacementBias),i.emissiveMap&&(n.emissiveMap.value=i.emissiveMap),i.normalMap&&(n.normalMap.value=i.normalMap,n.normalScale.value.copy(i.normalScale),i.side===nn&&n.normalScale.value.negate()),i.specularMap&&(n.specularMap.value=i.specularMap),i.alphaTest>0&&(n.alphaTest.value=i.alphaTest);const o=e.get(i).envMap;if(o&&(n.envMap.value=o,n.flipEnvMap.value=o.isCubeTexture&&o.isRenderTargetTexture===!1?-1:1,n.reflectivity.value=i.reflectivity,n.ior.value=i.ior,n.refractionRatio.value=i.refractionRatio),i.lightMap){n.lightMap.value=i.lightMap;const l=a.physicallyCorrectLights!==!0?Math.PI:1;n.lightMapIntensity.value=i.lightMapIntensity*l}let r,s;i.aoMap&&(n.aoMap.value=i.aoMap,n.aoMapIntensity.value=i.aoMapIntensity),i.map?r=i.map:i.specularMap?r=i.specularMap:i.displacementMap?r=i.displacementMap:i.normalMap?r=i.normalMap:i.bumpMap?r=i.bumpMap:i.roughnessMap?r=i.roughnessMap:i.metalnessMap?r=i.metalnessMap:i.alphaMap?r=i.alphaMap:i.emissiveMap?r=i.emissiveMap:i.clearcoatMap?r=i.clearcoatMap:i.clearcoatNormalMap?r=i.clearcoatNormalMap:i.clearcoatRoughnessMap?r=i.clearcoatRoughnessMap:i.iridescenceMap?r=i.iridescenceMap:i.iridescenceThicknessMap?r=i.iridescenceThicknessMap:i.specularIntensityMap?r=i.specularIntensityMap:i.specularColorMap?r=i.specularColorMap:i.transmissionMap?r=i.transmissionMap:i.thicknessMap?r=i.thicknessMap:i.sheenColorMap?r=i.sheenColorMap:i.sheenRoughnessMap&&(r=i.sheenRoughnessMap),r!==void 0&&(r.isWebGLRenderTarget&&(r=r.texture),r.matrixAutoUpdate===!0&&r.updateMatrix(),n.uvTransform.value.copy(r.matrix)),i.aoMap?s=i.aoMap:i.lightMap&&(s=i.lightMap),s!==void 0&&(s.isWebGLRenderTarget&&(s=s.texture),s.matrixAutoUpdate===!0&&s.updateMatrix(),n.uv2Transform.value.copy(s.matrix))}return{refreshFogUniforms:function(n,i){i.color.getRGB(n.fogColor.value,zg(a)),i.isFog?(n.fogNear.value=i.near,n.fogFar.value=i.far):i.isFogExp2&&(n.fogDensity.value=i.density)},refreshMaterialUniforms:function(n,i,o,r,s){i.ssrParams&&function(l,c){l.invProjectionMatrix.value=c.ssrParams.invProjectionMatrix,l.ssrSourceBuffer.value=c.ssrParams.sourceBuffer.texture,l.ssrDepthBuffer.value=c.ssrParams.depthBuffer.texture,l.ssrBackfaceDepthBuffer.value=c.ssrParams.backfaceDepthBuffer.texture,l.ssrResolution.value.set(c.ssrParams.sourceBuffer.width,c.ssrParams.sourceBuffer.height),l.ssrStride.value=c.ssrParams.stride,l.ssrThickness.value=c.ssrParams.thickness,l.ssrMaxDistance.value=c.ssrParams.maxDistance,l.ssrJitter.value=c.ssrParams.jitter}(n,i),i.isMeshBasicMaterial||i.isMeshLambertMaterial?t(n,i):i.isMeshToonMaterial?(t(n,i),function(l,c){c.gradientMap&&(l.gradientMap.value=c.gradientMap)}(n,i)):i.isMeshPhongMaterial?(t(n,i),function(l,c){l.specular.value.copy(c.specular),l.shininess.value=Math.max(c.shininess,1e-4)}(n,i)):i.isMeshStandardMaterial?(t(n,i),function(l,c){l.roughness.value=c.roughness,l.metalness.value=c.metalness,c.roughnessMap&&(l.roughnessMap.value=c.roughnessMap),c.metalnessMap&&(l.metalnessMap.value=c.metalnessMap),e.get(c).envMap&&(l.envMapIntensity.value=c.envMapIntensity,l.envMapParallaxType.value=c.envMapParallaxType,l.envMapParallaxMatrix.value.copy(c.envMapParallaxMatrix),l.envMapParallaxMatrixInv.value.copy(c.envMapParallaxMatrixInv))}(n,i),i.isMeshPhysicalMaterial&&function(l,c,d){l.ior.value=c.ior,c.sheen>0&&(l.sheenColor.value.copy(c.sheenColor).multiplyScalar(c.sheen),l.sheenRoughness.value=c.sheenRoughness,c.sheenColorMap&&(l.sheenColorMap.value=c.sheenColorMap),c.sheenRoughnessMap&&(l.sheenRoughnessMap.value=c.sheenRoughnessMap)),c.clearcoat>0&&(l.clearcoat.value=c.clearcoat,l.clearcoatRoughness.value=c.clearcoatRoughness,c.clearcoatMap&&(l.clearcoatMap.value=c.clearcoatMap),c.clearcoatRoughnessMap&&(l.clearcoatRoughnessMap.value=c.clearcoatRoughnessMap),c.clearcoatNormalMap&&(l.clearcoatNormalScale.value.copy(c.clearcoatNormalScale),l.clearcoatNormalMap.value=c.clearcoatNormalMap,c.side===nn&&l.clearcoatNormalScale.value.negate())),c.iridescence>0&&(l.iridescence.value=c.iridescence,l.iridescenceIOR.value=c.iridescenceIOR,l.iridescenceThicknessMinimum.value=c.iridescenceThicknessRange[0],l.iridescenceThicknessMaximum.value=c.iridescenceThicknessRange[1],c.iridescenceMap&&(l.iridescenceMap.value=c.iridescenceMap),c.iridescenceThicknessMap&&(l.iridescenceThicknessMap.value=c.iridescenceThicknessMap)),c.transmission>0&&(l.transmission.value=c.transmission,l.transmissionSamplerMap.value=d.texture,l.transmissionSamplerSize.value.set(d.width,d.height),c.transmissionMap&&(l.transmissionMap.value=c.transmissionMap),l.thickness.value=c.thickness,c.thicknessMap&&(l.thicknessMap.value=c.thicknessMap),l.attenuationDistance.value=c.attenuationDistance,l.attenuationColor.value.copy(c.attenuationColor)),l.specularIntensity.value=c.specularIntensity,l.specularColor.value.copy(c.specularColor),c.specularIntensityMap&&(l.specularIntensityMap.value=c.specularIntensityMap),c.specularColorMap&&(l.specularColorMap.value=c.specularColorMap)}(n,i,s)):i.isMeshMatcapMaterial?(t(n,i),function(l,c){c.matcap&&(l.matcap.value=c.matcap)}(n,i)):i.isMeshDepthMaterial?(t(n,i),function(l,c){l.slopeScaledBias.value=c.slopeScaledBias}(n,i)):i.isMeshDistanceMaterial?(t(n,i),function(l,c){l.referencePosition.value.copy(c.referencePosition),l.nearDistance.value=c.nearDistance,l.farDistance.value=c.farDistance,l.slopeScaledBias.value=c.slopeScaledBias}(n,i)):i.isMeshNormalMaterial?t(n,i):i.isLineBasicMaterial?(function(l,c){l.diffuse.value.copy(c.color),l.opacity.value=c.opacity}(n,i),i.isLineDashedMaterial&&function(l,c){l.dashSize.value=c.dashSize,l.totalSize.value=c.dashSize+c.gapSize,l.scale.value=c.scale}(n,i)):i.isPointsMaterial?function(l,c,d,u){l.diffuse.value.copy(c.color),l.opacity.value=c.opacity,l.size.value=c.size*d,l.scale.value=.5*u,c.map&&(l.map.value=c.map),c.alphaMap&&(l.alphaMap.value=c.alphaMap),c.alphaTest>0&&(l.alphaTest.value=c.alphaTest);let h;c.map?h=c.map:c.alphaMap&&(h=c.alphaMap),h!==void 0&&(h.matrixAutoUpdate===!0&&h.updateMatrix(),l.uvTransform.value.copy(h.matrix))}(n,i,o,r):i.isSpriteMaterial?function(l,c){l.diffuse.value.copy(c.color),l.opacity.value=c.opacity,l.rotation.value=c.rotation,c.map&&(l.map.value=c.map),c.alphaMap&&(l.alphaMap.value=c.alphaMap),c.alphaTest>0&&(l.alphaTest.value=c.alphaTest);let d;c.map?d=c.map:c.alphaMap&&(d=c.alphaMap),d!==void 0&&(d.matrixAutoUpdate===!0&&d.updateMatrix(),l.uvTransform.value.copy(d.matrix))}(n,i):i.isShadowMaterial?(n.color.value.copy(i.color),n.opacity.value=i.opacity):i.isMeshMaskMaterial?(t(n,i),function(l,c){c.cameraNearFar&&(l.cameraNearFar.value=c.cameraNearFar),l.depthTexture.value=c.depthTexture,c.textureMatrix&&(l.textureMatrix.value=c.textureMatrix)}(n,i)):i.isMeshNodeMaterial?function(l,c){c.alphaTest>0&&(l.alphaTest.value=c.alphaTest);const d=e.get(c).envMap;d&&(l.envMap.value=d,l.flipEnvMap.value=d.isCubeTexture&&d.isRenderTargetTexture?-1:1,l.envMapIntensity.value=c.envMapIntensity,l.envMapParallaxType.value=c.envMapParallaxType,l.envMapParallaxMatrix.value.copy(c.envMapParallaxMatrix),l.envMapParallaxMatrixInv.value.copy(c.envMapParallaxMatrixInv)),c.displacementMap&&(l.displacementMap.value=c.displacementMap,l.displacementScale.value=c.displacementScale,l.displacementBias.value=c.displacementBias),l.materialIndex.value=c.materialIndex}(n,i):i.isMeshLineMaterial?function(l,c){l.lineWidth.value=c.lineWidth,l.sizeAttenuation.value=c.sizeAttenuation,l.color.value=c.color,l.opacity.value=c.opacity,l.useMap.value=c.useMap,c.map&&(l.map.value=c.map),l.useAlphaMap.value=c.useAlphaMap,c.alphaMap&&(l.alphaMap.value=c.alphaMap),l.visibility.value=c.visibility,l.alphaTest.value=c.alphaTest,l.repeat.value=c.repeat}(n,i):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)},refreshGTAOUniforms:function(n,i){n.gtaoMap.value=i},refreshPlaneReflProbeUniforms:function(n,i){n.planeReflTexture.value=i.renderTarget.texture,n.planeReflTextureMatrix.value.copy(i.textureMatrix),n.planeReflDir.value.copy(i.normal),n.planeReflBoundingBoxMin.value.copy(i.boundingBox.min),n.planeReflBoundingBoxMax.value.copy(i.boundingBox.max),n.planeReflInvModelMatrix.value.copy(i.matrixWorldInverse),n.planeReflFalloff.value=i.falloff}}}function ww(a,e,t,n){let i={},o={},r=[];const s=t.isWebGL2?a.getParameter(35375):0;function l(u,h,p){const m=u.value;if(p[h]===void 0){if(typeof m=="number")p[h]=m;else{const f=Array.isArray(m)?m:[m],g=[];for(let _=0;_<f.length;_++)g.push(f[_].clone());p[h]=g}return!0}if(typeof m=="number"){if(p[h]!==m)return p[h]=m,!0}else{const f=Array.isArray(p[h])?p[h]:[p[h]],g=Array.isArray(m)?m:[m];for(let _=0;_<f.length;_++){const A=f[_];if(A.equals(g[_])===!1)return A.copy(g[_]),!0}}return!1}function c(u){const h={boundary:0,storage:0};return typeof u=="number"?(h.boundary=4,h.storage=4):u.isVector2?(h.boundary=8,h.storage=8):u.isVector3||u.isColor?(h.boundary=16,h.storage=12):u.isVector4?(h.boundary=16,h.storage=16):u.isMatrix3?(h.boundary=48,h.storage=48):u.isMatrix4?(h.boundary=64,h.storage=64):u.isTexture?console.warn("v3d.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("v3d.WebGLRenderer: Unsupported uniform value type.",u),h}function d(u){const h=u.target;h.removeEventListener("dispose",d);const p=r.indexOf(h.__bindingPointIndex);r.splice(p,1),a.deleteBuffer(i[h.id]),delete i[h.id],delete o[h.id]}return{bind:function(u,h){const p=h.program;n.uniformBlockBinding(u,p)},update:function(u,h){let p=i[u.id];p===void 0&&(function(g){const _=g.uniforms;let A=0;const x=16;let S=0;for(let M=0,T=_.length;M<T;M++){const L=_[M],z={boundary:0,storage:0},W=Array.isArray(L.value)?L.value:[L.value];for(let V=0,N=W.length;V<N;V++){const j=c(W[V]);z.boundary+=j.boundary,z.storage+=j.storage}L.__data=new Float32Array(z.storage/Float32Array.BYTES_PER_ELEMENT),L.__offset=A,M>0&&(S=A%x,S!==0&&x-S-z.boundary<0&&(A+=x-S,L.__offset=A)),A+=z.storage}S=A%x,S>0&&(A+=x-S),g.__size=A,g.__cache={}}(u),p=function(g){const _=function(){for(let M=0;M<s;M++)if(r.indexOf(M)===-1)return r.push(M),M;return console.error("v3d.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();g.__bindingPointIndex=_;const A=a.createBuffer(),x=g.__size,S=g.usage;return a.bindBuffer(35345,A),a.bufferData(35345,x,S),a.bindBuffer(35345,null),a.bindBufferBase(35345,_,A),A}(u),i[u.id]=p,u.addEventListener("dispose",d));const m=h.program;n.updateUBOMapping(u,m);const f=e.render.frame;o[u.id]!==f&&(function(g){const _=i[g.id],A=g.uniforms,x=g.__cache;a.bindBuffer(35345,_);for(let S=0,M=A.length;S<M;S++){const T=A[S];if(l(T,S,x)===!0){const L=T.__offset,z=Array.isArray(T.value)?T.value:[T.value];let W=0;for(let V=0;V<z.length;V++){const N=z[V],j=c(N);typeof N=="number"?(T.__data[0]=N,a.bufferSubData(35345,L+W,T.__data)):N.isMatrix3?(T.__data[0]=N.elements[0],T.__data[1]=N.elements[1],T.__data[2]=N.elements[2],T.__data[3]=N.elements[0],T.__data[4]=N.elements[3],T.__data[5]=N.elements[4],T.__data[6]=N.elements[5],T.__data[7]=N.elements[0],T.__data[8]=N.elements[6],T.__data[9]=N.elements[7],T.__data[10]=N.elements[8],T.__data[11]=N.elements[0]):(N.toArray(T.__data,W),W+=j.storage/Float32Array.BYTES_PER_ELEMENT)}a.bufferSubData(35345,L,T.__data)}}a.bindBuffer(35345,null)}(u),o[u.id]=f)},dispose:function(){for(const u in i)a.deleteBuffer(i[u]);r=[],i={},o={}}}}const Lt={checkWebGL:function(){try{const a=document.createElement("canvas");return!(!window.WebGLRenderingContext||!a.getContext("webgl")&&!a.getContext("experimental-webgl"))}catch{return!1}},checkWebGL2:function(){try{const a=document.createElement("canvas");return!(!window.WebGL2RenderingContext||!a.getContext("webgl2"))}catch{return!1}},checkWorkers:function(){return!!window.Worker},checkFileAPI:function(){return window.File&&window.FileReader&&window.FileList&&window.Blob},genWebGLErrorMessage:function(a){const e=document.createElement("div");e.setAttribute("class","v3d-webgl-error-container");const t=document.createElement("div");t.setAttribute("class","v3d-webgl-error-image"),e.appendChild(t);const n=document.createElement("div");return n.setAttribute("class","v3d-webgl-error"),n.innerHTML=a,e.appendChild(n),e},showWebGLErrorMessage:function(a,e){(a=a||document.body).appendChild(Lt.genWebGLErrorMessage(e));const t=document.getElementById("v3d_preloader_container");t&&(t.style.visibility="hidden")},checkIOS:function(){return(/iPad|iPhone|iPod/.test(navigator.platform)||navigator.platform==="MacIntel"&&navigator.maxTouchPoints>1)&&!window.MSStream},checkAndroid:function(){return!!navigator.userAgent.match(/Android/i)},checkSafari:function(){return/Safari/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)},checkFloatTex:function(a,e){const t=a.getContext();return!(!a.capabilities.isWebGL2||!t.getExtension("EXT_color_buffer_float")||e&&!t.getExtension("OES_texture_float_linear"))||!(a.capabilities.isWebGL2||!t.getExtension("OES_texture_float")||e&&!t.getExtension("OES_texture_float_linear"))},checkHalfFloatTex:function(a,e){const t=a.getContext();return!(!a.capabilities.isWebGL2||!t.getExtension("EXT_color_buffer_float"))||!(a.capabilities.isWebGL2||!t.getExtension("OES_texture_half_float")||e&&!t.getExtension("OES_texture_half_float_linear"))},checkHalfFloatReadPixels:function(a){const e=a.getContext(),t=a.capabilities;return!/Firefox/.test(navigator.userAgent)&&!!(e.getExtension("EXT_color_buffer_half_float")||t.isWebGL2&&e.getExtension("EXT_color_buffer_float"))},checkFloatReadPixels:function(a){const e=a.getContext();return!!(a.capabilities.isWebGL2||e.getExtension("OES_texture_float")||e.getExtension("WEBGL_color_buffer_float"))},checkDepthTex:function(a){const e=a.getContext();return!(!a.capabilities.isWebGL2&&!e.getExtension("WEBGL_depth_texture"))},getGPUVendor:function(a){const e=a?a.getContext():document.createElement("canvas").getContext("webgl")||document.createElement("canvas").getContext("experimental-webgl");if(/Firefox/.test(navigator.userAgent))return e.getParameter(7936);{const t=e.getExtension("WEBGL_debug_renderer_info");return t!=null?e.getParameter(t.UNMASKED_VENDOR_WEBGL):""}},getGPUModel:function(a){const e=a?a.getContext():document.createElement("canvas").getContext("webgl")||document.createElement("canvas").getContext("experimental-webgl");if(/Firefox/.test(navigator.userAgent))return e.getParameter(7937);{const t=e.getExtension("WEBGL_debug_renderer_info");return t!=null?e.getParameter(t.UNMASKED_RENDERER_WEBGL):""}},checkWebXR:function(a,e,t){"xr"in navigator&&navigator.xr.isSessionSupported?navigator.xr.isSessionSupported(a).then(function(n){n?e():t()}).catch(t):t()},checkNativeWebXR:function(){return!1},checkCardboard:function(){return!1},checkSwiftShader:function(a){return this.getGPUModel(a)=="Google SwiftShader"},checkWebAudio:function(){return(window.AudioContext||window.webkitAudioContext)!==void 0},isSafariWithMultisamplingBug:function(){const a=navigator.userAgent;return!(!this.checkSafari()&&!a.match("MicroMessenger"))&&(a.match("Version/15.4")||a.match(/CPU (OS|iPhone OS) (15_4|15_4_1|15_4_2|15_4_3) like Mac OS X/))},isSafariWithUint16Bug:function(){const a=navigator.userAgent;return!(!this.checkSafari()&&!a.match("MicroMessenger"))&&a.match(/CPU (OS|iPhone OS) (11_[0-9][0-9_]*|12_[0-9][0-9_]*) like Mac OS X/)},isTouchDevice:function(){return"ontouchstart"in window||navigator.maxTouchPoints>0||navigator.msMaxTouchPoints>0}};class ii extends An{constructor(){super(),this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("v3d.Pass: .render() must be implemented in derived pass.")}setCamera(e){}dispose(){}}const Tw=new fi(-1,1,1,-1,0,1),Lc=new Pe;Lc.setAttribute("position",new Ie([-1,3,0,-1,-1,0,3,-1,0],3)),Lc.setAttribute("uv",new Ie([0,2,0,0,2,0],2));class hi{constructor(e){this._mesh=new Ue(Lc,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,Tw)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}static dispose(){Lc.dispose()}}const Iw=new me,Hf=new ba;class Yg{constructor(e,t){this.resolution=e,this.textureType=t,this.type="WebGLOITMethod",this.mute=!1}render(){this.mute}dispose(){}setSize(e,t){this.resolution.set(e,t)}_ensureProperBuffersClearing(e){e.state.buffers.depth.setTest(!0),e.state.buffers.depth.setMask(!0),e.state.buffers.color.setMask(!0)}}Yg.prototype.isWebGLOITMethod=!0;class jg extends Yg{constructor(e,t,n){super(e,t),this.type="WebGLOITWeighted",this.shader=De.oitWeighted,this.uniforms=hn.clone(this.shader.uniforms),this.scene=null,this.camera=null,this.aaSamples=n||0,this.renderTargetMRT=new rh(this.resolution.x,this.resolution.y,2),this.renderTargetMRT.texture[0].name="wboit_rgba",this.renderTargetMRT.texture[0].format=Qe,this.renderTargetMRT.texture[0].type=t,this.renderTargetMRT.texture[1].name="wboit_r",this.renderTargetMRT.texture[1].format=Ki,this.renderTargetMRT.texture[1].type=t,this.aaSamples>0&&(this.renderTargetMRTMSAA=new rh(this.resolution.x,this.resolution.y,2,{samples:n}),this.renderTargetMRTMSAA.texture[0].name="wboit_rgba",this.renderTargetMRTMSAA.texture[0].format=Qe,this.renderTargetMRTMSAA.texture[0].type=t,this.renderTargetMRTMSAA.texture[1].name="wboit_r",this.renderTargetMRTMSAA.texture[1].format=Ki,this.renderTargetMRTMSAA.texture[1].type=t),this.fsQuadSolver=new hi(new vt({defines:Object.assign({},this.shader.defines),uniforms:hn.clone(this.shader.uniforms),vertexShader:this.shader.vertexShader,fragmentShader:this.shader.fragmentShader,depthTest:!1,depthWrite:!1,blending:no,blendEquation:tn,blendSrc:xr,blendDst:Ri,blendEquationAlpha:tn,blendSrcAlpha:ei,blendDstAlpha:Ri})),this._layerMasks={},this._matSettings={},this._savedCameraLayers=new ba}dispose(){super.dispose(),this.renderTargetMRT.dispose(),this.renderTargetMRTMSAA&&this.renderTargetMRTMSAA.dispose()}setSize(e,t){super.setSize(e,t),this.renderTargetMRT.setSize(e,t),this.renderTargetMRTMSAA&&this.renderTargetMRTMSAA.setSize(e,t)}render(e,t,n,i,o){if(this.mute)return;this._ensureProperBuffersClearing(e);const r=e.getRenderTarget();if(r.isWebGLCubeRenderTarget)return void t(n,i,o);const s=i.overrideMaterial;if(s&&!this.isSupportedMaterial(s))return void t(n,i,o);if(this.resolution.x!==r.width&&this.resolution.y!==r.height)return console.warn("v3d.WebGLOITRenderer: render target size mismatch in v3d.WebGLOITWeighted."),void t(n,i,o);this.scene=i,this.camera=o,this._savedCameraLayers.mask=this.camera.layers.mask;const l=e.getClearColor(Iw),c=e.getClearAlpha(),d=e.autoClear,u=e.useOIT,h=e.sortObjects;e.setClearColor(0),e.setClearAlpha(0),e.autoClear=!1,e.sortObjects=!1,e.useOIT=!1;const p=this.renderTargetMRTMSAA&&this.renderTargetMRTMSAA.samples==r.samples;if(s){const m=[{object:i,material:s}];this._accumulationPass(e,t,p,n,m);const f=s.colorWrite;s.colorWrite=!1,s.needsUpdate=!0,e.setRenderTarget(r),t(n,i,o),s.colorWrite=f,s.needsUpdate=!0}else this._saveLayers(n),this._setupLayers(n),o.layers.disableAll(),o.layers.enable(2),t(n,i,o),o.layers.disableAll(),o.layers.enable(1),this._accumulationPass(e,t,p,n),e.setRenderTarget(r),this._renderOnlyDepth(e,t,n,i,o),this._restoreLayers(n);e.setRenderTarget(r),this._solverPass(e,p),e.setClearColor(l),e.setClearAlpha(c),e.sortObjects=h,e.autoClear=d,e.useOIT=u}isSupportedMaterial(e){return!(!e||!e.isMeshStandardMaterial&&!e.isMeshNodeMaterial)}_accumulationPass(e,t,n,i,o){o||(o=i);const r=e.getContext(),s=e.getRenderTarget(),l=e.getClearAlpha();if(this._saveMatSettings(o),this._setupMatSettings(o),e.setClearAlpha(1),s)if(n){e.setRenderTarget(this.renderTargetMRTMSAA),e.clear();const c=e.properties.get(this.renderTargetMRTMSAA).__webglDepthRenderbuffer,d=e.properties.get(s).__webglDepthRenderbuffer;if(d&&(r.framebufferRenderbuffer(36160,36096,36161,d),r.checkFramebufferStatus(36160)!==36053)||(t(i,this.scene,this.camera),e.getTextureUtils().updateMultisampleRenderTarget(this.renderTargetMRTMSAA),d&&(r.framebufferRenderbuffer(36160,36096,36161,c||null),r.checkFramebufferStatus(36160)!==36053)))return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.")}else if(s.samples>0){e.setRenderTarget(this.renderTargetMRT),e.clear();const c=e.properties.get(this.renderTargetMRT).__webglFramebuffer,d=e.properties.get(s).__webglMultisampledFramebuffer;if(d&&(r.bindFramebuffer(36008,d),r.bindFramebuffer(36009,c),r.blitFramebuffer(0,0,this.resolution.x,this.resolution.y,0,0,this.resolution.x,this.resolution.y,256,9728),r.bindFramebuffer(36160,c),r.checkFramebufferStatus(36160)!==36053))return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted. Can not blit depth buffer from v3d.WebGLMultisampleRenderTarget.");t(i,this.scene,this.camera)}else{e.setRenderTarget(this.renderTargetMRT),e.clear();const c=e.properties.get(this.renderTargetMRT),d=c.__webglDepthRenderbuffer||c.__webglDepthbuffer,u=e.properties.get(s),h=u.__webglDepthRenderbuffer||u.__webglDepthbuffer;if(h){if(r.framebufferRenderbuffer(36160,36096,36161,h),r.checkFramebufferStatus(36160)!==36053)return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.")}else if(s.depthTexture){const p=e.properties.get(s.depthTexture).__webglTexture;r.framebufferTexture2D(36160,36096,3553,p,0)}if(t(i,this.scene,this.camera),h){if(r.framebufferRenderbuffer(36160,36096,36161,d||null),r.checkFramebufferStatus(36160)!==36053)return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.")}else if(s.depthTexture&&(r.framebufferRenderbuffer(36160,36096,36161,d||null),r.checkFramebufferStatus(36160)!==36053))return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.")}else console.error("v3d.WebGLOITRenderer: undefined render target in v3d.WebGLOITWeighted.");this._restoreMatSettings(o),e.setClearAlpha(l),e.setRenderTarget(s)}_solverPass(e,t){const n=t?this.renderTargetMRTMSAA:this.renderTargetMRT;this.fsQuadSolver.material.uniforms.tRGBABuffer.value=n.texture[0],this.fsQuadSolver.material.uniforms.tFloatBuffer.value=n.texture[1],this.fsQuadSolver.render(e)}_testInitialLayersWithInitialCameraLayers(e){const t=this._layerMasks[e.id];return Hf.mask=t!==void 0?t:e.layers.mask,this._savedCameraLayers.test(Hf)}_saveLayers(e){this._layerMasks[this.camera.id]=this.camera.layers.mask;for(let t=0,n=e.length;t<n;t++){const i=e[t].object;this._layerMasks[i.id]=i.layers.mask}}_setupLayers(e){for(let t=0,n=e.length;t<n;t++){const i=e[t],o=i.object,r=i.material;this._testInitialLayersWithInitialCameraLayers(o)?(o.layers.disableAll(),this.isSupportedMaterial(r)?o.layers.enable(1):o.layers.enable(2)):o.layers.disableAll()}}_restoreLayers(e){for(let t=0,n=e.length;t<n;t++){const i=e[t].object;i.layers.mask=this._layerMasks[i.id],delete this._layerMasks[i.id]}this.camera.layers.mask=this._layerMasks[this.camera.id],delete this._layerMasks[this.camera.id]}_saveMatSettings(e){for(let t=0,n=e.length;t<n;t++){const i=e[t],o=i.object,r=i.material;r&&r.id in this._matSettings||this._testInitialLayersWithInitialCameraLayers(o)&&this.isSupportedMaterial(r)&&(this._matSettings[r.id]={defines:{PREMULTIPLIED_ALPHA:r.defines.PREMULTIPLIED_ALPHA},properties:{blending:r.blending,blendEquation:r.blendEquation,blendSrc:r.blendSrc,blendDst:r.blendDst,blendEquationAlpha:r.blendEquationAlpha,blendSrcAlpha:r.blendSrcAlpha,blendDstAlpha:r.blendDstAlpha,depthTest:r.depthTest,depthWrite:r.depthWrite}})}}_setupMatSettings(e){for(let t=0,n=e.length;t<n;t++){const i=e[t],o=i.object,r=i.material;this._testInitialLayersWithInitialCameraLayers(o)&&this.isSupportedMaterial(r)&&(r.defines.PREMULTIPLIED_ALPHA="",r.defines.USE_OIT_WEIGHTED="",r.blending=no,r.blendEquation=tn,r.blendSrc=ei,r.blendDst=ei,r.blendEquationAlpha=tn,r.blendSrcAlpha=Ls,r.blendDstAlpha=Ri,r.depthTest=!0,r.depthWrite=!1,r.needsUpdate=!0)}}_restoreMatSettings(e){for(let t=0,n=e.length;t<n;t++){const i=e[t],o=i.object,r=i.material;if(!r||!(r.id in this._matSettings)||!this._testInitialLayersWithInitialCameraLayers(o)||!this.isSupportedMaterial(r))continue;delete r.defines.USE_OIT_WEIGHTED;const s=this._matSettings[r.id];for(let l in s.properties)r[l]=s.properties[l];for(let l in s.defines)s.defines[l]?r.defines[l]=s.defines[l]:delete r.defines[l];r.needsUpdate=!0,delete this._matSettings[r.id]}}_renderOnlyDepth(e,t,n,i,o){const r={};for(let s=0,l=n.length;s<l;s++){const c=n[s],d=c.object,u=c.material;u&&u.id in r||this._testInitialLayersWithInitialCameraLayers(d)&&this.isSupportedMaterial(u)&&(r[u.id]={properties:{colorWrite:u.colorWrite}},u.colorWrite=!1,u.needsUpdate=!0)}t(n,i,o);for(let s=0,l=n.length;s<l;s++){const c=n[s];c.object;const d=c.material;if(!d||!(d.id in r))continue;const u=r[d.id];for(let h in u.properties)d[h]=u.properties[h];d.needsUpdate=!0,delete r[d.id]}}}jg.prototype.isWebGLOITWeighted=!0;class Kg{constructor(e){this.resolution=e,this.texType=Ft,this.mute=!1,this.method=qr,this.oitRenderer=null}render(e,t,n,i,o){this.mute||this.oitRenderer&&this.oitRenderer.render(e,t,n,i,o)}setMethod(e,t){this.method!==e&&(this.oitRenderer&&this.oitRenderer.dispose(),this.oitRenderer=null,this.method=e,e!==qr&&e===1&&(this.oitRenderer=new jg(this.resolution,this.texType,t)))}isMethodCompatible(e,t){return e===qr||!(e!==1||!t.isWebGL2)}dispose(){this.oitRenderer&&this.oitRenderer.dispose(),this.method=qr}setSize(e,t){this.resolution.set(e,t),this.oitRenderer&&this.oitRenderer.setSize(e,t)}}Kg.prototype.isWebGLOITRenderer=!0;function Rw(){const a=vs("canvas");return a.style.display="block",a}function Yh(a={}){this.isWebGLRenderer=!0;const e=a.canvas!==void 0?a.canvas:Rw(),t=a.context!==void 0?a.context:null,n=a.depth===void 0||a.depth,i=a.stencil===void 0||a.stencil,o=a.antialias!==void 0&&a.antialias,r=a.premultipliedAlpha===void 0||a.premultipliedAlpha,s=a.preserveDrawingBuffer!==void 0&&a.preserveDrawingBuffer,l=a.powerPreference!==void 0?a.powerPreference:"default",c=a.failIfMajorPerformanceCaveat!==void 0&&a.failIfMajorPerformanceCaveat;let d;d=t!==null?t.getContextAttributes().alpha:a.alpha!==void 0&&a.alpha;let u=null,h=null;const p=[],m=[];this.domElement=e,this.debug={checkShaderErrors:!0,disableCompiledShaderCache:!1},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=_n,this.physicallyCorrectLights=!1,this.unitsScaleFactor=1,this.toneMapping=ci,this.toneMappingLook=rs,this.toneMappingExposure=1,this.gtaoMap=null,this.gtaoMapEnabled=!1,this.compatSettings={useSpecEnvBlenderApprox:!0,saturateSpecEnvBlenderApprox:!1,gtaoDisableBkgFix:!1};const f=this;let g=!1,_=0,A=0,x=null,S=-1,M=null;const T=new Re,L=new Re;let z=null,W=e.width,V=e.height,N=1,j=null,oe=null;const H=new Re(0,0,W,V),ne=new Re(0,0,W,V);let le=!1;const re=new Kc;let ae=!1,E=!1,F=null;const U=new Ae,B=new te,Z=new b,k={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0},X=new Ae,P=new Ae,v=new Re,y=new Ae;new At;let R=!1;function w(){return x===null?N:1}this.oitRenderer=new Kg(new te(W,V));let I,C,D,O,Y,J,G,K,ie,$,se,de,he,ee,ge,ve,_e,we,Be,ke,ht,tt,pt,Kt,pe=t;function gi(Q,ce){for(let ue=0;ue<Q.length;ue++){const ye=Q[ue],fe=e.getContext(ye,ce);if(fe!==null)return fe}return null}try{const Q={alpha:!0,depth:n,stencil:i,antialias:o,premultipliedAlpha:r,preserveDrawingBuffer:s,powerPreference:l,xrCompatible:!Lt.checkSafari(),failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`Verge3D ${pr}`),e.addEventListener("webglcontextlost",qt,!1),e.addEventListener("webglcontextrestored",Ni,!1),e.addEventListener("webglcontextcreationerror",Zt,!1),pe===null){const ce=["webgl2","webgl","experimental-webgl"];if(f.isWebGL1Renderer===!0&&ce.shift(),pe=gi(ce,Q),pe===null)throw gi(ce)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.");const ue=typeof WebGL2RenderingContext<"u"&&pe instanceof WebGL2RenderingContext;console.log("Verge3D "+pr+" "+uA()+" ("+(da(Ec)==3483952072?"Trial":"License")+", "+(ue?"WebGL 2.0":"WebGL 1.0")+")")}pe.getShaderPrecisionFormat===void 0&&(pe.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Q){throw console.error("v3d.WebGLRenderer: "+Q.message),Q}function St(){I=new GM(pe),C=new DM(pe,I,a),I.init(C),tt=new Hg(pe,I,C),D=new bw(pe,I,C),O=new WM,Y=new aw,J=new Cw(pe,I,D,Y,C,tt,O),G=new OM(f),K=new VM(f),ie=new OA(pe,C),pt=new PM(pe,I,ie,C),$=new kM(pe,ie,O,pt),se=new jM(pe,$,ie,O),Be=new YM(pe,C,J),ve=new NM(Y),de=new rw(f,G,K,I,C,pt,ve),he=new Ew(f,Y),ee=new lw,ge=new fw(I,C),we=new LM(f,G,K,D,se,d,r),_e=new yw(f,se,C),Kt=new ww(pe,O,C,D),ke=new BM(pe,I,O,C),ht=new QM(pe,I,O,C),O.programs=de.programs,f.capabilities=C,f.extensions=I,f.properties=Y,f.renderLists=ee,f.shadowMap=_e,f.state=D,f.info=O}St();const qe=new Mw(f,pe);function qt(Q){Q.preventDefault(),console.log("v3d.WebGLRenderer: Context Lost."),g=!0}function Ni(){console.log("v3d.WebGLRenderer: Context Restored."),g=!1;const Q=O.autoReset,ce=_e.enabled,ue=_e.autoUpdate,ye=_e.needsUpdate,fe=_e.type;St(),O.autoReset=Q,_e.enabled=ce,_e.autoUpdate=ue,_e.needsUpdate=ye,_e.type=fe}function Zt(Q){console.error("v3d.WebGLRenderer: A WebGL context could not be created. Reason: ",Q.statusMessage)}function yn(Q){const ce=Q.target;ce.removeEventListener("dispose",yn),function(ue){(function(ye){const fe=Y.get(ye).programs;fe!==void 0&&(fe.forEach(function(Ce){de.releaseProgram(Ce)}),ye.isShaderMaterial&&de.releaseShaderCache(ye))})(ue),Y.remove(ue)}(ce)}this.xr=qe,this.getContext=function(){return pe},this.getContextAttributes=function(){return pe.getContextAttributes()},this.forceContextLoss=function(){const Q=I.get("WEBGL_lose_context");Q&&Q.loseContext()},this.forceContextRestore=function(){const Q=I.get("WEBGL_lose_context");Q&&Q.restoreContext()},this.getTextureUtils=function(){return J},this.getPixelRatio=function(){return N},this.setPixelRatio=function(Q){Q!==void 0&&(N=Q,this.setSize(W,V,!1))},this.getSize=function(Q){return Q.set(W,V)},this.setSize=function(Q,ce,ue){qe.isPresenting?console.warn("v3d.WebGLRenderer: Can't change size while VR device is presenting."):(W=Q,V=ce,e.width=Math.floor(Q*N),e.height=Math.floor(ce*N),ue!==!1&&(e.style.width=Q+"px",e.style.height=ce+"px"),this.setViewport(0,0,Q,ce),this.oitRenderer&&(this.getDrawingBufferSize(B),this.oitRenderer.setSize(B.x,B.y)))},this.getDrawingBufferSize=function(Q){return Q.set(W*N,V*N).floor()},this.setDrawingBufferSize=function(Q,ce,ue){W=Q,V=ce,N=ue,e.width=Math.floor(Q*ue),e.height=Math.floor(ce*ue),this.setViewport(0,0,Q,ce)},this.getCurrentViewport=function(Q){return Q.copy(T)},this.getViewport=function(Q){return Q.copy(H)},this.setViewport=function(Q,ce,ue,ye){Q.isVector4?H.set(Q.x,Q.y,Q.z,Q.w):H.set(Q,ce,ue,ye),D.viewport(T.copy(H).multiplyScalar(N).floor())},this.getScissor=function(Q){return Q.copy(ne)},this.setScissor=function(Q,ce,ue,ye){Q.isVector4?ne.set(Q.x,Q.y,Q.z,Q.w):ne.set(Q,ce,ue,ye),D.scissor(L.copy(ne).multiplyScalar(N).floor())},this.getScissorTest=function(){return le},this.setScissorTest=function(Q){D.setScissorTest(le=Q)},this.setOpaqueSort=function(Q){j=Q},this.setTransparentSort=function(Q){oe=Q},this.getClearColor=function(Q){return Q.copy(we.getClearColor())},this.setClearColor=function(){we.setClearColor.apply(we,arguments)},this.getClearAlpha=function(){return we.getClearAlpha()},this.setClearAlpha=function(){we.setClearAlpha.apply(we,arguments)},this.clear=function(Q=!0,ce=!0,ue=!0){let ye=0;Q&&(ye|=16384),ce&&(ye|=256),ue&&(ye|=1024),pe.clear(ye)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",qt,!1),e.removeEventListener("webglcontextrestored",Ni,!1),e.removeEventListener("webglcontextcreationerror",Zt,!1),this.disposeGTAO(),this.disposeOIT(),this.disposeInternalCaches(),qe.dispose(),qe.removeEventListener("sessionstart",Pa),qe.removeEventListener("sessionend",$s),F&&(F.dispose(),F=null),Oi.stop()},this.canUseGTAO=function(){return this.gtaoMap&&this.gtaoMapEnabled},this.disposeGTAO=function(){var Q;(Q=this.gtaoMap)==null||Q.dispose(),this.gtaoMap=null},this.disposeOIT=function(){this.oitRenderer&&this.oitRenderer.dispose(),this.useOIT=!1},this.disposeInternalCaches=function(){ee.dispose(),ge.dispose(),Y.dispose(),G.dispose(),K.dispose(),se.dispose(),pt.dispose(),de.dispose(),Kt.dispose(),we.dispose(),ie.dispose()},this.renderBufferDirect=function(Q,ce,ue,ye,fe,Ce){ce===null&&(ce=k);const Ne=fe.isMesh&&fe.matrixWorld.determinant()<0,Oe=function(zt,_i,Pn,Se,gt){var nf;_i.isScene!==!0&&(_i=k),J.resetTextureUnits();const mu=_i.fog,yv=Se.isMeshStandardMaterial||Se.isMeshNodeMaterial?_i.environment:null,bv=x===null?f.outputEncoding:x.isXRRenderTarget===!0?x.texture.encoding:_n;if(Se.envMapAutoAssign&&(Se.isMeshStandardMaterial||Se.isMeshPhysicalMaterial||Se.isMeshNodeMaterial)){const je=h.state.envMapProbeArray.find(Vt=>Vt.influenceGroup===null?Vt.intersectsMesh(gt):gt.groupNames.includes(Vt.influenceGroup)^Vt.influenceGroupInv)||_i.worldEnvMapProbe;if(je){Se.envMap=((nf=je.renderTarget)==null?void 0:nf.texture)||null;const Vt=je.parallaxDistance;Se.envMapParallaxMatrix.copy(je.matrixWorldInverse).premultiply(y.makeScale(1/Vt,1/Vt,1/Vt)),Se.envMapParallaxMatrixInv.copy(je.matrixWorld).multiply(y.makeScale(Vt,Vt,Vt)),Se.envMapParallaxType=je.parallaxType}}const Cv=(Se.isMeshStandardMaterial||Se.isMeshNodeMaterial?K:G).get(Se.envMap||yv),Sv=Se.vertexColors===!0&&!!Pn.attributes.color&&Pn.attributes.color.itemSize===4,Mv=!!Se.normalMap&&!!Pn.attributes.tangent,Ev=!!Pn.morphAttributes.position,wv=!!Pn.morphAttributes.normal,Tv=!!Pn.morphAttributes.color,Iv=Se.toneMapped?f.toneMapping:ci,$p=Pn.morphAttributes.position||Pn.morphAttributes.normal||Pn.morphAttributes.color,Rv=$p!==void 0?$p.length:0,Lv=Se.side===nn,rt=Y.get(Se),Pv=h.state.lights;if(ae===!0&&(E===!0||zt!==M)){const je=zt===M&&Se.id===S;ve.setState(Se,zt,je)}const gu=Jp(gt,Se,h),Bv=Se.isMeshNodeMaterial&&Se.canUseGTAO()&&f.canUseGTAO();let Ai=!1,ef=!1;if(Se.version===rt.__version)rt.needsLights&&rt.lightsStateVersion!==Pv.state.version||rt.outputEncoding!==bv||gt.isInstancedMesh&&rt.instancing===!1?Ai=!0:gt.isInstancedMesh||rt.instancing!==!0?gt.isSkinnedMesh&&rt.skinning===!1?Ai=!0:gt.isSkinnedMesh||rt.skinning!==!0?rt.envMap!==Cv?(Ai=!0,ef=!0):Se.fog===!0&&rt.fog!==mu?Ai=!0:rt.numClippingPlanes===void 0||rt.numClippingPlanes===ve.numPlanes&&rt.numIntersection===ve.numIntersection?(rt.vertexAlphas!==Sv||rt.vertexTangents!==Mv||rt.morphTargets!==Ev||rt.morphNormals!==wv||rt.morphColors!==Tv||rt.toneMapping!==Iv||C.isWebGL2===!0&&rt.morphTargetsCount!==Rv||rt.planeReflProbe!==gu||Se.isMeshNormalMaterial&&rt.flipSided!==Lv||rt.useGTAO!==Bv)&&(Ai=!0):Ai=!0:Ai=!0:Ai=!0;else if(Ai=!0,rt.__version=Se.version,Se.nodeRGBArr)for(let je=0;je<Se.nodeRGB.length;je++)Se.nodeRGB[je].toArray(Se.nodeRGBArr,4*je);let Vo=rt.currentProgram;Ai===!0&&(Vo=bn(Se,_i,gt,h));let tf=!1,Cr=!1,vu=!1;const Ve=Vo.getUniforms(),Go=rt.uniforms;if(D.useProgram(Vo.program)&&(tf=!0,Cr=!0,vu=!0),Se.id!==S&&(S=Se.id,Cr=!0),ef&&(Cr=!0),tf||M!==zt){if(Ve.setValue(pe,"projectionMatrix",zt.projectionMatrix),C.logarithmicDepthBuffer&&Ve.setValue(pe,"logDepthBufFC",2/(Math.log(zt.far+1)/Math.LN2)),M!==zt&&(M=zt,Cr=!0,vu=!0),Se.isShaderMaterial||Se.isMeshPhongMaterial||Se.isMeshToonMaterial||Se.isMeshStandardMaterial||Se.isMeshNodeMaterial||Se.envMap){const je=Ve.map.cameraPosition;je!==void 0&&je.setValue(pe,Z.setFromMatrixPosition(zt.matrixWorld))}(Se.isMeshPhongMaterial||Se.isMeshToonMaterial||Se.isMeshLambertMaterial||Se.isMeshBasicMaterial||Se.isMeshStandardMaterial||Se.isShaderMaterial||Se.isMeshNodeMaterial)&&Ve.setValue(pe,"isOrthographic",zt.isOrthographicCamera===!0),(Se.isMeshPhongMaterial||Se.isMeshToonMaterial||Se.isMeshLambertMaterial||Se.isMeshBasicMaterial||Se.isMeshStandardMaterial||Se.isShaderMaterial||Se.isMeshNodeMaterial||Se.isShadowMaterial||gt.isSkinnedMesh)&&Ve.setValue(pe,"viewMatrix",zt.matrixWorldInverse),(Se.isMeshPhongMaterial||Se.isMeshToonMaterial||Se.isMeshLambertMaterial||Se.isMeshNodeMaterial||Se.isMeshStandardMaterial||Se.isMeshPhysicalMaterial||Se.isShadowMaterial)&&Ve.setValue(pe,"invViewMatrix",zt.matrixWorld)}if(gt.isSkinnedMesh){Ve.setOptional(pe,gt,"bindMatrix"),Ve.setOptional(pe,gt,"bindMatrixInverse");const je=gt.skeleton;je&&(C.floatVertexTextures?(je.boneTexture===null&&je.computeBoneTexture(),Ve.setValue(pe,"boneTexture",je.boneTexture,J),Ve.setValue(pe,"boneTextureSize",je.boneTextureSize)):console.warn("v3d.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const _u=Pn.morphAttributes;if((_u.position!==void 0||_u.normal!==void 0||_u.color!==void 0&&C.isWebGL2===!0)&&Be.update(gt,Pn,Se,Vo),(Cr||rt.receiveShadow!==gt.receiveShadow)&&(rt.receiveShadow=gt.receiveShadow,Ve.setValue(pe,"receiveShadow",gt.receiveShadow)),Se.needsBoundingBox){const je=gt.geometry;je&&(je.boundingBox===null&&je.computeBoundingBox(),Ve.setValue(pe,"boundingBoxMin",je.boundingBox.min),Ve.setValue(pe,"boundingBoxMax",je.boundingBox.max))}if(Cr){if(Ve.setValue(pe,"toneMappingExposure",f.toneMappingExposure),f.toneMapping==kc?(Ve.setValue(pe,"toneMappingBrightness",f.toneMappingBrightness),Ve.setValue(pe,"toneMappingContrast",f.toneMappingContrast),Ve.setValue(pe,"toneMappingMidTones",f.toneMappingMidTones),Ve.setValue(pe,"toneMappingPhysicalScale",f.toneMappingPhysicalScale),Ve.setValue(pe,"toneMappingChromaticAdaptation",f.toneMappingChromaticAdaptation),Ve.setValue(pe,"toneMappingWhiteColor",f.toneMappingWhiteColor),Ve.setValue(pe,"toneMappingColorDifferentiation",f.toneMappingColorDifferentiation),Ve.setValue(pe,"toneMappingExteriorDaylight",f.toneMappingExteriorDaylight)):f.toneMapping==Qc&&(Ve.setValue(pe,"toneMappingResolution",B.set(W,V)),Ve.setValue(pe,"toneMappingWhiteBalance",f.toneMappingWhiteBalance),Ve.setValue(pe,"toneMappingHighlights",f.toneMappingHighlights),Ve.setValue(pe,"toneMappingMidTones",f.toneMappingMidTones),Ve.setValue(pe,"toneMappingShadows",f.toneMappingShadows),Ve.setValue(pe,"toneMappingSaturation",f.toneMappingSaturation),Ve.setValue(pe,"toneMappingPhysicalScale",f.toneMappingPhysicalScale),Ve.setValue(pe,"toneMappingAperture",f.toneMappingAperture),Ve.setValue(pe,"toneMappingShutter",f.toneMappingShutter),Ve.setValue(pe,"toneMappingISO",f.toneMappingISO),Ve.setValue(pe,"toneMappingVignetting",f.toneMappingVignetting)),rt.needsLights&&(Bn=vu,(Xn=Go).ambientLightColor.needsUpdate=Bn,Xn.lightProbe.needsUpdate=Bn,Xn.directionalLights.needsUpdate=Bn,Xn.pointLights.needsUpdate=Bn,Xn.pointLightShadows.needsUpdate=Bn,Xn.spotLights.needsUpdate=Bn,Xn.spotLightShadows.needsUpdate=Bn,Xn.rectAreaLights.needsUpdate=Bn,Xn.hemisphereLights.needsUpdate=Bn,Xn.rectAreaLightShadows.needsUpdate=Bn,Xn.directionalLightShadowsCSM.needsUpdate=Bn,Xn.directionalLightShadowsCSMCascade.needsUpdate=Bn),mu&&Se.fog===!0&&he.refreshFogUniforms(Go,mu),rt.useGTAO){const je=(x==null?void 0:x.width)??W,Vt=(x==null?void 0:x.height)??V;Ve.setValue(pe,"currResolution",B.set(je,Vt)),he.refreshGTAOUniforms(Go,f.gtaoMap)}if(he.refreshMaterialUniforms(Go,Se,N,V,F),gu&&he.refreshPlaneReflProbeUniforms(Go,gu),Se.isMeshNodeMaterial)for(const je in Se.nodeTextures)Ve.setValue(pe,je,Se.nodeTextures[je],J);Se.isMeshLineMaterial&&Ve.setValue(pe,"resolution",B.set(W,V)),vc.upload(pe,Hn(rt),Go,J)}var Xn,Bn;if(Se.isShaderMaterial&&Se.uniformsNeedUpdate===!0&&(vc.upload(pe,Hn(rt),Go,J),Se.uniformsNeedUpdate=!1),Se.isSpriteMaterial&&Ve.setValue(pe,"center",gt.center),Se.isMeshNodeMaterial){X.copy(gt.matrixWorld).invert(),Ve.setValue(pe,"invModelMatrix",X),Ve.setValue(pe,"viewWidthHeight",B.set(T.z-T.x,T.w-T.y)),Se.nodeTexCoordObject.forEach(function(Vt,Au){(Vt===null?X:P.copy(Vt.matrixWorld).invert()).toArray(Se.nodeTexCoordObjectArr,16*Au)}),Se.nodeTexCoordObjectArr&&Ve.setValue(pe,"nodeTexCoordObjectMatrices",Se.nodeTexCoordObjectArr),Ve.setValue(pe,"objectIndex",gt.objectIndex);const je=gt.objectColor;Ve.setValue(pe,"objectColor",v.set(je.r,je.g,je.b,gt.objectAlpha)),Ve.setValue(pe,"objectRandom",da(gt.uuid)/Math.pow(2,32))}if(Ve.setValue(pe,"modelViewMatrix",gt.modelViewMatrix),Ve.setValue(pe,"normalMatrix",gt.normalMatrix),Ve.setValue(pe,"modelMatrix",gt.matrixWorld),Se.isShaderMaterial||Se.isRawShaderMaterial){const je=Se.uniformsGroups;for(let Vt=0,Au=je.length;Vt<Au;Vt++)if(C.isWebGL2){const of=je[Vt];Kt.update(of,Vo),Kt.bind(of,Vo)}else console.warn("v3d.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return Vo}(Q,ce,ue,ye,fe);D.setMaterial(ye,Ne);let He=ue.index,Ze=1;ye.wireframe===!0&&(He=$.getWireframeAttribute(ue),Ze=2);const it=ue.drawRange,Pt=ue.attributes.position;let ot=it.start*Ze,We=(it.start+it.count)*Ze;Ce!==null&&(ot=Math.max(ot,Ce.start*Ze),We=Math.min(We,(Ce.start+Ce.count)*Ze)),He!==null?(ot=Math.max(ot,0),We=Math.min(We,He.count)):Pt!=null&&(ot=Math.max(ot,0),We=Math.min(We,Pt.count));const Et=We-ot;if(Et<0||Et===1/0)return;let el;pt.setup(fe,ye,Oe,ue,He);let Bt=ke;if(He!==null&&(el=ie.get(He),Bt=ht,Bt.setIndex(el)),fe.isMesh)ye.wireframe===!0?(D.setLineWidth(ye.wireframeLinewidth*w()),Bt.setMode(1)):Bt.setMode(4);else if(fe.isLine){let zt=ye.linewidth;zt===void 0&&(zt=1),D.setLineWidth(zt*w()),fe.isLineSegments?Bt.setMode(1):fe.isLineLoop?Bt.setMode(2):Bt.setMode(3)}else fe.isPoints?Bt.setMode(0):fe.isSprite&&Bt.setMode(4);if(Oe.beginTimerQuery(pe,C.isWebGL2),ye.depthPrepass&&ye.transparent){const zt=D.buffers.depth.getTest(),_i=D.buffers.color.getMask();if(D.buffers.depth.setTest(!0),D.buffers.color.setMask(0),fe.isInstancedMesh)Bt.renderInstances(ot,Et,fe.count);else if(ue.isInstancedBufferGeometry){const Pn=ue._maxInstanceCount!==void 0?ue._maxInstanceCount:1/0,Se=Math.min(ue.instanceCount,Pn);Bt.renderInstances(ot,Et,Se)}else Bt.render(ot,Et);D.buffers.depth.setTest(zt),D.buffers.color.setMask(_i)}if(fe.isInstancedMesh)Bt.renderInstances(ot,Et,fe.count);else if(ue.isInstancedBufferGeometry){const zt=ue._maxInstanceCount!==void 0?ue._maxInstanceCount:1/0,_i=Math.min(ue.instanceCount,zt);Bt.renderInstances(ot,Et,_i)}else Bt.render(ot,Et);Oe.endTimerQuery(pe,C.isWebGL2)},this._compilePrepareRenderState=function(Q,ce,ue){ue.init(),Q.traverse(fe=>{fe.isLight?(ue.pushLight(fe),fe.castShadow&&ue.pushShadow(fe)):fe.isCubeReflectionProbe?ue.pushEnvMapProbe(fe):fe.isPlaneReflectionProbe&&ue.pushPlaneReflProbe(fe)}),ue.setupLights(f.physicallyCorrectLights),ue.sortEnvMapProbes();let ye=null;return Q.worldEnvMapProbe&&Q.worldEnvMapProbe.renderTarget!==null&&(ye=Q.worldEnvMapProbe.renderTarget.texture),Q.traverse(fe=>{fe.material&&(Array.isArray(fe.material)?fe.material:[fe.material]).forEach(Ce=>{(Ce.isMeshStandardMaterial||Ce.isMeshPhysicalMaterial||Ce.isMeshNodeMaterial)&&(fe.material.envMap=ye,fe.material.needsUpdate=!0)})}),ue},this.compile=function(Q,ce){this.gtaoMapEnabled=!0;const ue=ge.get(Q,m.length);this._compilePrepareRenderState(Q,ce,ue);const ye={};Q.traverse(function(fe){const Ce=fe.material;if(Ce)if(Array.isArray(Ce))for(let Ne=0;Ne<Ce.length;Ne++){const Oe=Ce[Ne];!(Oe.uuid in ye)&&(bn(Oe,Q,fe,ue),ye[Oe.uuid]=!0)}else!(Ce.uuid in ye)&&(bn(Ce,Q,fe,ue),ye[Ce.uuid]=!0)}),this.gtaoMapEnabled=!1},this.compileAsync=function(Q,ce,ue){const ye=new sh(I,C);this._compilePrepareRenderState(Q,ce,ye);const fe=[];if(Q.traverse(function(Ce){Ce.material&&(Array.isArray(Ce.material)?Ce.material:[Ce.material]).forEach(function(Ne){fe.push({scene:Q,obj:Ce,mat:Ne})})}),fe.length===0)ue(1);else{const Ce=I.get("KHR_parallel_shader_compile"),Ne=(Ce===null?1:2)*fe.length;let Oe=0,He=0;const Ze={};if(dA(fe,function(it,Pt,ot){f.gtaoMapEnabled=!0;var We=bn(it.mat,it.scene,it.obj,ye);if(f.gtaoMapEnabled=!1,Ce){const Et=We.id;Et in Ze||(Ze[Et]={program:We,weight:0}),Ze[Et].weight++}ue&&(Oe++,ue((Oe+He)/Ne))},16),Ce){const it=setInterval(function(){let Pt=0;for(let ot in Ze){const We=Ze[ot];(We.program.program===void 0||pe.getProgramParameter(We.program.program,Ce.COMPLETION_STATUS_KHR))&&(Pt+=We.weight)}He=Math.max(He,Pt),ue&&ue((Oe+He)/Ne),He===fe.length&&clearInterval(it)},16)}}};let Mt=null;function Pa(){Oi.stop()}function $s(){Oi.start()}const Oi=new Vg;function vi(Q,ce,ue,ye){Q.isAnnotationControl&&Q.update(ce);let fe=!1;if(Q.visible&&(fe=Q.layers.test(ce.layers),fe)){if(Q.isGroup)ue=Q.renderOrder;else if(Q.isLOD)Q.autoUpdate===!0&&Q.update(ce);else if(Q.isLight)h.pushLight(Q),Q.castShadow&&h.pushShadow(Q);else if(Q.isCubeReflectionProbe)h.pushEnvMapProbe(Q);else if(Q.isPlaneReflectionProbe)h.pushPlaneReflProbe(Q);else if(Q.isSprite){if(!Q.frustumCulled||re.intersectsSprite(Q)){ye&&Z.setFromMatrixPosition(Q.matrixWorld).applyMatrix4(U);const Ne=se.update(Q),Oe=Q.material;u.push(Q,Ne,Oe,ue,Z.z,null)}}else if(Q.isImmediateRenderObject)ye&&Z.setFromMatrixPosition(Q.matrixWorld).applyMatrix4(U),u.push(Q,null,Q.material,ue,Z.z,null);else if((Q.isMesh||Q.isLine||Q.isPoints)&&(Q.isSkinnedMesh&&Q.skeleton.frame!==O.render.frame&&(Q.skeleton.update(),Q.skeleton.frame=O.render.frame),!Q.frustumCulled||re.intersectsObject(Q))){ye&&Z.setFromMatrixPosition(Q.matrixWorld).applyMatrix4(U);const Ne=se.update(Q),Oe=Q.material;if(Array.isArray(Oe)){const He=Ne.groups;for(let Ze=0,it=He.length;Ze<it;Ze++){const Pt=He[Ze],ot=Oe[Pt.materialIndex];ot&&ot.visible&&u.push(Q,Ne,ot,ue,Z.z,Pt)}}else Oe.visible&&u.push(Q,Ne,Oe,ue,Z.z,null)}}if(Q.disableChildRendering)return;const Ce=Q.children;for(let Ne=0,Oe=Ce.length;Ne<Oe;Ne++){const He=Ce[Ne];!fe&&He.isMesh&&He.isMaterialGeneratedMesh||vi(He,ce,ue,ye)}}function be(Q,ce,ue,ye){const fe=Q.opaque,Ce=Q.transmissive,Ne=Q.transparent;h.setupLightsView(ue),Ce.length>0&&function(Oe,He,Ze){const it=C.isWebGL2;F===null&&(F=new et(1,1,{generateMipmaps:!0,type:I.has("EXT_color_buffer_half_float")?_t:Ft,minFilter:In,samples:it&&o===!0?4:0})),f.getDrawingBufferSize(B),it?F.setSize(B.x,B.y):F.setSize(Tc(B.x),Tc(B.y));const Pt=f.getRenderTarget();f.setRenderTarget(F),f.clear();const ot=f.toneMapping;f.toneMapping=ci,ct(Oe,He,Ze),f.toneMapping=ot,J.updateMultisampleRenderTarget(F),J.updateRenderTargetMipmap(F),f.setRenderTarget(Pt)}(fe,ce,ue),ye&&D.viewport(T.copy(ye)),fe.length>0&&ct(fe,ce,ue),Ce.length>0&&ct(Ce,ce,ue),Ne.length>0&&(R&&f.oitRenderer.method!==qr?f.oitRenderer.render(f,ct,Ne,ce,ue):ct(Ne,ce,ue)),D.buffers.depth.setTest(!0),D.buffers.depth.setMask(!0),D.buffers.color.setMask(!0),D.setPolygonOffset(!1)}function ct(Q,ce,ue){const ye=ce.isScene===!0?ce.overrideMaterial:null;for(let fe=0,Ce=Q.length;fe<Ce;fe++){const Ne=Q[fe],Oe=Ne.object,He=Ne.geometry,Ze=ye===null?Ne.material:ye,it=Ne.group;Oe.layers.test(ue.layers)&&Ln(Oe,ce,ue,He,Ze,it)}}function Ln(Q,ce,ue,ye,fe,Ce){Q.onBeforeRender(f,ce,ue,ye,fe,Ce),Q.modelViewMatrix.multiplyMatrices(ue.matrixWorldInverse,Q.matrixWorld),Q.normalMatrix.getNormalMatrix(Q.modelViewMatrix),fe.onBeforeRender(f,ce,ue,ye,Q,Ce),fe.transparent===!0&&fe.side===Od?(fe.side=nn,fe.needsUpdate=!0,f.renderBufferDirect(ue,ce,ye,fe,Q,Ce),fe.side=kn,fe.needsUpdate=!0,f.renderBufferDirect(ue,ce,ye,fe,Q,Ce),fe.side=Od):f.renderBufferDirect(ue,ce,ye,fe,Q,Ce),Q.onAfterRender(f,ce,ue,ye,fe,Ce)}function bn(Q,ce,ue,ye){ce.isScene!==!0&&(ce=k);const fe=Y.get(Q),Ce=ye.state.lights,Ne=ye.state.shadowsArray,Oe=Ce.state.version,He=Jp(ue,Q,ye);fe.planeReflProbe=He;const Ze=de.getParameters(Q,Ce.state,Ne,ce,ue,He),it=de.getProgramCacheKey(Ze);let Pt=fe.programs;fe.environment=Q.isMeshStandardMaterial||Q.isMeshNodeMaterial?ce.environment:null,fe.fog=ce.fog,fe.envMap=(Q.isMeshStandardMaterial||Q.isMeshNodeMaterial?K:G).get(Q.envMap||fe.environment),fe.useGTAO=Q.isMeshNodeMaterial&&Q.canUseGTAO()&&f.canUseGTAO(),Pt===void 0&&(Q.addEventListener("dispose",yn),Pt=new Map,fe.programs=Pt);let ot=Pt.get(it);if(ot!==void 0){if(fe.currentProgram===ot&&fe.lightsStateVersion===Oe)return Zp(Q,Ze),ot}else Ze.uniforms=de.getUniforms(Q),Q.onBuild(ue,Ze,f),Q.onBeforeCompile(Ze,f),ot=de.acquireProgram(Ze,it),Pt.set(it,ot),fe.uniforms=Ze.uniforms;const We=fe.uniforms;return(Q.isShaderMaterial||Q.isRawShaderMaterial)&&Q.clipping!==!0||Q.defines.WORLD_NODES||(We.clippingPlanes=ve.uniform),Zp(Q,Ze),fe.needsLights=function(Et){return Et.isMeshLambertMaterial||Et.isMeshToonMaterial||Et.isMeshPhongMaterial||Et.isMeshStandardMaterial||Et.isShadowMaterial||Et.isShaderMaterial&&Et.lights===!0||Et.isMeshNodeMaterial}(Q),fe.lightsStateVersion=Oe,fe.needsLights&&(We.ambientLightColor.value=Ce.state.ambient,We.lightProbe.value=Ce.state.probe,We.directionalLights.value=Ce.state.directional,We.spotLights.value=Ce.state.spot,We.spotLightShadows.value=Ce.state.spotShadow,We.rectAreaLights.value=Ce.state.rectArea,We.ltc_1.value=Ce.state.rectAreaLTC1,We.ltc_2.value=Ce.state.rectAreaLTC2,We.pointLights.value=Ce.state.point,We.pointLightShadows.value=Ce.state.pointShadow,We.hemisphereLights.value=Ce.state.hemi,We.spotShadowMap.value=Ce.state.spotShadowMap,We.spotLightMatrix.value=Ce.state.spotLightMatrix,We.spotLightMap.value=Ce.state.spotLightMap,We.pointShadowMap.value=Ce.state.pointShadowMap,We.pointShadowMatrix.value=Ce.state.pointShadowMatrix,We.rectAreaLightShadows.value=Ce.state.rectAreaShadow,We.rectAreaShadowMap.value=Ce.state.rectAreaShadowMap,We.rectAreaShadowMatrix.value=Ce.state.rectAreaShadowMatrix,We.directionalLightShadowsCSM.value=Ce.state.directionalShadowCSM,We.directionalShadowCSMMap.value=Ce.state.directionalShadowCSMMap,We.directionalShadowCSMMatrix.value=Ce.state.directionalShadowCSMMatrix,We.directionalLightShadowsCSMCascade.value=Ce.state.directionalShadowCSMCascade),Q.nodeValue&&(We.nodeValue.value=Q.nodeValue),Q.nodeRGBArr&&(We.nodeRGB.value=Q.nodeRGBArr),fe.currentProgram=ot,fe.uniformsList=null,ot}function Hn(Q){if(Q.uniformsList===null){const ce=Q.currentProgram.getUniforms();Q.uniformsList=vc.seqWithValue(ce.seq,Q.uniforms)}return Q.uniformsList}function Zp(Q,ce){const ue=Y.get(Q);ue.outputEncoding=ce.outputEncoding,ue.instancing=ce.instancing,ue.skinning=ce.skinning,ue.morphTargets=ce.morphTargets,ue.morphNormals=ce.morphNormals,ue.morphColors=ce.morphColors,ue.morphTargetsCount=ce.morphTargetsCount,ue.numClippingPlanes=ce.numClippingPlanes,ue.numIntersection=ce.numClipIntersection,ue.vertexAlphas=ce.vertexAlphas,ue.vertexTangents=ce.vertexTangents,ue.toneMapping=ce.toneMapping,ue.flipSided=ce.flipSided}function Jp(Q,ce,ue){return(ce.isMeshStandardMaterial||ce.isMeshPhysicalMaterial||ce.isMeshNodeMaterial)&&ue.state.planeReflProbeArray.find(ye=>ye.intersectsMesh(Q))||null}Oi.setAnimationLoop(function(Q){Mt&&Mt(Q)}),typeof self<"u"&&Oi.setContext(self),this.setAnimationLoop=function(Q){Mt=Q,qe.setAnimationLoop(Q),Q===null?Oi.stop():Oi.start()},qe.addEventListener("sessionstart",Pa),qe.addEventListener("sessionend",$s),this.render=function(Q,ce){if(ce!==void 0&&ce.isCamera!==!0)return void console.error("v3d.WebGLRenderer.render: camera is not an instance of v3d.Camera.");if(g===!0)return;Q.matrixWorldAutoUpdate===!0&&Q.updateMatrixWorld(),ce.parent===null&&ce.matrixWorldAutoUpdate===!0&&ce.updateMatrixWorld(),qe.enabled===!0&&qe.isPresenting===!0&&(qe.cameraAutoUpdate===!0&&qe.updateCamera(ce),ce=qe.getCamera()),Q.isScene===!0&&Q.onBeforeRender(f,Q,ce,x),h=ge.get(Q,m.length),h.init(),m.push(h),U.multiplyMatrices(ce.projectionMatrix,ce.matrixWorldInverse),re.setFromProjectionMatrix(U),E=this.localClippingEnabled,ae=ve.init(this.clippingPlanes,E,ce),u=ee.get(Q,p.length),u.init(),p.push(u),vi(Q,ce,0,f.sortObjects),u.finish(),f.sortObjects===!0&&u.sort(j,oe),ae===!0&&ve.beginShadows();const ue=h.state.shadowsArray;if(_e.render(ue,Q,ce),ae===!0&&ve.endShadows(),this.info.autoReset===!0&&this.info.reset(),we.render(u,Q),h.setupLights(f.physicallyCorrectLights),h.sortEnvMapProbes(),ce.isArrayCamera){const ye=ce.cameras;for(let fe=0,Ce=ye.length;fe<Ce;fe++){const Ne=ye[fe];be(u,Q,Ne,Ne.viewport)}}else be(u,Q,ce);x!==null&&(J.updateMultisampleRenderTarget(x),J.updateRenderTargetMipmap(x)),Q.isScene===!0&&Q.onAfterRender(f,Q,ce),pt.resetDefaultState(),S=-1,M=null,m.pop(),h=m.length>0?m[m.length-1]:null,p.pop(),u=p.length>0?p[p.length-1]:null},this.getActiveCubeFace=function(){return _},this.getActiveMipmapLevel=function(){return A},this.getRenderTarget=function(){return x},this.setRenderTargetTextures=function(Q,ce,ue){Y.get(Q.texture).__webglTexture=ce,Y.get(Q.depthTexture).__webglTexture=ue;const ye=Y.get(Q);ye.__hasExternalTextures=!0,ye.__hasExternalTextures&&(ye.__autoAllocateDepthBuffer=ue===void 0,ye.__autoAllocateDepthBuffer||I.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("v3d.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),ye.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(Q,ce){const ue=Y.get(Q);ue.__webglFramebuffer=ce,ue.__useDefaultFramebuffer=ce===void 0},this.setRenderTarget=function(Q,ce=0,ue=0){x=Q,_=ce,A=ue;let ye=!0,fe=null,Ce=!1,Ne=!1;if(Q){const Oe=Y.get(Q);Oe.__useDefaultFramebuffer!==void 0?(D.bindFramebuffer(36160,null),ye=!1):Oe.__webglFramebuffer===void 0?J.setupRenderTarget(Q):Oe.__hasExternalTextures&&J.rebindTextures(Q,Y.get(Q.texture).__webglTexture,Y.get(Q.depthTexture).__webglTexture);const He=Q.texture;(He.isData3DTexture||He.isDataArrayTexture||He.isCompressedArrayTexture)&&(Ne=!0);const Ze=Y.get(Q).__webglFramebuffer;Q.isWebGLCubeRenderTarget?(fe=Ze[ce],Ce=!0):fe=C.isWebGL2&&Q.samples>0&&J.useMultisampledRTT(Q)===!1?Y.get(Q).__webglMultisampledFramebuffer:Ze,T.copy(Q.viewport),L.copy(Q.scissor),z=Q.scissorTest}else T.copy(H).multiplyScalar(N).floor(),L.copy(ne).multiplyScalar(N).floor(),z=le;if(D.bindFramebuffer(36160,fe)&&C.drawBuffers&&ye&&D.drawBuffers(Q,fe),D.viewport(T),D.scissor(L),D.setScissorTest(z),Ce){const Oe=Y.get(Q.texture);pe.framebufferTexture2D(36160,36064,34069+ce,Oe.__webglTexture,ue)}else if(Ne){const Oe=Y.get(Q.texture),He=ce||0;pe.framebufferTextureLayer(36160,36064,Oe.__webglTexture,ue||0,He)}S=-1},this.readRenderTargetPixels=function(Q,ce,ue,ye,fe,Ce,Ne){if(!Q||!Q.isWebGLRenderTarget)return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not v3d.WebGLRenderTarget.");let Oe=Y.get(Q).__webglFramebuffer;if(Q.isWebGLCubeRenderTarget&&Ne!==void 0&&(Oe=Oe[Ne]),Oe){D.bindFramebuffer(36160,Oe);try{const He=Q.texture,Ze=He.format,it=He.type;if(Ze!==Qe&&tt.convert(Ze)!==pe.getParameter(35739))return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const Pt=it===_t&&(I.has("EXT_color_buffer_half_float")||C.isWebGL2&&I.has("EXT_color_buffer_float"));if(!(it===Ft||tt.convert(it)===pe.getParameter(35738)||it===Ct&&(C.isWebGL2||I.has("OES_texture_float")||I.has("WEBGL_color_buffer_float"))||Pt))return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");ce>=0&&ce<=Q.width-ye&&ue>=0&&ue<=Q.height-fe&&pe.readPixels(ce,ue,ye,fe,tt.convert(Ze),tt.convert(it),Ce)}finally{const He=x!==null?Y.get(x).__webglFramebuffer:null;D.bindFramebuffer(36160,He)}}},this.copyFramebufferToTexture=function(Q,ce,ue=0){const ye=Math.pow(2,-ue),fe=Math.floor(ce.image.width*ye),Ce=Math.floor(ce.image.height*ye);J.setTexture2D(ce,0),pe.copyTexSubImage2D(3553,ue,0,0,Q.x,Q.y,fe,Ce),D.unbindTexture()},this.copyTextureToTexture=function(Q,ce,ue,ye=0){const fe=ce.image.width,Ce=ce.image.height,Ne=tt.convert(ue.format),Oe=tt.convert(ue.type);J.setTexture2D(ue,0),pe.pixelStorei(37440,ue.flipY),pe.pixelStorei(37441,ue.premultiplyAlpha),pe.pixelStorei(3317,ue.unpackAlignment),ce.isDataTexture?pe.texSubImage2D(3553,ye,Q.x,Q.y,fe,Ce,Ne,Oe,ce.image.data):ce.isCompressedTexture?pe.compressedTexSubImage2D(3553,ye,Q.x,Q.y,ce.mipmaps[0].width,ce.mipmaps[0].height,Ne,ce.mipmaps[0].data):pe.texSubImage2D(3553,ye,Q.x,Q.y,Ne,Oe,ce.image),ye===0&&ue.generateMipmaps&&pe.generateMipmap(3553),D.unbindTexture()},this.copyTextureToTexture3D=function(Q,ce,ue,ye,fe=0){if(f.isWebGL1Renderer)return void console.warn("v3d.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const Ce=Q.max.x-Q.min.x+1,Ne=Q.max.y-Q.min.y+1,Oe=Q.max.z-Q.min.z+1,He=tt.convert(ye.format),Ze=tt.convert(ye.type);let it;if(ye.isData3DTexture)J.setTexture3D(ye,0),it=32879;else{if(!ye.isDataArrayTexture)return void console.warn("v3d.WebGLRenderer.copyTextureToTexture3D: only supports v3d.DataTexture3D and v3d.DataTexture2DArray.");J.setTexture2DArray(ye,0),it=35866}pe.pixelStorei(37440,ye.flipY),pe.pixelStorei(37441,ye.premultiplyAlpha),pe.pixelStorei(3317,ye.unpackAlignment);const Pt=pe.getParameter(3314),ot=pe.getParameter(32878),We=pe.getParameter(3316),Et=pe.getParameter(3315),el=pe.getParameter(32877),Bt=ue.isCompressedTexture?ue.mipmaps[0]:ue.image;pe.pixelStorei(3314,Bt.width),pe.pixelStorei(32878,Bt.height),pe.pixelStorei(3316,Q.min.x),pe.pixelStorei(3315,Q.min.y),pe.pixelStorei(32877,Q.min.z),ue.isDataTexture||ue.isData3DTexture?pe.texSubImage3D(it,fe,ce.x,ce.y,ce.z,Ce,Ne,Oe,He,Ze,Bt.data):ue.isCompressedArrayTexture?(console.warn("v3d.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),pe.compressedTexSubImage3D(it,fe,ce.x,ce.y,ce.z,Ce,Ne,Oe,He,Bt.data)):pe.texSubImage3D(it,fe,ce.x,ce.y,ce.z,Ce,Ne,Oe,He,Ze,Bt),pe.pixelStorei(3314,Pt),pe.pixelStorei(32878,ot),pe.pixelStorei(3316,We),pe.pixelStorei(3315,Et),pe.pixelStorei(32877,el),fe===0&&ye.generateMipmaps&&pe.generateMipmap(it),D.unbindTexture()},this.initTexture=function(Q){Q.isCubeTexture?J.setTextureCube(Q,0):Q.isData3DTexture?J.setTexture3D(Q,0):Q.isDataArrayTexture||Q.isCompressedArrayTexture?J.setTexture2DArray(Q,0):J.setTexture2D(Q,0),D.unbindTexture()},this.resetState=function(){_=0,A=0,x=null,D.reset(),pt.reset()},typeof __V3D_DEVTOOLS__<"u"&&__V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this})),this.updateGeometry=function(Q){return se.update(Q)},this.setOIT=function(Q,ce){this.oitRenderer.setSize(W,V),this.oitRenderer.texType=tt.convert(_t)!==null?_t:Ft;let ue=ce||(o===!0?4:0);this.oitRenderer.isMethodCompatible(Q,C)?this.oitRenderer.setMethod(Q,ue):console.log("v3d.WebGLRenderer: the OIT method is not compatible.")},this.getOIT=function(){return this.oitRenderer.method},Object.defineProperty(this,"useOIT",{get:function(){return R},set:function(Q){this.setTransparentSort(Q?function(){}:null),R=Q}})}class qg extends Yh{}qg.prototype.isWebGL1Renderer=!0;class $c{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new me(e),this.density=t}clone(){return new $c(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class eu{constructor(e,t=1,n=1e3){this.isFog=!0,this.name="",this.color=new me(e),this.near=t,this.far=n}clone(){return new eu(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class Ma{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=wn()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,o=this.stride;i<o;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=wn()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=wn()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const fn=new b;class io{constructor(e,t,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)fn.fromBufferAttribute(this,t),fn.applyMatrix4(e),this.setXYZ(t,fn.x,fn.y,fn.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)fn.fromBufferAttribute(this,t),fn.applyNormalMatrix(e),this.setXYZ(t,fn.x,fn.y,fn.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)fn.fromBufferAttribute(this,t),fn.transformDirection(e),this.setXYZ(t,fn.x,fn.y,fn.z);return this}setX(e,t){return this.normalized&&(t=ut(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=ut(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=ut(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=ut(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Ji(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Ji(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Ji(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Ji(t,this.array)),t}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.normalized&&(t=ut(t,this.array),n=ut(n,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=ut(t,this.array),n=ut(n,this.array),i=ut(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,o){return e=e*this.data.stride+this.offset,this.normalized&&(t=ut(t,this.array),n=ut(n,this.array),i=ut(i,this.array),o=ut(o,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=o,this}clone(e){if(e===void 0){console.log("v3d.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let o=0;o<this.itemSize;o++)t.push(this.data.array[i+o])}return new Te(new this.array.constructor(t),this.itemSize,this.normalized)}return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new io(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("v3d.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let o=0;o<this.itemSize;o++)t.push(this.data.array[i+o])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class tu extends Ut{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new me(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let Or;const Oa=new b,Fr=new b,Ur=new b,zr=new te,Fa=new te,Zg=new Ae,Al=new b,Ua=new b,xl=new b,Xf=new te,Yu=new te,Yf=new te;class jh extends ze{constructor(e){if(super(),this.isSprite=!0,this.type="Sprite",Or===void 0){Or=new Pe;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new Ma(t,5);Or.setIndex([0,1,2,0,2,3]),Or.setAttribute("position",new io(n,3,0,!1)),Or.setAttribute("uv",new io(n,2,3,!1))}this.geometry=Or,this.material=e!==void 0?e:new tu,this.center=new te(.5,.5)}raycast(e,t){e.camera===null&&console.error('v3d.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Fr.setFromMatrixScale(this.matrixWorld),Zg.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Ur.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Fr.multiplyScalar(-Ur.z);const n=this.material.rotation;let i,o;n!==0&&(o=Math.cos(n),i=Math.sin(n));const r=this.center;yl(Al.set(-.5,-.5,0),Ur,r,Fr,i,o),yl(Ua.set(.5,-.5,0),Ur,r,Fr,i,o),yl(xl.set(.5,.5,0),Ur,r,Fr,i,o),Xf.set(0,0),Yu.set(1,0),Yf.set(1,1);let s=e.ray.intersectTriangle(Al,Ua,xl,!1,Oa);if(s===null&&(yl(Ua.set(-.5,.5,0),Ur,r,Fr,i,o),Yu.set(0,1),s=e.ray.intersectTriangle(Al,xl,Ua,!1,Oa),s===null))return;const l=e.ray.origin.distanceTo(Oa);l<e.near||l>e.far||t.push({distance:l,point:Oa.clone(),uv:gn.getUV(Oa,Al,Ua,xl,Xf,Yu,Yf,new te),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function yl(a,e,t,n,i,o){zr.subVectors(a,t).addScalar(.5).multiply(n),i!==void 0?(Fa.x=o*zr.x-i*zr.y,Fa.y=i*zr.x+o*zr.y):Fa.copy(zr),a.copy(e),a.x+=Fa.x,a.y+=Fa.y,a.applyMatrix4(Zg)}const bl=new b,jf=new b;class Jg extends ze{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let n=0,i=t.length;n<i;n++){const o=t[n];this.addLevel(o.object.clone(),o.distance,o.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,n=0){t=Math.abs(t);const i=this.levels;let o;for(o=0;o<i.length&&!(t<i[o].distance);o++);return i.splice(o,0,{distance:t,hysteresis:n,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i;n++){let o=t[n].distance;if(t[n].object.visible&&(o-=o*t[n].hysteresis),e<o)break}return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){bl.setFromMatrixPosition(this.matrixWorld);const n=e.ray.origin.distanceTo(bl);this.getObjectForDistance(n).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){bl.setFromMatrixPosition(e.matrixWorld),jf.setFromMatrixPosition(this.matrixWorld);const n=bl.distanceTo(jf)/e.zoom;let i,o;for(t[0].object.visible=!0,i=1,o=t.length;i<o;i++){let r=t[i].distance;if(t[i].object.visible&&(r-=r*t[i].hysteresis),!(n>=r))break;t[i-1].object.visible=!1,t[i].object.visible=!0}for(this._currentLevel=i-1;i<o;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let i=0,o=n.length;i<o;i++){const r=n[i];t.object.levels.push({object:r.object.uuid,distance:r.distance,hysteresis:r.hysteresis})}return t}}const Kf=new b,qf=new Re,Zf=new Re,Lw=new b,Jf=new Ae;class xs extends Ue{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Ae,this.bindMatrixInverse=new Ae,this.normalizeSkinWeights()}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Re,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.fromBufferAttribute(t,n);const o=1/e.manhattanLength();o!==1/0?e.multiplyScalar(o):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("v3d.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,i=this.geometry;qf.fromBufferAttribute(i.attributes.skinIndex,e),Zf.fromBufferAttribute(i.attributes.skinWeight,e),Kf.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let o=0;o<4;o++){const r=Zf.getComponent(o);if(r!==0){const s=qf.getComponent(o);Jf.multiplyMatrices(n.bones[s].matrixWorld,n.boneInverses[s]),t.addScaledVector(Lw.copy(Kf).applyMatrix4(Jf),r)}}return t.applyMatrix4(this.bindMatrixInverse)}}class nu extends ze{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Jn extends yt{constructor(e=null,t=1,n=1,i,o,r,s,l,c=st,d=st,u,h){super(null,r,s,l,c,d,i,o,u,h),this.isDataTexture=!0,this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const $f=new Ae,Pw=new Ae;class zs{constructor(e=[],t=[]){this.uuid=wn(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("v3d.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new Ae)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new Ae;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let o=0,r=e.length;o<r;o++){const s=e[o]?e[o].matrixWorld:Pw;$f.multiplyMatrices(s,t[o]),$f.toArray(n,16*o)}i!==null&&(i.needsUpdate=!0)}clone(){return new zs(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(4*this.bones.length);e=Lg(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new Jn(t,e,e,Qe,Ct);return n.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=n,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const o=e.bones[n];let r=t[o];r===void 0&&(console.warn("v3d.Skeleton: No bone found with UUID:",o),r=new nu),this.bones.push(r),this.boneInverses.push(new Ae().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,o=t.length;i<o;i++){const r=t[i];e.bones.push(r.uuid);const s=n[i];e.boneInverses.push(s.toArray())}return e}}let pa=class extends Te{constructor(a,e,t,n=1){super(a,e,t),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(a){return super.copy(a),this.meshPerAttribute=a.meshPerAttribute,this}toJSON(){const a=super.toJSON();return a.meshPerAttribute=this.meshPerAttribute,a.isInstancedBufferAttribute=!0,a}};const em=new Ae,tm=new Ae,Cl=[],Bw=new Ae,za=new Ue;let $g=class extends Ue{constructor(a,e,t){super(a,e),this.isInstancedMesh=!0,this.instanceMatrix=new pa(new Float32Array(16*t),16),this.instanceColor=null,this.count=t,this.frustumCulled=!1;for(let n=0;n<t;n++)this.setMatrixAt(n,Bw)}copy(a,e){return super.copy(a,e),this.instanceMatrix.copy(a.instanceMatrix),a.instanceColor!==null&&(this.instanceColor=a.instanceColor.clone()),this.count=a.count,this}getColorAt(a,e){e.fromArray(this.instanceColor.array,3*a)}getMatrixAt(a,e){e.fromArray(this.instanceMatrix.array,16*a)}raycast(a,e){const t=this.matrixWorld,n=this.count;if(za.geometry=this.geometry,za.material=this.material,za.material!==void 0)for(let i=0;i<n;i++){this.getMatrixAt(i,em),tm.multiplyMatrices(t,em),za.matrixWorld=tm,za.raycast(a,Cl);for(let o=0,r=Cl.length;o<r;o++){const s=Cl[o];s.instanceId=i,s.object=this,e.push(s)}Cl.length=0}}setColorAt(a,e){this.instanceColor===null&&(this.instanceColor=new pa(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*a)}setMatrixAt(a,e){e.toArray(this.instanceMatrix.array,16*a)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}},un=class extends Ut{constructor(a){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new me(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(a)}copy(a){return super.copy(a),this.color.copy(a.color),this.linewidth=a.linewidth,this.linecap=a.linecap,this.linejoin=a.linejoin,this.fog=a.fog,this}};const nm=new b,im=new b,om=new Ae,ju=new ya,Sl=new Rn;class Pi extends ze{constructor(e=new Pe,t=new un){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,o=t.count;i<o;i++)nm.fromBufferAttribute(t,i-1),im.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=nm.distanceTo(im);e.setAttribute("lineDistance",new Ie(n,1))}else console.warn("v3d.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,o=e.params.Line.threshold,r=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Sl.copy(n.boundingSphere),Sl.applyMatrix4(i),Sl.radius+=o,e.ray.intersectsSphere(Sl)===!1)return;om.copy(i).invert(),ju.copy(e.ray).applyMatrix4(om);const s=o/((this.scale.x+this.scale.y+this.scale.z)/3),l=s*s,c=new b,d=new b,u=new b,h=new b,p=this.isLineSegments?2:1,m=n.index,f=n.attributes.position;if(m!==null)for(let g=Math.max(0,r.start),_=Math.min(m.count,r.start+r.count)-1;g<_;g+=p){const A=m.getX(g),x=m.getX(g+1);if(c.fromBufferAttribute(f,A),d.fromBufferAttribute(f,x),ju.distanceSqToSegment(c,d,h,u)>l)continue;h.applyMatrix4(this.matrixWorld);const S=e.ray.origin.distanceTo(h);S<e.near||S>e.far||t.push({distance:S,point:u.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this})}else for(let g=Math.max(0,r.start),_=Math.min(f.count,r.start+r.count)-1;g<_;g+=p){if(c.fromBufferAttribute(f,g),d.fromBufferAttribute(f,g+1),ju.distanceSqToSegment(c,d,h,u)>l)continue;h.applyMatrix4(this.matrixWorld);const A=e.ray.origin.distanceTo(h);A<e.near||A>e.far||t.push({distance:A,point:u.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this})}}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=n.length;i<o;i++){const r=n[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=i}}}}}const rm=new b,am=new b;class Wn extends Pi{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,o=t.count;i<o;i+=2)rm.fromBufferAttribute(t,i),am.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+rm.distanceTo(am);e.setAttribute("lineDistance",new Ie(n,1))}else console.warn("v3d.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Kh extends Pi{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}let qh=class extends Ut{constructor(a){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new me(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(a)}copy(a){return super.copy(a),this.color.copy(a.color),this.map=a.map,this.alphaMap=a.alphaMap,this.size=a.size,this.sizeAttenuation=a.sizeAttenuation,this.fog=a.fog,this}};const sm=new Ae,ch=new ya,Ml=new Rn,El=new b;class Zh extends ze{constructor(e=new Pe,t=new qh){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,o=e.params.Points.threshold,r=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Ml.copy(n.boundingSphere),Ml.applyMatrix4(i),Ml.radius+=o,e.ray.intersectsSphere(Ml)===!1)return;sm.copy(i).invert(),ch.copy(e.ray).applyMatrix4(sm);const s=o/((this.scale.x+this.scale.y+this.scale.z)/3),l=s*s,c=n.index,d=n.attributes.position;if(c!==null)for(let u=Math.max(0,r.start),h=Math.min(c.count,r.start+r.count);u<h;u++){const p=c.getX(u);El.fromBufferAttribute(d,p),lm(El,p,l,i,e,t,this)}else for(let u=Math.max(0,r.start),h=Math.min(d.count,r.start+r.count);u<h;u++)El.fromBufferAttribute(d,u),lm(El,u,l,i,e,t,this)}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=n.length;i<o;i++){const r=n[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=i}}}}}function lm(a,e,t,n,i,o,r){const s=ch.distanceSqToPoint(a);if(s<t){const l=new b;ch.closestPointToPoint(a,l),l.applyMatrix4(n);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;o.push({distance:c,distanceToRay:Math.sqrt(s),point:l,index:e,face:null,object:r})}}class Dw extends yt{constructor(e,t,n,i,o,r,s,l,c){super(e,t,n,i,o,r,s,l,c),this.isVideoTexture=!0,this.minFilter=r!==void 0?r:Le,this.magFilter=o!==void 0?o:Le,this.generateMipmaps=!1;const d=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(function u(){d.needsUpdate=!0,e.requestVideoFrameCallback(u)})}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;!("requestVideoFrameCallback"in e)&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class Nw extends yt{constructor(e,t,n){super({width:e,height:t}),this.isFramebufferTexture=!0,this.format=n,this.magFilter=st,this.minFilter=st,this.generateMipmaps=!1,this.needsUpdate=!0}}class ys extends yt{constructor(e,t,n,i,o,r,s,l,c,d,u,h){super(null,r,s,l,c,d,i,o,u,h),this.isCompressedTexture=!0,this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class Ow extends ys{constructor(e,t,n,i,o,r){super(e,t,n,o,r),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=mt}}class Fw extends yt{constructor(e,t,n,i,o,r,s,l,c){super(e,t,n,i,o,r,s,l,c),this.isCanvasTexture=!0,this.needsUpdate=!0}}class mi{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("v3d.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),o=0;t.push(0);for(let r=1;r<=e;r++)n=this.getPoint(r/e),o+=n.distanceTo(i),t.push(o),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let i=0;const o=n.length;let r;r=t||e*n[o-1];let s,l=0,c=o-1;for(;l<=c;)if(i=Math.floor(l+(c-l)/2),s=n[i]-r,s<0)l=i+1;else{if(!(s>0)){c=i;break}c=i-1}if(i=c,n[i]===r)return i/(o-1);const d=n[i];return(i+(r-d)/(n[i+1]-d))/(o-1)}getTangent(e,t){let i=e-1e-4,o=e+1e-4;i<0&&(i=0),o>1&&(o=1);const r=this.getPoint(i),s=this.getPoint(o),l=t||(r.isVector2?new te:new b);return l.copy(s).sub(r).normalize(),l}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new b,i=[],o=[],r=[],s=new b,l=new Ae;for(let p=0;p<=e;p++){const m=p/e;i[p]=this.getTangentAt(m,new b)}o[0]=new b,r[0]=new b;let c=Number.MAX_VALUE;const d=Math.abs(i[0].x),u=Math.abs(i[0].y),h=Math.abs(i[0].z);d<=c&&(c=d,n.set(1,0,0)),u<=c&&(c=u,n.set(0,1,0)),h<=c&&n.set(0,0,1),s.crossVectors(i[0],n).normalize(),o[0].crossVectors(i[0],s),r[0].crossVectors(i[0],o[0]);for(let p=1;p<=e;p++){if(o[p]=o[p-1].clone(),r[p]=r[p-1].clone(),s.crossVectors(i[p-1],i[p]),s.length()>Number.EPSILON){s.normalize();const m=Math.acos(Ye(i[p-1].dot(i[p]),-1,1));o[p].applyMatrix4(l.makeRotationAxis(s,m))}r[p].crossVectors(i[p],o[p])}if(t===!0){let p=Math.acos(Ye(o[0].dot(o[e]),-1,1));p/=e,i[0].dot(s.crossVectors(o[0],o[e]))>0&&(p=-p);for(let m=1;m<=e;m++)o[m].applyMatrix4(l.makeRotationAxis(i[m],p*m)),r[m].crossVectors(i[m],o[m])}return{tangents:i,normals:o,binormals:r}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class iu extends mi{constructor(e=0,t=0,n=1,i=1,o=0,r=2*Math.PI,s=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=o,this.aEndAngle=r,this.aClockwise=s,this.aRotation=l}getPoint(e,t){const n=t||new te,i=2*Math.PI;let o=this.aEndAngle-this.aStartAngle;const r=Math.abs(o)<Number.EPSILON;for(;o<0;)o+=i;for(;o>i;)o-=i;o<Number.EPSILON&&(o=r?0:i),this.aClockwise!==!0||r||(o===i?o=-i:o-=i);const s=this.aStartAngle+e*o;let l=this.aX+this.xRadius*Math.cos(s),c=this.aY+this.yRadius*Math.sin(s);if(this.aRotation!==0){const d=Math.cos(this.aRotation),u=Math.sin(this.aRotation),h=l-this.aX,p=c-this.aY;l=h*d-p*u+this.aX,c=h*u+p*d+this.aY}return n.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class e1 extends iu{constructor(e,t,n,i,o,r){super(e,t,n,n,i,o,r),this.isArcCurve=!0,this.type="ArcCurve"}}function Jh(){let a=0,e=0,t=0,n=0;function i(o,r,s,l){a=o,e=s,t=-3*o+3*r-2*s-l,n=2*o-2*r+s+l}return{initCatmullRom:function(o,r,s,l,c){i(r,s,c*(s-o),c*(l-r))},initNonuniformCatmullRom:function(o,r,s,l,c,d,u){let h=(r-o)/c-(s-o)/(c+d)+(s-r)/d,p=(s-r)/d-(l-r)/(d+u)+(l-s)/u;h*=d,p*=d,i(r,s,h,p)},calc:function(o){const r=o*o;return a+e*o+t*r+n*(r*o)}}}const wl=new b,Ku=new Jh,qu=new Jh,Zu=new Jh;class t1 extends mi{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new b){const n=t,i=this.points,o=i.length,r=(o-(this.closed?0:1))*e;let s,l,c=Math.floor(r),d=r-c;this.closed?c+=c>0?0:(Math.floor(Math.abs(c)/o)+1)*o:d===0&&c===o-1&&(c=o-2,d=1),this.closed||c>0?s=i[(c-1)%o]:(wl.subVectors(i[0],i[1]).add(i[0]),s=wl);const u=i[c%o],h=i[(c+1)%o];if(this.closed||c+2<o?l=i[(c+2)%o]:(wl.subVectors(i[o-1],i[o-2]).add(i[o-1]),l=wl),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let m=Math.pow(s.distanceToSquared(u),p),f=Math.pow(u.distanceToSquared(h),p),g=Math.pow(h.distanceToSquared(l),p);f<1e-4&&(f=1),m<1e-4&&(m=f),g<1e-4&&(g=f),Ku.initNonuniformCatmullRom(s.x,u.x,h.x,l.x,m,f,g),qu.initNonuniformCatmullRom(s.y,u.y,h.y,l.y,m,f,g),Zu.initNonuniformCatmullRom(s.z,u.z,h.z,l.z,m,f,g)}else this.curveType==="catmullrom"&&(Ku.initCatmullRom(s.x,u.x,h.x,l.x,this.tension),qu.initCatmullRom(s.y,u.y,h.y,l.y,this.tension),Zu.initCatmullRom(s.z,u.z,h.z,l.z,this.tension));return n.set(Ku.calc(d),qu.calc(d),Zu.calc(d)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new b().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function cm(a,e,t,n,i){const o=.5*(n-e),r=.5*(i-t),s=a*a;return(2*t-2*n+o+r)*(a*s)+(-3*t+3*n-2*o-r)*s+o*a+t}function Uw(a,e){const t=1-a;return t*t*e}function zw(a,e){return 2*(1-a)*a*e}function Vw(a,e){return a*a*e}function Ja(a,e,t,n){return Uw(a,e)+zw(a,t)+Vw(a,n)}function Gw(a,e){const t=1-a;return t*t*t*e}function kw(a,e){const t=1-a;return 3*t*t*a*e}function Qw(a,e){return 3*(1-a)*a*a*e}function Ww(a,e){return a*a*a*e}function $a(a,e,t,n,i){return Gw(a,e)+kw(a,t)+Qw(a,n)+Ww(a,i)}class $h extends mi{constructor(e=new te,t=new te,n=new te,i=new te){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new te){const n=t,i=this.v0,o=this.v1,r=this.v2,s=this.v3;return n.set($a(e,i.x,o.x,r.x,s.x),$a(e,i.y,o.y,r.y,s.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class n1 extends mi{constructor(e=new b,t=new b,n=new b,i=new b){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new b){const n=t,i=this.v0,o=this.v1,r=this.v2,s=this.v3;return n.set($a(e,i.x,o.x,r.x,s.x),$a(e,i.y,o.y,r.y,s.y),$a(e,i.z,o.z,r.z,s.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class ou extends mi{constructor(e=new te,t=new te){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new te){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new te;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class i1 extends mi{constructor(e=new b,t=new b){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new b){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class ep extends mi{constructor(e=new te,t=new te,n=new te){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new te){const n=t,i=this.v0,o=this.v1,r=this.v2;return n.set(Ja(e,i.x,o.x,r.x),Ja(e,i.y,o.y,r.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class tp extends mi{constructor(e=new b,t=new b,n=new b){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new b){const n=t,i=this.v0,o=this.v1,r=this.v2;return n.set(Ja(e,i.x,o.x,r.x),Ja(e,i.y,o.y,r.y),Ja(e,i.z,o.z,r.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class np extends mi{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new te){const n=t,i=this.points,o=(i.length-1)*e,r=Math.floor(o),s=o-r,l=i[r===0?r:r-1],c=i[r],d=i[r>i.length-2?i.length-1:r+1],u=i[r>i.length-3?i.length-1:r+2];return n.set(cm(s,l.x,c.x,d.x,u.x),cm(s,l.y,c.y,d.y,u.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new te().fromArray(i))}return this}}var ip=Object.freeze({__proto__:null,ArcCurve:e1,CatmullRomCurve3:t1,CubicBezierCurve:$h,CubicBezierCurve3:n1,EllipseCurve:iu,LineCurve:ou,LineCurve3:i1,QuadraticBezierCurve:ep,QuadraticBezierCurve3:tp,SplineCurve:np});class o1 extends mi{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new ou(t,e))}getPoint(e,t){const n=e*this.getLength(),i=this.getCurveLengths();let o=0;for(;o<i.length;){if(i[o]>=n){const r=i[o]-n,s=this.curves[o],l=s.getLength(),c=l===0?0:1-r/l;return s.getPointAt(c,t)}o++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let i=0,o=this.curves;i<o.length;i++){const r=o[i],s=r.isEllipseCurve?2*e:r.isLineCurve||r.isLineCurve3?1:r.isSplineCurve?e*r.points.length:e,l=r.getPoints(s);for(let c=0;c<l.length;c++){const d=l[c];n&&n.equals(d)||(t.push(d),n=d)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new ip[i.type]().fromJSON(i))}return this}}class bs extends o1{constructor(e){super(),this.type="Path",this.currentPoint=new te,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new ou(this.currentPoint.clone(),new te(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){const o=new ep(this.currentPoint.clone(),new te(e,t),new te(n,i));return this.curves.push(o),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,o,r){const s=new $h(this.currentPoint.clone(),new te(e,t),new te(n,i),new te(o,r));return this.curves.push(s),this.currentPoint.set(o,r),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new np(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,o,r){const s=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+s,t+l,n,i,o,r),this}absarc(e,t,n,i,o,r){return this.absellipse(e,t,n,n,i,o,r),this}ellipse(e,t,n,i,o,r,s,l){const c=this.currentPoint.x,d=this.currentPoint.y;return this.absellipse(e+c,t+d,n,i,o,r,s,l),this}absellipse(e,t,n,i,o,r,s,l){const c=new iu(e,t,n,i,o,r,s,l);if(this.curves.length>0){const u=c.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(c);const d=c.getPoint(1);return this.currentPoint.copy(d),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Ea extends Pe{constructor(e=[new te(0,-.5),new te(.5,0),new te(0,.5)],t=12,n=0,i=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:i},t=Math.floor(t),i=Ye(i,0,2*Math.PI);const o=[],r=[],s=[],l=[],c=[],d=1/t,u=new b,h=new te,p=new b,m=new b,f=new b;let g=0,_=0;for(let A=0;A<=e.length-1;A++)switch(A){case 0:g=e[A+1].x-e[A].x,_=e[A+1].y-e[A].y,p.x=1*_,p.y=-g,p.z=0*_,f.copy(p),p.normalize(),l.push(p.x,p.y,p.z);break;case e.length-1:l.push(f.x,f.y,f.z);break;default:g=e[A+1].x-e[A].x,_=e[A+1].y-e[A].y,p.x=1*_,p.y=-g,p.z=0*_,m.copy(p),p.x+=f.x,p.y+=f.y,p.z+=f.z,p.normalize(),l.push(p.x,p.y,p.z),f.copy(m)}for(let A=0;A<=t;A++){const x=n+A*d*i,S=Math.sin(x),M=Math.cos(x);for(let T=0;T<=e.length-1;T++){u.x=e[T].x*S,u.y=e[T].y,u.z=e[T].x*M,r.push(u.x,u.y,u.z),h.x=A/t,h.y=T/(e.length-1),s.push(h.x,h.y);const L=l[3*T+0]*S,z=l[3*T+1],W=l[3*T+0]*M;c.push(L,z,W)}}for(let A=0;A<t;A++)for(let x=0;x<e.length-1;x++){const S=x+A*e.length,M=S,T=S+e.length,L=S+e.length+1,z=S+1;o.push(M,T,z),o.push(L,z,T)}this.setIndex(o),this.setAttribute("position",new Ie(r,3)),this.setAttribute("uv",new Ie(s,2)),this.setAttribute("normal",new Ie(c,3))}static fromJSON(e){return new Ea(e.points,e.segments,e.phiStart,e.phiLength)}}class Vs extends Ea{constructor(e=1,t=1,n=4,i=8){const o=new bs;o.absarc(0,-t/2,e,1.5*Math.PI,0),o.absarc(0,t/2,e,0,.5*Math.PI),super(o.getPoints(n),i),this.type="CapsuleGeometry",this.parameters={radius:e,height:t,capSegments:n,radialSegments:i}}static fromJSON(e){return new Vs(e.radius,e.length,e.capSegments,e.radialSegments)}}class Gs extends Pe{constructor(e=1,t=32,n=0,i=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:i},t=Math.max(3,t);const o=[],r=[],s=[],l=[],c=new b,d=new te;r.push(0,0,0),s.push(0,0,1),l.push(.5,.5);for(let u=0,h=3;u<=t;u++,h+=3){const p=n+u/t*i;c.x=e*Math.cos(p),c.y=e*Math.sin(p),r.push(c.x,c.y,c.z),s.push(0,0,1),d.x=(r[h]/e+1)/2,d.y=(r[h+1]/e+1)/2,l.push(d.x,d.y)}for(let u=1;u<=t;u++)o.push(u,u+1,0);this.setIndex(o),this.setAttribute("position",new Ie(r,3)),this.setAttribute("normal",new Ie(s,3)),this.setAttribute("uv",new Ie(l,2))}static fromJSON(e){return new Gs(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class yr extends Pe{constructor(e=1,t=1,n=1,i=32,o=1,r=!1,s=0,l=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:i,heightSegments:o,openEnded:r,thetaStart:s,thetaLength:l};const c=this;i=Math.floor(i),o=Math.floor(o);const d=[],u=[],h=[],p=[];let m=0;const f=[],g=n/2;let _=0;function A(x){const S=m,M=new te,T=new b;let L=0;const z=x===!0?e:t,W=x===!0?1:-1;for(let N=1;N<=i;N++)u.push(0,g*W,0),h.push(0,W,0),p.push(.5,.5),m++;const V=m;for(let N=0;N<=i;N++){const j=N/i*l+s,oe=Math.cos(j),H=Math.sin(j);T.x=z*H,T.y=g*W,T.z=z*oe,u.push(T.x,T.y,T.z),h.push(0,W,0),M.x=.5*oe+.5,M.y=.5*H*W+.5,p.push(M.x,M.y),m++}for(let N=0;N<i;N++){const j=S+N,oe=V+N;x===!0?d.push(oe,oe+1,j):d.push(oe+1,oe,j),L+=3}c.addGroup(_,L,x===!0?1:2),_+=L}(function(){const x=new b,S=new b;let M=0;const T=(t-e)/n;for(let L=0;L<=o;L++){const z=[],W=L/o,V=W*(t-e)+e;for(let N=0;N<=i;N++){const j=N/i,oe=j*l+s,H=Math.sin(oe),ne=Math.cos(oe);S.x=V*H,S.y=-W*n+g,S.z=V*ne,u.push(S.x,S.y,S.z),x.set(H,T,ne).normalize(),h.push(x.x,x.y,x.z),p.push(j,1-W),z.push(m++)}f.push(z)}for(let L=0;L<i;L++)for(let z=0;z<o;z++){const W=f[z][L],V=f[z+1][L],N=f[z+1][L+1],j=f[z][L+1];d.push(W,V,j),d.push(V,N,j),M+=6}c.addGroup(_,M,0),_+=M})(),r===!1&&(e>0&&A(!0),t>0&&A(!1)),this.setIndex(d),this.setAttribute("position",new Ie(u,3)),this.setAttribute("normal",new Ie(h,3)),this.setAttribute("uv",new Ie(p,2))}static fromJSON(e){return new yr(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class ks extends yr{constructor(e=1,t=1,n=32,i=1,o=!1,r=0,s=2*Math.PI){super(0,e,t,n,i,o,r,s),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:i,openEnded:o,thetaStart:r,thetaLength:s}}static fromJSON(e){return new ks(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class so extends Pe{constructor(e=[],t=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:i};const o=[],r=[];function s(h,p,m,f){const g=f+1,_=[];for(let A=0;A<=g;A++){_[A]=[];const x=h.clone().lerp(m,A/g),S=p.clone().lerp(m,A/g),M=g-A;for(let T=0;T<=M;T++)_[A][T]=T===0&&A===g?x:x.clone().lerp(S,T/M)}for(let A=0;A<g;A++)for(let x=0;x<2*(g-A)-1;x++){const S=Math.floor(x/2);x%2==0?(l(_[A][S+1]),l(_[A+1][S]),l(_[A][S])):(l(_[A][S+1]),l(_[A+1][S+1]),l(_[A+1][S]))}}function l(h){o.push(h.x,h.y,h.z)}function c(h,p){const m=3*h;p.x=e[m+0],p.y=e[m+1],p.z=e[m+2]}function d(h,p,m,f){f<0&&h.x===1&&(r[p]=h.x-1),m.x===0&&m.z===0&&(r[p]=f/2/Math.PI+.5)}function u(h){return Math.atan2(h.z,-h.x)}(function(h){const p=new b,m=new b,f=new b;for(let g=0;g<t.length;g+=3)c(t[g+0],p),c(t[g+1],m),c(t[g+2],f),s(p,m,f,h)})(i),function(h){const p=new b;for(let m=0;m<o.length;m+=3)p.x=o[m+0],p.y=o[m+1],p.z=o[m+2],p.normalize().multiplyScalar(h),o[m+0]=p.x,o[m+1]=p.y,o[m+2]=p.z}(n),function(){const h=new b;for(let m=0;m<o.length;m+=3){h.x=o[m+0],h.y=o[m+1],h.z=o[m+2];const f=u(h)/2/Math.PI+.5,g=(p=h,Math.atan2(-p.y,Math.sqrt(p.x*p.x+p.z*p.z))/Math.PI+.5);r.push(f,1-g)}var p;(function(){const m=new b,f=new b,g=new b,_=new b,A=new te,x=new te,S=new te;for(let M=0,T=0;M<o.length;M+=9,T+=6){m.set(o[M+0],o[M+1],o[M+2]),f.set(o[M+3],o[M+4],o[M+5]),g.set(o[M+6],o[M+7],o[M+8]),A.set(r[T+0],r[T+1]),x.set(r[T+2],r[T+3]),S.set(r[T+4],r[T+5]),_.copy(m).add(f).add(g).divideScalar(3);const L=u(_);d(A,T+0,m,L),d(x,T+2,f,L),d(S,T+4,g,L)}})(),function(){for(let m=0;m<r.length;m+=6){const f=r[m+0],g=r[m+2],_=r[m+4],A=Math.max(f,g,_),x=Math.min(f,g,_);A>.9&&x<.1&&(f<.2&&(r[m+0]+=1),g<.2&&(r[m+2]+=1),_<.2&&(r[m+4]+=1))}}()}(),this.setAttribute("position",new Ie(o,3)),this.setAttribute("normal",new Ie(o.slice(),3)),this.setAttribute("uv",new Ie(r,2)),i===0?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(e){return new so(e.vertices,e.indices,e.radius,e.details)}}class Qs extends so{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Qs(e.radius,e.detail)}}const Tl=new b,Il=new b,Ju=new b,Rl=new gn;class r1 extends Pe{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const i=Math.pow(10,4),o=Math.cos(eo*t),r=e.getIndex(),s=e.getAttribute("position"),l=r?r.count:s.count,c=[0,0,0],d=["a","b","c"],u=new Array(3),h={},p=[];for(let m=0;m<l;m+=3){r?(c[0]=r.getX(m),c[1]=r.getX(m+1),c[2]=r.getX(m+2)):(c[0]=m,c[1]=m+1,c[2]=m+2);const{a:f,b:g,c:_}=Rl;if(f.fromBufferAttribute(s,c[0]),g.fromBufferAttribute(s,c[1]),_.fromBufferAttribute(s,c[2]),Rl.getNormal(Ju),u[0]=`${Math.round(f.x*i)},${Math.round(f.y*i)},${Math.round(f.z*i)}`,u[1]=`${Math.round(g.x*i)},${Math.round(g.y*i)},${Math.round(g.z*i)}`,u[2]=`${Math.round(_.x*i)},${Math.round(_.y*i)},${Math.round(_.z*i)}`,u[0]!==u[1]&&u[1]!==u[2]&&u[2]!==u[0])for(let A=0;A<3;A++){const x=(A+1)%3,S=u[A],M=u[x],T=Rl[d[A]],L=Rl[d[x]],z=`${S}_${M}`,W=`${M}_${S}`;W in h&&h[W]?(Ju.dot(h[W].normal)<=o&&(p.push(T.x,T.y,T.z),p.push(L.x,L.y,L.z)),h[W]=null):z in h||(h[z]={index0:c[A],index1:c[x],normal:Ju.clone()})}}for(const m in h)if(h[m]){const{index0:f,index1:g}=h[m];Tl.fromBufferAttribute(s,f),Il.fromBufferAttribute(s,g),p.push(Tl.x,Tl.y,Tl.z),p.push(Il.x,Il.y,Il.z)}this.setAttribute("position",new Ie(p,3))}}}class hr extends bs{constructor(e){super(e),this.uuid=wn(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new bs().fromJSON(i))}return this}}const Hw={triangulate:function(a,e,t=2){const n=e&&e.length,i=n?e[0]*t:a.length;let o=a1(a,0,i,t,!0);const r=[];if(!o||o.next===o.prev)return r;let s,l,c,d,u,h,p;if(n&&(o=qw(a,e,o,t)),a.length>80*t){s=c=a[0],l=d=a[1];for(let m=t;m<i;m+=t)u=a[m],h=a[m+1],u<s&&(s=u),h<l&&(l=h),u>c&&(c=u),h>d&&(d=h);p=Math.max(c-s,d-l),p=p!==0?32767/p:0}return Cs(o,r,t,s,l,p,0),r}};function a1(a,e,t,n,i){let o,r;if(i===sT(a,e,t,n)>0)for(o=e;o<t;o+=n)r=um(o,a[o],a[o+1],r);else for(o=t-n;o>=e;o-=n)r=um(o,a[o],a[o+1],r);return r&&ru(r,r.next)&&(Ms(r),r=r.next),r}function _r(a,e){if(!a)return a;e||(e=a);let t,n=a;do if(t=!1,n.steiner||!ru(n,n.next)&&Tt(n.prev,n,n.next)!==0)n=n.next;else{if(Ms(n),n=e=n.prev,n===n.next)break;t=!0}while(t||n!==e);return e}function Cs(a,e,t,n,i,o,r){if(!a)return;!r&&o&&tT(a,n,i,o);let s,l,c=a;for(;a.prev!==a.next;)if(s=a.prev,l=a.next,o?Yw(a,n,i,o):Xw(a))e.push(s.i/t|0),e.push(a.i/t|0),e.push(l.i/t|0),Ms(a),a=l.next,c=l.next;else if((a=l)===c){r?r===1?Cs(a=jw(_r(a),e,t),e,t,n,i,o,2):r===2&&Kw(a,e,t,n,i,o):Cs(_r(a),e,t,n,i,o,1);break}}function Xw(a){const e=a.prev,t=a,n=a.next;if(Tt(e,t,n)>=0)return!1;const i=e.x,o=t.x,r=n.x,s=e.y,l=t.y,c=n.y,d=i<o?i<r?i:r:o<r?o:r,u=s<l?s<c?s:c:l<c?l:c,h=i>o?i>r?i:r:o>r?o:r,p=s>l?s>c?s:c:l>c?l:c;let m=n.next;for(;m!==e;){if(m.x>=d&&m.x<=h&&m.y>=u&&m.y<=p&&Jr(i,s,o,l,r,c,m.x,m.y)&&Tt(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function Yw(a,e,t,n){const i=a.prev,o=a,r=a.next;if(Tt(i,o,r)>=0)return!1;const s=i.x,l=o.x,c=r.x,d=i.y,u=o.y,h=r.y,p=s<l?s<c?s:c:l<c?l:c,m=d<u?d<h?d:h:u<h?u:h,f=s>l?s>c?s:c:l>c?l:c,g=d>u?d>h?d:h:u>h?u:h,_=uh(p,m,e,t,n),A=uh(f,g,e,t,n);let x=a.prevZ,S=a.nextZ;for(;x&&x.z>=_&&S&&S.z<=A;){if(x.x>=p&&x.x<=f&&x.y>=m&&x.y<=g&&x!==i&&x!==r&&Jr(s,d,l,u,c,h,x.x,x.y)&&Tt(x.prev,x,x.next)>=0||(x=x.prevZ,S.x>=p&&S.x<=f&&S.y>=m&&S.y<=g&&S!==i&&S!==r&&Jr(s,d,l,u,c,h,S.x,S.y)&&Tt(S.prev,S,S.next)>=0))return!1;S=S.nextZ}for(;x&&x.z>=_;){if(x.x>=p&&x.x<=f&&x.y>=m&&x.y<=g&&x!==i&&x!==r&&Jr(s,d,l,u,c,h,x.x,x.y)&&Tt(x.prev,x,x.next)>=0)return!1;x=x.prevZ}for(;S&&S.z<=A;){if(S.x>=p&&S.x<=f&&S.y>=m&&S.y<=g&&S!==i&&S!==r&&Jr(s,d,l,u,c,h,S.x,S.y)&&Tt(S.prev,S,S.next)>=0)return!1;S=S.nextZ}return!0}function jw(a,e,t){let n=a;do{const i=n.prev,o=n.next.next;!ru(i,o)&&s1(i,n,n.next,o)&&Ss(i,o)&&Ss(o,i)&&(e.push(i.i/t|0),e.push(n.i/t|0),e.push(o.i/t|0),Ms(n),Ms(n.next),n=a=o),n=n.next}while(n!==a);return _r(n)}function Kw(a,e,t,n,i,o){let r=a;do{let s=r.next.next;for(;s!==r.prev;){if(r.i!==s.i&&oT(r,s)){let l=l1(r,s);return r=_r(r,r.next),l=_r(l,l.next),Cs(r,e,t,n,i,o,0),void Cs(l,e,t,n,i,o,0)}s=s.next}r=r.next}while(r!==a)}function qw(a,e,t,n){const i=[];let o,r,s,l,c;for(o=0,r=e.length;o<r;o++)s=e[o]*n,l=o<r-1?e[o+1]*n:a.length,c=a1(a,s,l,n,!1),c===c.next&&(c.steiner=!0),i.push(iT(c));for(i.sort(Zw),o=0;o<i.length;o++)t=Jw(i[o],t);return t}function Zw(a,e){return a.x-e.x}function Jw(a,e){const t=$w(a,e);if(!t)return e;const n=l1(t,a);return _r(n,n.next),_r(t,t.next)}function $w(a,e){let t,n=e,i=-1/0;const o=a.x,r=a.y;do{if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){const h=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(h<=o&&h>i&&(i=h,t=n.x<n.next.x?n:n.next,h===o))return t}n=n.next}while(n!==e);if(!t)return null;const s=t,l=t.x,c=t.y;let d,u=1/0;n=t;do o>=n.x&&n.x>=l&&o!==n.x&&Jr(r<c?o:i,r,l,c,r<c?i:o,r,n.x,n.y)&&(d=Math.abs(r-n.y)/(o-n.x),Ss(n,a)&&(d<u||d===u&&(n.x>t.x||n.x===t.x&&eT(t,n)))&&(t=n,u=d)),n=n.next;while(n!==s);return t}function eT(a,e){return Tt(a.prev,a,e.prev)<0&&Tt(e.next,a,a.next)<0}function tT(a,e,t,n){let i=a;do i.z===0&&(i.z=uh(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==a);i.prevZ.nextZ=null,i.prevZ=null,nT(i)}function nT(a){let e,t,n,i,o,r,s,l,c=1;do{for(t=a,a=null,o=null,r=0;t;){for(r++,n=t,s=0,e=0;e<c&&(s++,n=n.nextZ,n);e++);for(l=c;s>0||l>0&&n;)s!==0&&(l===0||!n||t.z<=n.z)?(i=t,t=t.nextZ,s--):(i=n,n=n.nextZ,l--),o?o.nextZ=i:a=i,i.prevZ=o,o=i;t=n}o.nextZ=null,c*=2}while(r>1);return a}function uh(a,e,t,n,i){return(a=1431655765&((a=858993459&((a=252645135&((a=16711935&((a=(a-t)*i|0)|a<<8))|a<<4))|a<<2))|a<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*i|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function iT(a){let e=a,t=a;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==a);return t}function Jr(a,e,t,n,i,o,r,s){return(i-r)*(e-s)>=(a-r)*(o-s)&&(a-r)*(n-s)>=(t-r)*(e-s)&&(t-r)*(o-s)>=(i-r)*(n-s)}function oT(a,e){return a.next.i!==e.i&&a.prev.i!==e.i&&!rT(a,e)&&(Ss(a,e)&&Ss(e,a)&&aT(a,e)&&(Tt(a.prev,a,e.prev)||Tt(a,e.prev,e))||ru(a,e)&&Tt(a.prev,a,a.next)>0&&Tt(e.prev,e,e.next)>0)}function Tt(a,e,t){return(e.y-a.y)*(t.x-e.x)-(e.x-a.x)*(t.y-e.y)}function ru(a,e){return a.x===e.x&&a.y===e.y}function s1(a,e,t,n){const i=Pl(Tt(a,e,t)),o=Pl(Tt(a,e,n)),r=Pl(Tt(t,n,a)),s=Pl(Tt(t,n,e));return i!==o&&r!==s||!(i!==0||!Ll(a,t,e))||!(o!==0||!Ll(a,n,e))||!(r!==0||!Ll(t,a,n))||!(s!==0||!Ll(t,e,n))}function Ll(a,e,t){return e.x<=Math.max(a.x,t.x)&&e.x>=Math.min(a.x,t.x)&&e.y<=Math.max(a.y,t.y)&&e.y>=Math.min(a.y,t.y)}function Pl(a){return a>0?1:a<0?-1:0}function rT(a,e){let t=a;do{if(t.i!==a.i&&t.next.i!==a.i&&t.i!==e.i&&t.next.i!==e.i&&s1(t,t.next,a,e))return!0;t=t.next}while(t!==a);return!1}function Ss(a,e){return Tt(a.prev,a,a.next)<0?Tt(a,e,a.next)>=0&&Tt(a,a.prev,e)>=0:Tt(a,e,a.prev)<0||Tt(a,a.next,e)<0}function aT(a,e){let t=a,n=!1;const i=(a.x+e.x)/2,o=(a.y+e.y)/2;do t.y>o!=t.next.y>o&&t.next.y!==t.y&&i<(t.next.x-t.x)*(o-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==a);return n}function l1(a,e){const t=new dh(a.i,a.x,a.y),n=new dh(e.i,e.x,e.y),i=a.next,o=e.prev;return a.next=e,e.prev=a,t.next=i,i.prev=t,n.next=t,t.prev=n,o.next=n,n.prev=o,n}function um(a,e,t,n){const i=new dh(a,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function Ms(a){a.next.prev=a.prev,a.prev.next=a.next,a.prevZ&&(a.prevZ.nextZ=a.nextZ),a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function dh(a,e,t){this.i=a,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function sT(a,e,t,n){let i=0;for(let o=e,r=t-n;o<t;o+=n)i+=(a[r]-a[o])*(a[o+1]+a[r+1]),r=o;return i}class Li{static area(e){const t=e.length;let n=0;for(let i=t-1,o=0;o<t;i=o++)n+=e[i].x*e[o].y-e[o].x*e[i].y;return .5*n}static isClockWise(e){return Li.area(e)<0}static triangulateShape(e,t){const n=[],i=[],o=[];dm(e),hm(n,e);let r=e.length;t.forEach(dm);for(let l=0;l<t.length;l++)i.push(r),r+=t[l].length,hm(n,t[l]);const s=Hw.triangulate(n,i);for(let l=0;l<s.length;l+=3)o.push(s.slice(l,l+3));return o}}function dm(a){const e=a.length;e>2&&a[e-1].equals(a[0])&&a.pop()}function hm(a,e){for(let t=0;t<e.length;t++)a.push(e[t].x),a.push(e[t].y)}class wa extends Pe{constructor(e=new hr([new te(.5,.5),new te(-.5,.5),new te(-.5,-.5),new te(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],o=[];for(let s=0,l=e.length;s<l;s++)r(e[s]);function r(s){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,d=t.steps!==void 0?t.steps:1,u=t.depth!==void 0?t.depth:1;let h=t.bevelEnabled===void 0||t.bevelEnabled,p=t.bevelThickness!==void 0?t.bevelThickness:.2,m=t.bevelSize!==void 0?t.bevelSize:p-.1,f=t.bevelOffset!==void 0?t.bevelOffset:0,g=t.bevelSegments!==void 0?t.bevelSegments:3;const _=t.extrudePath,A=t.UVGenerator!==void 0?t.UVGenerator:lT;let x,S,M,T,L,z=!1;_&&(x=_.getSpacedPoints(d),z=!0,h=!1,S=_.computeFrenetFrames(d,!1),M=new b,T=new b,L=new b),h||(g=0,p=0,m=0,f=0);const W=s.extractPoints(c);let V=W.shape;const N=W.holes;if(!Li.isClockWise(V)){V=V.reverse();for(let R=0,w=N.length;R<w;R++){const I=N[R];Li.isClockWise(I)&&(N[R]=I.reverse())}}const j=Li.triangulateShape(V,N),oe=V;for(let R=0,w=N.length;R<w;R++){const I=N[R];V=V.concat(I)}function H(R,w,I){return w||console.error("v3d.ExtrudeGeometry: vec does not exist"),w.clone().multiplyScalar(I).add(R)}const ne=V.length,le=j.length;function re(R,w,I){let C,D,O;const Y=R.x-w.x,J=R.y-w.y,G=I.x-R.x,K=I.y-R.y,ie=Y*Y+J*J,$=Y*K-J*G;if(Math.abs($)>Number.EPSILON){const se=Math.sqrt(ie),de=Math.sqrt(G*G+K*K),he=w.x-J/se,ee=w.y+Y/se,ge=((I.x-K/de-he)*K-(I.y+G/de-ee)*G)/(Y*K-J*G);C=he+Y*ge-R.x,D=ee+J*ge-R.y;const ve=C*C+D*D;if(ve<=2)return new te(C,D);O=Math.sqrt(ve/2)}else{let se=!1;Y>Number.EPSILON?G>Number.EPSILON&&(se=!0):Y<-Number.EPSILON?G<-Number.EPSILON&&(se=!0):Math.sign(J)===Math.sign(K)&&(se=!0),se?(C=-J,D=Y,O=Math.sqrt(ie)):(C=Y,D=J,O=Math.sqrt(ie/2))}return new te(C/O,D/O)}const ae=[];for(let R=0,w=oe.length,I=w-1,C=R+1;R<w;R++,I++,C++)I===w&&(I=0),C===w&&(C=0),ae[R]=re(oe[R],oe[I],oe[C]);const E=[];let F,U=ae.concat();for(let R=0,w=N.length;R<w;R++){const I=N[R];F=[];for(let C=0,D=I.length,O=D-1,Y=C+1;C<D;C++,O++,Y++)O===D&&(O=0),Y===D&&(Y=0),F[C]=re(I[C],I[O],I[Y]);E.push(F),U=U.concat(F)}for(let R=0;R<g;R++){const w=R/g,I=p*Math.cos(w*Math.PI/2),C=m*Math.sin(w*Math.PI/2)+f;for(let D=0,O=oe.length;D<O;D++){const Y=H(oe[D],ae[D],C);k(Y.x,Y.y,-I)}for(let D=0,O=N.length;D<O;D++){const Y=N[D];F=E[D];for(let J=0,G=Y.length;J<G;J++){const K=H(Y[J],F[J],C);k(K.x,K.y,-I)}}}const B=m+f;for(let R=0;R<ne;R++){const w=h?H(V[R],U[R],B):V[R];z?(T.copy(S.normals[0]).multiplyScalar(w.x),M.copy(S.binormals[0]).multiplyScalar(w.y),L.copy(x[0]).add(T).add(M),k(L.x,L.y,L.z)):k(w.x,w.y,0)}for(let R=1;R<=d;R++)for(let w=0;w<ne;w++){const I=h?H(V[w],U[w],B):V[w];z?(T.copy(S.normals[R]).multiplyScalar(I.x),M.copy(S.binormals[R]).multiplyScalar(I.y),L.copy(x[R]).add(T).add(M),k(L.x,L.y,L.z)):k(I.x,I.y,u/d*R)}for(let R=g-1;R>=0;R--){const w=R/g,I=p*Math.cos(w*Math.PI/2),C=m*Math.sin(w*Math.PI/2)+f;for(let D=0,O=oe.length;D<O;D++){const Y=H(oe[D],ae[D],C);k(Y.x,Y.y,u+I)}for(let D=0,O=N.length;D<O;D++){const Y=N[D];F=E[D];for(let J=0,G=Y.length;J<G;J++){const K=H(Y[J],F[J],C);z?k(K.x,K.y+x[d-1].y,x[d-1].x+I):k(K.x,K.y,u+I)}}}function Z(R,w){let I=R.length;for(;--I>=0;){const C=I;let D=I-1;D<0&&(D=R.length-1);for(let O=0,Y=d+2*g;O<Y;O++){const J=ne*O,G=ne*(O+1);P(w+C+J,w+D+J,w+D+G,w+C+G)}}}function k(R,w,I){l.push(R),l.push(w),l.push(I)}function X(R,w,I){v(R),v(w),v(I);const C=i.length/3,D=A.generateTopUV(n,i,C-3,C-2,C-1);y(D[0]),y(D[1]),y(D[2])}function P(R,w,I,C){v(R),v(w),v(C),v(w),v(I),v(C);const D=i.length/3,O=A.generateSideWallUV(n,i,D-6,D-3,D-2,D-1);y(O[0]),y(O[1]),y(O[3]),y(O[1]),y(O[2]),y(O[3])}function v(R){i.push(l[3*R+0]),i.push(l[3*R+1]),i.push(l[3*R+2])}function y(R){o.push(R.x),o.push(R.y)}(function(){const R=i.length/3;if(h){let w=0,I=ne*w;for(let C=0;C<le;C++){const D=j[C];X(D[2]+I,D[1]+I,D[0]+I)}w=d+2*g,I=ne*w;for(let C=0;C<le;C++){const D=j[C];X(D[0]+I,D[1]+I,D[2]+I)}}else{for(let w=0;w<le;w++){const I=j[w];X(I[2],I[1],I[0])}for(let w=0;w<le;w++){const I=j[w];X(I[0]+ne*d,I[1]+ne*d,I[2]+ne*d)}}n.addGroup(R,i.length/3-R,0)})(),function(){const R=i.length/3;let w=0;Z(oe,w),w+=oe.length;for(let I=0,C=N.length;I<C;I++){const D=N[I];Z(D,w),w+=D.length}n.addGroup(R,i.length/3-R,1)}()}this.setAttribute("position",new Ie(i,3)),this.setAttribute("uv",new Ie(o,2)),this.computeVertexNormals()}toJSON(){const e=super.toJSON();return cT(this.parameters.shapes,this.parameters.options,e)}static fromJSON(e,t){const n=[];for(let o=0,r=e.shapes.length;o<r;o++){const s=t[e.shapes[o]];n.push(s)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new ip[i.type]().fromJSON(i)),new wa(n,e.options)}}const lT={generateTopUV:function(a,e,t,n,i){const o=e[3*t],r=e[3*t+1],s=e[3*n],l=e[3*n+1],c=e[3*i],d=e[3*i+1];return[new te(o,r),new te(s,l),new te(c,d)]},generateSideWallUV:function(a,e,t,n,i,o){const r=e[3*t],s=e[3*t+1],l=e[3*t+2],c=e[3*n],d=e[3*n+1],u=e[3*n+2],h=e[3*i],p=e[3*i+1],m=e[3*i+2],f=e[3*o],g=e[3*o+1],_=e[3*o+2];return Math.abs(s-d)<Math.abs(r-c)?[new te(r,1-l),new te(c,1-u),new te(h,1-m),new te(f,1-_)]:[new te(s,1-l),new te(d,1-u),new te(p,1-m),new te(g,1-_)]}};function cT(a,e,t){if(t.shapes=[],Array.isArray(a))for(let n=0,i=a.length;n<i;n++){const o=a[n];t.shapes.push(o.uuid)}else t.shapes.push(a.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class Ws extends so{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Ws(e.radius,e.detail)}}class Ta extends so{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Ta(e.radius,e.detail)}}class Hs extends Pe{constructor(e=.5,t=1,n=32,i=1,o=0,r=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:i,thetaStart:o,thetaLength:r},n=Math.max(3,n);const s=[],l=[],c=[],d=[];let u=e;const h=(t-e)/(i=Math.max(1,i)),p=new b,m=new te;for(let f=0;f<=i;f++){for(let g=0;g<=n;g++){const _=o+g/n*r;p.x=u*Math.cos(_),p.y=u*Math.sin(_),l.push(p.x,p.y,p.z),c.push(0,0,1),m.x=(p.x/t+1)/2,m.y=(p.y/t+1)/2,d.push(m.x,m.y)}u+=h}for(let f=0;f<i;f++){const g=f*(n+1);for(let _=0;_<n;_++){const A=_+g,x=A,S=A+n+1,M=A+n+2,T=A+1;s.push(x,S,T),s.push(S,M,T)}}this.setIndex(s),this.setAttribute("position",new Ie(l,3)),this.setAttribute("normal",new Ie(c,3)),this.setAttribute("uv",new Ie(d,2))}static fromJSON(e){return new Hs(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class Xs extends Pe{constructor(e=new hr([new te(0,.5),new te(-.5,-.5),new te(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],i=[],o=[],r=[];let s=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let d=0;d<e.length;d++)c(e[d]),this.addGroup(s,l,d),s+=l,l=0;function c(d){const u=i.length/3,h=d.extractPoints(t);let p=h.shape;const m=h.holes;Li.isClockWise(p)===!1&&(p=p.reverse());for(let g=0,_=m.length;g<_;g++){const A=m[g];Li.isClockWise(A)===!0&&(m[g]=A.reverse())}const f=Li.triangulateShape(p,m);for(let g=0,_=m.length;g<_;g++){const A=m[g];p=p.concat(A)}for(let g=0,_=p.length;g<_;g++){const A=p[g];i.push(A.x,A.y,0),o.push(0,0,1),r.push(A.x,A.y)}for(let g=0,_=f.length;g<_;g++){const A=f[g],x=A[0]+u,S=A[1]+u,M=A[2]+u;n.push(x,S,M),l+=3}}this.setIndex(n),this.setAttribute("position",new Ie(i,3)),this.setAttribute("normal",new Ie(o,3)),this.setAttribute("uv",new Ie(r,2))}toJSON(){const e=super.toJSON();return uT(this.parameters.shapes,e)}static fromJSON(e,t){const n=[];for(let i=0,o=e.shapes.length;i<o;i++){const r=t[e.shapes[i]];n.push(r)}return new Xs(n,e.curveSegments)}}function uT(a,e){if(e.shapes=[],Array.isArray(a))for(let t=0,n=a.length;t<n;t++){const i=a[t];e.shapes.push(i.uuid)}else e.shapes.push(a.uuid);return e}class Ia extends Pe{constructor(e=1,t=32,n=16,i=0,o=2*Math.PI,r=0,s=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:i,phiLength:o,thetaStart:r,thetaLength:s},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const l=Math.min(r+s,Math.PI);let c=0;const d=[],u=new b,h=new b,p=[],m=[],f=[],g=[];for(let _=0;_<=n;_++){const A=[],x=_/n;let S=0;_==0&&r==0?S=.5/t:_==n&&l==Math.PI&&(S=-.5/t);for(let M=0;M<=t;M++){const T=M/t;u.x=-e*Math.cos(i+T*o)*Math.sin(r+x*s),u.y=e*Math.cos(r+x*s),u.z=e*Math.sin(i+T*o)*Math.sin(r+x*s),m.push(u.x,u.y,u.z),h.copy(u).normalize(),f.push(h.x,h.y,h.z),g.push(T+S,1-x),A.push(c++)}d.push(A)}for(let _=0;_<n;_++)for(let A=0;A<t;A++){const x=d[_][A+1],S=d[_][A],M=d[_+1][A],T=d[_+1][A+1];(_!==0||r>0)&&p.push(x,S,T),(_!==n-1||l<Math.PI)&&p.push(S,M,T)}this.setIndex(p),this.setAttribute("position",new Ie(m,3)),this.setAttribute("normal",new Ie(f,3)),this.setAttribute("uv",new Ie(g,2))}static fromJSON(e){return new Ia(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class Ys extends so{constructor(e=1,t=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Ys(e.radius,e.detail)}}class js extends Pe{constructor(e=1,t=.4,n=12,i=48,o=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:i,arc:o},n=Math.floor(n),i=Math.floor(i);const r=[],s=[],l=[],c=[],d=new b,u=new b,h=new b;for(let p=0;p<=n;p++)for(let m=0;m<=i;m++){const f=m/i*o,g=p/n*Math.PI*2;u.x=(e+t*Math.cos(g))*Math.cos(f),u.y=(e+t*Math.cos(g))*Math.sin(f),u.z=t*Math.sin(g),s.push(u.x,u.y,u.z),d.x=e*Math.cos(f),d.y=e*Math.sin(f),h.subVectors(u,d).normalize(),l.push(h.x,h.y,h.z),c.push(m/i),c.push(p/n)}for(let p=1;p<=n;p++)for(let m=1;m<=i;m++){const f=(i+1)*p+m-1,g=(i+1)*(p-1)+m-1,_=(i+1)*(p-1)+m,A=(i+1)*p+m;r.push(f,g,A),r.push(g,_,A)}this.setIndex(r),this.setAttribute("position",new Ie(s,3)),this.setAttribute("normal",new Ie(l,3)),this.setAttribute("uv",new Ie(c,2))}static fromJSON(e){return new js(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class Ks extends Pe{constructor(e=1,t=.4,n=64,i=8,o=2,r=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:i,p:o,q:r},n=Math.floor(n),i=Math.floor(i);const s=[],l=[],c=[],d=[],u=new b,h=new b,p=new b,m=new b,f=new b,g=new b,_=new b;for(let x=0;x<=n;++x){const S=x/n*o*Math.PI*2;A(S,o,r,e,p),A(S+.01,o,r,e,m),g.subVectors(m,p),_.addVectors(m,p),f.crossVectors(g,_),_.crossVectors(f,g),f.normalize(),_.normalize();for(let M=0;M<=i;++M){const T=M/i*Math.PI*2,L=-t*Math.cos(T),z=t*Math.sin(T);u.x=p.x+(L*_.x+z*f.x),u.y=p.y+(L*_.y+z*f.y),u.z=p.z+(L*_.z+z*f.z),l.push(u.x,u.y,u.z),h.subVectors(u,p).normalize(),c.push(h.x,h.y,h.z),d.push(x/n),d.push(M/i)}}for(let x=1;x<=n;x++)for(let S=1;S<=i;S++){const M=(i+1)*(x-1)+(S-1),T=(i+1)*x+(S-1),L=(i+1)*x+S,z=(i+1)*(x-1)+S;s.push(M,T,z),s.push(T,L,z)}function A(x,S,M,T,L){const z=Math.cos(x),W=Math.sin(x),V=M/S*x,N=Math.cos(V);L.x=T*(2+N)*.5*z,L.y=T*(2+N)*W*.5,L.z=T*Math.sin(V)*.5}this.setIndex(s),this.setAttribute("position",new Ie(l,3)),this.setAttribute("normal",new Ie(c,3)),this.setAttribute("uv",new Ie(d,2))}static fromJSON(e){return new Ks(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class qs extends Pe{constructor(e=new tp(new b(-1,-1,0),new b(-1,1,0),new b(1,1,0)),t=64,n=1,i=8,o=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:i,closed:o};const r=e.computeFrenetFrames(t,o);this.tangents=r.tangents,this.normals=r.normals,this.binormals=r.binormals;const s=new b,l=new b,c=new te;let d=new b;const u=[],h=[],p=[],m=[];function f(g){d=e.getPointAt(g/t,d);const _=r.normals[g],A=r.binormals[g];for(let x=0;x<=i;x++){const S=x/i*Math.PI*2,M=Math.sin(S),T=-Math.cos(S);l.x=T*_.x+M*A.x,l.y=T*_.y+M*A.y,l.z=T*_.z+M*A.z,l.normalize(),h.push(l.x,l.y,l.z),s.x=d.x+n*l.x,s.y=d.y+n*l.y,s.z=d.z+n*l.z,u.push(s.x,s.y,s.z)}}(function(){for(let g=0;g<t;g++)f(g);f(o===!1?t:0),function(){for(let g=0;g<=t;g++)for(let _=0;_<=i;_++)c.x=g/t,c.y=_/i,p.push(c.x,c.y)}(),function(){for(let g=1;g<=t;g++)for(let _=1;_<=i;_++){const A=(i+1)*(g-1)+(_-1),x=(i+1)*g+(_-1),S=(i+1)*g+_,M=(i+1)*(g-1)+_;m.push(A,x,M),m.push(x,S,M)}}()})(),this.setIndex(m),this.setAttribute("position",new Ie(u,3)),this.setAttribute("normal",new Ie(h,3)),this.setAttribute("uv",new Ie(p,2))}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new qs(new ip[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class c1 extends Pe{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],n=new Set,i=new b,o=new b;if(e.index!==null){const r=e.attributes.position,s=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:s.count,materialIndex:0}]);for(let c=0,d=l.length;c<d;++c){const u=l[c],h=u.start;for(let p=h,m=h+u.count;p<m;p+=3)for(let f=0;f<3;f++){const g=s.getX(p+f),_=s.getX(p+(f+1)%3);i.fromBufferAttribute(r,g),o.fromBufferAttribute(r,_),pm(i,o,n)===!0&&(t.push(i.x,i.y,i.z),t.push(o.x,o.y,o.z))}}}else{const r=e.attributes.position;for(let s=0,l=r.count/3;s<l;s++)for(let c=0;c<3;c++){const d=3*s+c,u=3*s+(c+1)%3;i.fromBufferAttribute(r,d),o.fromBufferAttribute(r,u),pm(i,o,n)===!0&&(t.push(i.x,i.y,i.z),t.push(o.x,o.y,o.z))}}this.setAttribute("position",new Ie(t,3))}}}function pm(a,e,t){const n=`${a.x},${a.y},${a.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${a.x},${a.y},${a.z}`;return t.has(n)!==!0&&t.has(i)!==!0&&(t.add(n),t.add(i),!0)}class Ra extends wa{constructor(e,t={}){const n=t.font;if(!n||!n.isFont)return console.error("v3d.TextGeometry: font parameter is not an instance of v3d.Font."),new Pe;t.alignX===void 0&&(t.alignX="left"),t.alignY===void 0&&(t.alignY="topBaseline"),t.lineHeight===void 0&&(t.lineHeight=-1),t.scaledEmSize===void 0&&(t.scaledEmSize=!1);const i=n.generateShapes(e,t.size,t.alignX,t.alignY,t.lineHeight,t.scaledEmSize);t.depth=t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(i,t),this.type="TextGeometry",this.parameters={text:e,parameters:t}}cloneWithText(e){var t=this.parameters.parameters;return new Ra(e,{font:t.font,size:t.size,height:t.height,curveSegments:t.curveSegments,bevelEnabled:t.bevelEnabled,bevelThickness:t.bevelThickness,bevelSize:t.bevelSize,alignX:t.alignX,alignY:t.alignY,lineHeight:t.lineHeight,scaledEmSize:t.scaledEmSize})}}function dT(a,e,t,n,i){a.computeBoundingBox();const o=n.split(/\r\n|\r|\n/).length,r=a.boundingBox.max.x-a.boundingBox.min.x,s=a.boundingBox.max.y-a.boundingBox.min.y;let l,c,d=s/(o+o-1);switch(e){case"left":l=0;break;case"center":l=-.5*r;break;case"right":l=-r;break;default:c=0}const u=d*Math.abs(i.data.descender)/i.data.ascender;switch(t){case"topBaseline":default:c=0;break;case"top":c=-d;break;case"center":c=o>1?.5*s-d:-.5*d+.5*u;break;case"bottom":c=s-d+u;break;case"bottomBaseline":c=o>1?s-d-u:0}(Math.abs(l)>0||Math.abs(c)>0)&&a.translate(l,c,0)}class fa extends Ra{constructor(e,t){super(e,t),dT(this,t.alignX||"left",t.alignY||"bottom",e,t.font),this.type="BlenderTextGeometry"}cloneWithText(e){var t=this.parameters.parameters;return new fa(e,{font:t.font,size:t.size,height:t.height,curveSegments:t.curveSegments,bevelEnabled:t.bevelEnabled,bevelThickness:t.bevelThickness,bevelSize:t.bevelSize,alignX:t.alignX,alignY:t.alignY})}}class u1 extends Pe{constructor(e=50,t=10,n=!0,i=!0,o=!0,r=!0,s=!0){const l=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,3,16,17,18,7,19,20,21,11,22,23,24,15,25,26,27,18,28,29,30,21,31,32,33,24,34,35,36,27,37,38,39,30,40,41,0,33,42,43,4,36,44,45,8,39,46,47,12,12,13,14,15,48,49,50,51,52,53,54,55,56,57,58,59,15,25,26,27,51,60,61,62,55,63,64,65,59,66,67,68,27,37,38,39,62,69,70,71,65,72,73,74,68,75,76,77,39,46,47,12,71,78,79,48,74,80,81,52,77,82,83,56,56,57,58,59,84,85,86,87,88,89,90,91,92,93,94,95,59,66,67,68,87,96,97,98,91,99,100,101,95,102,103,104,68,75,76,77,98,105,106,107,101,108,109,110,104,111,112,113,77,82,83,56,107,114,115,84,110,116,117,88,113,118,119,92,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,123,136,137,120,127,138,139,124,131,140,141,128,135,142,143,132,132,133,134,135,144,145,146,147,148,149,150,151,68,152,153,154,135,142,143,132,147,155,156,144,151,157,158,148,154,159,160,68,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,164,177,178,161,168,179,180,165,172,181,182,169,176,183,184,173,173,174,175,176,185,186,187,188,189,190,191,192,193,194,195,196,176,183,184,173,188,197,198,185,192,199,200,189,196,201,202,193,203,203,203,203,204,205,206,207,208,208,208,208,209,210,211,212,203,203,203,203,207,213,214,215,208,208,208,208,212,216,217,218,203,203,203,203,215,219,220,221,208,208,208,208,218,222,223,224,203,203,203,203,221,225,226,204,208,208,208,208,224,227,228,209,209,210,211,212,229,230,231,232,233,234,235,236,237,238,239,240,212,216,217,218,232,241,242,243,236,244,245,246,240,247,248,249,218,222,223,224,243,250,251,252,246,253,254,255,249,256,257,258,224,227,228,209,252,259,260,229,255,261,262,233,258,263,264,237,265,265,265,265,266,267,268,269,270,271,272,273,92,119,118,113,265,265,265,265,269,274,275,276,273,277,278,279,113,112,111,104,265,265,265,265,276,280,281,282,279,283,284,285,104,103,102,95,265,265,265,265,282,286,287,266,285,288,289,270,95,94,93,92],c=[1.4,0,2.4,1.4,-.784,2.4,.784,-1.4,2.4,0,-1.4,2.4,1.3375,0,2.53125,1.3375,-.749,2.53125,.749,-1.3375,2.53125,0,-1.3375,2.53125,1.4375,0,2.53125,1.4375,-.805,2.53125,.805,-1.4375,2.53125,0,-1.4375,2.53125,1.5,0,2.4,1.5,-.84,2.4,.84,-1.5,2.4,0,-1.5,2.4,-.784,-1.4,2.4,-1.4,-.784,2.4,-1.4,0,2.4,-.749,-1.3375,2.53125,-1.3375,-.749,2.53125,-1.3375,0,2.53125,-.805,-1.4375,2.53125,-1.4375,-.805,2.53125,-1.4375,0,2.53125,-.84,-1.5,2.4,-1.5,-.84,2.4,-1.5,0,2.4,-1.4,.784,2.4,-.784,1.4,2.4,0,1.4,2.4,-1.3375,.749,2.53125,-.749,1.3375,2.53125,0,1.3375,2.53125,-1.4375,.805,2.53125,-.805,1.4375,2.53125,0,1.4375,2.53125,-1.5,.84,2.4,-.84,1.5,2.4,0,1.5,2.4,.784,1.4,2.4,1.4,.784,2.4,.749,1.3375,2.53125,1.3375,.749,2.53125,.805,1.4375,2.53125,1.4375,.805,2.53125,.84,1.5,2.4,1.5,.84,2.4,1.75,0,1.875,1.75,-.98,1.875,.98,-1.75,1.875,0,-1.75,1.875,2,0,1.35,2,-1.12,1.35,1.12,-2,1.35,0,-2,1.35,2,0,.9,2,-1.12,.9,1.12,-2,.9,0,-2,.9,-.98,-1.75,1.875,-1.75,-.98,1.875,-1.75,0,1.875,-1.12,-2,1.35,-2,-1.12,1.35,-2,0,1.35,-1.12,-2,.9,-2,-1.12,.9,-2,0,.9,-1.75,.98,1.875,-.98,1.75,1.875,0,1.75,1.875,-2,1.12,1.35,-1.12,2,1.35,0,2,1.35,-2,1.12,.9,-1.12,2,.9,0,2,.9,.98,1.75,1.875,1.75,.98,1.875,1.12,2,1.35,2,1.12,1.35,1.12,2,.9,2,1.12,.9,2,0,.45,2,-1.12,.45,1.12,-2,.45,0,-2,.45,1.5,0,.225,1.5,-.84,.225,.84,-1.5,.225,0,-1.5,.225,1.5,0,.15,1.5,-.84,.15,.84,-1.5,.15,0,-1.5,.15,-1.12,-2,.45,-2,-1.12,.45,-2,0,.45,-.84,-1.5,.225,-1.5,-.84,.225,-1.5,0,.225,-.84,-1.5,.15,-1.5,-.84,.15,-1.5,0,.15,-2,1.12,.45,-1.12,2,.45,0,2,.45,-1.5,.84,.225,-.84,1.5,.225,0,1.5,.225,-1.5,.84,.15,-.84,1.5,.15,0,1.5,.15,1.12,2,.45,2,1.12,.45,.84,1.5,.225,1.5,.84,.225,.84,1.5,.15,1.5,.84,.15,-1.6,0,2.025,-1.6,-.3,2.025,-1.5,-.3,2.25,-1.5,0,2.25,-2.3,0,2.025,-2.3,-.3,2.025,-2.5,-.3,2.25,-2.5,0,2.25,-2.7,0,2.025,-2.7,-.3,2.025,-3,-.3,2.25,-3,0,2.25,-2.7,0,1.8,-2.7,-.3,1.8,-3,-.3,1.8,-3,0,1.8,-1.5,.3,2.25,-1.6,.3,2.025,-2.5,.3,2.25,-2.3,.3,2.025,-3,.3,2.25,-2.7,.3,2.025,-3,.3,1.8,-2.7,.3,1.8,-2.7,0,1.575,-2.7,-.3,1.575,-3,-.3,1.35,-3,0,1.35,-2.5,0,1.125,-2.5,-.3,1.125,-2.65,-.3,.9375,-2.65,0,.9375,-2,-.3,.9,-1.9,-.3,.6,-1.9,0,.6,-3,.3,1.35,-2.7,.3,1.575,-2.65,.3,.9375,-2.5,.3,1.125,-1.9,.3,.6,-2,.3,.9,1.7,0,1.425,1.7,-.66,1.425,1.7,-.66,.6,1.7,0,.6,2.6,0,1.425,2.6,-.66,1.425,3.1,-.66,.825,3.1,0,.825,2.3,0,2.1,2.3,-.25,2.1,2.4,-.25,2.025,2.4,0,2.025,2.7,0,2.4,2.7,-.25,2.4,3.3,-.25,2.4,3.3,0,2.4,1.7,.66,.6,1.7,.66,1.425,3.1,.66,.825,2.6,.66,1.425,2.4,.25,2.025,2.3,.25,2.1,3.3,.25,2.4,2.7,.25,2.4,2.8,0,2.475,2.8,-.25,2.475,3.525,-.25,2.49375,3.525,0,2.49375,2.9,0,2.475,2.9,-.15,2.475,3.45,-.15,2.5125,3.45,0,2.5125,2.8,0,2.4,2.8,-.15,2.4,3.2,-.15,2.4,3.2,0,2.4,3.525,.25,2.49375,2.8,.25,2.475,3.45,.15,2.5125,2.9,.15,2.475,3.2,.15,2.4,2.8,.15,2.4,0,0,3.15,.8,0,3.15,.8,-.45,3.15,.45,-.8,3.15,0,-.8,3.15,0,0,2.85,.2,0,2.7,.2,-.112,2.7,.112,-.2,2.7,0,-.2,2.7,-.45,-.8,3.15,-.8,-.45,3.15,-.8,0,3.15,-.112,-.2,2.7,-.2,-.112,2.7,-.2,0,2.7,-.8,.45,3.15,-.45,.8,3.15,0,.8,3.15,-.2,.112,2.7,-.112,.2,2.7,0,.2,2.7,.45,.8,3.15,.8,.45,3.15,.112,.2,2.7,.2,.112,2.7,.4,0,2.55,.4,-.224,2.55,.224,-.4,2.55,0,-.4,2.55,1.3,0,2.55,1.3,-.728,2.55,.728,-1.3,2.55,0,-1.3,2.55,1.3,0,2.4,1.3,-.728,2.4,.728,-1.3,2.4,0,-1.3,2.4,-.224,-.4,2.55,-.4,-.224,2.55,-.4,0,2.55,-.728,-1.3,2.55,-1.3,-.728,2.55,-1.3,0,2.55,-.728,-1.3,2.4,-1.3,-.728,2.4,-1.3,0,2.4,-.4,.224,2.55,-.224,.4,2.55,0,.4,2.55,-1.3,.728,2.55,-.728,1.3,2.55,0,1.3,2.55,-1.3,.728,2.4,-.728,1.3,2.4,0,1.3,2.4,.224,.4,2.55,.4,.224,2.55,.728,1.3,2.55,1.3,.728,2.55,.728,1.3,2.4,1.3,.728,2.4,0,0,0,1.425,0,0,1.425,.798,0,.798,1.425,0,0,1.425,0,1.5,0,.075,1.5,.84,.075,.84,1.5,.075,0,1.5,.075,-.798,1.425,0,-1.425,.798,0,-1.425,0,0,-.84,1.5,.075,-1.5,.84,.075,-1.5,0,.075,-1.425,-.798,0,-.798,-1.425,0,0,-1.425,0,-1.5,-.84,.075,-.84,-1.5,.075,0,-1.5,.075,.798,-1.425,0,1.425,-.798,0,.84,-1.5,.075,1.5,-.84,.075];super(),t=Math.max(2,Math.floor(t));const d=3.15*(s?1:1.3)/2,u=e/d;let h=n?(8*t-4)*t:0;h+=i?(16*t-4)*t:0,h+=o?40*t*t:0;const p=new Uint32Array(3*h);let m=n?4:0;m+=i?8:0,m+=o?20:0,m*=(t+1)*(t+1);const f=new Float32Array(3*m),g=new Float32Array(3*m),_=new Float32Array(2*m),A=new Ae;A.set(-1,3,-3,1,3,-6,3,0,-3,3,0,0,1,0,0,0);const x=[],S=[],M=[],T=[],L=[],z=[],W=[],V=[],N=[],j=new b;let oe,H,ne,le,re=0,ae=0;const E=new b,F=new Ae,U=new Ae,B=new Re,Z=new Re,k=new Re,X=new Re,P=new b,v=new b,y=A.clone();y.transpose();const R=(G,K,ie)=>!(f[3*G]===f[3*K]&&f[3*G+1]===f[3*K+1]&&f[3*G+2]===f[3*K+2]||f[3*G]===f[3*ie]&&f[3*G+1]===f[3*ie+1]&&f[3*G+2]===f[3*ie+2]||f[3*K]===f[3*ie]&&f[3*K+1]===f[3*ie+1]&&f[3*K+2]===f[3*ie+2]);for(let G=0;G<3;G++)z[G]=new Ae;const w=n?32:28,I=t+1;let C=0,D=0,O=0,Y=0,J=0;for(let G=o?0:20;G<w;G++)if(i||G<20||G>=28){for(let K=0;K<3;K++){for(let ie=0;ie<4;ie++)for(let $=0;$<4;$++)x[4*$+ie]=c[3*l[16*G+4*ie+$]+K],r&&G>=20&&G<28&&K!==2&&(x[4*$+ie]*=1.077),s||K!==2||(x[4*$+ie]*=1.3);F.set(x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10],x[11],x[12],x[13],x[14],x[15]),U.multiplyMatrices(F,A),z[K].multiplyMatrices(y,U)}for(let K=0;K<=t;K++){const ie=K/t;for(let $=0;$<=t;$++){const se=$/t;for(le=4,H=ne=1;le--;)S[le]=H,M[le]=ne,H*=ie,ne*=se,le===3?(T[le]=L[le]=0,re=ae=1):(T[le]=re*(3-le),L[le]=ae*(3-le),re*=ie,ae*=se);B.fromArray(S),Z.fromArray(M),k.fromArray(T),X.fromArray(L);for(let de=0;de<3;de++)oe=B.clone(),oe.applyMatrix4(z[de]),W[de]=oe.dot(Z),oe=k.clone(),oe.applyMatrix4(z[de]),V[de]=oe.dot(Z),oe=B.clone(),oe.applyMatrix4(z[de]),N[de]=oe.dot(X);P.fromArray(V),v.fromArray(N),j.crossVectors(v,P),j.normalize(),W[0]===0&&W[1]===0?E.set(0,W[2]>d?1:-1,0):E.set(j.x,j.z,-j.y),f[D++]=u*W[0],f[D++]=u*(W[2]-d),f[D++]=-u*W[1],g[O++]=E.x,g[O++]=E.y,g[O++]=E.z,_[Y++]=1-se,_[Y++]=1-ie}}for(let K=0;K<t;K++)for(let ie=0;ie<t;ie++){const $=C*I*I+K*I+ie,se=$+1,de=se+I,he=$+I;R($,se,de)&&(p[J++]=$,p[J++]=se,p[J++]=de),R($,de,he)&&(p[J++]=$,p[J++]=de,p[J++]=he)}C++}this.setIndex(new Te(p,1)),this.setAttribute("position",new Te(f,3)),this.setAttribute("normal",new Te(g,3)),this.setAttribute("uv",new Te(_,2)),this.computeBoundingSphere()}}var fm=Object.freeze({__proto__:null,BlenderTextBufferGeometry:fa,BlenderTextGeometry:fa,BoxGeometry:ao,CapsuleGeometry:Vs,CircleGeometry:Gs,ConeGeometry:ks,CylinderGeometry:yr,DodecahedronGeometry:Qs,EdgesGeometry:r1,ExtrudeGeometry:wa,IcosahedronGeometry:Ws,LatheGeometry:Ea,OctahedronGeometry:Ta,PlaneGeometry:ni,PolyhedronGeometry:so,RingGeometry:Hs,ShapeGeometry:Xs,SphereGeometry:Ia,TeapotGeometry:u1,TetrahedronGeometry:Ys,TextGeometry:Ra,TorusGeometry:js,TorusKnotGeometry:Ks,TubeGeometry:qs,WireframeGeometry:c1});class d1 extends Ut{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new me(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class Zs extends Ut{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new me(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new me(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Uo,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.envMapParallaxType=0,this.envMapParallaxMatrix=new Ae,this.envMapParallaxMatrixInv=new Ae,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this.envMapParallaxType=e.envMapParallaxType,this.envMapParallaxMatrix.copy(e.envMapParallaxMatrix),this.envMapParallaxMatrixInv.copy(e.envMapParallaxMatrixInv),this}}class lo extends Zs{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new te(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ye(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new me(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new me(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new me(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class h1 extends Ut{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new me(16777215),this.specular=new me(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new me(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Uo,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ps,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class p1 extends Ut{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new me(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new me(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Uo,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class op extends Ut{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Uo,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class f1 extends Ut{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new me(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new me(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Uo,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ps,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class m1 extends Ut{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new me(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Uo,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class g1 extends un{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}class rp extends Ut{constructor(e){super(),this.type="MeshMaskMaterial",this.side=Tn,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.lights=!1,this.cameraNearFar=null,this.depthTexture=null,this.textureMatrix=null,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,e.cameraNearFar&&(this.cameraNearFar=e.cameraNearFar.clone()),e.textureMatrix&&(this.textureMatrix=e.textureMatrix.clone()),e.depthTexture&&(this.depthTexture=e.depthTexture),this}}rp.prototype.isMeshMaskMaterial=!0;class La{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],o=t[n-1];t:{e:{let r;n:{i:if(!(e<i)){for(let s=n+2;;){if(i===void 0){if(e<o)break i;return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===s)break;if(o=i,i=t[++n],e<i)break e}r=t.length;break n}if(e>=o)break t;{const s=t[1];e<s&&(n=2,o=s);for(let l=n-2;;){if(o===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===l)break;if(i=o,o=t[--n-1],e>=o)break e}r=n,n=0}}for(;n<r;){const s=n+r>>>1;e<t[s]?r=s:n=s+1}if(i=t[n],o=t[n-1],o===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,o,i)}return this.interpolate_(n,o,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,o=e*i;for(let r=0;r!==i;++r)t[r]=n[o+r];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class ap extends La{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}const mm=function(a){this.value=a,this.next=null},ji=function(){this.N=0,this.first=null};ji.prototype.push=function(a){this.first=this._push(this.first,a)},ji.prototype._push=function(a,e){if(a==null)return this.N++,new mm(e);const t=a;return this.N++,(a=new mm(e)).next=t,a},ji.prototype.pop=function(){if(this.first==null)return;const a=this.first,e=a.value;return this.first=a.next,this.N--,e},ji.prototype.size=function(){return this.N},ji.prototype.isEmpty=function(){return this.N==0},ji.prototype.peep=function(){if(this.first!=null)return this.first.value},ji.prototype.toArray=function(){const a=[];let e=this.first;for(;e!=null;)a.push(e.value),e=e.next;return a};const v1=function(a){this.value=a,this.prev=null,this.next=null},Pc=function(){this.first=null,this.last=null,this.map={}};Pc.prototype.push=function(a,e){this.map[e]=a,this.first===null?(this.first=a,this.last=a):(this.last.next=a,a.prev=this.last,this.last=a)},Pc.prototype.removeNodeByKey=function(a){const e=this.map[a],t=e.prev,n=e.next;t!==null&&n!==null?(t.next=n,n.prev=t):t===null&&n!==null?(this.first=n,n.prev=null):t!==null&&n===null?(this.last=t,t.next=null):(this.first=null,this.last=null),delete this.map[a]};const xt=function(a){this.V=a,this.adjList=[],this.nodeInfo=[],this.edges={};for(let e=0;e<a;++e)this.adjList.push([]),this.nodeInfo.push({})};xt.prototype.removeAll=function(){this.V=0,this.adjList=[],this.nodeInfo=[],this.edges={}},xt.prototype.addNode=function(a){a=a||{},this.V++,this.adjList.push([]),this.nodeInfo.push(a)},xt.prototype.addNewEdge=function(a,e){this.adjList[a].push(e);const t=a+"_"+e,n=new Mn(a,e,0);return this.edges[t]=n,n},xt.prototype.addEdge=function(a){const e=a.v,t=a.w;this.adjList[e].push(t);const n=e+"_"+t;this.edges[n]=a},xt.prototype.removeEdge=function(a,e){const t=this.adjList[a];for(let i=0;i<t.length;i++)t[i]==e&&(t.splice(i,1),i--);const n=a+"_"+e;n in this.edges&&delete this.edges[n]},xt.prototype.edge=function(a,e){const t=a+"_"+e;return t in this.edges?this.edges[t]:null},xt.prototype.adj=function(a){return this.adjList[a]},xt.prototype.node=function(a){return this.nodeInfo[a]},xt.prototype.nodeIndex=function(a){for(let e=0;e<this.V;++e)if(this.nodeInfo[e]==a)return e;return-1},xt.prototype.reverse=function(){const a=new xt(this.V);for(let e=0;e<this.V;++e){const t=this.adjList[e];for(let n=0;n<t.length;++n){const i=t[n];a.addNewEdge(i,e)}}return a},xt.prototype.len=function(){return this.V},xt.prototype.findInEdges=function(a){const e=[];for(let t=0;t<this.V;t++){const n=this.adjList[t];for(let i=0;i<n.length;i++)n[i]==a&&e.push(this.edge(t,a))}return e},xt.prototype.findOutEdges=function(a){const e=[],t=this.adjList[a];for(let n=0;n<t.length;n++)e.push(this.edge(a,t[n]));return e},xt.prototype.disconnect=function(a,e){this.adjList[a].splice(0);for(let t=0;t<this.V;t++){const n=this.adjList[t];for(let o=0;o<n.length;o++)n[o]==a&&(n.splice(o,1),o--);let i=t+"_"+a;i in this.edges&&delete this.edges[i],i=a+"_"+t,i in this.edges&&delete this.edges[i]}if(e){const t=new xt(this.V-1);for(let n=0;n<this.V;n++){if(n==a)continue;const i=this.adjList[n];for(let o=0;o<i.length;o++){const r=i[o],s=n>a?n-1:n,l=r>a?r-1:r,c=this.edge(n,r).copy();c.v=s,c.w=l,t.addEdge(c)}}this.V--,this.adjList=t.adjList,this.nodeInfo.splice(a,1),this.edges=t.edges}},xt.prototype.insert=function(a,e,t,n=o=>o,i=o=>o){const o=this.V,r=a.V;for(let s=0;s<r;s++){this.adjList.push([]),this.nodeInfo.push(n(a.nodeInfo[s]));const l=a.adjList[s];for(let c=0;c<l.length;c++){const d=l[c],u=a.edge(s,d).copy(i);u.v+=o,u.w+=o,this.addEdge(u)}}this.V+=r;for(let s=0;s<e.length;s++){const l=e[s].copy(i);l.w+=o,this.addEdge(l)}for(let s=0;s<t.length;s++){const l=t[s].copy(i);l.v+=o,this.addEdge(l)}},xt.prototype.vis=function(a){a=a||function(t,n){return String(t)};let e="digraph G {";for(let t=0;t<this.V;t++){e+=t+' [label="'+a(t,this.nodeInfo[t])+'"];';const n=this.adjList[t];for(let i=0;i<n.length;i++)e+=t+" -> "+n[i]+";"}e+="}",console.log(e)};const Mn=function(a,e,t){this.v=a,this.w=e,this.weight=t};Mn.prototype.either=function(){return this.v},Mn.prototype.other=function(a){return a==this.v?this.w:this.v},Mn.prototype.from=function(){return this.v},Mn.prototype.to=function(){return this.w},Mn.prototype.copy=function(a=e=>e){const e=new Mn(0,0,0);for(const t in this)this.hasOwnProperty(t)&&(typeof this[t]=="object"?e[t]=a(this[t]):e[t]=this[t]);return e};const $r=function(a){this.V=a,this.adjList=[],this.nodeInfo=[];for(let e=0;e<a;++e)this.adjList.push([]),this.nodeInfo.push({})};$r.prototype.adj=function(a){return this.adjList[a]},$r.prototype.edge=function(a,e){const t=this.adjList[a];for(let n=0;n<t.length;++n)if(t[n].other(a)==e)return t[n];return null},$r.prototype.node=function(a){return this.nodeInfo[a]},$r.prototype.addNewEdge=function(a){const e=a.either(),t=a.other(e);this.adjList[e].push(a),this.adjList[t].push(a)};const $u=function(a){$r.call(this,a)};($u.prototype=Object.create($r.prototype)).addNewEdge=function(a){const e=a.from();this.adjList[e].push(a)},$u.prototype.edge=function(a,e){const t=this.adjList[a];for(let n=0;n<t.length;++n)if(t[n].other(a)==e)return t[n];return null},$u.prototype.toDiGraph=function(){const a=new xt(this.V);for(let e=0;e<this.V;++e){const t=this.adjList[e];for(let n=0;n<t.length;++n){const i=t[n].other(e);a.addNewEdge(e,i)}}return a};const es=function(a,e){this.s=e;const t=a.V;this.marked=[],this.edgeTo=[];for(let n=0;n<t;++n)this.marked.push(!1),this.edgeTo.push(-1);this.dfs(a,e)};es.prototype.dfs=function(a,e){this.marked[e]=!0;const t=a.adj(e);for(let n=0;n<t.length;++n){const i=t[n];this.marked[i]||(this.edgeTo[i]=e,this.dfs(a,i))}},es.prototype.hasPathTo=function(a){return this.marked[a]},es.prototype.pathTo=function(a){const e=new ji;if(a==this.s)return[a];for(let t=a;t!=this.s;t=this.edgeTo[t])e.push(t);return e.push(this.s),e.toArray()};const Bc=function(a){this.postOrder=new ji,this.marked=[];const e=a.V;for(let t=0;t<e;++t)this.marked.push(!1);for(let t=0;t<e;++t)this.marked[t]||this.dfs(a,t)};Bc.prototype.dfs=function(a,e){this.marked[e]=!0;const t=a.adj(e);for(let n=0;n<t.length;++n){const i=t[n];this.marked[i]||this.dfs(a,i)}this.postOrder.push(e)},Bc.prototype.order=function(){return this.postOrder.toArray()};var hT=Object.freeze({__proto__:null,DepthFirstSearch:es,DiGraph:xt,Edge:Mn,LinkMap:Pc,LinkMapNode:v1,TopologicalSort:Bc}),pT=[-1.117001,-.1867262,-11.13505,12.59865,-.03937339,1.167571,.007100686,3.592678,.6083296,-1.152006,-.1926669,6.152049,-4.770802,-.08704701,.7483626,.03372718,4.464592,.4036546,-1.072371,-.2696632,.2816168,1.820571,-.3742666,2.080607,-.07675295,-2.835366,1.129329,-1.109935,-.1532764,1.198787,-.9015183,.005173015,.5749178,.1075633,4.387949,.2650413,-1.052297,-.2229452,1.952347,.5727205,-4.88507,1.984016,-.1106197,-.4898361,.8907873,-1.070108,-.1600465,1.593886,-4479251e-11,-3.306541,.9390193,.09513168,2.343583,.5335404,-1.113253,-.16996,-10.38822,11.37513,-.04040911,1.037455,.04991792,4.801919,.630271,-1.135747,-.1678594,4.970755,-4.43023,-.06657408,.3636161,.1558009,6.01337,.3959601,-1.095892,-.2732595,.7666496,1.350731,-.4401401,2.470135,-.1707929,-3.260793,1.170337,-1.073668,-.02603929,-.1944589,.4575207,.6878164,-.139077,.3690299,7.885781,.1877694,-1.070091,-.2798957,2.338478,-2.647221,-7.387808,2.32921,-.1644639,-2.00371,.9874527,-1.06712,-.1418866,1.25409,6.053048,-2.918892,.5322812,.1613053,3.018161,.527409,-1.129483,-.1890619,-9.065101,9.659923,-.03607819,.8314359,.08181661,4.768868,.6339777,-1.14642,-.1883579,3.309173,-3.127882,-.06938176,.3987113,.1400581,6.283042,.5267076,-1.128348,-.2641305,1.223176,.05514952,-.3490649,1.997784,-.04123709,-2.251251,.9483466,-1.02582,.0140469,-1.187406,2.7299,.5877588,-.276114,.4602633,8.305125,.3945001,-1.083957,-.2606679,2.207108,-7.202803,-5.968103,2.129455,-.07789512,-1.137688,.8871769,-1.062465,-.1512189,1.042881,14.27839,-4.242214,.40381,.199778,2.814449,.5803196,-1.175099,-.2410789,-11.08587,11.33404,-.018193,.6772942,.09605043,4.231166,.6239972,-1.224207,-.2883527,3.002206,-2.649612,-.04795418,.4984398,.03251434,4.851611,.6551019,-1.136955,-.2423048,1.058823,-.2489236,-.2462179,1.93314,.09106828,-.1905869,.8171065,-1.014535,-.0082625,-1.448017,2.295788,.3510334,-1.477418,.5432449,5.762796,.4908751,-1.070666,-.237978,1.844589,-5.442448,-4.012768,2.945275,.009854725,.08455959,.814503,-1.071525,-.1777132,.807659,9.925865,-3.324623,-.6367437,.2844581,2.248384,.6544022,-1.218818,-.2952382,-13.45975,13.47153,-.006814585,.5079068,.119723,3.776949,.5836961,-1.409868,-.511433,2.776539,-2.039001,-.02673769,.4145288,.0007829342,2.275883,.6629691,-1.069151,-.09434247,.7293972,-1.222473,-.1533461,2.160357,.04626837,3.852415,.859357,-1.021306,-.1149551,-1.108414,4.178343,.4013665,-2.222814,.6929462,1.392652,.4401662,-1.074251,-.2224002,1.372356,-8.858704,-3.92266,3.020018,-.01458724,1.511186,.8288064,-1.062048,-.1526582,.4921067,14.85522,-3.229936,-.8426604,.3916243,2.678994,.6689264,-1.257023,-.33647,-15.27795,15.04223,.002717715,.302991,.1636851,3.561663,.5283161,-1.635124,-.7329993,3.523939,-2.566337,-.01902543,.5505483,-.06242176,1.065992,.6654236,-.9295823,.04845834,-.299299,-.2001327,-.08019339,1.807806,.09020277,5.095372,.8639936,-1.09374,-.2148608,-.521624,2.119777,.09506454,-1.831439,.6961204,.1102084,.4384319,-1.044181,-.1849257,.9071246,-4.648901,-2.279385,2.356502,-.04169147,1.932557,.829655,-1.061451,-.1458745,.2952267,8.967214,-3.726228,-.5022316,.5684877,3.102347,.6658443,-1.332391,-.4127769,-9.328643,9.046194,.003457775,.3377425,.1530909,3.301209,.4997917,-1.932002,-.9947777,-2.042329,3.58694,-.05642182,.8130478,-.08195988,.1118294,.5617231,-.8707374,.1286999,1.820054,-4.674706,.003317471,.5919018,.1975278,6.686519,.9631727,-1.070378,-.3030579,-.9041938,6.200201,.1232207,-.3650628,.5029403,-2.903162,.3811408,-1.063035,-.1637545,.5853072,-7.889906,-1.200641,1.035018,.1192093,3.267054,.8416151,-1.053655,-.1562286,.2423683,11.28575,-4.363262,-.0731416,.5642088,2.514023,.6670457,-1.366112,-.4718287,-7.876222,7.7469,-.009182309,.4716076,.08320252,3.165603,.5392334,-2.468204,-1.33634,-5.386723,7.072672,-.08329266,.8636876,-.01978177,-.1326218,.2979222,-.9653522,-.02373416,1.81025,-6.467262,.1410706,-.4753717,.3003095,6.551163,1.151083,-.8943186,-.2487152,-.230896,8.512648,.1298402,1.034705,.2303509,-3.924095,.2982717,-1.146999,-.2318784,.08992419,-9.933614,-.886092,-.03071656,.2852012,3.046199,.8599001,-1.032399,-.1645145,.2683599,13.27701,-4.40767,.07709869,.4951727,1.957277,.6630943,-1.46907,-.6135092,-6.506263,6.661315,-.03835383,.7150413,.007784318,2.820577,.6756784,-2.501583,-1.247404,-15.23462,16.33191,-.01204803,.5896471,-.02002023,1.144647,.06177874,-2.438672,-1.127291,5.731172,-10.2135,.0616561,-.7752641,.4708254,4.176847,1.200881,-.1513427,.09792731,-1.612349,9.814289,.05188921,1.716403,-.07039255,-2.815115,.3291874,-1.318511,-.3650554,.4221268,-9.294529,-.0439752,-.8100625,.3742719,1.834166,.822345,-1.016009,-.1820264,.1278426,11.82696,-4.801528,.4947899,.4660378,1.601254,.6702359,-1.84131,-.9781779,-4.610903,4.824662,-.05100806,.6463776,-6377724e-12,2.216875,.861853,-2.376373,-1.108657,-14.89799,15.46458,.04091025,.0976178,-.01048958,2.165834,-.1609171,-4.710318,-2.261963,6.947327,-10.34828,-.1325542,.7508674,.2247553,2.873142,1.2971,.216375,-.1944345,-2.43786,10.11314,.44505,.3111492,.2751323,-1.627906,.2531213,-1.258794,-.3524641,.8425444,-10.85313,-1.154381,-.4638014,-.002781115,.4344498,.8507091,-1.018938,-.1804153,-.06354054,15.7315,-4.386999,.6211115,.5294648,1.580749,.6586655,-1.116416,-.1917524,-10.68233,12.22221,-.03668978,1.054022,.01592132,3.180583,.562737,-1.132341,-.1671286,5.976499,-4.227366,-.09542489,.8664938,.008351793,4.876068,.4492779,-1.087635,-.3173679,.4314407,1.100555,-.4410057,1.677253,-.03005925,-4.201249,1.070902,-1.083031,-.08847705,1.291773,.4546776,.3091894,.726176,.04203659,5.990615,.3704756,-1.057899,-.2246706,2.329563,-1.219656,-5.33526,.8545378,-.03906209,-.9025499,.7797348,-1.073305,-.1522553,1.767063,1.90428,-3.101673,.3995856,.02905192,2.563977,.5753067,-1.113674,-.1759694,-9.754125,10.87391,-.03841093,.9524272,.05680219,4.227034,.6029571,-1.126496,-.1680281,5.332352,-4.575579,-.06761755,.3295335,.1194896,5.570901,.4536185,-1.103074,-.2681801,.06571479,2.396522,-.455128,2.466331,-.1232022,-3.023201,1.086379,-1.053299,-.02697173,.8379121,-.9681458,.5890692,-.4872027,.2936929,7.510139,.3079122,-1.079553,-.2710448,2.462379,-.3713554,-8.534512,1.828242,-.1686398,-1.96134,.8941077,-1.069741,-.1396394,1.657868,3.236313,-2.706344,-.2948122,.1314816,2.868457,.5413403,-1.131649,-.1954455,-7.751595,8.685861,-.04910871,.8992952,.04710143,4.254818,.6821116,-1.156689,-.1884324,3.163519,-3.091522,-.06613927,-.02575883,.1640065,6.073643,.4453468,-1.079224,-.2621389,.9446437,1.448479,-.3969384,2.626638,-.08101186,-3.016355,1.076295,-1.080832,.01033057,-.3500156,-.03281419,.5655512,-1.156742,.453471,8.774122,.2772869,-1.051202,-.2679975,2.719109,-2.190316,-6.878798,2.250481,-.2030252,-2.026527,.9701096,-1.089849,-.1598589,1.564748,6.869187,-3.05367,-.6110435,.1644472,2.370452,.551177,-1.171419,-.2429746,-8.991334,9.571216,-.02772861,.6688262,.07683478,3.785611,.6347635,-1.228554,-.2917562,2.753986,-2.49178,-.04663434,.3118303,.07546506,4.463096,.5955071,-1.093124,-.2447767,.9097406,.5448296,-.2957824,2.024167,-.0005152333,-1.069081,.9369565,-1.056994,.01569507,-.8217491,1.870818,.706193,-1.483928,.5978206,6.864902,.3673332,-1.054871,-.2758129,2.712807,-5.95011,-6.554039,2.447523,-.1895171,-1.454292,.9131738,-1.100218,-.1746241,1.438505,11.15481,-3.266076,-.8837357,.19701,1.991595,.5907821,-1.207267,-.291361,-11.03767,11.40724,-.014168,.5564047,.08476262,3.371255,.6221335,-1.429698,-.5374218,2.837524,-2.221936,-.02422337,.09313758,.0719025,1.869022,.5609035,-1.002274,-.0697281,.4031308,-.3932997,-.1521923,2.390646,-.0689399,2.999661,1.017843,-1.081168,-.1178666,-.496808,3.919299,.6046866,-2.440615,.7891538,2.140835,.274047,-1.050727,-.2307688,2.276396,-9.454407,-5.505176,2.99262,-.2450942,.6078372,.9606765,-1.103752,-.1810202,1.375044,15.89095,-3.438954,-1.265669,.2475172,1.680768,.5978056,-1.244324,-.3378542,-11.11001,11.37784,-.007896794,.4808023,.09249904,3.025816,.5880239,-1.593165,-.7027621,2.220896,-1.437709,-.01534738,.06286958,.06644555,1.091727,.547008,-.9136506,.01344874,.7772636,-1.209396,-.1408978,2.433718,-.1041938,3.791244,1.037916,-1.134968,-.1803315,-.9267335,4.57667,.6851928,-2.805,.8687208,1.161483,.2571688,-1.017037,-.2053943,2.36164,-9.887818,-5.122889,3.287088,-.2594102,.8578927,.959234,-1.118723,-.1934942,1.226023,16.7414,-3.277335,-1.629809,.2765232,1.637713,.6113963,-1.314779,-.4119915,-12.4115,12.41578,.002344284,.2980837,.1414613,2.781731,.4998556,-1.926199,-1.020038,2.5692,-1.081159,-.02266833,.3588668,.008750078,-.2452171,.4796758,-.7780002,.1850647,.04445456,-2.409297,-.07816346,1.54679,-.02807227,5.998176,1.132396,-1.179326,-.357833,-.2392933,6.467883,.5904596,-1.869975,.8045839,-2.498121,.1610633,-1.009956,-.1311896,1.726577,-12.19356,-3.466239,2.343602,-.2252205,2.573681,1.027109,-1.11246,-.2063093,1.233051,20.58946,-4.578074,-1.145643,.3160192,1.420159,.5860212,-1.371689,-.4914196,-10.7661,11.07405,-.01485077,.5936218,.03685482,2.599968,.6002204,-2.436997,-1.377939,.02130141,1.079593,-.01796232,-.03933248,.1610711,-.6901181,.1206416,-.8743368,.0733137,.8734259,-3.743126,-.03151167,1.297596,-.07634926,6.532873,1.435737,-.9810197,-.3521634,-.2855205,7.134674,.6839748,-1.394841,.6952036,-4.633104,-.02173401,-1.122958,-.1691536,1.38236,-11.02913,-2.608171,1.865111,-.1345154,3.112342,1.094134,-1.075586,-.2077415,1.171477,17.9327,-4.656858,-1.036839,.3338295,1.042793,.5739374,-1.465871,-.6364486,-8.833718,9.34365,-.032236,.7552848,-3121341e-12,2.249164,.8094662,-2.448924,-1.270878,-4.823703,5.853058,-.02149127,.03581132,-.001230276,.4892553,-.1597657,-2.419809,-1.071337,1.575648,-4.98358,.009545185,.5032615,.4186266,4.634147,1.433517,-.1383278,-.02797095,-.1943067,6.679623,.411828,-.2744289,-.02118722,-4.337025,.1505072,-1.341872,-.2518572,1.027009,-6.527103,-1.081271,1.015465,.2845789,2.470371,.927812,-1.04064,-.2367454,1.100744,8.827253,-4.560794,-.7287017,.2842503,.6336593,.6327335,-1.877993,-1.025135,-4.311037,4.715016,-.04711631,.6335844,-7665398e-12,1.788017,.9001409,-2.28154,-1.137668,-10.36869,11.36254,.01961739,-.09836174,-.006734567,1.320918,-.2400807,-4.904054,-2.315781,5.735999,-8.626257,-.1255643,1.545446,.139686,2.972897,1.429934,.4077067,-.1833688,-2.450939,9.119433,.4505361,-1.340828,.397369,-1.78537,.09628711,-1.296052,-.3250526,1.813294,-10.31485,-1.38869,1.239733,-.08989196,-.3389637,.963956,-1.062181,-.2423444,.7577592,15.66938,-4.462264,-.574281,.3262259,.9461672,.6232887],fT=[-1.127942,-.1905548,-12.52356,13.75799,-.03624732,1.055453,.01385036,4.17697,.5928345,-1.15526,-.1778135,6.216056,-5.254116,-.08787445,.8434621,.04025734,6.195322,.3111856,-1.125624,-.3217593,.5043919,1.686284,-.3536071,1.476321,-.07899019,-4.522531,1.271691,-1.081801,-.1033234,.999555,.007482946,-.06776018,1.463141,.09492021,5.612723,.1298846,-1.07532,-.2402711,2.141284,-1.203359,-4.945188,1.437221,-.0809675,-1.028378,1.004164,-1.073337,-.1516517,1.639379,2.304669,-3.214244,1.286245,.05613957,2.480902,.4999363,-1.128399,-.1857793,-10.89863,11.72984,-.03768099,.9439285,.04869335,4.845114,.6119211,-1.114002,-.139928,4.9638,-4.6855,-.07780879,.4049736,.1586297,7.770264,.3449006,-1.185472,-.3403543,.6588322,1.133713,-.4118674,2.061191,-.1882768,-4.372586,1.22353,-1.002272,.02000703,.07073269,1.485075,.5005589,.4301494,.3626541,7.921098,.1574766,-1.121006,-.3007777,2.242051,-4.571561,-7.761071,2.053404,-.1524018,-1.886162,1.018208,-1.058864,-.1358673,1.389667,8.633409,-3.437249,.7295429,.15147,2.842513,.5014325,-1.144464,-.2043799,-10.20188,10.71247,-.03256693,.7860205,.06872719,4.824771,.6259836,-1.170104,-.2118626,4.391405,-4.1989,-.07111559,.3890442,.1024831,6.282535,.5365688,-1.129171,-.255288,.2238298,.7314295,-.356273,1.881931,-.03078716,-1.03912,.9096301,-1.042294,.004450203,-.5116033,2.627589,.6098996,-.1264638,.4325281,7.080503,.4583646,-1.082293,-.2723056,2.065076,-8.143133,-7.892212,2.142231,-.0710624,-1.122398,.8338505,-1.071715,-.1426568,1.095351,17.29783,-3.851931,.4360514,.211444,2.970832,.5944389,-1.195909,-.2590449,-11.91037,12.07947,-.01589842,.6297846,.09054772,4.285959,.5933752,-1.245763,-.3316637,4.29366,-3.694011,-.04699947,.4843684,.02130425,4.097549,.6530809,-1.148742,-.1902509,-.2393233,-.2441254,-.2610918,1.846988,.03532866,2.660106,.8358294,-1.01608,-.0744496,-.5053436,4.388855,.6054987,-1.2083,.5817215,2.54357,.4726568,-1.072027,-.210144,1.518378,-10.60119,-6.016546,2.649475,-.05166992,1.571269,.8344622,-1.072365,-.1511201,.747801,19.00732,-3.950387,-.3473907,.3797211,2.782949,.6296808,-1.239423,-.3136289,-13.511,13.49468,-.007070423,.5012315,.1106008,3.803619,.5577948,-1.452524,-.5676944,2.993153,-2.277288,-.02168954,.305672,.01152338,1.852697,.6427228,-1.061421,-.04590521,.6057022,-1.096835,-.1504952,2.344921,-.05491832,5.268322,.9082253,-1.042373,-.1769498,-1.075388,3.831712,.315414,-2.416458,.7909032,-.01492892,.3854049,-1.064159,-.1892684,1.438685,-8.166362,-3.616364,3.275206,-.1203825,2.039491,.8688057,-1.07012,-.1569508,.412476,13.99683,-3.547085,-1.046326,.4973825,2.791231,.6503286,-1.283579,-.3609518,-13.35397,13.15248,-.0004431938,.3769526,.1429824,3.573613,.4998696,-1.657952,-.7627948,1.958222,-.7949816,-.02882837,.5356149,-.05191946,.8869955,.626332,-.95276,.06494189,.5361303,-2.12959,-.0925863,1.604776,.0506777,6.376055,.9138052,-1.080827,-.252312,-.7154262,4.120085,.1878228,-1.492158,.6881655,-1.446611,.4040631,-1.054075,-.1665498,.9191052,-6.636943,-1.894826,2.10781,-.03680499,2.655452,.841384,-1.061127,-.1448849,.2667493,10.34103,-4.285769,-.3874504,.5998752,3.132426,.6652753,-1.347345,-.4287832,-9.305553,9.133813,-.003173527,.3977564,.115142,3.320564,.4998134,-1.927296,-.9901372,-2.593499,4.087421,-.05833993,.8158929,-.04681279,.2423716,.4938052,-.9470092,.07325237,2.064735,-5.16754,-.01313751,.4832169,.1126295,6.970522,1.035022,-1.022557,-.2762616,-.9375748,6.696739,.2200765,-.1133253,.5492505,-3.109391,.3321914,-1.087444,-.1836263,.6225024,-8.576765,-1.107637,.7859427,.09910909,3.112938,.8596261,-1.051544,-.1546262,.2371731,12.00502,-4.527291,.07268862,.5571478,2.532873,.6662,-1.375576,-.4840019,-8.12129,8.05814,-.01445661,.5123314,.05813321,3.203219,.5442318,-2.325221,-1.241463,-7.06343,8.741369,-.0782995,.8844273,-.03471106,.1740583,.2814079,-1.2287,-.2013412,2.949042,-7.371945,.1071753,-.249197,.2265223,6.391504,1.172389,-.7601786,-.1680631,-.7584444,8.541356,.08222291,.6729633,.3206615,-3.70094,.2710054,-1.191166,-.2672347,.2927498,-9.713613,-.4783721,.2352803,.2161949,2.691481,.8745447,-1.030135,-.1653301,.2263443,12.96157,-4.650644,.007055709,.5091975,2.00037,.6603839,-1.508018,-.6460933,-6.402745,6.545995,-.0375032,.6921803,.003309819,2.797527,.6978446,-2.333308,-1.167837,-17.46787,18.6863,-.008948229,.5621946,-.03402626,1.217943,.01149865,-2.665953,-1.226307,7.169725,-11.59434,.0358342,-.3074378,.3412248,4.422122,1.283791,-.09705116,.08312991,-2.160462,10.28235,.03543357,1.032049,.105831,-2.972898,.2418628,-1.329617,-.3699557,.5560117,-9.730113,.09938865,-.3071488,.2510691,1.777111,.8705142,-1.019387,-.1893247,.1194079,12.39436,-4.799224,.2940213,.4841268,1.529724,.6582615,-1.896737,-1.005442,-6.411032,6.54822,-.03227596,.5717262,-8115192e-12,2.296704,.9000749,-2.411116,-1.225587,-17.53629,18.29393,.01247555,.2364616,-.005114637,1.603778,-.2224156,-4.707121,-2.074977,7.9423,-11.32407,-.05415654,.5446811,.1032493,4.010235,1.369802,.1010482,-.4013305,-2.674579,9.779409,.1782506,.7053045,.4200002,-2.400671,.1953165,-1.243526,-.3391255,.8848882,-9.789025,-.3997324,-.9546227,-.1044017,.6010593,.8714462,-1.014633,-.1730009,-.07738934,13.90903,-4.847307,1.076059,.5685743,1.572992,.6561432,-1.122998,-.1881183,-10.30709,11.58932,-.04079495,.9603774,.03079436,4.009235,.5060745,-1.13479,-.1539688,5.478405,-4.21727,-.1043858,.7165008,.01524765,6.473623,.4207882,-1.134957,-.3513318,.7393837,1.354415,-.4764078,1.690441,-.0549264,-5.563523,1.145743,-1.058344,-.05758503,1.16823,.3269824,.1795193,.7849011,.07441853,6.904804,.281879,-1.075194,-.2355813,2.463685,-1.536505,-7.505771,.9619712,-.06465851,-1.355492,.8489847,-1.07903,-.1465328,1.773838,2.310131,-3.136065,.3507952,.04435014,2.819225,.5689008,-1.125833,-.1870849,-9.555833,10.59713,-.04225402,.9164663,.04338796,4.40098,.6056119,-1.12744,-.1551891,4.755621,-4.408806,-.07851763,.2268284,.146007,7.048003,.3525997,-1.143788,-.3170178,.5480669,2.04183,-.4532139,2.302233,-.1887419,-4.489221,1.250967,-1.032849,.007376031,.5666073,-.2312203,.4862894,-.1748294,.357287,8.380522,.1302333,-1.093728,-.2786977,2.641272,-1.507494,-8.731243,1.684055,-.2023377,-2.176398,1.013249,-1.076578,-.1456205,1.693935,2.945003,-2.822673,-.2520033,.1517034,2.649109,.5179094,-1.146417,-.2119353,-7.187525,8.058599,-.05256438,.8375733,.03887093,4.222111,.6695347,-1.173674,-.2067025,2.899359,-2.804918,-.08473899,.003944225,.1340641,6.160887,.4527141,-1.090098,-.2599633,.9180856,1.09271,-.4215019,2.42766,-.09277667,-2.123523,1.058159,-1.08446,.008056181,-.245351,.6619567,.4668118,-.9526719,.4648454,8.001572,.3054194,-1.053728,-.2765784,2.792388,-3.489517,-8.150535,2.195757,-.2017234,-2.128017,.9326589,-1.099348,-.1593939,1.568292,7.247853,-2.933,-.5890481,.172444,2.433484,.5736558,-1.185983,-.2581184,-7.761056,8.317053,-.03351773,.6676667,.05941733,3.820727,.6324032,-1.268591,-.3398067,2.348503,-2.023779,-.05368458,.1083282,.08402858,3.910254,.5577481,-1.071353,-.1992459,.7878387,.1974702,-.3033058,2.335298,-.08205259,.7954454,.9972312,-1.089513,-.03104364,-.5995746,2.330281,.6581939,-1.821467,.6679973,5.090195,.3125161,-1.040214,-.2570934,2.660489,-6.506045,-7.053586,2.763153,-.2433632,-.7648176,.9452937,-1.116052,-.1831993,1.457694,11.63608,-3.216426,-1.045594,.2285002,1.817407,.5810396,-1.230134,-.3136264,-8.909301,9.145006,-.01055387,.4467317,.1016826,3.342964,.563384,-1.442907,-.5593147,2.156447,-1.241657,-.0351213,.3050274,.01797175,1.742358,.5977153,-1.027627,-.06481539,.4351975,-1.051677,-.2030672,1.942684,-.03615993,4.050266,.9801624,-1.08211,-.1578209,-.3397511,4.163851,.6650368,-1.84173,.7062544,.6789881,.3172623,-1.047447,-.197756,2.183364,-8.805249,-5.483962,2.551309,-.177964,1.519501,.9212536,-1.111853,-.1935736,1.394408,13.92405,-3.46543,-1.068432,.2388671,1.455336,.6233425,-1.262238,-.3546341,-10.08703,10.20084,-.001852187,.353758,.1239199,3.056093,.5132052,-1.61381,-.7355585,2.760123,-1.685253,-.02517552,.2914258,.004743448,.8689596,.5674192,-.9462336,.02950767,-.2613816,-.7398653,-.1315558,1.901042,-.06447844,4.969341,1.027342,-1.111481,-.2194054,-.09004538,3.983442,.4871278,-1.965315,.7956121,-.2363225,.2718037,-1.036397,-.1827106,1.964747,-8.870759,-4.208011,2.461215,-.2158905,1.561676,.9436866,-1.113769,-.1947819,1.30072,15.16476,-4.088732,-1.069384,.2836434,1.671451,.6229612,-1.328069,-.4244047,-8.41704,8.552244,-.006813504,.4127422,.09619897,2.854227,.505988,-1.927552,-1.02529,.9529576,.425595,-.03738779,.2584586,.04911004,-.2640913,.4138626,-.8488094,.1435988,.6356807,-2.895732,-.08473961,1.701305,-.1323908,6.499338,1.210928,-1.128313,-.3397048,-.404314,6.265097,.5482395,-2.057614,.8884087,-2.943879,.09760301,-1.039764,-.1494772,1.781915,-11.53012,-3.379232,2.517231,-.2764393,2.588849,1.05212,-1.108447,-.2012251,1.19864,19.25331,-4.423892,-1.257122,.339569,1.48122,.5880175,-1.374185,-.4967434,-7.401318,7.724021,-.02345723,.5979653,.02436346,2.65897,.6014891,-2.310933,-1.29029,-1.301909,2.557806,-.03744449,.08982861,.1090613,-.4398363,.1184329,-1.12473,-.0992183,1.366902,-4.172489,-.05078016,1.393597,-.09323843,6.452721,1.435913,-.8468477,-.2744819,-.43472,6.713362,.6127133,-1.685634,.7360941,-4.535502,-.02920866,-1.165242,-.2008697,1.438778,-10.08936,-2.214771,2.102909,-.1763085,2.859075,1.09347,-1.074614,-.2066374,1.131891,16.30063,-4.801441,-1.11259,.3595785,1.122227,.579461,-1.521515,-.6835604,-5.571044,6.028774,-.04253715,.6875746,-5279456e-12,2.18015,.8487705,-2.240415,-1.171166,-7.182771,8.417068,-.01932866,.1101887,-.01098862,.6242195,-.2393875,-2.712354,-1.19883,3.1802,-6.76813,-.002563386,.7984607,.2764376,4.695358,1.557045,-.03655172,-.02142321,-.913812,7.932786,.3516542,-.7994343,.1786761,-4.208399,.01820576,-1.36861,-.2656212,1.249397,-8.317818,-.8962772,1.423249,.1478381,2.19166,1.007748,-1.041753,-.2453366,1.061102,11.30172,-4.739312,-.9223334,.2982776,.6162931,.6080302,-1.989159,-1.09516,-2.91555,3.275339,-.05735765,.5742174,-7683288e-12,1.7634,.9001342,-2.07002,-1.086338,-10.95898,12.0696,.03780123,-.01774699,-.0005881348,1.333819,-.2605423,-5.249653,-2.38304,6.160406,-9.097138,-.1955319,1.651785,.0006016463,3.021824,1.493574,.4685432,-.2358662,-2.666433,9.685763,.5804928,-1.521875,.5668989,-1.548136,.01688642,-1.296891,-.3449031,1.928548,-11.6756,-1.627615,1.355603,-.1929074,-.6568952,1.009774,-1.067288,-.2410392,.7147961,17.8384,-4.374399,-.6588777,.3329831,1.012066,.6118645],mT=[-1.310023,-.4407658,-36.4034,36.83292,-.008124762,.5297961,.01188633,3.13832,.5134778,-1.4241,-.5501606,-17.5351,18.22769,-.01539272,.6366826,.002661996,2.659915,.4071138,-1.103436,-.1884105,6.425322,-6.910579,-.02019861,.3553271,-.01589061,5.345985,.8790218,-1.1862,-.4307514,-3.957947,5.979352,-.05348869,1.736117,.03491346,-2.692261,.5610506,-1.006038,-.1305995,4.473513,-3.806719,.1419407,-.02148238,-.05081185,3.735362,.535828,-1.078507,-.1633754,-3.812368,4.3817,.02988122,1.754224,.1472376,3.722798,.4999157,-1.333582,-.4649908,-33.59528,34.04375,-.009384242,.5587511,.00572631,3.073145,.5425529,-1.562624,-.7107068,-14.7817,15.59839,-.01462375,.5050133,.02516017,1.604696,.2902403,-.8930158,.04068077,1.373481,-2.342752,-.02098058,.6248686,-.05258363,7.058214,1.150373,-1.262823,-.4818353,889261e-9,1.92312,-.04979718,1.040693,.1558103,-2.85248,.2420691,-.9968383,-.1200648,1.324342,-.9430889,.1931098,.4436916,-.07320456,4.215931,.7898019,-1.078185,-.1718192,-1.720191,2.358918,.02765637,1.260245,.2021941,3.395483,.5173628,-1.353023,-.4813523,-31.0492,31.40156,-.009510741,.554203,.008135471,3.136646,.5215989,-1.624704,-.7990201,-21.67125,22.46341,-.01163533,.5415746,.02618378,1.139214,.3444357,-.798361,.1417476,9.914841,-10.81503,-.01218845,.3411392,-.06137698,7.445848,1.18008,-1.266679,-.4288977,-5.818701,6.986437,-.08180711,1.397403,.2016916,-1.275731,.2592773,-1.009707,-.1537754,3.496378,-3.013726,.242115,-.2831925,.03003395,3.702862,.774632,-1.075646,-.1768747,-1.347762,1.989004,.01375836,1.76481,.1330018,3.230864,.662621,-1.375269,-.5103569,-34.42661,34.78703,-.008460009,.5408643,.004813323,3.016078,.5062069,-1.821679,-.9766461,-19.26488,19.97912,-.009822567,.3649556,.04316092,.893019,.4166527,-.6633542,.1997841,2.395592,-3.117175,-.01080884,.8983814,-.1375825,6.673463,1.115663,-1.30324,-.3612712,.08292959,.3381364,-.06078648,.3229247,.3680987,.7046755,.3144924,-.9952598,-.2039076,.4026851,.2686684,.1640712,.5186341,-.0120552,2.659613,.8030394,-1.098579,-.2151992,.6558198,-74369e-8,-.001421817,1.073701,.1886875,2.536857,.6673923,-1.457986,-.5906842,-38.12464,38.38539,-.006024357,.4741484,.01209223,2.818432,.5012433,-1.835728,-1.003405,-6.848129,7.601943,-.01277375,.4785598,.03366853,1.097701,.4636635,-.8491348,.009466365,-2.685226,2.00406,-.01168708,.6752316,-.1543371,5.674759,1.039534,-1.083379,-.150679,.7328236,-.5095568,-.08609153,.444882,.4174662,1.481556,.3942551,-1.117089,-.3337605,.2502281,.4036323,.2673899,.2829817,.0224245,2.043207,.7706902,-1.071648,-.21262,.6069466,-.00145629,-.551596,1.046755,.1985021,2.290245,.6876058,-1.483903,-.6309647,-43.80213,44.10537,-.005712161,.5195992,.002028428,2.687114,.5098321,-2.053976,-1.141473,.5109183,.08060391,-.01033983,.4066532,.04869627,1.161722,.4039525,-.6348185,.07651292,-10.31327,10.07598,-.02083688,.7359516,-.2029459,5.013257,1.077649,-1.22863,-.1650496,.04077157,-.7189167,-.0509222,.2959814,.5111496,2.540433,.361533,-1.041883,-.3278413,-.06691911,1.307364,.2166663,.3000595,-.003157136,1.389208,.7999026,-1.103556,-.2443602,.4705347,-.0009296482,-.530992,.9654511,.2142587,2.244723,.6839976,-1.555684,-.6962113,-46.47983,46.7427,-.005034895,.475509,-9502561e-13,2.626569,.5056194,-1.998288,-1.12472,-1.629586,2.187993,-.008284384,.3845258,.0572624,1.185644,.4255812,-1.03257,-.251385,-3.721112,3.506967,-.02186561,.9436049,-.2451412,4.725724,1.039256,-.8597532,.09073332,-2.553741,1.993237,-.04390891,-.2046928,.5515623,1.909127,.3948212,-1.210482,-.4477622,-.2267805,1.219488,.1336186,.6866897,.02808997,1.600403,.7816409,-1.078168,-.2699261,.2537282,.3820684,-.4425103,.5298235,.2185217,1.728679,.6882743,-1.697968,-.8391488,-57.90105,58.1412,-.00340476,.426514,-1796301e-12,2.368442,.5324429,-2.141552,-1.17223,16.77872,-16.4147,-.005732425,.2002199,.06841834,1.485338,.3215763,-1.442946,-.7264245,-9.503706,9.650462,-.02120995,1.419263,-.2893098,3.860731,1.120857,-.5696752,.3411279,-.2931035,-.6512552,-.1068437,-1.085661,.6107549,1.459503,.3210336,-1.313839,-.5921371,-.2332222,1.648196,.2492787,1.381033,-.01993392,.981256,.8316329,-1.087464,-.3195534,.2902095,.3383709,-.8798482,.01494668,.2529703,1.452644,.669387,-2.068582,-1.118605,-50.81598,50.97486,-.003280669,.4067371,-2544951e-12,2.179497,.5778017,-1.744693,-.8537207,22.34361,-22.08318,-.005932616,.1035049,.05742772,1.97788,.2124846,-3.287515,-2.140268,-12.49566,12.40091,-.02409349,1.397821,-.2371627,2.771192,1.170496,.5502311,1.04663,2.193517,-2.2204,-.1064394,-1.017926,.4795457,1.030644,.3177516,-1.719734,-.9536198,-.6586821,1.386361,-.02513065,1.187011,.06542539,.5296055,.808266,-1.0057,-.3028096,.04470957,1.00776,-.8119016,.03153338,.2311321,1.182208,.6824758,-2.728867,-1.580388,-30.79627,30.92586,-.004197673,.3154759,-3897675e-12,1.920567,.6664791,-1.322495,-.7249275,14.7766,-14.68154,-.009044857,.05624314,.06498392,2.047389,.0636754,-6.102376,-3.473018,-9.926071,9.637797,-.01097909,1.103498,-.2424521,2.520748,1.24026,1.351796,1.018588,2.009081,-1.333394,-.1979125,-.3318292,.4476624,.9095235,.2955611,-1.774467,-1.07988,-.0808468,.2577697,-.1149295,.4975303,.002931611,-.3803171,.8002794,-.9898401,-.2542513,-.07530911,1.870355,-1.521918,.2405164,.2964615,1.3348,.6789053,-1.27973,-.4290674,-42.77972,43.43305,-.006541826,.4945086,.01425338,2.685244,.5011313,-1.449506,-.5766374,-16.88496,17.81118,-.01121649,.354502,.02287338,1.904281,.4936998,-1.02198,-.1897574,2.482462,-2.941725,-.01570448,.7532578,-.042568,5.23966,.4983116,-1.162608,-.3428049,3.974358,-1.527935,-.03919201,.8758593,.07291363,-3.455257,.8007426,-.9929985,-.08712006,-.7397313,1.348372,.09511685,.3233584,-.07549148,5.806452,.4990042,-1.084996,-.1739767,.1580475,.908818,.06871433,.5933079,.1188921,3.074079,.4999327,-1.317009,-.4661946,-42.55347,43.12782,-.005727235,.4285447,.02189854,2.60831,.51907,-1.469236,-.6282139,-12.41404,13.48765,-.0120477,.5070285,-.0007280216,1.491533,.3635064,-.9713808,-.08138038,.3709854,-1.041174,-.01814075,.506086,-.02053756,6.161431,1.093736,-1.159057,-.3698074,2.711209,-.6006479,-.04896926,.9273957,.1137712,-3.496828,.2867109,-1.011601,-.0820189,.2105725,.459752,.1478925,.213894,-.0566067,6.057755,.7859121,-1.07802,-.181158,.1646622,.8348426,.1149064,.4985738,.1376605,2.746607,.4999626,-1.325672,-.4769313,-41.11215,41.68293,-.006274997,.4649469,.01119411,2.631267,.5234546,-1.619391,-.8000253,-15.34098,16.32706,-.01012023,.4242255,.02931597,.8925807,.3314765,-.7356979,.1368406,2.972579,-3.535359,-.01318948,.460762,-.07182778,6.2541,1.236299,-1.316217,-.4194427,.03489902,1.289849,-.0475596,1.138222,.1975992,-.8991542,.2290572,-.9502188,-.1172703,1.405202,-.3061919,.1058772,-.3760592,-.01983179,3.562353,.7895959,-1.100117,-.1900567,.492503,.5250225,.1576804,1.042701,.07330743,2.796064,.6749783,-1.354183,-.5130625,-42.19268,42.71772,-.005365373,.4136743,.01235172,2.520122,.5187269,-1.741434,-.9589761,-8.230339,9.296799,-.009600162,.4994969,.02955452,.3667099,.3526999,-.6917347,.2154887,-.8760264,.2334121,-.01909621,.4748033,-.1138514,6.51536,1.225097,-1.293189,-.42187,1.620952,-.7858597,-.0376941,.6636786,.3364945,-.5341017,.2128347,-.9735521,-.1325495,1.007517,.2598258,.06762169,.001421018,-.06915987,3.185897,.8641956,-1.0948,-.1962062,.5755591,.2906259,.2625748,.7644049,.1347492,2.677126,.646546,-1.393063,-.5578338,-41.85249,42.33504,-.00543564,.4743765,.007422477,2.442801,.5211707,-1.939487,-1.128509,-8.974257,9.978383,-.007965597,.294883,.04436763,.2839868,.3440424,-.6011562,.2354877,-3.07982,2.585094,-.02002701,.7793909,-.1598414,5.834678,1.202856,-1.315676,-.3903446,1.7019,-1.304609,-.01045121,.2747707,.4143967,.3197102,.263758,-.9618628,-.1625841,1.187138,.1497802,-5590954e-12,.03178475,-.04153145,2.496096,.8195082,-1.111554,-.2365546,.7831875,.2018684,.2074369,.7395978,.122573,1.876478,.6821167,-1.427879,-.5994879,-35.31016,35.81581,-.006431497,.4554192,.0007348731,2.334619,.5233377,-1.998177,-1.206633,-21.4651,22.42237,-.005857596,.2755663,.06384795,.1358244,.3328437,-.644063,.2058571,2.155499,-2.587968,-.01840023,.8826555,-.2222452,5.847073,1.228387,-1.229071,-.3360441,-.3429599,.6179469,.00202961,.08899319,.5041624,.1882964,.225204,-1.022905,-.2101621,1.915689,-.6498794,-.03463651,.08954605,-.06797854,2.417705,.8568618,-1.082538,-.2007723,.4731009,.4077267,.1324289,.651488,.1702912,2.309383,.6600895,-1.472139,-.6499815,-34.28465,34.69659,-.005747023,.4174167,.001688597,2.323046,.5395191,-2.161176,-1.353089,-22.26827,23.29138,-.005583808,.2364793,.06096656,.001944666,.2861624,-.6593044,.1393558,4.698373,-5.193883,-.0199839,1.095635,-.2391254,5.598103,1.236193,-1.195717,-.2972715,.04648953,.3024588,.005003313,-.3754741,.5247265,-.1381312,.2493896,-1.020139,-.2253524,.3548437,.7030485,-.02107076,.4581395,-.03243757,2.453259,.8323623,-1.09877,-.243578,.8761614,.1941613,-.1990692,.3761139,.1657412,1.590503,.6741417,-1.648007,-.8205121,-44.35106,44.79801,-.004181353,.385483,-1842385e-12,2.000281,.5518363,-2.140986,-1.282239,-3.979213,4.672459,-.005008582,.242192,.06253602,.6612713,.2555851,-1.300502,-.5137898,.5179821,-.4032341,-.02066785,1.087929,-.2615309,4.225887,1.229237,-.696334,.0924106,.06936356,-.3588571,-.05461843,-.5616643,.5484166,-.04776267,.2414935,-1.233179,-.4325498,.6479813,.8368356,.2458875,.6464752,-.02897097,1.561773,.8518598,-1.051023,-.253369,1.004294,.3028083,-1.520108,.1607013,.1619975,1.131094,.6706655,-1.948249,-1.097383,-44.53697,44.94902,-.003579939,.3491605,-2500253e-12,1.740442,.6188022,-2.154253,-1.209559,4.144894,-3.562411,-.005638843,.1067169,.07594858,1.00528,.1072543,-2.513259,-1.507208,-1.602979,1.404154,-.00556075,1.24049,-.2852117,3.485252,1.349321,-.07832214,.3655626,.3856288,.6867894,-.1609523,-.6704306,.5357301,-.6457935,.1479503,-1.354784,-.5454375,.8797469,-1.466514,.713442,.5934903,-.02911178,.8643737,.9030724,-1.048324,-.2738736,.8783074,3.246188,-4.435369,.1251791,.1783486,1.064657,.6522878,-2.770408,-1.618911,-25.04031,25.31674,-.004239279,.3241013,-3764484e-12,1.586843,.7035906,-1.9135,-1.144014,-10.80587,11.53677,-.01003197,.1577515,.05217789,1.225278,.005172771,-5.293208,-2.876463,2.087053,-3.201552,.003892964,.532393,-.2034512,2.61776,1.273597,.906034,.3773409,-.6399945,3.213979,-.09112172,.6494055,.395328,.5047796,.2998695,-1.482179,-.677831,1.161775,-3.004872,.4774797,-.4969248,-.003512074,-1.30719,.7927378,-.9863181,-.1803364,.5810824,4.58057,-3.863454,.5328174,.2272821,1.771114,.6791814],gT=[1.560219,1.417388,1.206927,10.91949,5.931416,7.304788,1.533049,1.560532,.3685059,13.5504,5.543711,7.792189,1.471043,1.746088,-.9299697,17.20362,5.473384,8.336416,1.355991,2.109348,-3.295855,22.64843,5.454607,9.304656,1.244963,2.547533,-5.841485,27.56879,5.576104,10.43287,1.175532,2.784634,-7.212225,29.75347,6.47298,10.92331,1.082973,3.118094,-8.934293,31.86879,8.473885,11.74019,.96925,3.349574,-10.0381,31.47654,13.38931,12.72547,.8547044,3.151538,-9.095567,25.54995,22.73219,14.10398,.758034,2.311153,-5.170814,12.29669,36.86529,15.98882,1.664273,1.574468,1.422078,9.768247,14.47338,16.44988,1.638295,1.719586,.5786675,12.39846,14.15419,17.28605,1.572623,1.921559,-.7714802,16.09246,14.20954,18.25908,1.468395,2.21197,-2.845869,20.75027,15.24822,19.37622,1.355047,2.556469,-4.96092,24.60237,16.4836,20.65648,1.291642,2.742036,-6.061967,26.02002,18.19144,21.16712,1.194565,2.97212,-7.295779,26.91805,21.2488,22.01819,1.083631,3.047021,-7.766096,24.96261,27.44264,22.91875,.9707994,2.736459,-6.308284,17.6086,37.76291,23.9215,.8574294,1.865155,-2.364707,4.337793,50.92831,25.23432],vT=[1.632341,1.39523,1.375634,12.38193,5.921102,7.766508,1.597115,1.554617,.3932382,15.05284,5.725234,8.158155,1.522034,1.844545,-1.322862,19.18382,5.440769,8.837119,1.403048,2.290852,-4.013792,24.851,5.521888,9.845547,1.286364,2.774498,-6.648221,29.64151,5.923777,10.97075,1.213544,3.040195,-8.092676,31.86082,6.789782,11.58899,1.122622,3.347465,-9.649016,33.43824,9.347715,12.31374,1.007356,3.543858,-10.5352,32.39842,14.83962,13.31718,.8956642,3.2787,-9.254933,25.57923,24.89677,14.76166,.7985143,2.340404,-4.928274,11.41787,39.61501,16.82448,1.745162,1.639467,1.342721,11.66033,14.90124,17.74031,1.708439,1.819144,.2834399,14.48066,14.59214,18.58679,1.63172,2.094799,-1.378825,18.43198,14.63173,19.62881,1.516536,2.438729,-3.624121,22.98621,15.99782,20.70027,1.405863,2.785191,-5.705236,26.45121,17.6833,21.91903,1.344052,2.951807,-6.683851,27.44271,19.85706,22.29452,1.245827,3.182923,-7.82296,27.91395,23.27254,23.1591,1.132305,3.202593,-8.008429,25.21093,30.00014,24.05306,1.02033,2.820556,-6.238704,17.09276,40.77916,25.09949,.903157,1.863917,-1.955738,3.032665,54.3429,26.4178],_T=[1.168084,2.156455,-3.980314,19.89302,13.28335,14.35621,1.135488,2.294701,-4.585886,20.90208,13.4784,14.67658,1.107408,2.382765,-5.112357,21.47823,14.93128,14.60882,1.054193,2.592891,-6.115,22.68967,16.35672,15.18999,1.006946,2.70542,-6.69893,22.9183,18.34324,15.70651,.9794044,2.74244,-6.805283,22.25271,20.50797,15.6313,.9413577,2.722009,-6.760707,20.98242,23.42588,16.05011,.8917923,2.59278,-6.152635,17.74141,28.58324,16.5791,.8288391,2.153434,-4.118327,10.78118,36.8171,17.38139,.7623528,1.418187,-.8845235,.7590129,46.29859,19.21657,1.352858,2.048862,-2.053393,14.05874,30.45344,30.4443,1.330497,2.126497,-2.466296,14.67559,30.90738,30.69707,1.286344,2.200436,-2.877228,14.92701,32.36288,30.77223,1.234428,2.289628,-3.404699,14.99436,34.6839,30.84842,1.17866,2.306071,-3.549159,14.11006,37.54188,30.7973,1.151366,2.333005,-3.728627,13.63374,39.05894,30.92599,1.101593,2.299422,-3.565787,11.96745,41.88472,31.02755,1.038322,2.083539,-2.649585,8.037389,47.00869,30.65948,.9596146,1.67147,-.8751538,1.679772,53.45784,30.5452,.8640731,.9858301,1.854956,-6.798097,59.36468,31.10255],AT=[pT,fT,mT],xT=[gT,vT,_T],_1={getTableValue:function(a,e,t,n,i){var o=540*e,r=54*(t-1),s=9*n;return AT[a][o+r+s+i]},getTableValueRad:function(a,e,t,n){var i=60*e,o=6*(t-1);return xT[a][i+o+n]}},gm=9;function Bl(a,e,t,n,i){return A1(a).reduce(function(o,r,s){return o+r*_1.getTableValue(e,t,n,s,i)},0)}function Dl(a,e,t,n){return A1(a).reduce(function(i,o,r){return i+o*_1.getTableValueRad(e,t,n,r)},0)}function A1(a){var e=Math.pow(2*a/Math.PI,.3333333333333333);return[Math.pow(1-e,5),5*Math.pow(1-e,4)*e,10*Math.pow(1-e,3)*Math.pow(e,2),10*Math.pow(1-e,2)*Math.pow(e,3),5*(1-e)*Math.pow(e,4),Math.pow(e,5)]}var Vr={getDistParams:function(a,e,t,n){for(var i=new Array(gm),o=Math.trunc(a),r=a-o,s=0;s<gm;s++){var l=Bl(t,n,0,o,s),c=Bl(t,n,1,o,s);if(i[s]=(1-e)*(1-r)*l+e*(1-r)*c,o!=10){var d=Bl(t,n,0,o+1,s),u=Bl(t,n,1,o+1,s);i[s]+=(1-e)*r*d+e*r*u}}return i},getRadiance:function(a,e,t,n){var i=Math.trunc(a),o=a-i,r=(1-e)*(1-o)*Dl(t,n,0,i)+e*(1-o)*Dl(t,n,1,i);return i!=10&&(r+=(1-e)*o*Dl(t,n,0,i+1)+e*o*Dl(t,n,1,i+1)),r}};class au extends La{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const o=this.resultBuffer,r=this.sampleValues,s=this.valueSize,l=e*s,c=l-s,d=(n-t)/(i-t),u=1-d;for(let h=0;h!==s;++h)o[h]=r[c+h]*u+r[l+h]*d;return o}}var yT=[.1787,-1.463,-.3554,.4275,-.0227,5.3251,.1206,-2.5771,-.067,.3703],bT=[-.0193,-.2592,-.0665,8e-4,-4e-4,.2125,-.0641,-.8989,-.0033,.0452],CT=[-.0167,-.2608,-.095,.0092,-.0079,.2102,-.0441,-1.6537,-.0109,.0529],ST=[4.0453,-4.971,-.2155,2.4192],MT=[.00166,-.00375,.00209,0,-.02903,.06377,-.03202,.00394,.11693,-.21196,.06052,.25886],ET=[.00275,-.0061,.00317,0,-.04214,.0897,-.04153,.00516,.15346,-.26756,.0667,.26688],wT=[yT,bT,CT],TT=[ST,MT,ET],Nl={getTableValue:function(a,e,t){return wT[a][2*e+t]},getTableDataZenith:function(a){return TT[a]}},vm=5,IT=.06;function _m(a,e,t){return(1+a[0]*Math.exp(a[1]/Math.cos(e)))*(1+a[2]*Math.exp(a[3]*t)+a[4]*Math.pow(Math.cos(t),2))}function RT(a){return .212671*a+.71516*a+.072169*a}var Fn={getDistParams:function(a,e){for(var t=new Array(vm),n=0;n<vm;n++)t[n]=Nl.getTableValue(e,n,0)*a+Nl.getTableValue(e,n,1);return t},getZenithParams:function(a,e,t){switch(t){case 0:var n=Nl.getTableDataZenith(t),i=new Re(n[0],n[1],n[2],n[3]),o=Math.tan((4/9-a/120)*(Math.PI-2*e)),r=new Re(a*o,o,a,1);return i.dot(r)*IT/_m(this.getDistParams(a,t),0,e);case 1:case 2:n=Nl.getTableDataZenith(t);var s=Math.pow(e,2),l=Math.pow(e,3),c=n[0]*l+n[1]*s+n[2]*e+n[3],d=n[4]*l+n[5]*s+n[6]*e+n[7],u=n[8]*l+n[9]*s+n[10]*e+n[11];return i=new b(c,d,u),new b(Math.pow(a,2),a,1).dot(i)/_m(this.getDistParams(a,t),0,e)}},getSunIlluminance:function(a,e){var t=[0,0,0];if(a[1]<0)return t;for(var n=[.605,.54,.445],i=[12.25,7.5,.3],o=.04608*e-.04586,r=1/(a[1]+.15*Math.pow(93.885-Math.acos(a[1])*(180/Math.PI),-1.253)),s=[1.05513096,.993359745,.903543472],l=0;l<3;l++){var c=Math.exp(.008735*-r*Math.pow(n[l],-4.08)),d=Math.exp(-r*o*Math.pow(n[l],-1.3)),u=Math.exp(.0035*-i[l]*r);t[l]=128e3*s[l]/RT(s[l]),t[l]*=c*d*u}return t},getSunIntegral:function(a,e,t,n){var i=a,o=e,r=t;function s(u){return u*u}var l=1-cos(i),c=((s(Math.PI)-2*s(i-o))*cos(i)-s(Math.PI)*cos(o))/(2*(i-o+Math.PI)*(-i+o+Math.PI)),d=r*((.0892351-.00247875*s(r))*sin(r)+cube(r)+24*r+.029745*r*cos(r))/s(s(r)+36);return 2*Math.PI*(l+c+n*d)}};class Bi{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(Ye(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}const LT=1500/Math.PI,ed={LAMBERT_AR:2,STANDARD_SURFACE_AR:24,BEVEL_BL:1,BSDF_DIFFUSE_BL:2,BSDF_GLASS_BL:3,BSDF_GLOSSY_BL:4,"BSDF_GLOSSY_BL_<4.0_BL":2,BSDF_PRINCIPLED_BL:5,"BSDF_PRINCIPLED_<4.0_BL":22,BSDF_REFRACTION_BL:3,BSDF_SHEEN_BL:2,BSDF_TRANSLUCENT_BL:1,BUMP_BL:3,"BUMP_BL_<3.2_BL":5,EEVEE_SPECULAR_BL:5,FRESNEL_BL:1,LAYER_WEIGHT_BL:1,SAMPLER_INFO_MY:0,LAMBERT_MY:5,BLINN_MY:5,PHONG_MY:5,PHONG_E_MY:5};class wt extends Ut{constructor(e){super();const t=this;function n(E,F){const U=E.node(F);U.originData.type;for(let B=0;B<U.originData.inputs.length;B++)i(E,F,U.originData,B)}function i(E,F,U,B,Z){if(nt(E,F,B))return!1;Z=Z||"Input "+B;const k=U.inputs[B],X={name:U.name+" "+Z,type:"",inputs:[],outputs:[]};switch(H(k)){case"float":X.type="VALUE"+U.type.slice(-3),X.outputs.push(k);break;case"vec3":X.type="RGB"+U.type.slice(-3);const y=k.slice();y.push(1),X.outputs.push(y);break;case"vec4":X.type="RGB"+U.type.slice(-3),X.outputs.push(k);break;default:throw new Error("Unsupported group input")}E.addNode({originData:X});const P=new Mn(E.len()-1,F,0);P.connections=[];const v={from:0,to:B};return P.connections.push(v),E.addEdge(P),!0}function o(E,F,U){const B={inputs:[],outputs:[],removedNodes:[]};B.removedNodes.push(U);const Z=Gr(F,"GROUP_INPUT_BL");if(Z>-1){B.removedNodes.push(Z+E.len());const v=E.findInEdges(U),y=F.findOutEdges(Z);for(let R=0;R<v.length;R++){const w=v[R];for(let I=0;I<y.length;I++){const C=y[I];for(let D=0;D<w.connections.length;D++){const O=w.connections[D];for(let Y=0;Y<C.connections.length;Y++){const J=C.connections[Y];if(O.to==J.from){let G=s(B.inputs,w.from(),C.to());G||(G=new Mn(w.from(),C.to(),0),G.connections=[],B.inputs.push(G));const K={from:O.from,to:J.to};G.connections.push(K)}}}}}}const k=Gr(F,"GROUP_OUTPUT_BL");B.removedNodes.push(k+E.len());const X=E.findOutEdges(U),P=F.findInEdges(k);for(let v=0;v<X.length;v++){const y=X[v];for(let R=0;R<P.length;R++){const w=P[R];for(let I=0;I<y.connections.length;I++){const C=y.connections[I];for(let D=0;D<w.connections.length;D++){const O=w.connections[D];if(C.from==O.to){let Y=s(B.outputs,w.from(),y.to());Y||(Y=new Mn(w.from(),y.to(),0),Y.connections=[],B.outputs.push(Y));const J={from:O.from,to:C.to};Y.connections.push(J)}}}}}return B}function r(E,F){Array.isArray(F)||(F=[F]);let U=0;for(let B=0;B<E.len();B++){const Z=E.node(B);for(let k=0;k<F.length;k++){const X=F[k];Z.originData.type==X&&U++}}return U}function s(E,F,U){for(let B=0;B<E.length;B++){const Z=E[B];if(Z.from()==F&&Z.to()==U)return Z}return null}function l(E,F,U){const B=U.type;let Z=E.findInEdges(F);for(let k=0;k<Z.length;k++){const X=Z[k];let P=E.node(X.from()).originData;for(let v=0;v<X.connections.length;v++){const y=X.connections[v];if(B=="MATERIAL_MX"&&d(P.type)&&(y.to==9?P.reflectMode="MAX_ENV_COORDS_REFLECT":y.to==10&&(P.reflectMode="MAX_ENV_COORDS_REFRACT")),u(B,y.to)){if(P.type=="BITMAP_MX"||P.type=="OUTPUT_MAP_MX"){E.removeEdge(X.from(),X.to()),P.type=="OUTPUT_MAP_MX"&&(P=Wi(E,X.from(),0).originData);const R={originData:{name:P.name+"Bump"+k,type:"BUMP_MX",texture:P.texture,uvIndex:P.uvIndex,inputs:JSON.parse(JSON.stringify(P.inputs)),outputs:[[0,0,0]]}};E.addNode(R),Xe(E,E.len()-1,0,F,y.to),k=-1,Z=E.findInEdges(F);break}for(let R=0;R<E.len();R++){const w=E.node(R).originData;if(c(w.type)){const I=w.inputs.length-1;Xe(E,X.from(),y.from,R,I),w.inputFactors[I]=U.inputFactors[y.to]}}}}}}function c(E){return!(!d(E)&&E!="FALLOFF_MX")}function d(E){return E=="BITMAP_ENV_MX"||E=="REFLECT_REFRACT_MX"}function u(E,F){switch(E){case"BITMAP_ENV_MX":return F==5;case"FALLOFF_MX":return F==2;case"MATERIAL_MX":return F==8;case"PHYSICAL_MX":return F==21||F==22;case"REFLECT_REFRACT_MX":return F==0;default:return!1}}function h(E,F,U){const B=U.blendMode.length,Z=E.findInEdges(F),k=E.findOutEdges(F);for(let X=0;X<B;X++){const P={originData:{name:U.name+"Layer"+X,type:"COMPOSITE_LAYER_MX",blendMode:X!=0?U.blendMode[X]:0,opacity:U.opacity[X],inputs:[[0,0,0,0]].concat(U.inputs.slice(2*X,2*X+2)),outputs:[U.outputs[X]]}};E.addNode(P);for(let v=0;v<Z.length;v++){const y=Z[v];for(let R=0;R<y.connections.length;R++){const w=y.connections[R];w.to==2*X&&U.mapEnabled[X]?Xe(E,y.from(),w.from,E.len()-1,1):w.to==2*X+1&&U.maskEnabled[X]&&Xe(E,y.from(),w.from,E.len()-1,2)}}X>0&&Xe(E,E.len()-2,0,E.len()-1,0)}for(let X=0;X<k.length;X++){const P=k[X];for(let v=0;v<P.connections.length;v++){const y=P.connections[v];Xe(E,E.len()-1,0,P.to(),y.to)}}}function p(E,F,U){const B=U.output,Z=E.findInEdges(F),k=E.findOutEdges(F),X={originData:{name:U.name+"Output",type:"OUTPUT_MAP_MX",invert:B.invert,clamp:B.clamp,alphaFromRGB:B.alphaFromRGB,inputs:[[0,0,0,0],B.rgbLevel,B.rgbOffset,B.outputAmount,B.bumpAmount],outputs:[[0,0,0,0]]}};q(B.colorMap)&&(X.originData.colorMap=B.colorMap),E.addNode(X);for(let P=0;P<k.length;P++){const v=k[P];for(let y=0;y<v.connections.length;y++){const R=v.connections[y];Xe(E,E.len()-1,0,v.to(),R.to)}}E.disconnect(F,!1);for(let P=0;P<Z.length;P++)E.addEdge(Z[P]);Xe(E,F,0,E.len()-1,0),delete U.output}function m(E,F,U){const B=U.inputs.length/4,Z=E.findInEdges(F),k=E.findOutEdges(F);for(let X=0;X<B;X++){const P={originData:{name:U.name+"Layer"+X,type:"LAYERED_TEXTURE_LAYER_MY",inputs:[0,[0,0,0]].concat(U.inputs.slice(4*X,4*X+4)),outputs:[0,[0,0,0]]}};E.addNode(P);for(let v=0;v<Z.length;v++){const y=Z[v];for(let R=0;R<y.connections.length;R++){const w=y.connections[R];w.to==4*X?Xe(E,y.from(),w.from,E.len()-1,2,w.channelMatrix):w.to==4*X+1?Xe(E,y.from(),w.from,E.len()-1,3,w.channelMatrix):w.to==4*X+2?Xe(E,y.from(),w.from,E.len()-1,4,w.channelMatrix):w.to==4*X+3&&Xe(E,y.from(),w.from,E.len()-1,5,w.channelMatrix)}}X>0&&(Xe(E,E.len()-1,0,E.len()-2,0),Xe(E,E.len()-1,1,E.len()-2,1))}for(let X=0;X<k.length;X++){const P=k[X];for(let v=0;v<P.connections.length;v++){const y=P.connections[v];Xe(E,E.len()-B,y.from,P.to(),y.to,y.channelMatrix)}}}function f(E){return E.type.indexOf("uniform")>-1}function g(E){return E.type.indexOf("varying")>-1}function _(E,F){return F=q(F)?F:"color",t.nodeVCAliases[E]||F}function A(E,F,U,B){const Z=new Jn(E,F,1,U,B,yt.DEFAULT_MAPPING,mt,mt,Le,Le);return Z.needsUpdate=!0,Z}function x(E){return E.isVideoTexture===!0&&E.encoding===Ke?"1":"0"}function S(E,F,U,B,Z){let k;return F==U?k=E:F=="float"&&U=="vec3"?k="vec3("+[E,E,E].join(",")+")":F=="float"&&U=="vec4"?k="vec4("+[E,E,E,E].join(",")+")":F=="vec3"&&U=="float"||F=="vec4"&&U=="float"?k="("+[E+"[0]",E+"[1]",E+"[2]"].join("+")+")/3.0":F=="vec3"&&U=="vec4"?k="vec4("+E+", 1.0)":F=="vec4"&&U=="vec3"?k="vec3("+[E+"[0]",E+"[1]",E+"[2]"].join(",")+")":F=="float"&&U=="int"?k="int("+E+")":F=="int"&&U=="float"||F=="bool"&&U=="float"?k="float("+E+")":console.error("MeshNodeMaterial: Missing type conversion: "+F+" -> "+U),(Z<1||Z!=1&&B=="normal")&&(k="mix("+B+","+k+","+ae(Z)+")",B=="normal"&&(k="normalize("+k+")")),k}function M(E,F,U,B,Z){let k;const X=[],P=le(U),v=le(B);for(let y=0;y<v;y++){let R=v==1?Z:Z+"["+y+"]";for(let w=0;w<E.length;w++){const I=E[w],C=F[w];for(let D=0;D<P;D++)C[D][y]&&(R=P==1?I:I+"["+D+"]")}X.push(R)}return k=B+"("+X.join(",")+")",k}function T(E,F,U,B,Z,k){for(let X in E.edges){const P=E.edges[X];if(P.to()==F){const v=E.node(P.from());for(let y=0;y<P.connections.length;y++){const R=P.connections[y];if(R.to==U){const w=v.originData.type;w!="BITMAP_MX"&&w!="BITMAP_ENV_MX"||H(B)!="float"?Z.push(v.outputs[R.from]):Z.push(v.outputs[R.from+1]),R.channelMatrix&&k.push(R.channelMatrix)}}}}}function L(E){return{name:"",type:H(E),value:E}}function z(E,F){const U=wt.nodeTexUniName(E,F);return{name:U,type:t.nodeTextures[U].isCubeTexture?"uniform samplerCube":"uniform sampler2D",value:F}}function W(E){return{name:"",type:"int",value:E}}function V(E){return N(E?"true":"false")}function N(E){return{name:E,type:"",value:null}}function j(E,F,U){return U=U||E,{name:"_vary_par_"+E,type:"varying "+ne(F),value:null,attrBindName:U}}function oe(E){return E?1:0}function H(E){return typeof E=="number"?"float":typeof E=="boolean"?"bool":ne(E.length)}function ne(E){switch(E){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";case 9:return"mat3";case 16:return"mat4"}}function le(E){switch(E){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;case"mat3":return 9;case"mat4":return 16}}function re(E,F){switch(E){case"float":return ae(F);case"bool":case"int":return String(F);default:const U=[];for(let B=0;B<F.length;B++)U.push(ae(F[B]));return E+"("+U.join(",")+")"}}function ae(E){return E%1?String(E):String(E)+".0"}this.type="MeshNodeMaterial",this.defines={LIGHT_PATH_IS_CAM_RAY:1,WORLD_NODES:0,NORMAL_OUTPUT:0},this.definesFragOnly=["LIGHT_PATH_IS_CAM_RAY","WORLD_NODES","NORMAL_OUTPUT"],this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.fog=!0,this.profile="blender",this.nodeTextures={},this.nodeRGB=[],this.nodeRGBMap={},this.nodeRGBArr=null,this.nodeTexCoordObject=[],this.nodeTexCoordObjectMap={},this.nodeTexCoordObjectArr=null,this.nodeValue=null,this.nodeValueMap={},this.needsBoundingBox=!1,this.useFloatTex=!1,this.nodeGraph=null,this.additionalNodeGraphs={},this.nodeChunks={},this.nodeChunksHash=0,this.nodeVCAliases={},this.nodeUVAliases={},this.color=new me(16777215),this.envMap=null,this.envMapIntensity=1,this.envMapParallaxType=0,this.envMapParallaxMatrix=new Ae,this.envMapParallaxMatrixInv=new Ae,this.materialIndex=0,q(e)&&this.setValues(e),this.nodeGraph||(this.nodeGraph=function(){const E=new xt(1),F=t.color;return E.node(0).originData={name:"ShadelessOutput",type:"OUTPUT_MATERIAL_BL",inputs:[[F.r,F.g,F.b,1],[0,0,0,0],[0,0,0]],outputs:[],is_active_output:!0},E}()),this.updateNodeGraph=function(){t.nodeRGB=[],t.nodeRGBMap={},t.nodeTexCoordObject=[],t.nodeTexCoordObjectMap={},t.nodeValueMap={},t.needsBoundingBox=!1,t.nodeChunks={};const E=t.nodeGraph;t.nodeRGBArr=new Float32Array(4*r(E,["RGB_BL","RGB_MX","RGB_ALPHA"])),t.nodeTexCoordObjectArr=new Float32Array(16*r(E,"TEX_COORD_BL")),t.nodeValue=new Float32Array(r(E,["VALUE_BL","VALUE_MX","ANIM_CURVE_TA_MY","ANIM_CURVE_TU_MY","VALUE"])),function(F){let U=0,B=0,Z=0,k=0;for(let P=0;P<F.len();P++){const v=F.node(P),y=v.originData,R=y.type;let w,I,C,D,O,Y,J,G,K,ie,$,se,de,he,ee,ge,ve,_e;v.attributes=[],v.params=[],v.inputFactors=[],v.inputs=[],v.outputs=[],q(y.inputFactors)&&(v.inputFactors=y.inputFactors.slice(0));for(let we=0;we<y.outputs.length;we++){const Be=y.outputs[we],ke=y.outputTypes?y.outputTypes[we]:H(Be);v.outputs.push({name:R.toLowerCase()+"_out"+we+"_n"+P,type:ke,clamp:!1,normalize:!1})}switch(R!="OUTPUT_MATERIAL_BL"&&R!="OUTPUT_WORLD_BL"&&R!="OUTPUT_MX"&&R!="SHADING_ENGINE_MY"&&R!="SKYDOME_LIGHT_AR"||v.outputs.push({name:"outgoingLight",type:"",clamp:!1,normalize:!1}),R){case"ATAN_AR":v.params.push(N(y.units));break;case"CLAMP_AR":case"COLOR_TO_FLOAT_AR":case"COLOR_TO_FLOAT_AR":case"FLOAT_TO_INT_AR":case"LENGTH_AR":case"MIX_SHADER_AR":case"RGB_TO_FLOAT_AR":case"RGB_TO_VECTOR_AR":case"RGBA_TO_FLOAT_AR":case"RGB_TO_VECTOR_AR":case"VECTOR_TO_RGB_AR":v.params.push(N(y.mode));break;case"COLOR_CONVERT_AR":v.params.push(N(y.from)),v.params.push(N(y.to));break;case"CHECKERBOARD_AR":case"PLACE_2D_TEXTURE_MY":w=y.uvIndex?"uv"+String(y.uvIndex+1):"uv",I=j(w,2),v.attributes.push({name:w,type:"attribute vec2"}),v.params.push(I);break;case"COMPOSITE_AR":v.params.push(N(y.operation)),v.params.push(N(y.alphaOperation));break;case"FACING_RATIO_AR":case"FACING_RATIO_AR":case"SHADOW_MATTE_AR":case"NORMAL":v.params.push(N("normal"));break;case"COMPARE_AR":v.params.push(N(y.test));break;case"IMAGE_AR":C=z(R,y.texture),v.params.push(C),v.params.push(N(x(t.nodeTextures[C.name])));break;case"LAMBERT_AR":case"BSDF_GLASS_BL":case"BSDF_GLOSSY_BL":case"BLINN_MY":case"LAMBERT_MY":case"PHONG_MY":case"PHONG_E_MY":v.params.push(N("geometryNormal"));break;case"MAP_TO_MTL_AR":v.params.push(V(y.opaqueEnabled));break;case"NORMAL_MAP_AR":w="tangent",I=j(w,4),v.attributes.push({name:w,type:"attribute vec4"}),v.params.push(I);break;case"SHUFFLE_AR":case"CHANNELS_MY":v.params.push(N(y.channelR)),v.params.push(N(y.channelG)),v.params.push(N(y.channelB)),v.params.push(N(y.channelA));break;case"STANDARD_SURFACE_AR":v.params.push(N("geometryNormal")),v.params.push(V(y.thinWalled)),(y.inputs[15]>0||nt(F,P,15))&&(t.defines.USE_CLEARCOAT=""),(y.inputs[18]>0||nt(F,P,18))&&(t.defines.USE_SHEEN=""),v.inputFactors.length=0;break;case"TRIGO_AR":v.params.push(N(y.function)),v.params.push(N(y.units));break;case"TWO_SIDED_AR":v.params.push(N("faceDirection"));break;case"USER_DATA_COLOR_AR":w=_(y.colorLayer,""),w?(I=j(w,4),v.attributes.push({name:w,type:"attribute vec4"}),v.params.push(I)):v.params.push(N(re("vec4",y.defaultColor)));break;case"ATTRIBUTE_BL":case"VERTEX_COLOR_BL":w=_(y.colorLayer,""),w?(I=j(w,4),v.attributes.push({name:w,type:"attribute vec4"}),v.params.push(I)):v.params.push(N("vec4(0.0, 0.0, 0.0, 1.0)"));break;case"BSDF_PRINCIPLED_BL":v.params.push(N("geometryNormal")),y.inputs.length==25?((y.inputs[14]>0||nt(F,P,14))&&(t.defines.USE_CLEARCOAT=""),(y.inputs[12]>0||nt(F,P,12))&&(t.defines.USE_SHEEN_BLENDER_OLD="")):((y.inputs[17]>0||nt(F,P,17))&&(t.defines.USE_CLEARCOAT=""),(y.inputs[22]>0||nt(F,P,22))&&(t.defines.USE_SHEEN_BLENDER=""));break;case"BSDF_REFRACTION_BL":v.params.push(N("geometryNormal")),v.params.push(N("BSDF_REFRACTION_"+y.distribution));break;case"BUMP_BL":v.params.push(L(y.invert));break;case"CAMERA_BL":v.params.push(N("vViewPosition")),r(F,"OUTPUT_MATERIAL_BL")>0||r(F,"OUTPUT_WORLD_BL")>0?v.params.push(V(!0)):v.params.push(V(!1));break;case"CLAMP_BL":v.params.push(N(y.clampType=="RANGE"));break;case"COMBINE_COLOR_BL":v.params.push(N("NODE_COMB_COL_"+y.mode));break;case"CURVE_FLOAT_BL":t.useFloatTex?(D=new Float32Array(1024),O=1):(D=new Uint8Array(1024),O=255);for(let be=0;be<256;be++){let ct=O*(y.curveData[be]/2+.5);D[4*be]=Ye(ct,0,O)}J=A(D,256,Qe,t.useFloatTex?Ct:Ft),G=wt.nodeTexUniName(R,U),t.nodeTextures[G]=J,v.params.push(z(R,U)),U++;break;case"CURVE_RGB_BL":case"CURVE_VEC_BL":t.useFloatTex?(D=new Float32Array(1024),O=1):(D=new Uint8Array(1024),O=255);for(let be=0;be<256;be++){let ct,Ln,bn,Hn;ie=y.curveData.length/256,ie>3?(ct=O*y.curveData[ie*be],Ln=O*y.curveData[ie*be+1],bn=O*y.curveData[ie*be+2],Hn=O*y.curveData[ie*be+3]):(ct=O*(y.curveData[ie*be]/2+.5),Ln=O*(y.curveData[ie*be+1]/2+.5),bn=O*(y.curveData[ie*be+2]/2+.5),Hn=O),D[4*be]=Ye(ct,0,O),D[4*be+1]=Ye(Ln,0,O),D[4*be+2]=Ye(bn,0,O),D[4*be+3]=Ye(Hn,0,O)}J=A(D,256,Qe,t.useFloatTex?Ct:Ft),G=wt.nodeTexUniName(R,U),t.nodeTextures[G]=J,v.params.push(z(R,U)),U++;break;case"EEVEE_SPECULAR_BL":v.params.push(N("geometryNormal")),(y.inputs[6]>0||nt(F,P,6))&&(t.defines.USE_CLEARCOAT="");break;case"FRESNEL_BL":case"LAYER_WEIGHT_BL":case"INCIDENT":case"POSITION":v.params.push(N("vViewPosition"));break;case"GRADIENT_MX":v.params.push(N(re("float",y.color2Pos))),v.params.push(N(re("int",y.gradientType))),w=y.uvIndex?"uv"+String(y.uvIndex+1):"uv",I=j(w,2),v.attributes.push({name:w,type:"attribute vec2"}),v.params.push(I),v.params.push(N("vViewPosition")),v.params.push(N("MAPPING_"+y.mapping)),v.params.push(N("AXIS_"+y.axis)),v.params.push(N(re("ivec2",[oe(y.clampToEdgeNoExtend[0]),oe(y.clampToEdgeNoExtend[1])])));break;case"GRADIENT_RAMP_MX":t.useFloatTex?(D=new Float32Array(2048),O=1):(D=new Uint8Array(2048),O=255);for(let be=0;be<512;be++){let ct,Ln,bn,Hn;ct=O*y.gradientData[3*be],Ln=O*y.gradientData[3*be+1],bn=O*y.gradientData[3*be+2],Hn=1,D[4*be]=Ye(ct,0,O),D[4*be+1]=Ye(Ln,0,O),D[4*be+2]=Ye(bn,0,O),D[4*be+3]=Ye(Hn,0,O)}J=A(D,512,Qe,t.useFloatTex?Ct:Ft),G=wt.nodeTexUniName(R,U),t.nodeTextures[G]=J,v.params.push(z(R,U)),U++,v.params.push(N(re("int",y.gradientType))),w=y.uvIndex?"uv"+String(y.uvIndex+1):"uv",I=j(w,2),v.attributes.push({name:w,type:"attribute vec2"}),v.params.push(I),v.params.push(N("geometryNormal")),v.params.push(N("vViewPosition")),["SPHERICAL_ENVIRONMENT","CYLINDRICAL_ENVIRONMENT","SHRINK_WRAP_ENVIRONMENT","SCREEN"].indexOf(y.mapping)>-1?v.params.push(N("MAPPING_EXPLICIT_MAP_CHANNEL")):v.params.push(N("MAPPING_"+y.mapping)),v.params.push(N("AXIS_"+y.axis)),v.params.push(N(re("ivec2",[oe(y.clampToEdgeNoExtend[0]),oe(y.clampToEdgeNoExtend[1])])));break;case"MAPPING_BL":v.params.push(N("NODE_MAPPING_"+y.vectorType));break;case"MAP_RANGE_BL":q(y.dataType)&&v.params.push(N("NODE_MAP_RANGE_TYPE_"+y.dataType)),v.params.push(N("NODE_MAP_RANGE_INTERP_"+y.interpolationType)),v.params.push(V(y.clamp));break;case"NEW_GEOMETRY_BL":v.params.push(N("faceDirection")),v.params.push(N("vViewPosition")),v.params.push(N("normal")),kr(F,P,2)&&(t.needsBoundingBox=!0);break;case"NORMAL_MAP_BL":w="tangent",I=j(w,4),v.attributes.push({name:w,type:"attribute vec4"}),v.params.push(I),v.params.push(N("vNormal"));break;case"SEPARATE_COLOR_BL":v.params.push(N("NODE_SEP_COL_"+y.mode));break;case"TANGENT_BL":y.directionType==="RADIAL"?(v.params.push(N("TANGENT_AXIS_"+y.axis)),v.params.push(N("vViewPosition")),v.params.push(N("normal")),t.needsBoundingBox=!0):y.directionType==="UV_MAP"&&(w="tangent",I=j(w,4),v.attributes.push({name:w,type:"attribute vec4"}),v.params.push(I));break;case"TEX_BRICK_BL":v.params.push(N(re("float",y.offset))),v.params.push(N(re("int",y.offsetFrequency))),v.params.push(N(re("float",y.squash))),v.params.push(N(re("int",y.squashFrequency)));break;case"TEX_COORD_BL":v.params.push(N(`nodeTexCoordObjectMatrices[${Z}]`)),v.params.push(N("vViewPosition")),v.params.push(N("normal")),w="uv",I=j(w,2),v.attributes.push({name:w,type:"attribute vec2"}),v.params.push(I),kr(F,P,0)&&(t.needsBoundingBox=!0),t.nodeTexCoordObject.push(null),t.nodeTexCoordObjectMap[y.name]=Z,Z++;break;case"TEX_ENVIRONMENT_BL":case"TEX_IMAGE_BL":if(K=z(R,y.texture),v.params.push(K),v.params.push(N(x(t.nodeTextures[K.name]))),R=="TEX_ENVIRONMENT_BL"){const be=y.projection;v.params.push(N("TEX_PROJ_"+be))}else if(R=="TEX_IMAGE_BL"){let be;switch(y.alphaMode||"STRAIGHT"){case"STRAIGHT":be=kr(F,P,1)?"TEX_ALPHA_CLEAR":"TEX_ALPHA_PREMUL";break;case"PREMUL":be=kr(F,P,1)?"TEX_ALPHA_UNPREMUL":"TEX_ALPHA_CLEAR";break;case"CHANNEL_PACKED":be="TEX_ALPHA_CLEAR";break;case"NONE":be="TEX_ALPHA_ONE";break;default:console.error("MeshNodeMaterial: incorrect TEX_IMAGE_BL alpha mode"),be="TEX_ALPHA_ONE"}v.params.push(N(be)),v.params.push(N("normal"));const ct=y.projection;v.params.push(N("TEX_PROJ_"+ct)),v.params.push(L(y.projectionBlend)),v.params.push(V(y.clampToEdgeNoExtend))}break;case"TEX_GRADIENT_BL":v.params.push(N("TEX_GRAD_"+y.gradientType));break;case"TEX_NOISE_BL":q(y.noiseType)&&v.params.push(N("TEX_NOISE_"+y.noiseType)),v.params.push(N(re("float",y.falloffFactor))),v.params.push(N(re("float",y.dispersionFactor)));break;case"TEX_SKY_BL":if(se=new b().fromArray(y.sunDirection).angleTo(new b(0,0,1)),y.skyType=="PREETHAM")de=Fn.getDistParams(y.turbidity,0).concat([0,0,0,0]),he=Fn.getDistParams(y.turbidity,1).concat([0,0,0,0]),ee=Fn.getDistParams(y.turbidity,2).concat([0,0,0,0]),ge=Fn.getZenithParams(y.turbidity,se,0),ve=Fn.getZenithParams(y.turbidity,se,1),_e=Fn.getZenithParams(y.turbidity,se,2);else if(y.skyType=="HOSEK_WILKIE"){const be=Math.max(Math.PI/2-se,0);de=Vr.getDistParams(y.turbidity,y.groundAlbedo,be,0),he=Vr.getDistParams(y.turbidity,y.groundAlbedo,be,1),ee=Vr.getDistParams(y.turbidity,y.groundAlbedo,be,2),ge=Vr.getRadiance(y.turbidity,y.groundAlbedo,be,0),ve=Vr.getRadiance(y.turbidity,y.groundAlbedo,be,1),_e=Vr.getRadiance(y.turbidity,y.groundAlbedo,be,2)}else de=he=ee=new Array(9).fill(0),ge=ve=_e=0;v.params.push(N("TEX_SKY_"+y.skyType)),v.params.push(L([de[0],he[0],ee[0]])),v.params.push(L([de[1],he[1],ee[1]])),v.params.push(L([de[2],he[2],ee[2]])),v.params.push(L([de[3],he[3],ee[3]])),v.params.push(L([de[4],he[4],ee[4]])),v.params.push(L([de[5],he[5],ee[5]])),v.params.push(L([de[6],he[6],ee[6]])),v.params.push(L([de[7],he[7],ee[7]])),v.params.push(L([de[8],he[8],ee[8]])),v.params.push(L([ge,ve,_e])),v.params.push(L(y.sunDirection));break;case"TEX_VORONOI_BL":v.params.push(N("DISTANCE_"+y.distance)),v.params.push(N("FEATURE_"+y.feature));break;case"TEX_WAVE_BL":v.params.push(N("TEX_WAVE_TYPE_"+y.waveType)),v.params.push(N("TEX_WAVE_PROFILE_"+y.waveProfile)),v.params.push(N(`TEX_WAVE_BANDS_DIR_${y.bandsDirection}`)),v.params.push(N(`TEX_WAVE_RINGS_DIR_${y.ringsDirection}`));break;case"MATH_BL":v.outputs[0].clamp=y.useClamp;break;case"MIX_BL":switch(v.originData.blendType){case"HUE":case"SATURATION":case"VALUE":case"COLOR":t.defines.HSV_NODES=""}y.dataType=="RGBA"&&(v.outputs[0].clamp=y.clampResult);break;case"MIX_RGB_BL":switch(v.originData.blendType){case"HUE":case"SATURATION":case"VALUE":case"COLOR":t.defines.HSV_NODES=""}v.outputs[0].clamp=y.useClamp;break;case"MIX_SHADER_BL":let we=-1;for(let be=1;be<3;be++){const ct=Wi(F,P,be);ct&&ct.originData.type=="BSDF_TRANSPARENT_BL"&&(we=be-1)}v.params.push(N(String(we)));break;case"NORMAL_BL":v.params.push(L(y.outputs[0]));break;case"RGB_BL":case"RGB_MX":K=new Re().fromArray(y.outputs[0]),t.nodeRGB.push(K),t.nodeRGBMap[y.name]=B,v.params.push(N("nodeRGB["+B+"]")),B++;break;case"UVMAP_BL":X=y.uvLayer,w=t.nodeUVAliases[X]||"uv",I=j(w,2),v.attributes.push({name:w,type:"attribute vec2"}),v.params.push(I);break;case"VALUE_BL":case"VALUE_MX":case"ANIM_CURVE_TA_MY":case"ANIM_CURVE_TU_MY":case"VALUE":K=y.outputs[0],t.nodeValue[k]=K,t.nodeValueMap[y.name]=k,v.params.push(N("nodeValue["+k+"]")),k++;break;case"VALTORGB_BL":$=y.curve;const Be=new($.interpolation=="STEP"?ap:au)(new Float32Array($.input),new Float32Array($.output),4);t.useFloatTex?(D=new Float32Array(1024),O=1):(D=new Uint8Array(1024),O=255);for(let be=0;be<256;be++){const ct=Be.evaluate(be/255);D[4*be]=O*ct[0],D[4*be+1]=O*ct[1],D[4*be+2]=O*ct[2],D[4*be+3]=O*ct[3]}J=A(D,256,Qe,t.useFloatTex?Ct:Ft),$.interpolation=="STEP"&&(J.minFilter=st,J.magFilter=st),G=wt.nodeTexUniName(R,U),t.nodeTextures[G]=J,v.params.push(z(R,U)),U++;break;case"VECTOR_ROTATE_BL":v.params.push(N(re("float",y.invert?-1:1)));break;case"VECT_TRANSFORM_BL":const ke=y.vectorType,ht=y.convertFrom,tt=y.convertTo;ke=="NORMAL"&&(v.outputs[0].normalize=!0);let pt="";ht==tt?pt="VEC_TRANS_NONE":(pt="VEC_TRANS_"+ht[0]+"_"+tt[0],ke!="VECTOR"&&ke!="NORMAL"||(pt+="_DIR")),v.params.push(N(pt)),r(F,"OUTPUT_MATERIAL_BL")>0||r(F,"OUTPUT_WORLD_BL")>0?v.params.push(V(!0)):v.params.push(V(!1));break;case"BITMAP_MX":case"BITMAP_ENV_MX":case"REFLECT_REFRACT_MX":if(C=z(R,y.texture),v.params.push(C),R=="BITMAP_MX"){w=y.uvIndex?"uv"+String(y.uvIndex+1):"uv",I=j(w,2),v.attributes.push({name:w,type:"attribute vec2"}),v.params.push(I),v.params.push(N("MAPPING_"+y.mapping)),v.params.push(N("AXIS_"+y.axis));const be=re("ivec2",[oe(y.clampToEdgeNoExtend[0]),oe(y.clampToEdgeNoExtend[1])]);v.params.push(N(be))}else v.params.push(N(y.reflectMode)),v.params.push(L(y.IOR));v.params.push(N(x(t.nodeTextures[C.name]))),R!="BITMAP_MX"&&R!="BITMAP_ENV_MX"||(v.params.push(V(y.alphaAsMono)),v.params.push(V(y.alphaAsRGB)),v.outputs.push({name:R.toLowerCase()+"_out1_n"+P,type:"float",clamp:!1,normalize:!1}));break;case"BLEND_MX":v.params.push(V(y.useCurve)),v.params.push(L(y.curveLower)),v.params.push(L(y.curveUpper));break;case"BUMP_MX":C=z("BITMAP_MX",y.texture),v.params.push(C),v.params.push(N("-vViewPosition")),v.params.push(N("normal")),w=y.uvIndex?"uv"+String(y.uvIndex+1):"uv",I=j(w,2),v.attributes.push({name:w,type:"attribute vec2"}),v.params.push(I);break;case"COLOR_CORRECTION_MX":const Kt=re("ivec4",[y.rewireR,y.rewireG,y.rewireB,y.rewireA]);v.params.push(N(Kt)),y.gainPivotGammaLift&&(v.params.push(L(y.gainPivotGammaLift)),v.params.push(V(y.enableR)),v.params.push(V(y.enableG)),v.params.push(V(y.enableB)),v.params.push(W(y.exposureMode)),v.params.push(L(y.printerLights)));break;case"COMPOSITE_LAYER_MX":v.params.push(N(re("int",y.blendMode)));const pe=nt(F,P,1)?y.opacity:0;v.params.push(L(pe));break;case"COLOR_MAP_MX":v.params.push(V(y.reverseGamma));break;case"FALLOFF_MX":if(v.params.push(N("-vViewPosition")),y.falloffType!=4)v.params.push(L(y.IOR)),v.params.push(W(y.falloffType));else{const be=y.extrapolateOn!==void 0&&y.extrapolateOn,ct=y.nearDistance===void 0?0:y.nearDistance,Ln=y.farDistance===void 0?100:y.farDistance;v.params.push(V(be)),v.params.push(L(ct)),v.params.push(L(Ln))}break;case"MASK_MX":v.params.push(V(y.maskInverted));break;case"MATERIAL_MX":v.params.push(L(y.inputFactors[9])),v.params.push(L(y.inputFactors[10])),y.inputFactors[9]=1,y.inputFactors[10]=1,v.params.push(V(y.selfIllumColorOn));break;case"MATTE_SHADOW_MX":v.params.push(N("normal")),v.params.push(V(y.receiveShadows)),v.params.push(L(y.shadowBrightness)),v.params.push(L(y.color));break;case"NOISE_MX":y.coordType==2?(w=y.uvIndex?"uv"+String(y.uvIndex+1):"uv",I=j(w,2),v.attributes.push({name:w,type:"attribute vec2"}),v.params.push(I)):v.params.push(N("vViewPosition")),v.params.push(W(y.noiseType)),v.params.push(W(y.coordType));break;case"NORMAL_BUMP_MX":w="tangent",I=j(w,4),v.attributes.push({name:w,type:"attribute vec4"}),v.params.push(I),v.params.push(N("normal"));const gi="ivec2("+oe(y.flip[0])+","+oe(y.flip[1])+")";v.params.push(N(gi));break;case"OUTPUT_MAP_MX":if(v.params.push(V(y.invert)),v.params.push(V(y.clamp)),v.params.push(V(y.alphaFromRGB)),y.colorMap){t.useFloatTex?(Y=y.colorMap,D=new Float32Array(1024),O=1):(Y=Ng(y.colorMap.slice(),0,1),D=new Uint8Array(1024),O=255),ie=Y.length/256;for(let be=0;be<256;be++)D[4*be]=O*Y[ie*be],ie==3?(D[4*be+1]=O*Y[ie*be+1],D[4*be+2]=O*Y[ie*be+2]):(D[4*be+1]=D[4*be],D[4*be+2]=D[4*be]),D[4*be+3]=O;J=A(D,256,Qe,t.useFloatTex?Ct:Ft),G=wt.nodeTexUniName(R,U),t.nodeTextures[G]=J,v.params.push(z(R,U)),U++}break;case"PHYSICAL_MX":v.params.push(N("geometryNormal")),v.params.push(L(y.emitLuminance));const St=y.brdfMode===void 0||y.brdfMode,qe=y.brdfLow===void 0?0:y.brdfLow,qt=y.brdfHigh===void 0?0:y.brdfHigh,Ni=y.brdfCurve===void 0?0:y.brdfCurve;v.params.push(V(!St)),v.params.push(N(re("float",qe))),v.params.push(N(re("float",qt))),v.params.push(N(re("float",Ni))),v.params.push(V(q(y.roughnessInv)&&y.roughnessInv)),v.params.push(V(q(y.transRoughnessLock)&&y.transRoughnessLock)),v.params.push(V(q(y.transRoughnessInv)&&y.transRoughnessInv)),v.params.push(V(q(y.thinWalled)&&y.thinWalled)),(y.inputs[18]>0||nt(F,P,18))&&(t.defines.USE_CLEARCOAT="");break;case"PHY_SUN_SKY_ENV_MX":const Zt=15*y.haze+2,yn=new Bi;se=Math.PI/2-y.sunPolarAngle;const Mt=Math.PI-y.sunAzimuthAngle;yn.phi=se,yn.theta=Mt;const Pa=new b().setFromSpherical(yn).toArray();de=Fn.getDistParams(Zt,0),he=Fn.getDistParams(Zt,1),ee=Fn.getDistParams(Zt,2),ge=Fn.getZenithParams(Zt,se,0),ve=Fn.getZenithParams(Zt,se,1),_e=Fn.getZenithParams(Zt,se,2),ge/=.06,ge*=1e3,v.params.push(L([de[0],he[0],ee[0]])),v.params.push(L([de[1],he[1],ee[1]])),v.params.push(L([de[2],he[2],ee[2]])),v.params.push(L([de[3],he[3],ee[3]])),v.params.push(L([de[4],he[4],ee[4]])),v.params.push(L([ge,ve,_e]));const $s=Fn.getSunIlluminance(Pa,Zt),Oi=[0,0,0];v.params.push(L(Pa)),v.params.push(L($s)),v.params.push(L(Oi)),v.params.push(L(y.globalIntensity/LT)),v.params.push(L(y.groundColor));break;case"REFLECT_REFRACT_COLOR_MX":K=y.outputs[0],v.params.push(L(K));break;case"VERTEX_COLOR_MX":w="color",I=j(w,3),v.attributes.push({name:w,type:"attribute vec3"}),v.params.push(I);break;case"BUMP_2D_MY":v.params.push(N("vNormal")),y.bumpInterp>0&&(w="tangent",I=j(w,4),v.attributes.push({name:w,type:"attribute vec4"}),v.params.push(I));break;case"COLOR_COMPOSITE_MY":case"COLOR_LOGIC_MY":case"COLOR_MATH_MY":case"CONDITION_MY":case"FLOAT_COMPOSITE_MY":case"FLOAT_LOGIC_MY":case"FLOAT_MATH_MY":case"MULTIPLY_DIVIDE_MY":v.params.push(N(y.operation));break;case"COLOR_CORRECT_MY":v.params.push(V(y.colClamp)),v.params.push(L(y.colClampMin)),v.params.push(L(y.colClampMax)),v.params.push(V(y.alphaClamp)),v.params.push(L(y.alphaClampMin)),v.params.push(L(y.alphaClampMax)),v.params.push(V(y.unpremultiplyInput)),v.params.push(V(y.premultiplyResult));break;case"COLOR_MASK_MY":v.params.push(V(y.maskAlphaIsLuminance));break;case"COMPOSE_MATRIX_MY":v.params.push(V(y.useEulerRotation)),v.params.push(N(y.inputRotateOrder));break;case"FILE_MY":case"ENV_SPHERE_MY":if(K=z("FILE_MY",y.texture),v.params.push(K),v.params.push(N(x(t.nodeTextures[K.name]))),R=="ENV_SPHERE_MY")v.params.push(N("normal"));else{const be=y.fileHasAlpha===!1;v.params.push(V(be&&kr(F,P,0)))}break;case"RAMP_MY":t.useFloatTex?(D=new Float32Array(2048),O=1):(D=new Uint8Array(2048),O=255);for(let be=0;be<512;be++){let ct,Ln,bn,Hn;ct=O*y.rampData[3*be],Ln=O*y.rampData[3*be+1],bn=O*y.rampData[3*be+2],Hn=1,D[4*be]=Ye(ct,0,O),D[4*be+1]=Ye(Ln,0,O),D[4*be+2]=Ye(bn,0,O),D[4*be+3]=Ye(Hn,0,O)}J=A(D,512,Qe,t.useFloatTex?Ct:Ft),J.wrapS=y.wrapS,J.wrapT=y.wrapT,G=wt.nodeTexUniName(R,U),t.nodeTextures[G]=J,v.params.push(z(R,U)),U++,v.params.push(N(re("int",y.rampType)));break;case"SAMPLER_INFO_MY":v.params.push(N("faceDirection")),w="tangent",I=j(w,4),v.attributes.push({name:w,type:"attribute vec4"}),v.params.push(I),w="uv",I=j(w,2),v.attributes.push({name:w,type:"attribute vec2"}),v.params.push(I);break;case"UNIT_CONVERSION_MY":v.params.push(L(y.conversionFactor));break;case"VECTOR_PRODUCT_MY":v.params.push(N(y.operation)),v.params.push(V(y.normalizeOutput));break;case"OSL_NODE":q(y.texture)&&(C=z(R,y.texture),v.params.push(C));const vi=y.globalVariables||[];vi.indexOf("P")>-1&&v.params.push(N("oslGetP(vViewPosition)")),vi.indexOf("I")>-1&&v.params.push(N("oslGetI(vViewPosition)")),vi.indexOf("N")>-1&&v.params.push(N("oslGetN(normal)")),(vi.indexOf("u")>-1||vi.indexOf("v")>-1)&&(w="uv",v.attributes.push({name:w,type:"attribute vec2"}),vi.indexOf("u")>-1&&v.params.push(j(w+"_u",1,w+".x")),vi.indexOf("v")>-1&&v.params.push(j(w+"_v",1,"1.0 - "+w+".y")));break;case"RGB_ALPHA":K=new Re().fromArray(y.outputs[0].concat([y.outputs[1]])),t.nodeRGB.push(K),t.nodeRGBMap[y.name]=B,v.params.push(N("nodeRGB["+B+"]")),B++;break;case"U_FLOAT":w="uv",I=j(w,2),v.attributes.push({name:w,type:"attribute vec2"}),v.params.push(I)}}var X;for(let P=0;P<F.len();P++){const v=F.node(P),y=v.originData,R=y.type;for(let w=0;w<y.inputs.length;w++){const I=y.inputs[w],C=y.inputTypes?y.inputTypes[w]:H(I),D=[],O=[];T(F,P,w,I,D,O);const Y=u(R,w);if(D.length){let J,G;if(J=v.inputFactors.length?v.inputFactors[w]:1,G=Y?"normal":re(C,I),O.length){const K=D.map(function(ie){return ie.name});v.inputs.push({code:M(K,O,D[0].type,C,G)})}else D.length==1?v.inputs.push({code:S(D[0].name,D[0].type,C,G,J)}):console.error("MeshNodeMaterial: wrong node connections")}else Y?v.inputs.push({code:"normal"}):v.inputs.push({code:re(C,I)})}}}(E),function(F){const U=[],B=[],Z=[],k=[],X=new Bc(F).order();t.defines.NODE_RGB_NUM=t.nodeRGB.length,t.defines.NODE_VALUE_NUM=t.nodeValue.length,t.defines.NODE_TEX_COORD_NUM=t.nodeTexCoordObject.length,t.definesFragOnly.push("NODE_RGB_NUM"),t.definesFragOnly.push("NODE_VALUE_NUM"),t.definesFragOnly.push("NODE_TEX_COORD_NUM");for(let P=0;P<X.length;P++){const v=F.node(X[P]),y=v.originData.type;let R,w;if(t.defines["NODE_"+y]="",y!="REFLECT_REFRACT_MX"&&y!="BITMAP_ENV_MX"&&y!="BUMP_BL"&&y!="PHY_SUN_SKY_ENV_MX"&&y!="SKYDOME_LIGHT_AR"&&y!="ENV_SPHERE_MY"&&t.definesFragOnly.push("NODE_"+y),y=="OSL_NODE"&&(t.defines.USE_OSL=""),y!="OSL_NODE"){const I="node_"+y.toLowerCase()+"_vert";R=Me[I]}else R=v.originData.vertCode;if(R&&U.indexOf(R)<0&&U.push(R),y!="OSL_NODE"){const I="node_"+y.toLowerCase()+"_frag";w=Me[I]}else w=v.originData.fragCode;w&&Z.indexOf(w)<0&&Z.push(w);for(let I=0;I<v.attributes.length;I++){const C=v.attributes[I],D=C.type+" "+C.name+";";C.name!="uv"&&U.indexOf(D)<0&&U.push(D)}for(let I=0;I<v.params.length;I++){const C=v.params[I];if(f(C)){const D=C.type+" "+C.name+";";Z.indexOf(D)<0&&Z.push(D)}else if(g(C)){const D=C.type+" "+C.name+";";U.indexOf(D)<0&&U.push(D);const O=C.type+" "+C.name+";";Z.indexOf(O)<0&&Z.push(O)}}}q(t.defines.USE_OSL)&&Z.unshift("#include <node_osl_frag>");for(let P=0;P<X.length;P++){const v=F.node(X[P]),y=v.originData.type;if(y=="CHECKERBOARD_AR"||y=="IMAGE_AR"||y=="TWO_SIDED_AR"||y=="USER_DATA_COLOR_AR"||y=="ATTRIBUTE_BL"||y=="NEW_GEOMETRY_BL"||y=="NORMAL_MAP_BL"||y=="TANGENT_BL"||y=="TEX_COORD_BL"||y=="UVMAP_BL"||y=="VERTEX_COLOR_BL"||y=="BITMAP_MX"||y=="NOISE_MX"||y=="NORMAL_BUMP_MX"||y=="BUMP_MX"||y=="VERTEX_COLOR_MX"||y=="GRADIENT_MX"||y=="GRADIENT_RAMP_MX"||y=="BUMP_2D_MY"||y=="PLACE_2D_TEXTURE_MY"||y=="SAMPLER_INFO_MY"||y=="OSL_NODE"||y=="U_FLOAT")for(let I=0;I<v.params.length;I++){const C=v.params[I];if(g(C)){const D=C.name+"="+C.attrBindName+";";B.indexOf(D)<0&&B.push(D)}}for(let I=0;I<v.outputs.length;I++){const C=v.outputs[I];C.type&&k.push(C.type+" "+C.name+";")}const R=[];for(let I=0;I<v.params.length;I++){const C=v.params[I];!C.type||f(C)||g(C)?R.push(C.name):R.push(re(C.type,C.value))}for(let I=0;I<v.inputs.length;I++){const C=v.inputs[I];R.push(C.code)}for(let I=0;I<v.outputs.length;I++){const C=v.outputs[I];R.push(C.name)}let w;switch(y!="OSL_NODE"?(w="node_"+y.toLowerCase(),(y.endsWith("_AR")||y.endsWith("_BL")||y.endsWith("_MX")||y.endsWith("_MY"))&&(w=w.slice(0,-3))):w=v.originData.shaderName,y){case"MATH_BL":case"VECT_MATH_BL":w+="_"+v.originData.operation.toLowerCase();break;case"VECTOR_ROTATE_BL":w+="_"+v.originData.rotationType.toLowerCase();break;case"MIX_BL":w+="_"+v.originData.dataType.toLowerCase(),v.originData.dataType=="RGBA"?w+="_"+v.originData.blendType.toLowerCase():v.originData.dataType=="VECTOR"&&(w+="_"+v.originData.factorMode.toLowerCase());break;case"MIX_RGB_BL":w+="_"+v.originData.blendType.toLowerCase();break;case"TEX_WHITE_NOISE_BL":w+="_"+v.originData.noise_dimension.toLowerCase()}k.push(w+"("+R.join(",")+");");for(let I=0;I<v.outputs.length;I++){const C=v.outputs[I],D=C.name;if(C.clamp){const O=C.type;k.push(D+"=clamp("+D+","+O+"(0.0),"+O+"(1.0));")}C.normalize&&k.push(D+"=normalize("+D+");")}}t.nodeChunks.node_pars_vertex=U.join(`
`),t.nodeChunks.node_vertex=B.join(`
`),t.nodeChunks.node_pars_fragment=Z.join(`
`),t.nodeChunks.node_fragment=k.join(`
`),t.nodeChunksHash=da(JSON.stringify(t.nodeChunks))}(E)},function(E){for(let F=0;F<E.len();F++){const U=E.node(F),B=U.originData.type;if(B!="GROUP_BL")if(B!="REROUTE_BL"){if(B=="OSL_OUTPUT_SELECTOR_MX"){const Z=E.findInEdges(F),k=E.findOutEdges(F),X=Z[0],P=X.connections[0];for(let v=0;v<k.length;v++){const y=k[v],R=new Mn(X.from(),y.to(),0);R.connections=[];for(let w=0;w<y.connections.length;w++){const I=y.connections[w],C={from:P.from,to:I.to};R.connections.push(C)}E.addEdge(R)}E.disconnect(F,!0),F=-1}}else{E.findInEdges(F).length<1&&n(E,F);const Z=E.findInEdges(F),k=E.findOutEdges(F),X=Z[0],P=X.connections[0];for(let v=0;v<k.length;v++){const y=k[v],R=new Mn(X.from(),y.to(),0);R.connections=[];for(let w=0;w<y.connections.length;w++){const I=y.connections[w],C={from:P.from,to:I.to};R.connections.push(C)}E.addEdge(R)}E.disconnect(F,!0),F=-1}else{const Z=U.originData.nodeGraph,k=t.additionalNodeGraphs[Z];if(n(E,F),k.len()<=2){const R=E.findInEdges(F),w=E.findOutEdges(F),I=Math.min(R.length,w.length);for(let C=0;C<I;C++){const D=R[C],O=w[C],Y=new Mn(D.from(),O.to(),0);Y.connections=[];const J=Math.min(D.connections.length,O.connections.length);for(let G=0;G<J;G++){const K=D.connections[G],ie=O.connections[G],$={from:K.from,to:ie.to};Y.connections.push($)}E.addEdge(Y)}E.disconnect(F,!0),F=-1;continue}const X=o(E,k,F),P=R=>JSON.parse(JSON.stringify(R)),v=P;E.insert(k,X.inputs,X.outputs,P,v);const y=X.removedNodes.sort(function(R,w){return w-R});for(let R=0;R<y.length;R++)E.disconnect(y[R],!0);F=-1}}}(t.nodeGraph),function(E){for(let U=0;U<E.len();U++){const B=E.node(U).originData,Z=B.type;if(Z=="TEX_IMAGE_BL"&&!nt(E,U,0)){const X={originData:{name:"UVMapGenerated",type:"UVMAP_BL",uvLayer:"",inputs:[],outputs:[[0,0,0]]}};E.addNode(X),Xe(E,E.len()-1,0,U,0)}if((Z=="TEX_BRICK_BL"||Z=="TEX_CHECKER_BL"||Z=="TEX_GRADIENT_BL"||Z=="TEX_NOISE_BL"||Z=="TEX_WAVE_BL"||Z=="TEX_VORONOI_BL"||Z=="TEX_SKY_BL")&&!nt(E,U,0)){const X={originData:{name:"TexCoordGenerated",type:"TEX_COORD_BL",inputs:[],outputs:[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]]}};E.addNode(X),Xe(E,E.len()-1,0,U,0)}if(Z=="TEX_ENVIRONMENT_BL"&&!nt(E,U,0)){const X={originData:{name:"TexCoordObject",type:"TEX_COORD_BL",inputs:[],outputs:[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]]}};E.addNode(X),Xe(E,E.len()-1,3,U,0)}let k=Z;if(k=="BSDF_PRINCIPLED_BL"&&B.inputs.length===25&&(k="BSDF_PRINCIPLED_<4.0_BL"),k=="BSDF_GLOSSY_BL"&&B.inputs.length===3&&(k="BSDF_GLOSSY_BL_<4.0_BL"),k=="BUMP_BL"&&B.inputs.length===6&&(k="BUMP_BL_<3.2_BL"),k=="STANDARD_SURFACE_AR"&&B.inputs.length==25&&(console.warn("v3d.MeshNodeMaterial: adding missing params to standard surface node, please reexport your scene"),B.inputs.push([0,0,0])),k in ed&&!nt(E,U,ed[k])){const X={originData:{name:"Normal",type:"NORMAL",inputs:[],outputs:[[0,0,0]]}};E.addNode(X),Xe(E,E.len()-1,0,U,ed[k])}if(k=="BSDF_PRINCIPLED_<4.0_BL"&&!nt(E,U,23)&&(B.inputs[14]>0||nt(E,U,14))){const X={originData:{name:"CoatNormal",type:"NORMAL",inputs:[],outputs:[[0,0,0]]}};E.addNode(X),Xe(E,E.len()-1,0,U,23)}if(k=="BSDF_PRINCIPLED_BL"&&!nt(E,U,21)&&(B.inputs[17]>0||nt(E,U,17))){const X={originData:{name:"CoatNormal",type:"NORMAL",inputs:[],outputs:[[0,0,0]]}};E.addNode(X),Xe(E,E.len()-1,0,U,21)}if(k=="EEVEE_SPECULAR_BL"&&!nt(E,U,8)&&(B.inputs[6]>0||nt(E,U,6))){const X={originData:{name:"CoatNormal",type:"NORMAL",inputs:[],outputs:[[0,0,0]]}};E.addNode(X),Xe(E,E.len()-1,0,U,8)}if(k=="OSL_NODE"){const X=B.initializers;for(let P=0;P<X.length;P++){const v=X[P];if(v&&!nt(E,U,P)){const y={originData:{name:k+"init"+P,type:"OSL_NODE",shaderName:B.shaderName+"_init_"+P,inputs:[],outputs:[B.inputs[0]],fragCode:v[0],globalVariables:v[1],initializers:[]}};E.addNode(y),Xe(E,E.len()-1,0,U,P)}}}if(!(k!="NORMAL_MAP_AR"||nt(E,U,1)&&nt(E,U,3))){const X={originData:{name:"SamplerInfo",type:"SAMPLER_INFO_MY",inputs:[[0,0,0]],outputs:[0,!1,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0],[0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0]]}};E.addNode(X),nt(E,U,1)||Xe(E,E.len()-1,3,U,1),nt(E,U,3)||Xe(E,E.len()-1,8,U,3)}if(k=="IMAGE_AR"&&!nt(E,U,2)){const X={originData:{name:"place2dTexture",type:"PLACE_2D_TEXTURE_MY",inputs:[[0,0],[1,1],0],outputs:[[0,0]],uvIndex:0}};E.addNode(X),Xe(E,E.len()-1,0,U,2)}if(k=="FILE_MY"&&!nt(E,U,0)){const X={originData:{name:"place2dTexture",type:"PLACE_2D_TEXTURE_MY",inputs:[[0,0],[1,1],0],outputs:[[0,0]],uvIndex:0}};E.addNode(X),Xe(E,E.len()-1,0,U,0)}if(k=="RAMP_MY"&&!nt(E,U,0)){const X={originData:{name:"place2dTexture",type:"PLACE_2D_TEXTURE_MY",inputs:[[0,0],[1,1],0],outputs:[[0,0]],uvIndex:0}};E.addNode(X),Xe(E,E.len()-1,0,U,0)}if(q(B.output)&&p(E,U,B),c(Z)){if(!q(B.inputFactors)){B.inputFactors=[];for(let X=0;X<B.inputs.length;X++)B.inputFactors.push(1)}B.inputs.push([0,0,0]),B.inputFactors.push(0)}if(k=="STANDARD_SURFACE_AR"&&!nt(E,U,25)&&(B.inputs[15]>0||nt(E,U,15))){const X={originData:{name:"CoatNormal",type:"NORMAL",inputs:[],outputs:[[0,0,0]]}};E.addNode(X),Xe(E,E.len()-1,0,U,25)}if(k=="MIX_BL"&&B.outputs.length>1){const X=[-1,-1,-1,-1,-1,-1,-1],P=[-1,-1,-1];switch(B.dataType){case"RGBA":B.inputs=[B.inputs[0],B.inputs[6],B.inputs[7]],X[0]=0,X[6]=1,X[7]=2,B.outputs=[B.outputs[2]],P[2]=0;break;case"VECTOR":B.inputs=[B.inputs[0],B.inputs[1],B.inputs[4],B.inputs[5]],X[0]=0,X[1]=1,X[4]=2,X[5]=3,B.outputs=[B.outputs[1]],P[1]=0;break;case"FLOAT":B.inputs=[B.inputs[0],B.inputs[2],B.inputs[3]],X[0]=0,X[2]=1,X[3]=2,B.outputs=[B.outputs[0]],P[0]=0}const v=E.findInEdges(U);for(let R=0;R<v.length;R++){const w=v[R];for(let I=w.connections.length-1;I>=0;I--){const C=w.connections[I];X[C.to]>-1?C.to=X[C.to]:w.connections.splice(I,1)}}const y=E.findOutEdges(U);for(let R=0;R<y.length;R++){const w=y[R];for(let I=w.connections.length-1;I>=0;I--){const C=w.connections[I];P[C.from]>-1?C.from=P[C.from]:w.connections.splice(I,1)}}}if(Z=="BUMP_2D_MY"&&B.bumpInterp>0){B.inputs[1]=[0,0,0];const X=E.findInEdges(U);for(let P=0;P<X.length;P++){const v=X[P],y=E.node(v.from()).originData;for(let R=0;R<v.connections.length;R++){const w=v.connections[R];w.to==1&&y.type=="FILE_MY"?w.from=1:w.to==1&&y.type=="IMAGE_AR"&&(w.from=0)}}}Z!="COLOR_CONSTANT_MY"||nt(E,U,0)||nt(E,U,1)||(B.type="RGB_ALPHA",B.inputs=[]),Z!="FLOAT_CONSTANT_MY"||nt(E,U,0)||(B.type="VALUE",B.inputs=[])}let F=0;for(let U=0;U<E.len();U++){const B=E.node(U).originData,Z=B.type;Z!="MATERIAL_MX"&&Z!="PHYSICAL_MX"||(l(E,U,B),Z=="MATERIAL_MX"&&(F=B.IOR))}for(let U=0;U<E.len();U++){const B=E.node(U).originData,Z=B.type;d(Z)&&(B.IOR=F),d(Z)&&!q(B.reflectMode)&&(B.reflectMode="MAX_ENV_COORDS_REFLECT")}for(let U=0;U<E.len();U++){const B=E.node(U).originData;B.type=="COMPOSITE_MX"&&(h(E,U,B),E.disconnect(U,!0))}for(let U=0;U<E.len();U++){const B=E.node(U).originData;B.type=="LAYERED_TEXTURE_MY"&&(m(E,U,B),E.disconnect(U,!0))}if(t.hasNode("SKYDOME_LIGHT_AR"))for(let U=0;U<E.len();U++){const B=E.node(U).originData;if(B.type=="FILE_MY"||B.type=="IMAGE_AR"){const Z={originData:{name:"envSphere",type:"ENV_SPHERE_MY",inputs:[[-1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]],outputs:[0,[0,0,0]],texture:B.texture}};E.addNode(Z);const k=E.findOutEdges(U);for(let X=0;X<k.length;X++){const P=k[X];for(let v=0;v<P.connections.length;v++){const y=P.connections[v];y.from<2&&Xe(E,E.len()-1,y.from,P.to(),y.to)}}E.disconnect(U,!0),U=-1}}for(let U=0;U<E.len();U++){const B=E.node(U).originData;if(B.type=="ENV_SPHERE_MY"&&B.inputs.length==2){const Z=E.findInEdges(U);for(let k=0;k<Z.length;k++){const X=Z[k],P=E.node(X.from()).originData;P.type!="FILE_MY"&&P.type!="IMAGE_AR"||(B.inputs.splice(0,1),B.texture=P.texture,E.removeEdge(X.from(),X.to()))}}}for(let U=0;U<E.len();U++){const B=E.node(U).originData;switch(B.type){case"BSDF_DIFFUSE_BL":case"BSDF_GLOSSY_BL":case"BSDF_TRANSLUCENT_BL":case"BSDF_PRINCIPLED_BL":i(E,U,B,0,"Color");break;case"MATERIAL_MX":i(E,U,B,0,"Ambient Color")&&(B.inputFactors[0]=1),i(E,U,B,1,"Diffuse Color")&&(B.inputFactors[1]=1);break;case"PHYSICAL_MX":i(E,U,B,1,"Base Color")&&(B.inputFactors[1]=1)}}}(t.nodeGraph),Am(t.nodeGraph),this.updateNodeGraph()}static nodeTexUniName(e,t){return e.toLowerCase()+"_par_tex_idx"+t}static nodeGraphFromExtGraph(e){const t=e.nodes,n=e.edges,i=new xt(t.length);for(let o=0;o<t.length;o++)t[o],i.node(o).originData=t[o];for(let o=0;o<n.length;o++){const r=n[o];i.edge(r.fromNode,r.toNode)||i.addNewEdge(r.fromNode,r.toNode);const s=i.edge(r.fromNode,r.toNode);if(s.connections=s.connections||[],q(r.fromChannel)||q(r.toChannel)){let l=null;for(let u=0;u<s.connections.length;u++){const h=s.connections[u];if(h.from==r.fromOutput&&h.to==r.toInput&&h.channelMatrix){l=h.channelMatrix;break}}if(!l){l=[[0,0,0],[0,0,0],[0,0,0]];const u={from:r.fromOutput,to:r.toInput,channelMatrix:l};s.connections.push(u)}const c=r.fromChannel||0,d=r.toChannel||0;l[c][d]=1}else{const l={from:r.fromOutput,to:r.toInput};s.connections.push(l)}}return Am(i),i}static nodeGraphTraverse(e,t){for(let n=0;n<e.len();n++)t(e.node(n))}static nodeGraphDiffuse(e,t,n="blender"){let i,o=new xt(0);switch(n){case"blender":i=e.toArray(),i.push(1),o.addNode({originData:{name:"Output",type:"OUTPUT_MATERIAL_BL",inputs:[[0,0,0,0],[0,0,0,0],[0,0,0]],outputs:[],is_active_output:!0}}),t<1?(o.addNode({originData:{name:"Mix",type:"MIX_SHADER_BL",inputs:[t,[0,0,0,0],[0,0,0,0]],outputs:[[0,0,0,0]],is_active_output:!1}}),Xe(o,1,0,0,0),o.addNode({originData:{name:"Transparent",type:"BSDF_TRANSPARENT_BL",inputs:[[1,1,1,1]],outputs:[[0,0,0,0]],is_active_output:!1}}),Xe(o,2,0,1,1),o.addNode({originData:{name:"Diffuse",type:"BSDF_DIFFUSE_BL",inputs:[i,0,[0,0,0]],outputs:[[0,0,0,0]],is_active_output:!1}}),Xe(o,3,0,1,2)):(o.addNode({originData:{name:"Diffuse",type:"BSDF_DIFFUSE_BL",inputs:[i,0,[0,0,0]],outputs:[[0,0,0,0]],is_active_output:!1}}),Xe(o,1,0,0,0));break;case"max":i=e.toArray();let r=[t,t,t];o.addNode({originData:{name:"Diffuse",type:"LAMBERT_AR",inputs:[1,i,[0,0,0],r],outputs:[[0,0,0,0],0,[0,0,0]],is_active_output:!1}}),o.addNode({originData:{name:"Output",type:"OUTPUT_MX",inputs:[[0,0,0,0]],outputs:[],is_active_output:!0}}),Xe(o,0,0,1,0);break;case"maya":i=e.toArray();let s=[1-t,1-t,1-t];o.addNode({originData:{name:"Diffuse",type:"LAMBERT_MY",inputs:[i,[0,0,0],[0,0,0],1,.8,[1,1,1],0,s],outputs:[[0,0,0,0]],is_active_output:!1}}),o.addNode({originData:{name:"Output",type:"SHADING_ENGINE_MY",inputs:[[0,0,0,0],[0,0,0,0],[0,0,0]],outputs:[],is_active_output:!0}}),Xe(o,0,0,1,0);break;default:console.error("nodeGraphDiffuse: Incorrect material profile - "+n),o=null}return o}hasNode(e){for(let t=0;t<this.nodeGraph.len();t++)if(this.nodeGraph.node(t).originData.type==e)return!0;return!1}traverseNodes(e){for(let t=0;t<this.nodeGraph.len();t++)e(this.nodeGraph.node(t))}findNodeByName(e){for(let t=0;t<this.nodeGraph.len();t++){const n=this.nodeGraph.node(t);if(n.originData.name===e)return n}return null}needsLightPathDir(){return!!(this.hasNode("LIGHT_PATH_BL")||this.hasNode("RAY_SWITCH_AR")||"USE_OSL"in this.defines)}canUseGTAO(){return(this.hasNode("BSDF_DIFFUSE_BL")||this.hasNode("SUBSURFACE_SCATTERING_BL")||this.hasNode("PHYSICAL_MX")||this.hasNode("STANDARD_SURFACE_AR")||this.hasNode("BSDF_GLASS_BL")||this.hasNode("BSDF_GLOSSY_BL")||this.hasNode("BSDF_PRINCIPLED_BL")||this.hasNode("EEVEE_SPECULAR_BL"))&&this.gtaoVisible}worldMaterialColor(){const e=this.nodeGraph;let t=Gr(e,"OUTPUT_WORLD_BL");if(t>=0){const n=Wi(e,t,0);if(!n||n.originData.type!="BACKGROUND_BL")return null;if(e.findInEdges(e.nodeIndex(n)).length==0)return new me().fromArray(n.originData.inputs[0]).multiplyScalar(n.originData.inputs[1]);if(nt(e,e.nodeIndex(n),1))return null;const i=Wi(e,e.nodeIndex(n),0);if(!i||(i.originData.type!="MIX_BL"||i.originData.dataType!="RGBA")&&i.originData.type!="MIX_RGB_BL"||i.originData.blendType!="MIX")return null;const o=Wi(e,e.nodeIndex(i),0);return o&&o.originData.type=="LIGHT_PATH_BL"?nt(e,e.nodeIndex(i),2)?null:kr(e,e.nodeIndex(o),0)?new me().fromArray(i.originData.inputs[2]):null:null}if(t=Gr(e,"OUTPUT_MX"),t>=0&&e.findInEdges(t).length==0)return new me().fromArray(e.node(t).originData.inputs[0]);if(t=Gr(e,"SKYDOME_LIGHT_AR"),t>=0){if(e.findInEdges(t).length==0){const i=e.node(t);return new me().fromArray(i.originData.inputs[0]).multiplyScalar(i.originData.inputs[1])}const n=Wi(e,t,0);if(!n||n.originData.type!="RAY_SWITCH_AR")return null;if(e.findInEdges(e.nodeIndex(n)).length==0)return new me().fromArray(n.originData.inputs[0])}return null}useAddTransparency(){const e=this.nodeGraph,t=Gr(e,"OUTPUT_MATERIAL_BL");if(t>=0){const n=Wi(e,t,0);if(n&&n.originData.type=="ADD_SHADER_BL"){const i=Wi(e,e.nodeIndex(n),0),o=Wi(e,e.nodeIndex(n),1);if(i&&o&&(i.originData.type=="BSDF_TRANSPARENT_BL"||o.originData.type=="BSDF_TRANSPARENT_BL"))return!0}}return!1}copy(e){super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=hn.clone(e.uniforms),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this.fog=e.fog,this.color.copy(e.color),this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.envMapParallaxType=e.envMapParallaxType,this.envMapParallaxMatrix.copy(e.envMapParallaxMatrix),this.envMapParallaxMatrixInv.copy(e.envMapParallaxMatrixInv),this.materialIndex=e.materialIndex,this.profile=e.profile,this.nodeTextures=e.nodeTextures,this.nodeRGB=e.nodeRGB.slice(),this.nodeRGBMap=Object.assign({},e.nodeRGBMap),this.nodeRGBArr=e.nodeRGBArr.slice(),this.nodeTexCoordObject=e.nodeTexCoordObject.slice(),this.nodeTexCoordObjectMap=Object.assign({},e.nodeTexCoordObjectMap),this.nodeTexCoordObjectArr=e.nodeTexCoordObjectArr.slice(),this.nodeValue=e.nodeValue.slice(),this.nodeValueMap=Object.assign({},e.nodeValueMap),this.needsBoundingBox=e.needsBoundingBox,this.useFloatTex=e.useFloatTex,this.nodeGraph=new xt(e.nodeGraph.len());for(let t=0;t<this.nodeGraph.len();t++)this.nodeGraph.node(t).originData=e.nodeGraph.node(t).originData;for(let t in e.nodeGraph.edges){const n=e.nodeGraph.edges[t];this.nodeGraph.addNewEdge(n.from(),n.to()).connections=n.connections.slice()}return this.additionalNodeGraphs=Object.assign({},e.additionalNodeGraphs),this.nodeChunks=Object.assign({},e.nodeChunks),this.nodeChunksHash=e.nodeChunksHash,this.nodeVCAliases=Object.assign({},e.nodeVCAliases),this.nodeUVAliases=Object.assign({},e.nodeUVAliases),this}}function Gr(a,e){for(let t=0;t<a.len();t++)if(a.node(t).originData.type==e)return t;return-1}function Wi(a,e,t){for(let n in a.edges){const i=a.edges[n];if(i.to()==e){const o=a.node(i.from());for(let r=0;r<i.connections.length;r++)if(i.connections[r].to==t)return o}}return null}function nt(a,e,t){const n=a.findInEdges(e);for(let i=0;i<n.length;i++){const o=n[i];for(let r=0;r<o.connections.length;r++)if(o.connections[r].to==t)return!0}return!1}function kr(a,e,t){for(let n in a.edges){const i=a.edges[n];if(i.from()==e){for(let o=0;o<i.connections.length;o++)if(i.connections[o].from==t)return!0}}return!1}function Xe(a,e,t,n,i,o){a.edge(e,n)||a.addNewEdge(e,n);const r=a.edge(e,n);r.connections=r.connections||[];const s={from:t,to:i};o&&(s.channelMatrix=o),r.connections.push(s)}function Am(a){let e=-1;for(let t=0;t<a.len();t++)if(a.node(t).originData.is_active_output){e=t;break}if(e==-1)a.removeAll();else{const t=new es(a.reverse(),e),n=[];for(let i=0;i<a.len();i++)t.hasPathTo(i)||n.push(a.node(i));n.forEach(function(i){a.disconnect(a.nodeIndex(i),!0)})}}function qn(a,e,t){return ir(a)?new a.constructor(a.subarray(e,t!==void 0?t:a.length)):a.slice(e,t)}function Ka(a,e,t){return!a||!t&&a.constructor===e?a:typeof e.BYTES_PER_ELEMENT=="number"?new e(a):Array.prototype.slice.call(a)}function ir(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)}function x1(a){const e=a.length,t=new Array(e);for(let n=0;n!==e;++n)t[n]=n;return t.sort(function(n,i){return a[n]-a[i]}),t}function hh(a,e,t){const n=a.length,i=new a.constructor(n);for(let o=0,r=0;r!==n;++o){const s=t[o]*e;for(let l=0;l!==e;++l)i[r++]=a[s+l]}return i}function sp(a,e,t,n){let i=1,o=a[0];for(;o!==void 0&&o[n]===void 0;)o=a[i++];if(o===void 0)return;let r=o[n];if(r!==void 0)if(Array.isArray(r))do r=o[n],r!==void 0&&(e.push(o.time),t.push.apply(t,r)),o=a[i++];while(o!==void 0);else if(r.toArray!==void 0)do r=o[n],r!==void 0&&(e.push(o.time),r.toArray(t,t.length)),o=a[i++];while(o!==void 0);else do r=o[n],r!==void 0&&(e.push(o.time),t.push(r)),o=a[i++];while(o!==void 0)}function PT(a,e,t,n,i=30){const o=a.clone();o.name=e;const r=[];o.tracks.forEach(l=>{if(l.times.length===0)return;const c=[Math.max(t/i,l.times[0]),Math.min(n/i,l.times[l.times.length-1])];if(c[0]>c[1])return;const d=l.times.findIndex(T=>T>=c[0]),u=l.times.findLastIndex(T=>T<=c[1]),h=l.getValueSize();let p=[],m=ir(l.times)?l.times.subarray(d,u+1):l.times.slice(d,u+1),f=[],g=[],_=ir(l.values)?l.values.subarray(d*h,(u+1)*h):l.values.slice(d*h,(u+1)*h),A=[];const x=d>u;let S,M;(x||c[0]<l.times[d])&&(p=[c[0]],g=l.createInterpolant().evaluate(p[0])),c[0]!==c[1]&&(x||c[1]>l.times[u])&&(f=[c[1]],A=l.createInterpolant().evaluate(f[0])),ir(l.times)?(S=new l.times.constructor(p.length+m.length+f.length),S.set(p),S.set(m,p.length),S.set(f,p.length+m.length)):S=p.concat(m,f),ir(l.values)?(M=new l.values.constructor(g.length+_.length+A.length),M.set(g),M.set(_,g.length),M.set(A,g.length+_.length)):M=g.concat(_,A),l.times=S,l.values=M,r.push(l)});const s=r.reduce((l,c)=>Math.min(l,c.times[0]),1/0);return r.forEach(l=>l.shift(-s)),o.tracks=r,o.resetDuration(),o}function BT(a,e=0,t=a,n=30){n<=0&&(n=30);const i=t.tracks.length,o=e/n;for(let r=0;r<i;++r){const s=t.tracks[r],l=s.ValueTypeName;if(l==="bool"||l==="string")continue;const c=a.tracks.find(function(_){return _.name===s.name&&_.ValueTypeName===l});if(c===void 0)continue;let d=0;const u=s.getValueSize();s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=u/3);let h=0;const p=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=p/3);const m=s.times.length-1;let f;if(o<=s.times[0]){const _=d,A=u-d;f=qn(s.values,_,A)}else if(o>=s.times[m]){const _=m*u+d,A=_+u-d;f=qn(s.values,_,A)}else{const _=s.createInterpolant(),A=d,x=u-d;_.evaluate(o),f=qn(_.resultBuffer,A,x)}l==="quaternion"&&new Ge().fromArray(f).normalize().conjugate().toArray(f);const g=c.times.length;for(let _=0;_<g;++_){const A=_*p+h;if(l==="quaternion")Ge.multiplyQuaternionsFlat(c.values,A,f,0,c.values,A);else{const x=p-2*h;for(let S=0;S<x;++S)c.values[A+S]-=f[S]}}}return a.blendMode=Oh,a}wt.prototype.isMeshNodeMaterial=!0;var DT=Object.freeze({__proto__:null,arraySlice:qn,convertArray:Ka,flattenJSON:sp,getKeyframeOrder:x1,isTypedArray:ir,makeClipAdditive:BT,sortedArray:hh,subclip:PT});class y1 extends La{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(e,t,n){const i=this.parameterPositions;let o=e-2,r=e+1,s=i[o],l=i[r];if(s===void 0)switch(this.getSettings_().endingStart){case 2401:o=e,s=2*t-n;break;case 2402:o=i.length-2,s=t+i[o]-i[o+1];break;default:o=e,s=n}if(l===void 0)switch(this.getSettings_().endingEnd){case 2401:r=e,l=2*n-t;break;case 2402:r=1,l=n+i[1]-i[0];break;default:r=e-1,l=t}const c=.5*(n-t),d=this.valueSize;this._weightPrev=c/(t-s),this._weightNext=c/(l-n),this._offsetPrev=o*d,this._offsetNext=r*d}interpolate_(e,t,n,i){const o=this.resultBuffer,r=this.sampleValues,s=this.valueSize,l=e*s,c=l-s,d=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,p=this._weightNext,m=(n-t)/(i-t),f=m*m,g=f*m,_=-h*g+2*h*f-h*m,A=(1+h)*g+(-1.5-2*h)*f+(-.5+h)*m+1,x=(-1-p)*g+(1.5+p)*f+.5*m,S=p*g-p*f;for(let M=0;M!==s;++M)o[M]=_*r[d+M]+A*r[c+M]+x*r[l+M]+S*r[u+M];return o}}class di{constructor(e,t,n,i){if(e===void 0)throw new Error("v3d.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("v3d.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Ka(t,this.TimeBufferType),this.values=Ka(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:Ka(e.times,Array),values:Ka(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new ap(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new au(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new y1(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case 2300:t=this.InterpolantFactoryMethodDiscrete;break;case 2301:t=this.InterpolantFactoryMethodLinear;break;case 2302:t=this.InterpolantFactoryMethodSmooth}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0){if(e===this.DefaultInterpolation)throw new Error(n);this.setInterpolation(this.DefaultInterpolation)}return console.warn("v3d.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let o=0,r=i-1;for(;o!==i&&n[o]<e;)++o;for(;r!==-1&&n[r]>t;)--r;if(++r,o!==0||r!==i){o>=r&&(r=Math.max(r,1),o=r-1);const s=this.getValueSize();this.times=qn(n,o,r),this.values=qn(this.values,o*s,r*s)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("v3d.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,o=n.length;o===0&&(console.error("v3d.KeyframeTrack: Track is empty.",this),e=!1);let r=null;for(let s=0;s!==o;s++){const l=n[s];if(typeof l=="number"&&isNaN(l)){console.error("v3d.KeyframeTrack: Time is not a valid number.",this,s,l),e=!1;break}if(r!==null&&r>l){console.error("v3d.KeyframeTrack: Out of order keys.",this,s,l,r),e=!1;break}r=l}if(i!==void 0&&ir(i))for(let s=0,l=i.length;s!==l;++s){const c=i[s];if(isNaN(c)){console.error("v3d.KeyframeTrack: Value is not a valid number.",this,s,c),e=!1;break}}return e}optimize(){const e=qn(this.times),t=qn(this.values),n=this.getValueSize(),i=this.getInterpolation()===2302,o=e.length-1;let r=1;for(let s=1;s<o;++s){let l=!1;const c=e[s];if(c!==e[s+1]&&(s!==1||c!==e[0]))if(i)l=!0;else{const d=s*n,u=d-n,h=d+n;for(let p=0;p!==n;++p){const m=t[d+p];if(m!==t[u+p]||m!==t[h+p]){l=!0;break}}}if(l){if(s!==r){e[r]=e[s];const d=s*n,u=r*n;for(let h=0;h!==n;++h)t[u+h]=t[d+h]}++r}}if(o>0){e[r]=e[o];for(let s=o*n,l=r*n,c=0;c!==n;++c)t[l+c]=t[s+c];++r}return r!==e.length?(this.times=qn(e,0,r),this.values=qn(t,0,r*n)):(this.times=e,this.values=t),this}clone(){const e=qn(this.times,0),t=qn(this.values,0),n=new this.constructor(this.name,e,t);return n.createInterpolant=this.createInterpolant,n}}di.prototype.TimeBufferType=Float32Array,di.prototype.ValueBufferType=Float32Array,di.prototype.DefaultInterpolation=2301;class er extends di{}er.prototype.ValueTypeName="bool",er.prototype.ValueBufferType=Array,er.prototype.DefaultInterpolation=2300,er.prototype.InterpolantFactoryMethodLinear=void 0,er.prototype.InterpolantFactoryMethodSmooth=void 0;class lp extends di{}lp.prototype.ValueTypeName="color";class No extends di{}No.prototype.ValueTypeName="number";class b1 extends La{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const o=this.resultBuffer,r=this.sampleValues,s=this.valueSize,l=(n-t)/(i-t);let c=e*s;for(let d=c+s;c!==d;c+=4)Ge.slerpFlat(o,0,r,c-s,r,c,l);return o}}class Oo extends di{InterpolantFactoryMethodLinear(e){return new b1(this.times,this.values,this.getValueSize(),e)}}Oo.prototype.ValueTypeName="quaternion",Oo.prototype.DefaultInterpolation=2301,Oo.prototype.InterpolantFactoryMethodSmooth=void 0;class tr extends di{}tr.prototype.ValueTypeName="string",tr.prototype.ValueBufferType=Array,tr.prototype.DefaultInterpolation=2300,tr.prototype.InterpolantFactoryMethodLinear=void 0,tr.prototype.InterpolantFactoryMethodSmooth=void 0;class Ar extends di{}Ar.prototype.ValueTypeName="vector";class ma{constructor(e,t=-1,n,i=2500){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=wn(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let r=0,s=n.length;r!==s;++r)t.push(OT(n[r]).scale(i));const o=new this(e.name,e.duration,t,e.blendMode);return o.uuid=e.uuid,o}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let o=0,r=n.length;o!==r;++o)t.push(di.toJSON(n[o]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const o=t.length,r=[];for(let s=0;s<o;s++){let l=[],c=[];l.push((s+o-1)%o,s,(s+1)%o),c.push(0,1,0);const d=x1(l);l=hh(l,1,d),c=hh(c,1,d),i||l[0]!==0||(l.push(o),c.push(c[0])),r.push(new No(".morphTargetInfluences["+t[s].name+"]",l,c).scale(1/n))}return new this(e,-1,r)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},o=/^([\w-]*?)([\d]+)$/;for(let s=0,l=e.length;s<l;s++){const c=e[s],d=c.name.match(o);if(d&&d.length>1){const u=d[1];let h=i[u];h||(i[u]=h=[]),h.push(c)}}const r=[];for(const s in i)r.push(this.CreateFromMorphTargetSequence(s,i[s],t,n));return r}static parseAnimation(e,t){if(!e)return console.error("v3d.AnimationClip: No animation in JSONLoader data."),null;const n=function(d,u,h,p,m){if(h.length!==0){const f=[],g=[];sp(h,f,g,p),f.length!==0&&m.push(new d(u,f,g))}},i=[],o=e.name||"default",r=e.fps||30,s=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let d=0;d<c.length;d++){const u=c[d].keys;if(u&&u.length!==0)if(u[0].morphTargets){const h={};let p;for(p=0;p<u.length;p++)if(u[p].morphTargets)for(let m=0;m<u[p].morphTargets.length;m++)h[u[p].morphTargets[m]]=-1;for(const m in h){const f=[],g=[];for(let _=0;_!==u[p].morphTargets.length;++_){const A=u[p];f.push(A.time),g.push(A.morphTarget===m?1:0)}i.push(new No(".morphTargetInfluence["+m+"]",f,g))}l=h.length*r}else{const h=".bones["+t[d].name+"]";n(Ar,h+".position",u,"pos",i),n(Oo,h+".quaternion",u,"rot",i),n(Ar,h+".scale",u,"scl",i)}}return i.length===0?null:new this(o,l,i,s)}resetDuration(){let e=0;for(let t=0,n=this.tracks.length;t!==n;++t){const i=this.tracks[t];e=Math.max(e,i.times[i.times.length-1])}return this.duration=e,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function NT(a){switch(a.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return No;case"vector":case"vector2":case"vector3":case"vector4":return Ar;case"color":return lp;case"quaternion":return Oo;case"bool":case"boolean":return er;case"string":return tr}throw new Error("v3d.KeyframeTrack: Unsupported typeName: "+a)}function OT(a){if(a.type===void 0)throw new Error("v3d.KeyframeTrack: track type undefined, can not parse");const e=NT(a.type);if(a.times===void 0){const t=[],n=[];sp(a.keys,t,n,"value"),a.times=t,a.values=n}return e.parse!==void 0?e.parse(a):new e(a.name,a.times,a.values,a.interpolation)}const pi={enabled:!1,files:{},add:function(a,e){this.enabled!==!1&&(this.files[a]=e)},get:function(a){if(this.enabled!==!1)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}};class cp{constructor(e,t,n){const i=this;let o,r=!1,s=0,l=0;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(d){l++,r===!1&&i.onStart!==void 0&&i.onStart(d,s,l),r=!0},this.itemEnd=function(d){s++,i.onProgress!==void 0&&i.onProgress(d,s,l),s===l&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(d){i.onError!==void 0&&i.onError(d)},this.resolveURL=function(d){return o?o(d):d},this.setURLModifier=function(d){return o=d,this},this.addHandler=function(d,u){return c.push(d,u),this},this.removeHandler=function(d){const u=c.indexOf(d);return u!==-1&&c.splice(u,2),this},this.getHandler=function(d){for(let u=0,h=c.length;u<h;u+=2){const p=c[u],m=c[u+1];if(p.global&&(p.lastIndex=0),p.test(d))return m}return null}}}const up=new cp;class pn{constructor(e){this.manager=e!==void 0?e:up,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,o){n.load(e,i,t,o)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const Hi={};class FT extends Error{constructor(e,t){super(e),this.response=t}}class cn extends pn{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const o=pi.get(e);if(o!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(o),this.manager.itemEnd(e)},0),o;if(Hi[e]!==void 0)return void Hi[e].push({onLoad:t,onProgress:n,onError:i});Hi[e]=[],Hi[e].push({onLoad:t,onProgress:n,onError:i});const r=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),s=this.mimeType,l=this.responseType;fetch(r).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("v3d.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const d=Hi[e],u=c.body.getReader(),h=c.headers.get("Content-Length")||c.headers.get("X-File-Size"),p=h?parseInt(h):0,m=p!==0;let f=0;const g=new ReadableStream({start(_){(function A(){u.read().then(({done:x,value:S})=>{if(x)_.close();else{f+=S.byteLength;const M=new ProgressEvent("progress",{lengthComputable:m,loaded:f,total:p});for(let T=0,L=d.length;T<L;T++){const z=d[T];z.onProgress&&z.onProgress(M)}_.enqueue(S),A()}})})()}});return new Response(g)}throw new FT(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(d=>new DOMParser().parseFromString(d,s));case"json":return c.json();default:if(s===void 0)return c.text();{const d=/charset="?([^;"\s]*)"?/i.exec(s),u=d&&d[1]?d[1].toLowerCase():void 0,h=new TextDecoder(u);return c.arrayBuffer().then(p=>h.decode(p))}}}).then(c=>{pi.add(e,c);const d=Hi[e];delete Hi[e];for(let u=0,h=d.length;u<h;u++){const p=d[u];p.onLoad&&p.onLoad(c)}}).catch(c=>{const d=Hi[e];if(d===void 0)throw this.manager.itemError(e),c;delete Hi[e];for(let u=0,h=d.length;u<h;u++){const p=d[u];p.onError&&p.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class UT extends pn{constructor(e){super(e)}load(e,t,n,i){const o=this,r=new cn(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,function(s){try{t(o.parse(JSON.parse(s)))}catch(l){i?i(l):console.error(l),o.manager.itemError(e)}},n,i)}parse(e){const t=[];for(let n=0;n<e.length;n++){const i=ma.parse(e[n]);t.push(i)}return t}}class zT extends pn{constructor(e){super(e)}load(e,t,n,i){const o=this,r=[],s=new ys,l=new cn(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(o.withCredentials);let c=0;function d(u){l.load(e[u],function(h){const p=o.parse(h,!0);r[u]={width:p.width,height:p.height,format:p.format,mipmaps:p.mipmaps},c+=1,c===6&&(p.mipmapCount===1&&(s.minFilter=Le),s.image=r,s.format=p.format,s.needsUpdate=!0,t&&t(s))},n,i)}if(Array.isArray(e))for(let u=0,h=e.length;u<h;++u)d(u);else l.load(e,function(u){const h=o.parse(u,!0);if(h.isCubemap){const p=h.mipmaps.length/h.mipmapCount;for(let m=0;m<p;m++){r[m]={mipmaps:[]};for(let f=0;f<h.mipmapCount;f++)r[m].mipmaps.push(h.mipmaps[m*h.mipmapCount+f]),r[m].format=h.format,r[m].width=h.width,r[m].height=h.height}s.image=r}else s.image.width=h.width,s.image.height=h.height,s.mipmaps=h.mipmaps;h.mipmapCount===1&&(s.minFilter=Le),s.format=h.format,s.needsUpdate=!0,t&&t(s)},n,i);return s}}class Es extends pn{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const o=this,r=pi.get(e);if(r!==void 0)return o.manager.itemStart(e),setTimeout(function(){t&&t(r),o.manager.itemEnd(e)},0),r;const s=vs("img");function l(){d(),pi.add(e,this),t&&t(this),o.manager.itemEnd(e)}function c(u){d(),i&&i(u),o.manager.itemError(e),o.manager.itemEnd(e)}function d(){s.removeEventListener("load",l,!1),s.removeEventListener("error",c,!1)}return s.addEventListener("load",l,!1),s.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(s.crossOrigin=this.crossOrigin),o.manager.itemStart(e),s.src=e,s}}class VT extends pn{constructor(e){super(e)}load(e,t,n,i){const o=new Fs,r=new Es(this.manager);r.setCrossOrigin(this.crossOrigin),r.setPath(this.path);let s=0;function l(c){r.load(e[c],function(d){o.images[c]=d,s++,s===6&&(o.needsUpdate=!0,t&&t(o))},void 0,i)}for(let c=0;c<e.length;++c)l(c);return o}}class C1 extends pn{constructor(e){super(e)}load(e,t,n,i){const o=this,r=new Jn,s=new cn(this.manager);return s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(o.withCredentials),s.load(e,function(l){const c=o.parse(l);c&&(c.image!==void 0?r.image=c.image:c.data!==void 0&&(r.image.width=c.width,r.image.height=c.height,r.image.data=c.data),r.wrapS=c.wrapS!==void 0?c.wrapS:mt,r.wrapT=c.wrapT!==void 0?c.wrapT:mt,r.magFilter=c.magFilter!==void 0?c.magFilter:Le,r.minFilter=c.minFilter!==void 0?c.minFilter:Le,r.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.encoding!==void 0&&(r.encoding=c.encoding),c.flipY!==void 0&&(r.flipY=c.flipY),c.format!==void 0&&(r.format=c.format),c.type!==void 0&&(r.type=c.type),c.mipmaps!==void 0&&(r.mipmaps=c.mipmaps,r.minFilter=In),c.mipmapCount===1&&(r.minFilter=Le),c.generateMipmaps!==void 0&&(r.generateMipmaps=c.generateMipmaps),r.needsUpdate=!0,t&&t(r,c))},n,i),r}}class dp extends pn{constructor(e){super(e)}load(e,t,n,i){const o=new yt,r=new Es(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(e,function(s){o.image=s,o.needsUpdate=!0,t!==void 0&&t(o)},n,i),o}}class zo extends ze{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new me(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}getWorldDirection(e){this.updateMatrixWorld(!0);var t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}class hp extends zo{constructor(e,t,n){super(e,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(ze.DefaultUp),this.updateMatrix(),this.groundColor=new me(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const xm=new b;class su extends zo{constructor(e,t,n=0,i=Math.PI/3,o=0,r=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(ze.DefaultUp),this.updateMatrix(),this.target=new ze,this.distance=n,this.angle=i,this.penumbra=o,this.decay=r,this.map=null,this.shadow=new gw,this.isFreeLight=!1}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this.isFreeLight=e.isFreeLight,this}updateMatrixWorld(e){super.updateMatrixWorld(e),this.isFreeLight&&this.updateFreeLightTarget()}updateFreeLightTarget(){xm.set(0,0,-1).applyQuaternion(this.quaternion).normalize(),this.target.position.addVectors(this.position,xm),this.target.updateMatrixWorld()}}const ym=new Ae,Va=new b,td=new b;class S1 extends Zc{constructor(){super(new Qt(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new te(4,2),this._viewportCount=6,this._viewports=[new Re(2,1,1,1),new Re(0,1,1,1),new Re(3,1,1,1),new Re(1,1,1,1),new Re(3,0,1,1),new Re(1,0,1,1)],this._cubeDirections=[new b(1,0,0),new b(-1,0,0),new b(0,0,1),new b(0,0,-1),new b(0,1,0),new b(0,-1,0)],this._cubeUps=[new b(0,1,0),new b(0,1,0),new b(0,1,0),new b(0,1,0),new b(0,0,1),new b(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,o=e.distance||n.far;o!==n.far&&(n.far=o,n.updateProjectionMatrix()),Va.setFromMatrixPosition(e.matrixWorld),n.position.copy(Va),td.copy(n.position),td.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(td),n.updateMatrixWorld(),i.makeTranslation(-Va.x,-Va.y,-Va.z),ym.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ym)}}class lu extends zo{constructor(e,t,n=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new S1}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}const nd=new Ae;class cu{constructor({maxFar:e=1e5,projectionMatrix:t=null}={}){this.vertices={near:[new b,new b,new b,new b],far:[new b,new b,new b,new b]},t&&this.setFromProjectionMatrix(t,e)}setFromProjectionMatrix(e,t){const n=e.elements[11]===0;return nd.copy(e).invert(),this.vertices.near[0].set(1,1,-1),this.vertices.near[1].set(1,-1,-1),this.vertices.near[2].set(-1,-1,-1),this.vertices.near[3].set(-1,1,-1),this.vertices.near.forEach(function(i){i.applyMatrix4(nd)}),this.vertices.far[0].set(1,1,1),this.vertices.far[1].set(1,-1,1),this.vertices.far[2].set(-1,-1,1),this.vertices.far[3].set(-1,1,1),this.vertices.far.forEach(function(i){i.applyMatrix4(nd);const o=Math.abs(i.z);n?i.z*=Math.min(t/o,1):i.multiplyScalar(Math.min(t/o,1))}),this.vertices}split(e,t,n){for(;e.length>t.length;)t.push(new cu);t.length=e.length;for(let i=0;i<e.length;i++){const o=t[i];if(i===0||n)for(let r=0;r<4;r++)o.vertices.near[r].copy(this.vertices.near[r]);else for(let r=0;r<4;r++)o.vertices.near[r].lerpVectors(this.vertices.near[r],this.vertices.far[r],e[i-1]);if(i===e.length-1)for(let r=0;r<4;r++)o.vertices.far[r].copy(this.vertices.far[r]);else for(let r=0;r<4;r++)o.vertices.far[r].lerpVectors(this.vertices.near[r],this.vertices.far[r],e[i])}}toSpace(e,t){for(let n=0;n<4;n++)t.vertices.near[n].copy(this.vertices.near[n]).applyMatrix4(e),t.vertices.far[n].copy(this.vertices.far[n]).applyMatrix4(e)}}const M1=new b,GT=new b,kT=new b,E1=new Ae;new Ae;const Ga=new At,id=new cu,od=[],rd=[];class QT extends Zc{constructor(){super(new fi(-5,5,5,-5,.5,500)),this.esmBlurRadius=0,this.pancakeDepth=!0,this.isDirectionalLightShadowCascade=!0}updateMatrices(e){const t=this.camera,n=this.matrix,i=M1.setFromMatrixPosition(t.matrixWorld),o=GT.setFromMatrixPosition(e.matrixWorld);t.position.copy(o);const r=kT.setFromMatrixPosition(e.target.matrixWorld);t.lookAt(r),t.position.copy(i),t.updateMatrixWorld();const s=E1.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse);this._frustum.setFromProjectionMatrix(s),this.pancakeDepth&&(this._frustum.planes[5].constant=1/0),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(s)}}class WT extends Zc{constructor({numCascades:e=1,maxDistance:t=500,fade:n=0,lightMargin:i=1,noLastCascadeCutOff:o=!0,customSplitsCallback:r=null}={}){super(new fi(-5,5,5,-5,.5,500)),this.numCascades=e,this.exponent=.5,this.customSplitsCallback=r,this.maxDistance=t,this.fade=n,this.lightMargin=i,this.noLastCascadeCutOff=o,this.cascadesFitToScene=!1,this.mainFrustum=new cu,this._frustums=[],this._breaks=[],this._cascades=[],this._sceneViewProjectionMatrix=new Ae,this._sceneViewCamera=null,this._needsCascadeFrustumsUpdate=!0,this.createCascades(),this.isDirectionalLightShadowCSM=!0}createCascades(){const e=this._cascades;for(;e.length>this.numCascades;)e.pop().dispose();for(let t=e.length;t<this.numCascades;t++){const n=new QT;n.mapSize.copy(this.mapSize),n.copy(this),e.push(n)}for(let t=0;t<e.length;t++){const n=e[t];n.mapSize.copy(this.mapSize),n.copy(this)}this.updateMapSize()}initCascades(e){e.updateProjectionMatrix(),this.mainFrustum.setFromProjectionMatrix(e.projectionMatrix,this.maxDistance),this.mainFrustum.split(this._breaks,this._frustums,this.cascadesFitToScene)}updateShadowBounds(e){const t=this._frustums;for(let n=0;n<t.length;n++){const i=this._cascades[n],o=this._cascades[n].camera,r=t[n],s=r.vertices.near,l=r.vertices.far,c=l[0];let d;d=c.distanceTo(l[2])>c.distanceTo(s[2])?l[2]:s[2];let u=c.distanceTo(d);if(this.fade>0){const h=Math.min(e.far,this.maxDistance),p=e.near,m=r.vertices.far[0].z/(h-p);u+=this.fade*Math.pow(m,2)*(h-p)}o.left=-u/2,o.right=u/2,o.top=u/2,o.bottom=-u/2,o.near=0,o.far=u+this.lightMargin,o.updateProjectionMatrix(),i.bias=this.bias,i.normalBias=this.normalBias,i.esmBlurRadius=i.radius/((o.right-o.left)/2)}}getBreaks(e){const t=e.near,n=Math.min(e.far,this.maxDistance),i=this.numCascades,o=this.exponent,r=this._breaks;r.length=0,this.customSplitsCallback?this.customSplitsCallback(i,t,n,r,o):function(s,l,c,d,u){od.length=0,rd.length=0,function(h,p,m,f){for(let g=1;g<h;g++)f.push(p*(m/p)**(g/h)/m);f.push(1)}(s,l,c,rd),function(h,p,m,f){for(let g=1;g<h;g++)f.push((p+(m-p)*g/h)/m);f.push(1)}(s,l,c,od);for(let h=1;h<s;h++)u.push(wi(od[h-1],rd[h-1],d));u.push(1)}(i,t,n,o,r)}updateCascadePositions(e){const t=this._frustums;for(let n=0;n<t.length;n++){const i=this._cascades[n],o=this._cascades[n].camera,r=(o.right-o.left)/i.mapSize.x,s=(o.top-o.bottom)/i.mapSize.y;o.updateMatrixWorld(!0);const l=E1.multiplyMatrices(o.matrixWorldInverse,e.matrixWorld);t[n].toSpace(l,id);const c=id.vertices.near,d=id.vertices.far;Ga.makeEmpty();for(let h=0;h<4;h++)Ga.expandByPoint(c[h]),Ga.expandByPoint(d[h]);const u=Ga.getCenter(M1);u.z=Ga.max.z+this.lightMargin,u.x=Math.floor(u.x/r)*r,u.y=Math.floor(u.y/s)*s,u.applyMatrix4(o.matrixWorld),o.position.copy(u),o.updateMatrixWorld()}}update(e,t){!this._needsCascadeFrustumsUpdate&&this._sceneViewCamera===e&&this._sceneViewProjectionMatrix.equals(e.projectionMatrix)||(this.updateFrustums(e),this.updateMatrices(t),this._sceneViewCamera=e,this._sceneViewProjectionMatrix.copy(e.projectionMatrix),this._needsCascadeFrustumsUpdate=!1),this.updateCascadePositions(e)}getCascadeRange(e,t){const n=this._breaks,i=n[t],o=n[t-1]||0;e.x=o,e.y=i,this.noLastCascadeCutOff&&t==n.length-1&&(e.y=1/0)}updateFrustums(e){this.getBreaks(e),this.initCascades(e),this.updateShadowBounds(e)}updateMatrices(e){for(let t=0;t<this._cascades.length;t++)this._cascades[t].updateMatrices(e)}updateMapSize(e){e&&this.mapSize.copy(e);const t=this.mapSize;for(let n=0;n<this._cascades.length;n++)this._cascades[n].mapSize.copy(t);this.updateMaps()}updateMaps(){for(let e=0;e<this._cascades.length;e++){const t=this._cascades[e];t.dispose(),t.map=null,t._additionalMap2D=null,t._additionalMapCube=null}}dispose(){for(let e=0;e<this._cascades.length;e++)this._cascades[e].dispose();super.dispose()}copy(e){return super.copy(e),this.numCascades=e.numCascades,this.exponent=e.exponent,this.maxDistance=e.maxDistance,this.fade=e.fade,this.lightMargin=e.lightMargin,this.noLastCascadeCutOff=e.noLastCascadeCutOff,this.createCascades(),this}clone(){return new this.constructor().copy(this)}setCascadesFitToScene(e){this.cascadesFitToScene=e,this._needsCascadeFrustumsUpdate=!0}setExponent(e){this.exponent=e,this._needsCascadeFrustumsUpdate=!0}setFade(e){this.fade=e,this._needsCascadeFrustumsUpdate=!0}setMaxDistance(e){this.maxDistance=e,this._needsCascadeFrustumsUpdate=!0}setNoLastCascadeCutOff(e){this.noLastCascadeCutOff=e,this._needsCascadeFrustumsUpdate=!0}setNumCascades(e){this.numCascades=e,this._needsCascadeFrustumsUpdate=!0,this.createCascades()}setLightMargin(e){this.lightMargin=e,this._needsCascadeFrustumsUpdate=!0}}const bm=new b;class uu extends zo{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(ze.DefaultUp),this.updateMatrix(),this.target=new ze,this.shadow=new WT,this.isFreeLight=!1}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this.isFreeLight=e.isFreeLight,this}updateMatrixWorld(e){super.updateMatrixWorld(e),this.isFreeLight&&this.updateFreeLightTarget()}updateFreeLightTarget(){bm.set(0,0,-1).applyQuaternion(this.quaternion).normalize(),this.target.position.addVectors(this.position,bm),this.target.updateMatrixWorld()}}class pp extends zo{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class w1 extends S1{constructor(){super()}}w1.prototype.isRectAreaLightShadow=!0;class fp extends zo{constructor(e,t,n=10,i=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=i,this.shadow=new w1}get power(){return 2*this.intensity*Math.PI}set power(e){this.intensity=e/(2*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this.shadow=e.shadow.clone(),this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class ea{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new b)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,i=e.y,o=e.z,r=this.coefficients;return t.copy(r[0]).multiplyScalar(.282095),t.addScaledVector(r[1],.488603*i),t.addScaledVector(r[2],.488603*o),t.addScaledVector(r[3],.488603*n),t.addScaledVector(r[4],n*i*1.092548),t.addScaledVector(r[5],i*o*1.092548),t.addScaledVector(r[6],.315392*(3*o*o-1)),t.addScaledVector(r[7],n*o*1.092548),t.addScaledVector(r[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){const n=e.x,i=e.y,o=e.z,r=this.coefficients;return t.copy(r[0]).multiplyScalar(.886227),t.addScaledVector(r[1],1.023328*i),t.addScaledVector(r[2],1.023328*o),t.addScaledVector(r[3],1.023328*n),t.addScaledVector(r[4],.858086*n*i),t.addScaledVector(r[5],.858086*i*o),t.addScaledVector(r[6],.743125*o*o-.247708),t.addScaledVector(r[7],.858086*n*o),t.addScaledVector(r[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+3*i);return this}toArray(e=[],t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+3*i);return e}static getBasisAt(e,t){const n=e.x,i=e.y,o=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*o,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*o,t[6]=.315392*(3*o*o-1),t[7]=1.092548*n*o,t[8]=.546274*(n*n-i*i)}}class ga extends zo{constructor(e=new ea,t=1){super(void 0,t),this.isLightProbe=!0,this.type="LightProbe",this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class du extends pn{constructor(e){super(e),this.textures={}}load(e,t,n,i){const o=this,r=new cn(o.manager);r.setPath(o.path),r.setRequestHeader(o.requestHeader),r.setWithCredentials(o.withCredentials),r.load(e,function(s){try{t(o.parse(JSON.parse(s)))}catch(l){i?i(l):console.error(l),o.manager.itemError(e)}},n,i)}parse(e){const t=this.textures;function n(o){return t[o]===void 0&&console.warn("v3d.MaterialLoader: Undefined texture",o),t[o]}const i=du.createMaterialFromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new me().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.iridescence!==void 0&&(i.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(i.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==1&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const o in e.uniforms){const r=e.uniforms[o];switch(i.uniforms[o]={},r.type){case"t":i.uniforms[o].value=n(r.value);break;case"c":i.uniforms[o].value=new me().setHex(r.value);break;case"v2":i.uniforms[o].value=new te().fromArray(r.value);break;case"v3":i.uniforms[o].value=new b().fromArray(r.value);break;case"v4":i.uniforms[o].value=new Re().fromArray(r.value);break;case"m3":i.uniforms[o].value=new ln().fromArray(r.value);break;case"m4":i.uniforms[o].value=new Ae().fromArray(r.value);break;default:i.uniforms[o].value=r.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(i.glslVersion=e.glslVersion),e.extensions!==void 0)for(const o in e.extensions)i.extensions[o]=e.extensions[o];if(e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=n(e.map)),e.matcap!==void 0&&(i.matcap=n(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=n(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=n(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=n(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let o=e.normalScale;Array.isArray(o)===!1&&(o=[o,o]),i.normalScale=new te().fromArray(o)}return e.displacementMap!==void 0&&(i.displacementMap=n(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=n(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=n(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=n(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=n(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=n(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=n(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=n(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=n(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=n(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=n(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=n(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new te().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(i.iridescenceMap=n(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=n(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(i.transmissionMap=n(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=n(e.thicknessMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=n(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=n(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){return new{ShadowMaterial:d1,SpriteMaterial:tu,RawShaderMaterial:Ca,ShaderMaterial:vt,PointsMaterial:qh,MeshPhysicalMaterial:lo,MeshStandardMaterial:Zs,MeshPhongMaterial:h1,MeshToonMaterial:p1,MeshNormalMaterial:op,MeshLambertMaterial:f1,MeshDepthMaterial:vr,MeshDistanceMaterial:Hh,MeshBasicMaterial:Xt,MeshMatcapMaterial:m1,LineDashedMaterial:g1,LineBasicMaterial:un,Material:Ut}[e]}}class ti{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class T1 extends Pe{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class I1 extends pn{constructor(e){super(e)}load(e,t,n,i){const o=this,r=new cn(o.manager);r.setPath(o.path),r.setRequestHeader(o.requestHeader),r.setWithCredentials(o.withCredentials),r.load(e,function(s){try{t(o.parse(JSON.parse(s)))}catch(l){i?i(l):console.error(l),o.manager.itemError(e)}},n,i)}parse(e){const t={},n={};function i(u,h){if(t[h]!==void 0)return t[h];const p=u.interleavedBuffers[h],m=function(_,A){if(n[A]!==void 0)return n[A];const x=_.arrayBuffers,S=x[A],M=new Uint32Array(S).buffer;return n[A]=M,M}(u,p.buffer),f=Zr(p.type,m),g=new Ma(f,p.stride);return g.uuid=p.uuid,t[h]=g,g}const o=e.isInstancedBufferGeometry?new T1:new Pe,r=e.data.index;if(r!==void 0){const u=Zr(r.type,r.array);o.setIndex(new Te(u,1))}const s=e.data.attributes;for(const u in s){const h=s[u];let p;if(h.isInterleavedBufferAttribute){const m=i(e.data,h.data);p=new io(m,h.itemSize,h.offset,h.normalized)}else{const m=Zr(h.type,h.array);p=new(h.isInstancedBufferAttribute?pa:Te)(m,h.itemSize,h.normalized)}h.name!==void 0&&(p.name=h.name),h.usage!==void 0&&p.setUsage(h.usage),h.updateRange!==void 0&&(p.updateRange.offset=h.updateRange.offset,p.updateRange.count=h.updateRange.count),o.setAttribute(u,p)}const l=e.data.morphAttributes;if(l)for(const u in l){const h=l[u],p=[];for(let m=0,f=h.length;m<f;m++){const g=h[m];let _;if(g.isInterleavedBufferAttribute){const A=i(e.data,g.data);_=new io(A,g.itemSize,g.offset,g.normalized)}else{const A=Zr(g.type,g.array);_=new Te(A,g.itemSize,g.normalized)}g.name!==void 0&&(_.name=g.name),p.push(_)}o.morphAttributes[u]=p}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const c=e.data.groups||e.data.drawcalls||e.data.offsets;if(c!==void 0)for(let u=0,h=c.length;u!==h;++u){const p=c[u];o.addGroup(p.start,p.count,p.materialIndex)}const d=e.data.boundingSphere;if(d!==void 0){const u=new b;d.center!==void 0&&u.fromArray(d.center),o.boundingSphere=new Rn(u,d.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class HT extends pn{constructor(e){super(e)}load(e,t,n,i){const o=this,r=this.path===""?ti.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||r;const s=new cn(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(u){return i!==void 0&&i(u),void console.error("v3d:ObjectLoader: Can't parse "+e+".",u.message)}const d=c.metadata;if(d===void 0||d.type===void 0||d.type.toLowerCase()==="geometry")return i!==void 0&&i(new Error("v3d.ObjectLoader: Can't load "+e)),void console.error("v3d.ObjectLoader: Can't load "+e);o.parse(c,t)},n,i)}async loadAsync(e,t){const n=this.path===""?ti.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||n;const i=new cn(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials);const o=await i.loadAsync(e,t),r=JSON.parse(o),s=r.metadata;if(s===void 0||s.type===void 0||s.type.toLowerCase()==="geometry")throw new Error("v3d.ObjectLoader: Can't load "+e);return await this.parseAsync(r)}parse(e,t){const n=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),o=this.parseGeometries(e.geometries,i),r=this.parseImages(e.images,function(){t!==void 0&&t(c)}),s=this.parseTextures(e.textures,r),l=this.parseMaterials(e.materials,s),c=this.parseObject(e.object,o,l,s,n),d=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,d),t!==void 0){let u=!1;for(const h in r)if(r[h].data instanceof HTMLImageElement){u=!0;break}u===!1&&t(c)}return c}async parseAsync(e){const t=this.parseAnimations(e.animations),n=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,n),o=await this.parseImagesAsync(e.images),r=this.parseTextures(e.textures,o),s=this.parseMaterials(e.materials,r),l=this.parseObject(e.object,i,s,r,t),c=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,c),l}parseShapes(e){const t={};if(e!==void 0)for(let n=0,i=e.length;n<i;n++){const o=new hr().fromJSON(e[n]);t[o.uuid]=o}return t}parseSkeletons(e,t){const n={},i={};if(t.traverse(function(o){o.isBone&&(i[o.uuid]=o)}),e!==void 0)for(let o=0,r=e.length;o<r;o++){const s=new zs().fromJSON(e[o],i);n[s.uuid]=s}return n}parseGeometries(e,t){const n={};if(e!==void 0){const i=new I1;for(let o=0,r=e.length;o<r;o++){let s;const l=e[o];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":s=i.parse(l);break;default:l.type in fm?s=fm[l.type].fromJSON(l,t):console.warn(`v3d.ObjectLoader: Unsupported geometry type "${l.type}"`)}s.uuid=l.uuid,l.name!==void 0&&(s.name=l.name),s.isBufferGeometry===!0&&l.userData!==void 0&&(s.userData=l.userData),n[l.uuid]=s}}return n}parseMaterials(e,t){const n={},i={};if(e!==void 0){const o=new du;o.setTextures(t);for(let r=0,s=e.length;r<s;r++){const l=e[r];n[l.uuid]===void 0&&(n[l.uuid]=o.parse(l)),i[l.uuid]=n[l.uuid]}}return i}parseAnimations(e){const t={};if(e!==void 0)for(let n=0;n<e.length;n++){const i=e[n],o=ma.parse(i);t[o.uuid]=o}return t}parseImages(e,t){const n=this,i={};let o;function r(s){if(typeof s=="string"){const l=s;return function(c){return n.manager.itemStart(c),o.load(c,function(){n.manager.itemEnd(c)},void 0,function(){n.manager.itemError(c),n.manager.itemEnd(c)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(l)?l:n.resourcePath+l)}return s.data?{data:Zr(s.type,s.data),width:s.width,height:s.height}:null}if(e!==void 0&&e.length>0){const s=new cp(t);o=new Es(s),o.setCrossOrigin(this.crossOrigin);for(let l=0,c=e.length;l<c;l++){const d=e[l],u=d.url;if(Array.isArray(u)){const h=[];for(let p=0,m=u.length;p<m;p++){const f=r(u[p]);f!==null&&(f instanceof HTMLImageElement?h.push(f):h.push(new Jn(f.data,f.width,f.height)))}i[d.uuid]=new nr(h)}else{const h=r(d.url);i[d.uuid]=new nr(h)}}}return i}async parseImagesAsync(e){const t=this,n={};let i;async function o(r){if(typeof r=="string"){const s=r,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(s)?s:t.resourcePath+s;return await i.loadAsync(l)}return r.data?{data:Zr(r.type,r.data),width:r.width,height:r.height}:null}if(e!==void 0&&e.length>0){i=new Es(this.manager),i.setCrossOrigin(this.crossOrigin);for(let r=0,s=e.length;r<s;r++){const l=e[r],c=l.url;if(Array.isArray(c)){const d=[];for(let u=0,h=c.length;u<h;u++){const p=c[u],m=await o(p);m!==null&&(m instanceof HTMLImageElement?d.push(m):d.push(new Jn(m.data,m.width,m.height)))}n[l.uuid]=new nr(d)}else{const d=await o(l.url);n[l.uuid]=new nr(d)}}}return n}parseTextures(e,t){function n(o,r){return typeof o=="number"?o:(console.warn("v3d.ObjectLoader.parseTexture: Constant should be in numeric form.",o),r[o])}const i={};if(e!==void 0)for(let o=0,r=e.length;o<r;o++){const s=e[o];s.image===void 0&&console.warn('v3d.ObjectLoader: No "image" specified for',s.uuid),t[s.image]===void 0&&console.warn("v3d.ObjectLoader: Undefined image",s.image);const l=t[s.image],c=l.data;let d;Array.isArray(c)?(d=new Fs,c.length===6&&(d.needsUpdate=!0)):(d=c&&c.data?new Jn:new yt,c&&(d.needsUpdate=!0)),d.source=l,d.uuid=s.uuid,s.name!==void 0&&(d.name=s.name),s.mapping!==void 0&&(d.mapping=n(s.mapping,XT)),s.offset!==void 0&&d.offset.fromArray(s.offset),s.repeat!==void 0&&d.repeat.fromArray(s.repeat),s.center!==void 0&&d.center.fromArray(s.center),s.rotation!==void 0&&(d.rotation=s.rotation),s.wrap!==void 0&&(d.wrapS=n(s.wrap[0],Cm),d.wrapT=n(s.wrap[1],Cm)),s.format!==void 0&&(d.format=s.format),s.type!==void 0&&(d.type=s.type),s.encoding!==void 0&&(d.encoding=s.encoding),s.minFilter!==void 0&&(d.minFilter=n(s.minFilter,Sm)),s.magFilter!==void 0&&(d.magFilter=n(s.magFilter,Sm)),s.anisotropy!==void 0&&(d.anisotropy=s.anisotropy),s.flipY!==void 0&&(d.flipY=s.flipY),s.generateMipmaps!==void 0&&(d.generateMipmaps=s.generateMipmaps),s.premultiplyAlpha!==void 0&&(d.premultiplyAlpha=s.premultiplyAlpha),s.unpackAlignment!==void 0&&(d.unpackAlignment=s.unpackAlignment),s.userData!==void 0&&(d.userData=s.userData),i[s.uuid]=d}return i}parseObject(e,t,n,i,o){let r,s,l;function c(h){return t[h]===void 0&&console.warn("v3d.ObjectLoader: Undefined geometry",h),t[h]}function d(h){if(h!==void 0){if(Array.isArray(h)){const p=[];for(let m=0,f=h.length;m<f;m++){const g=h[m];n[g]===void 0&&console.warn("v3d.ObjectLoader: Undefined material",g),p.push(n[g])}return p}return n[h]===void 0&&console.warn("v3d.ObjectLoader: Undefined material",h),n[h]}}function u(h){return i[h]===void 0&&console.warn("v3d.ObjectLoader: Undefined texture",h),i[h]}switch(e.type){case"Scene":r=new vn,e.background!==void 0&&(Number.isInteger(e.background)?r.background=new me(e.background):r.background=u(e.background)),e.environment!==void 0&&(r.environment=u(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?r.fog=new eu(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(r.fog=new $c(e.fog.color,e.fog.density))),e.backgroundBlurriness!==void 0&&(r.backgroundBlurriness=e.backgroundBlurriness);break;case"PerspectiveCamera":r=new Qt(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(r.focus=e.focus),e.zoom!==void 0&&(r.zoom=e.zoom),e.filmGauge!==void 0&&(r.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(r.filmOffset=e.filmOffset),e.view!==void 0&&(r.view=Object.assign({},e.view));break;case"OrthographicCamera":r=new fi(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(r.zoom=e.zoom),e.view!==void 0&&(r.view=Object.assign({},e.view));break;case"AmbientLight":r=new pp(e.color,e.intensity);break;case"DirectionalLight":r=new uu(e.color,e.intensity);break;case"PointLight":r=new lu(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":r=new fp(e.color,e.intensity,e.width,e.height);break;case"SpotLight":r=new su(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":r=new hp(e.color,e.groundColor,e.intensity);break;case"LightProbe":r=new ga().fromJSON(e);break;case"SkinnedMesh":s=c(e.geometry),l=d(e.material),r=new xs(s,l),e.bindMode!==void 0&&(r.bindMode=e.bindMode),e.bindMatrix!==void 0&&r.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(r.skeleton=e.skeleton);break;case"Mesh":s=c(e.geometry),l=d(e.material),r=new Ue(s,l);break;case"InstancedMesh":s=c(e.geometry),l=d(e.material);const h=e.count,p=e.instanceMatrix,m=e.instanceColor;r=new $g(s,l,h),r.instanceMatrix=new pa(new Float32Array(p.array),16),m!==void 0&&(r.instanceColor=new pa(new Float32Array(m.array),m.itemSize));break;case"LOD":r=new Jg;break;case"Line":r=new Pi(c(e.geometry),d(e.material));break;case"LineLoop":r=new Kh(c(e.geometry),d(e.material));break;case"LineSegments":r=new Wn(c(e.geometry),d(e.material));break;case"PointCloud":case"Points":r=new Zh(c(e.geometry),d(e.material));break;case"Sprite":r=new jh(d(e.material));break;case"Group":r=new Zn;break;case"Bone":r=new nu;break;default:r=new ze}if(r.uuid=e.uuid,e.name!==void 0&&(r.name=e.name),e.matrix!==void 0?(r.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(r.matrixAutoUpdate=e.matrixAutoUpdate),r.matrixAutoUpdate&&r.matrix.decompose(r.position,r.quaternion,r.scale)):(e.position!==void 0&&r.position.fromArray(e.position),e.rotation!==void 0&&r.rotation.fromArray(e.rotation),e.quaternion!==void 0&&r.quaternion.fromArray(e.quaternion),e.scale!==void 0&&r.scale.fromArray(e.scale)),e.castShadow!==void 0&&(r.castShadow=e.castShadow),e.receiveShadow!==void 0&&(r.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(r.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(r.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(r.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&r.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(r.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(r.visible=e.visible),e.frustumCulled!==void 0&&(r.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(r.renderOrder=e.renderOrder),e.userData!==void 0&&(r.userData=e.userData),e.layers!==void 0&&(r.layers.mask=e.layers),e.children!==void 0){const h=e.children;for(let p=0;p<h.length;p++)r.add(this.parseObject(h[p],t,n,i,o))}if(e.animations!==void 0){const h=e.animations;for(let p=0;p<h.length;p++){const m=h[p];r.animations.push(o[m])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(r.autoUpdate=e.autoUpdate);const h=e.levels;for(let p=0;p<h.length;p++){const m=h[p],f=r.getObjectByProperty("uuid",m.object);f!==void 0&&r.addLevel(f,m.distance,m.hysteresis)}}return r}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(n){if(n.isSkinnedMesh===!0&&n.skeleton!==void 0){const i=t[n.skeleton];i===void 0?console.warn("v3d.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(i,n.bindMatrix)}})}}const XT={UVMapping:300,CubeReflectionMapping:_a,CubeRefractionMapping:Aa,EquirectangularReflectionMapping:as,EquirectangularRefractionMapping:ss,CubeUVReflectionMapping:xa},Cm={RepeatWrapping:Qn,ClampToEdgeWrapping:mt,MirroredRepeatWrapping:fr},Sm={NearestFilter:st,NearestMipmapNearestFilter:ca,NearestMipmapLinearFilter:cr,LinearFilter:Le,LinearMipmapNearestFilter:Bs,LinearMipmapLinearFilter:In};class R1 extends pn{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("v3d.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("v3d.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const o=this,r=pi.get(e);if(r!==void 0)return o.manager.itemStart(e),setTimeout(function(){t&&t(r),o.manager.itemEnd(e)},0),r;const s={};s.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",s.headers=this.requestHeader,fetch(e,s).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(o.options,{colorSpaceConversion:"none"}))}).then(function(l){pi.add(e,l),t&&t(l),o.manager.itemEnd(e)}).catch(function(l){i&&i(l),o.manager.itemError(e),o.manager.itemEnd(e)}),o.manager.itemStart(e)}}let Ol;class mp{static getContext(){return Ol===void 0&&(Ol=new(window.AudioContext||window.webkitAudioContext)),Ol}static setContext(e){Ol=e}}class YT extends pn{constructor(e){super(e)}load(e,t,n,i){const o=this,r=new cn(this.manager);r.setResponseType("arraybuffer"),r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,function(s){try{const l=s.slice(0);mp.getContext().decodeAudioData(l,function(c){t(c)})}catch(l){i?i(l):console.error(l),o.manager.itemError(e)}},n,i)}}class jT extends ga{constructor(e,t,n=1){super(void 0,n),this.isHemisphereLightProbe=!0,this.type="HemisphereLightProbe";const i=new me().set(e),o=new me().set(t),r=new b(i.r,i.g,i.b),s=new b(o.r,o.g,o.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(r).add(s).multiplyScalar(l),this.sh.coefficients[1].copy(r).sub(s).multiplyScalar(c)}}class KT extends ga{constructor(e,t=1){super(void 0,t),this.isAmbientLightProbe=!0,this.type="AmbientLightProbe";const n=new me().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}const Mm=new Ae,Em=new Ae,Xo=new Ae;class qT{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Qt,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Qt,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,Xo.copy(e.projectionMatrix);const n=t.eyeSep/2,i=n*t.near/t.focus,o=t.near*Math.tan(eo*t.fov*.5)/t.zoom;let r,s;Em.elements[12]=-n,Mm.elements[12]=n,r=-o*t.aspect+i,s=o*t.aspect+i,Xo.elements[0]=2*t.near/(s-r),Xo.elements[8]=(s+r)/(s-r),this.cameraL.projectionMatrix.copy(Xo),r=-o*t.aspect-i,s=o*t.aspect-i,Xo.elements[0]=2*t.near/(s-r),Xo.elements[8]=(s+r)/(s-r),this.cameraR.projectionMatrix.copy(Xo)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Em),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Mm)}}class Di{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=wm(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=wm();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function wm(){return(typeof performance>"u"?Date:performance).now()}const Yo=new b,Tm=new Ge,ZT=new b,jo=new b;class JT extends ze{constructor(){super(),this.type="AudioListener",this.context=mp.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Di}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Yo,Tm,ZT),jo.set(0,0,-1).applyQuaternion(Tm),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Yo.x,i),t.positionY.linearRampToValueAtTime(Yo.y,i),t.positionZ.linearRampToValueAtTime(Yo.z,i),t.forwardX.linearRampToValueAtTime(jo.x,i),t.forwardY.linearRampToValueAtTime(jo.y,i),t.forwardZ.linearRampToValueAtTime(jo.z,i),t.upX.linearRampToValueAtTime(n.x,i),t.upY.linearRampToValueAtTime(n.y,i),t.upZ.linearRampToValueAtTime(n.z,i)}else t.setPosition(Yo.x,Yo.y,Yo.z),t.setOrientation(jo.x,jo.y,jo.z,n.x,n.y,n.z)}}class L1 extends ze{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0)return void console.warn("v3d.Audio: Audio is already playing.");if(this.hasPlaybackControl===!1)return void console.warn("v3d.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl!==!1)return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("v3d.Audio: this Audio has no playback control.")}stop(){if(this.hasPlaybackControl!==!1)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("v3d.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl!==!1)return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("v3d.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("v3d.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl!==!1)return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this;console.warn("v3d.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const Ko=new b,Im=new Ge,$T=new b,qo=new b;class e4 extends L1{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Ko,Im,$T),qo.set(0,0,1).applyQuaternion(Im);const t=this.panner;if(t.positionX){const n=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Ko.x,n),t.positionY.linearRampToValueAtTime(Ko.y,n),t.positionZ.linearRampToValueAtTime(Ko.z,n),t.orientationX.linearRampToValueAtTime(qo.x,n),t.orientationY.linearRampToValueAtTime(qo.y,n),t.orientationZ.linearRampToValueAtTime(qo.z,n)}else t.setPosition(Ko.x,Ko.y,Ko.z),t.setOrientation(qo.x,qo.y,qo.z)}}class t4{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class P1{constructor(e,t,n){let i,o,r;switch(this.binding=e,this.valueSize=n,t){case"quaternion":i=this._slerp,o=this._slerpAdditive,r=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,o=this._select,r=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,o=this._lerpAdditive,r=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=o,this._setIdentity=r,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,i=this.valueSize,o=e*i+i;let r=this.cumulativeWeight;if(r===0){for(let s=0;s!==i;++s)n[o+s]=n[s];r=t}else{r+=t;const s=t/r;this._mixBufferRegion(n,o,0,s,i)}this.cumulativeWeight=r}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,i=e*t+t,o=this.cumulativeWeight,r=this.cumulativeWeightAdditive,s=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,o<1){const l=t*this._origIndex;this._mixBufferRegion(n,i,l,1-o,t)}r>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(n[l]!==n[l+t]){s.setValue(n,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let o=n,r=i;o!==r;++o)t[o]=t[i+o%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,i,o){if(i>=.5)for(let r=0;r!==o;++r)e[t+r]=e[n+r]}_slerp(e,t,n,i){Ge.slerpFlat(e,t,e,t,e,n,i)}_slerpAdditive(e,t,n,i,o){const r=this._workIndex*o;Ge.multiplyQuaternionsFlat(e,r,e,t,e,n),Ge.slerpFlat(e,t,e,t,e,r,i)}_lerp(e,t,n,i,o){const r=1-i;for(let s=0;s!==o;++s){const l=t+s;e[l]=e[l]*r+e[n+s]*i}}_lerpAdditive(e,t,n,i,o){for(let r=0;r!==o;++r){const s=t+r;e[s]=e[s]+e[n+r]*i}}}const n4=new RegExp("[\\[\\]\\.]","g"),gp="[^\\[\\]\\.]",i4="[^"+"\\[\\]\\.".replace("\\.","")+"]";/((?:WC+[\/:])*)/.source.replace("WC",gp);const o4=/(WCOD+)?/.source.replace("WCOD",i4),r4=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",gp),a4=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",gp),s4=new RegExp("^"+o4+r4+a4+"$"),l4=["material","materials","bones","map"];class c4{constructor(e,t,n){const i=n||$e.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,o=n.length;i!==o;++i)n[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class $e{constructor(e,t,n){this.path=t,this.parsedPath=n||$e.parseTrackName(t),this.node=$e.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new $e.Composite(e,t,n):new $e(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(n4,"")}static parseTrackName(e){const t=s4.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[1],objectName:t[2],objectIndex:t[3],propertyName:t[4],propertyIndex:t[5]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const o=n.nodeName.substring(i+1);l4.indexOf(o)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=o)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(o){for(let r=0;r<o.length;r++){const s=o[r];if(s.name===t||s.uuid===t)return s;const l=n(s.children);if(l)return l}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,o=n.length;i!==o;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,o=n.length;i!==o;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,o=n.length;i!==o;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,o=n.length;i!==o;++i)n[i]=e[t++];if(this.targetObject.matrixWorldNeedsUpdate=!0,this.propertyName==="morphTargetInfluences"){const i=this.targetObject.getAuxClippingMeshes();for(let o=0;o<i.length;o++){const r=i[o];if(r.morphTargetInfluences){const s=this.targetObject.morphTargetInfluences;for(let l=0;l<s.length;l++){const c=s[l];r.morphTargetInfluences[l]=c}}}}}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let o=t.propertyIndex;if(e||(e=$e.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("v3d.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let c=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("v3d.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("v3d.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("v3d.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let d=0;d<e.length;d++)if(e[d].name===c){c=d;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material)return void console.error("v3d.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.map)return void console.error("v3d.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);e=e.material.map;break;case"constraints":if(e.constraints===void 0)return void console.error("v3d.PropertyBinding: Can not bind to constraints of node undefined.",this);e=e.constraints,c=c.replace(/"/g,"");for(let d=0;d<e.length;d++)if(e[d].name===c){c=d;break}break;default:if(e[n]===void 0)return void console.error("v3d.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(c!==void 0){if(e[c]===void 0)return void console.error("v3d.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[c]}}let r=e[i];if(r===void 0){const c=t.nodeName;return void console.error("v3d.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e)}let s=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?s=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(s=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(o!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry)return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.morphAttributes)return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);e.morphTargetDictionary[o]!==void 0&&(o=e.morphTargetDictionary[o]),this.propertyName=i}else if(i=="nodeValue"){if(o=o.replace(/"/g,""),!e.nodeValueMap)return void console.error("v3d.PropertyBinding: Trying to animate nodes in non-node material",this);if(o=e.nodeValueMap[o],o===void 0)return void console.error("v3d.PropertyBinding: Animated node not found ",this)}if(l=this.BindingType.ArrayElement,i=="nodeRGB"){if(o=o.replace(/"/g,""),!e.nodeRGBMap)return void console.error("v3d.PropertyBinding: Trying to animate nodes in non-node material",this);if(o=e.nodeRGBMap[o],o===void 0)return void console.error("v3d.PropertyBinding: Animated node not found ",this);l=this.BindingType.HasFromToArray,r=e.nodeRGB[o]}this.resolvedProperty=r,this.propertyIndex=o}else r.fromArray!==void 0&&r.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(l=this.BindingType.EntireArray,this.resolvedProperty=r,i==="morphTargetInfluences"&&(this.propertyName=i)):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][s]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}$e.Composite=c4,$e.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},$e.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},$e.prototype.GetterByBindingType=[$e.prototype._getValue_direct,$e.prototype._getValue_array,$e.prototype._getValue_arrayElement,$e.prototype._getValue_toArray],$e.prototype.SetterByBindingTypeAndVersioning=[[$e.prototype._setValue_direct,$e.prototype._setValue_direct_setNeedsUpdate,$e.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[$e.prototype._setValue_array,$e.prototype._setValue_array_setNeedsUpdate,$e.prototype._setValue_array_setMatrixWorldNeedsUpdate],[$e.prototype._setValue_arrayElement,$e.prototype._setValue_arrayElement_setNeedsUpdate,$e.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[$e.prototype._setValue_fromArray,$e.prototype._setValue_fromArray_setNeedsUpdate,$e.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class u4{constructor(){this.isAnimationObjectGroup=!0,this.uuid=wn(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,i=arguments.length;n!==i;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,o=this._bindings,r=o.length;let s,l=e.length,c=this.nCachedObjects_;for(let d=0,u=arguments.length;d!==u;++d){const h=arguments[d],p=h.uuid;let m=t[p];if(m===void 0){m=l++,t[p]=m,e.push(h);for(let f=0,g=r;f!==g;++f)o[f].push(new $e(h,n[f],i[f]))}else if(m<c){s=e[m];const f=--c,g=e[f];t[g.uuid]=m,e[m]=g,t[p]=f,e[f]=h;for(let _=0,A=r;_!==A;++_){const x=o[_],S=x[f];let M=x[m];x[m]=S,M===void 0&&(M=new $e(h,n[_],i[_])),x[f]=M}}else e[m]!==s&&console.error("v3d.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let o=this.nCachedObjects_;for(let r=0,s=arguments.length;r!==s;++r){const l=arguments[r],c=l.uuid,d=t[c];if(d!==void 0&&d>=o){const u=o++,h=e[u];t[h.uuid]=d,e[d]=h,t[c]=u,e[u]=l;for(let p=0,m=i;p!==m;++p){const f=n[p],g=f[u],_=f[d];f[d]=g,f[u]=_}}}this.nCachedObjects_=o}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let o=this.nCachedObjects_,r=e.length;for(let s=0,l=arguments.length;s!==l;++s){const c=arguments[s].uuid,d=t[c];if(d!==void 0)if(delete t[c],d<o){const u=--o,h=e[u],p=--r,m=e[p];t[h.uuid]=d,e[d]=h,t[m.uuid]=u,e[u]=m,e.pop();for(let f=0,g=i;f!==g;++f){const _=n[f],A=_[u],x=_[p];_[d]=A,_[u]=x,_.pop()}}else{const u=--r,h=e[u];u>0&&(t[h.uuid]=d),e[d]=h,e.pop();for(let p=0,m=i;p!==m;++p){const f=n[p];f[d]=f[u],f.pop()}}}this.nCachedObjects_=o}subscribe_(e,t){const n=this._bindingsIndicesByPath;let i=n[e];const o=this._bindings;if(i!==void 0)return o[i];const r=this._paths,s=this._parsedPaths,l=this._objects,c=l.length,d=this.nCachedObjects_,u=new Array(c);i=o.length,n[e]=i,r.push(e),s.push(t),o.push(u);for(let h=d,p=l.length;h!==p;++h){const m=l[h];u[h]=new $e(m,e,t)}return u}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(n!==void 0){const i=this._paths,o=this._parsedPaths,r=this._bindings,s=r.length-1,l=r[s];t[e[s]]=n,r[n]=l,r.pop(),o[n]=o[s],o.pop(),i[n]=i[s],i.pop()}}}class d4{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;const o=t.tracks,r=o.length,s=new Array(r),l={endingStart:2400,endingEnd:2400};for(let c=0;c!==r;++c){const d=o[c].createInterpolant(null);s[c]=d,d.settings=l}this._interpolantSettings=l,this._interpolants=s,this._propertyBindings=new Array(r),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._pingIsEven=!0,this._startTime=null,this.time=0,this.timeStart=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this._pingIsEven=!0,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const i=this._clip.duration,o=e._clip.duration,r=o/i,s=i/o;e.warp(1,r,t),this.warp(s,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const i=this._mixer,o=i.time,r=this.timeScale;let s=this._timeScaleInterpolant;s===null&&(s=i._lendControlInterpolant(),this._timeScaleInterpolant=s);const l=s.parameterPositions,c=s.sampleValues;return l[0]=o,l[1]=o+n,c[0]=e/r,c[1]=t/r,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled)return void this._updateWeight(e);const o=this._startTime;if(o!==null){const l=(e-o)*n;if(l<0||n===0)return;this._startTime=null,t=n*l}t*=this._updateTimeScale(e);const r=this._updateTime(t),s=this._updateWeight(e);if(s>0){const l=this._interpolants,c=this._propertyBindings;if(this.blendMode===Oh)for(let d=0,u=l.length;d!==u;++d)l[d].evaluate(r),c[d].accumulateAdditive(s);else for(let d=0,u=l.length;d!==u;++d)l[d].evaluate(r),c[d].accumulate(i,s)}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_loopIsPing(e){return this.loop!==2202||e==-1?!0:(1&e)==0===this._pingIsEven}_updateTime(e){if(e===0)return this.time;if(this.loop!==2200&&this.repetitions<=0)return this.clampWhenFinished?this.paused=!0:this.enabled=!1,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1}),this.time;var t=this.timeStart,n=Math.max(t,this._clip.duration),i=n-t;if(this.loop===2200)return this.time+=e,this._loopCount===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1)),(this.time<t||this.time>n)&&(this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=Ye(this.time,t,n),this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})),this.time;var o=this.loop===2202,r=this._loopIsPing(this._loopCount)?1:-1;this.time+=r*e;var s=this.time<t||this.time>n,l=!1;if(this._loopCount===-1&&(l=s,this._loopCount=l?-1:0,this._pingIsEven=!l,e>=0?this._setEndings(!0,this.repetitions===0,o):this._setEndings(this.repetitions===0,!0,o)),s){var c=Math.floor((this.time-t)/i);this._loopCount+=Math.abs(c);var d=this.repetitions-this._loopCount;if(d<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=Ye(this.time,t,n),this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1});else{if(d==1){var u=e<0;this._setEndings(u,!u,o)}else this._setEndings(!1,!1,o);var h=(this.time-t)%i;h<0&&(h+=i),this.time=o?n-h:h+t,l||this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:c})}}return this.time}_setEndings(e,t,n){const i=this._interpolantSettings;n?(i.endingStart=2401,i.endingEnd=2401):(i.endingStart=e?this.zeroSlopeAtStart?2401:2400:2402,i.endingEnd=t?this.zeroSlopeAtEnd?2401:2400:2402)}_scheduleFading(e,t,n){const i=this._mixer,o=i.time;let r=this._weightInterpolant;r===null&&(r=i._lendControlInterpolant(),this._weightInterpolant=r);const s=r.parameterPositions,l=r.sampleValues;return s[0]=o,l[0]=t,s[1]=o+e,l[1]=n,this}}const h4=new Float32Array(1);class B1 extends An{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,o=i.length,r=e._propertyBindings,s=e._interpolants,l=n.uuid,c=this._bindingsByRootAndName;let d=c[l];d===void 0&&(d={},c[l]=d);for(let u=0;u!==o;++u){const h=i[u],p=h.name;let m=d[p];if(m!==void 0)++m.referenceCount,r[u]=m;else{if(m=r[u],m!==void 0){m._cacheIndex===null&&(++m.referenceCount,this._addInactiveBinding(m,l,p));continue}const f=t&&t._propertyBindings[u].binding.parsedPath;m=new P1($e.create(n,p,f),h.ValueTypeName,h.getValueSize()),++m.referenceCount,this._addInactiveBinding(m,l,p),r[u]=m}s[u].resultBuffer=m.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,o=this._actionsByClip[i];this._bindAction(e,o&&o.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const o=t[n];o.useCount++==0&&(this._lendBinding(o),o.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const o=t[n];--o.useCount==0&&(o.restoreOriginalState(),this._takeBackBinding(o))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const i=this._actions,o=this._actionsByClip;let r=o[t];if(r===void 0)r={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,o[t]=r;else{const s=r.knownActions;e._byClipCacheIndex=s.length,s.push(e)}e._cacheIndex=i.length,i.push(e),r.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const o=e._clip.uuid,r=this._actionsByClip,s=r[o],l=s.knownActions,c=l[l.length-1],d=e._byClipCacheIndex;c._byClipCacheIndex=d,l[d]=c,l.pop(),e._byClipCacheIndex=null,delete s.actionByRoot[(e._localRoot||this._root).uuid],l.length===0&&delete r[o],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const o=t[n];--o.referenceCount==0&&this._removeInactiveBinding(o)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,o=t[i];e._cacheIndex=i,t[i]=e,o._cacheIndex=n,t[n]=o}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,o=t[i];e._cacheIndex=i,t[i]=e,o._cacheIndex=n,t[n]=o}_addInactiveBinding(e,t,n){const i=this._bindingsByRootAndName,o=this._bindings;let r=i[t];r===void 0&&(r={},i[t]=r),r[n]=e,e._cacheIndex=o.length,o.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,o=n.path,r=this._bindingsByRootAndName,s=r[i],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete s[o],Object.keys(s).length===0&&delete r[i]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,o=t[i];e._cacheIndex=i,t[i]=e,o._cacheIndex=n,t[n]=o}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,o=t[i];e._cacheIndex=i,t[i]=e,o._cacheIndex=n,t[n]=o}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new au(new Float32Array(2),new Float32Array(2),1,h4),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,o=t[i];e.__cacheIndex=i,t[i]=e,o.__cacheIndex=n,t[n]=o}clipAction(e,t,n){const i=t||this._root,o=i.uuid;let r=typeof e=="string"?ma.findByName(i,e):e;const s=r!==null?r.uuid:e,l=this._actionsByClip[s];let c=null;if(n===void 0&&(n=r!==null?r.blendMode:2500),l!==void 0){const u=l.actionByRoot[o];if(u!==void 0&&u.blendMode===n)return u;c=l.knownActions[0],r===null&&(r=c._clip)}if(r===null)return null;const d=new d4(this,r,t,n);return this._bindAction(d,c),this._addInactiveAction(d,s,o),d}existingAction(e,t){const n=t||this._root,i=n.uuid,o=typeof e=="string"?ma.findByName(n,e):e,r=o?o.uuid:e,s=this._actionsByClip[r];return s!==void 0&&s.actionByRoot[i]||null}stopAllAction(){const e=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,o=Math.sign(e),r=this._accuIndex^=1;for(let c=0;c!==n;++c)t[c]._update(i,e,o,r);const s=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)s[c].apply(r);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,o=i[n];if(o!==void 0){const r=o.knownActions;for(let s=0,l=r.length;s!==l;++s){const c=r[s];this._deactivateAction(c);const d=c._cacheIndex,u=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,u._cacheIndex=d,t[d]=u,t.pop(),this._removeInactiveBindingsForAction(c)}delete i[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const o in n){const r=n[o].actionByRoot[t];r!==void 0&&(this._deactivateAction(r),this._removeInactiveAction(r))}const i=this._bindingsByRootAndName[t];if(i!==void 0)for(const o in i){const r=i[o];r.restoreOriginalState(),this._removeInactiveBinding(r)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}class vp{constructor(e){this.value=e}clone(){return new vp(this.value.clone===void 0?this.value:this.value.clone())}}let p4=0;class f4 extends An{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:p4++}),this.name="",this.usage=35044,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let n=0,i=t.length;n<i;n++)this.uniforms.push(t[n].clone());return this}clone(){return new this.constructor().copy(this)}}class m4 extends Ma{constructor(e,t,n=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class g4{constructor(e,t,n,i,o){this.isGLBufferAttribute=!0,this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=o,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}class v4{constructor(e=1,t=0,n=0){return this.radius=e,this.theta=t,this.y=n,this}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}clone(){return new this.constructor().copy(this)}}const Rm=new te;class _4{constructor(e=new te(1/0,1/0),t=new te(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Rm.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Rm.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Lm=new b,Fl=new b;class va{constructor(e=new b,t=new b){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){Lm.subVectors(e,this.start),Fl.subVectors(this.end,this.start);const n=Fl.dot(Fl);let i=Fl.dot(Lm)/n;return t&&(i=Ye(i,0,1)),i}closestPointToPoint(e,t,n){const i=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const Pm=new b;class A4 extends ze{constructor(e,t){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const n=new Pe,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let r=0,s=1,l=32;r<l;r++,s++){const c=r/l*Math.PI*2,d=s/l*Math.PI*2;i.push(Math.cos(c),Math.sin(c),1,Math.cos(d),Math.sin(d),1)}n.setAttribute("position",new Ie(i,3));const o=new un({fog:!1,toneMapped:!1});this.cone=new Wn(n,o),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Pm.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Pm),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Ao=new b,Ul=new Ae,ad=new Ae;class x4 extends Wn{constructor(e){const t=D1(e),n=new Pe,i=[],o=[],r=new me(0,0,1),s=new me(0,1,0);for(let l=0;l<t.length;l++){const c=t[l];c.parent&&c.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),o.push(r.r,r.g,r.b),o.push(s.r,s.g,s.b))}n.setAttribute("position",new Ie(i,3)),n.setAttribute("color",new Ie(o,3)),super(n,new un({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,i=n.getAttribute("position");ad.copy(this.root.matrixWorld).invert();for(let o=0,r=0;o<t.length;o++){const s=t[o];s.parent&&s.parent.isBone&&(Ul.multiplyMatrices(ad,s.matrixWorld),Ao.setFromMatrixPosition(Ul),i.setXYZ(r,Ao.x,Ao.y,Ao.z),Ul.multiplyMatrices(ad,s.parent.matrixWorld),Ao.setFromMatrixPosition(Ul),i.setXYZ(r+1,Ao.x,Ao.y,Ao.z),r+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function D1(a){const e=[];a.isBone===!0&&e.push(a);for(let t=0;t<a.children.length;t++)e.push.apply(e,D1(a.children[t]));return e}class y4 extends Ue{constructor(e,t,n){super(new Ia(t,4,2),new Xt({wireframe:!0,fog:!1,toneMapped:!1})),this.light=e,this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const b4=new b,Bm=new me,Dm=new me;class C4 extends ze{constructor(e,t,n){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="HemisphereLightHelper";const i=new Ta(t);i.rotateY(.5*Math.PI),this.material=new Xt({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const o=i.getAttribute("position"),r=new Float32Array(3*o.count);i.setAttribute("color",new Te(r,3)),this.add(new Ue(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");Bm.copy(this.light.color),Dm.copy(this.light.groundColor);for(let n=0,i=t.count;n<i;n++){const o=n<i/2?Bm:Dm;t.setXYZ(n,o.r,o.g,o.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(b4.setFromMatrixPosition(this.light.matrixWorld).negate())}}class S4 extends Wn{constructor(e=10,t=10,n=4473924,i=8947848){n=new me(n),i=new me(i);const o=t/2,r=e/t,s=e/2,l=[],c=[];for(let u=0,h=0,p=-s;u<=t;u++,p+=r){l.push(-s,0,p,s,0,p),l.push(p,0,-s,p,0,s);const m=u===o?n:i;m.toArray(c,h),h+=3,m.toArray(c,h),h+=3,m.toArray(c,h),h+=3,m.toArray(c,h),h+=3}const d=new Pe;d.setAttribute("position",new Ie(l,3)),d.setAttribute("color",new Ie(c,3)),super(d,new un({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class M4 extends Wn{constructor(e=10,t=16,n=8,i=64,o=4473924,r=8947848){o=new me(o),r=new me(r);const s=[],l=[];if(t>1)for(let d=0;d<t;d++){const u=d/t*(2*Math.PI),h=Math.sin(u)*e,p=Math.cos(u)*e;s.push(0,0,0),s.push(h,0,p);const m=1&d?o:r;l.push(m.r,m.g,m.b),l.push(m.r,m.g,m.b)}for(let d=0;d<n;d++){const u=1&d?o:r,h=e-e/n*d;for(let p=0;p<i;p++){let m=p/i*(2*Math.PI),f=Math.sin(m)*h,g=Math.cos(m)*h;s.push(f,0,g),l.push(u.r,u.g,u.b),m=(p+1)/i*(2*Math.PI),f=Math.sin(m)*h,g=Math.cos(m)*h,s.push(f,0,g),l.push(u.r,u.g,u.b)}}const c=new Pe;c.setAttribute("position",new Ie(s,3)),c.setAttribute("color",new Ie(l,3)),super(c,new un({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class Dc extends Wn{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Pe;i.setIndex(new Te(n,1)),i.setAttribute("position",new Ie([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(i,new un({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}const Nm=new b,zl=new b,Om=new b;class E4 extends ze{constructor(e,t,n){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="DirectionalLightHelper",t===void 0&&(t=1);let i=new Pe;i.setAttribute("position",new Ie([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const o=new un({fog:!1,toneMapped:!1});this.lightPlane=new Pi(i,o),this.add(this.lightPlane),i=new Pe,i.setAttribute("position",new Ie([0,0,0,0,0,1],3)),this.targetLine=new Pi(i,o),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),Nm.setFromMatrixPosition(this.light.matrixWorld),zl.setFromMatrixPosition(this.light.target.matrixWorld),Om.subVectors(zl,Nm),this.lightPlane.lookAt(zl),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(zl),this.targetLine.scale.z=Om.length()}}class w4 extends ze{constructor(e){super(),this.csm=e,this.displayFrustum=!0,this.displayPlanes=!0,this.displayShadowBounds=!0;const t=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Float32Array(24),i=new Pe;i.setIndex(new Te(t,1)),i.setAttribute("position",new Te(n,3,!1));const o=new Wn(i,new un);this.add(o),this.frustumLines=o,this.cascadeLines=[],this.cascadePlanes=[],this.shadowLines=[]}updateVisibility(){const e=this.displayFrustum&&this.visible,t=this.displayPlanes&&this.visible,n=this.displayShadowBounds&&this.visible,i=this.frustumLines,o=this.cascadeLines,r=this.cascadePlanes,s=this.shadowLines;for(let l=0,c=o.length;l<c;l++){const d=o[l],u=r[l],h=s[l];d.visible=e,u.visible=e&&t,h.visible=n,h.traverse(p=>{p.visible=n})}i.visible=e}update(){const e=this.csm,t=e._sceneViewCamera;if(!t||e._needsUpdate)return;const n=e._cascades,i=n.length,o=e.mainFrustum,r=e._frustums,s=this.frustumLines.geometry.getAttribute("position"),l=this.cascadeLines,c=this.cascadePlanes,d=this.shadowLines;for(this.position.copy(t.position),this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.updateMatrixWorld(!0);l.length>i;){this.remove(l.pop()),this.remove(c.pop());const p=d.pop();p.children[0].dispose(),this.remove(p)}for(;l.length<i;){const p=new Dc(new At,16777215),m=new Xt({transparent:!0,opacity:.1,depthWrite:!1,side:Tn}),f=new Ue(new ni,m),g=new Zn,_=new Dc(new At,16776960);g.add(_),this.add(p),this.add(f),this.add(g),l.push(p),c.push(f),d.push(g)}for(let p=0;p<i;p++){const m=r[p],f=n[p].camera,g=m.vertices.far,_=l[p],A=c[p],x=d[p],S=x.children[0];_.box.min.copy(g[2]),_.box.max.copy(g[0]),_.box.max.z+=1e-4,A.position.addVectors(g[0],g[2]),A.position.multiplyScalar(.5),A.scale.subVectors(g[0],g[2]),A.scale.z=1e-4,this.remove(x),x.position.copy(f.position),x.quaternion.copy(f.quaternion),x.scale.copy(f.scale),x.updateMatrixWorld(!0),this.attach(x),S.box.min.set(f.bottom,f.left,-f.far),S.box.max.set(f.top,f.right,-f.near)}const u=o.vertices.near,h=o.vertices.far;s.setXYZ(0,h[0].x,h[0].y,h[0].z),s.setXYZ(1,h[3].x,h[3].y,h[3].z),s.setXYZ(2,h[2].x,h[2].y,h[2].z),s.setXYZ(3,h[1].x,h[1].y,h[1].z),s.setXYZ(4,u[0].x,u[0].y,u[0].z),s.setXYZ(5,u[3].x,u[3].y,u[3].z),s.setXYZ(6,u[2].x,u[2].y,u[2].z),s.setXYZ(7,u[1].x,u[1].y,u[1].z),s.needsUpdate=!0}dispose(){const e=this.frustumLines,t=this.cascadeLines,n=this.cascadePlanes,i=this.shadowLines;e.geometry.dispose(),e.material.dispose();const o=this.csm.cascades;for(let r=0;r<o;r++){const s=t[r],l=n[r],c=i[r].children[0];s.dispose(),l.geometry.dispose(),l.material.dispose(),c.dispose()}}}const Vl=new b,Rt=new Os;class T4 extends Wn{constructor(e){const t=new Pe,n=new un({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],o=[],r={};function s(m,f){l(m),l(f)}function l(m){i.push(0,0,0),o.push(0,0,0),r[m]===void 0&&(r[m]=[]),r[m].push(i.length/3-1)}s("n1","n2"),s("n2","n4"),s("n4","n3"),s("n3","n1"),s("f1","f2"),s("f2","f4"),s("f4","f3"),s("f3","f1"),s("n1","f1"),s("n2","f2"),s("n3","f3"),s("n4","f4"),s("p","n1"),s("p","n2"),s("p","n3"),s("p","n4"),s("u1","u2"),s("u2","u3"),s("u3","u1"),s("c","t"),s("p","c"),s("cn1","cn2"),s("cn3","cn4"),s("cf1","cf2"),s("cf3","cf4"),t.setAttribute("position",new Ie(i,3)),t.setAttribute("color",new Ie(o,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=r,this.update();const c=new me(16755200),d=new me(16711680),u=new me(43775),h=new me(16777215),p=new me(3355443);this.setColors(c,d,u,h,p)}setColors(e,t,n,i,o){const r=this.geometry.getAttribute("color");r.setXYZ(0,e.r,e.g,e.b),r.setXYZ(1,e.r,e.g,e.b),r.setXYZ(2,e.r,e.g,e.b),r.setXYZ(3,e.r,e.g,e.b),r.setXYZ(4,e.r,e.g,e.b),r.setXYZ(5,e.r,e.g,e.b),r.setXYZ(6,e.r,e.g,e.b),r.setXYZ(7,e.r,e.g,e.b),r.setXYZ(8,e.r,e.g,e.b),r.setXYZ(9,e.r,e.g,e.b),r.setXYZ(10,e.r,e.g,e.b),r.setXYZ(11,e.r,e.g,e.b),r.setXYZ(12,e.r,e.g,e.b),r.setXYZ(13,e.r,e.g,e.b),r.setXYZ(14,e.r,e.g,e.b),r.setXYZ(15,e.r,e.g,e.b),r.setXYZ(16,e.r,e.g,e.b),r.setXYZ(17,e.r,e.g,e.b),r.setXYZ(18,e.r,e.g,e.b),r.setXYZ(19,e.r,e.g,e.b),r.setXYZ(20,e.r,e.g,e.b),r.setXYZ(21,e.r,e.g,e.b),r.setXYZ(22,e.r,e.g,e.b),r.setXYZ(23,e.r,e.g,e.b),r.setXYZ(24,t.r,t.g,t.b),r.setXYZ(25,t.r,t.g,t.b),r.setXYZ(26,t.r,t.g,t.b),r.setXYZ(27,t.r,t.g,t.b),r.setXYZ(28,t.r,t.g,t.b),r.setXYZ(29,t.r,t.g,t.b),r.setXYZ(30,t.r,t.g,t.b),r.setXYZ(31,t.r,t.g,t.b),r.setXYZ(32,n.r,n.g,n.b),r.setXYZ(33,n.r,n.g,n.b),r.setXYZ(34,n.r,n.g,n.b),r.setXYZ(35,n.r,n.g,n.b),r.setXYZ(36,n.r,n.g,n.b),r.setXYZ(37,n.r,n.g,n.b),r.setXYZ(38,i.r,i.g,i.b),r.setXYZ(39,i.r,i.g,i.b),r.setXYZ(40,o.r,o.g,o.b),r.setXYZ(41,o.r,o.g,o.b),r.setXYZ(42,o.r,o.g,o.b),r.setXYZ(43,o.r,o.g,o.b),r.setXYZ(44,o.r,o.g,o.b),r.setXYZ(45,o.r,o.g,o.b),r.setXYZ(46,o.r,o.g,o.b),r.setXYZ(47,o.r,o.g,o.b),r.setXYZ(48,o.r,o.g,o.b),r.setXYZ(49,o.r,o.g,o.b),r.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap;Rt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Dt("c",t,e,Rt,0,0,-1),Dt("t",t,e,Rt,0,0,1),Dt("n1",t,e,Rt,-1,-1,-1),Dt("n2",t,e,Rt,1,-1,-1),Dt("n3",t,e,Rt,-1,1,-1),Dt("n4",t,e,Rt,1,1,-1),Dt("f1",t,e,Rt,-1,-1,1),Dt("f2",t,e,Rt,1,-1,1),Dt("f3",t,e,Rt,-1,1,1),Dt("f4",t,e,Rt,1,1,1),Dt("u1",t,e,Rt,.7,1.1,-1),Dt("u2",t,e,Rt,-.7,1.1,-1),Dt("u3",t,e,Rt,0,2,-1),Dt("cf1",t,e,Rt,-1,0,1),Dt("cf2",t,e,Rt,1,0,1),Dt("cf3",t,e,Rt,0,-1,1),Dt("cf4",t,e,Rt,0,1,1),Dt("cn1",t,e,Rt,-1,0,-1),Dt("cn2",t,e,Rt,1,0,-1),Dt("cn3",t,e,Rt,0,-1,-1),Dt("cn4",t,e,Rt,0,1,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Dt(a,e,t,n,i,o,r){Vl.set(i,o,r).unproject(n);const s=e[a];if(s!==void 0){const l=t.getAttribute("position");for(let c=0,d=s.length;c<d;c++)l.setXYZ(s[c],Vl.x,Vl.y,Vl.z)}}const Gl=new At;class I4 extends Wn{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),o=new Pe;o.setIndex(new Te(n,1)),o.setAttribute("position",new Te(i,3)),super(o,new un({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("v3d.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&Gl.setFromObject(this.object),Gl.isEmpty())return;const t=Gl.min,n=Gl.max,i=this.geometry.attributes.position,o=i.array;o[0]=n.x,o[1]=n.y,o[2]=n.z,o[3]=t.x,o[4]=n.y,o[5]=n.z,o[6]=t.x,o[7]=t.y,o[8]=n.z,o[9]=n.x,o[10]=t.y,o[11]=n.z,o[12]=n.x,o[13]=n.y,o[14]=t.z,o[15]=t.x,o[16]=n.y,o[17]=t.z,o[18]=t.x,o[19]=t.y,o[20]=t.z,o[21]=n.x,o[22]=t.y,o[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class R4 extends Pi{constructor(e,t=1,n=16776960){const i=n,o=new Pe;o.setAttribute("position",new Ie([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),o.computeBoundingSphere(),super(o,new un({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const r=new Pe;r.setAttribute("position",new Ie([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),r.computeBoundingSphere(),this.add(new Ue(r,new Xt({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const Fm=new b;let kl,sd;class L4 extends ze{constructor(e=new b(0,0,1),t=new b(0,0,0),n=1,i=16776960,o=.2*n,r=.2*o){super(),this.type="ArrowHelper",kl===void 0&&(kl=new Pe,kl.setAttribute("position",new Ie([0,0,0,0,1,0],3)),sd=new yr(0,.5,1,5,1),sd.translate(0,-.5,0)),this.position.copy(t),this.line=new Pi(kl,new un({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Ue(sd,new Xt({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,o,r)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Fm.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(Fm,t)}}setLength(e,t=.2*e,n=.2*t){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class P4 extends Wn{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=new Pe;n.setAttribute("position",new Ie(t,3)),n.setAttribute("color",new Ie([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new un({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(e,t,n){const i=new me,o=this.geometry.attributes.color.array;return i.set(e),i.toArray(o,0),i.toArray(o,3),i.set(t),i.toArray(o,6),i.toArray(o,9),i.set(n),i.toArray(o,12),i.toArray(o,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class N1{constructor(){this.type="ShapePath",this.color=new me,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new bs,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this}bezierCurveTo(e,t,n,i,o,r){return this.currentPath.bezierCurveTo(e,t,n,i,o,r),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(g,_){const A=_.length;let x=!1;for(let S=A-1,M=0;M<A;S=M++){let T=_[S],L=_[M],z=L.x-T.x,W=L.y-T.y;if(Math.abs(W)>Number.EPSILON){if(W<0&&(T=_[M],z=-z,L=_[S],W=-W),g.y<T.y||g.y>L.y)continue;if(g.y===T.y){if(g.x===T.x)return!0}else{const V=W*(g.x-T.x)-z*(g.y-T.y);if(V===0)return!0;if(V<0)continue;x=!x}}else{if(g.y!==T.y)continue;if(L.x<=g.x&&g.x<=T.x||T.x<=g.x&&g.x<=L.x)return!0}}return x}const n=Li.isClockWise,i=this.subPaths;if(i.length===0)return[];let o,r,s;const l=[];if(i.length===1)return r=i[0],s=new hr,s.curves=r.curves,l.push(s),l;let c=!n(i[0].getPoints());c=e?!c:c;const d=[],u=[];let h,p,m=[],f=0;u[f]=void 0,m[f]=[];for(let g=0,_=i.length;g<_;g++)r=i[g],h=r.getPoints(),o=n(h),o=e?!o:o,o?(!c&&u[f]&&f++,u[f]={s:new hr,p:h},u[f].s.curves=r.curves,c&&f++,m[f]=[]):m[f].push({h:r,p:h[0]});if(!u[0])return function(g){const _=[];for(let A=0,x=g.length;A<x;A++){const S=g[A],M=new hr;M.curves=S.curves,_.push(M)}return _}(i);if(u.length>1){let g=!1,_=0;for(let A=0,x=u.length;A<x;A++)d[A]=[];for(let A=0,x=u.length;A<x;A++){const S=m[A];for(let M=0;M<S.length;M++){const T=S[M];let L=!0;for(let z=0;z<u.length;z++)t(T.p,u[z].p)&&(A!==z&&_++,L?(L=!1,d[z].push(T)):g=!0);L&&d[A].push(T)}}_>0&&g===!1&&(m=d)}for(let g=0,_=u.length;g<_;g++){s=u[g].s,l.push(s),p=m[g];for(let A=0,x=p.length;A<x;A++)s.holes.push(p[A].h)}return l}}const qi=B4();function B4(){const a=new ArrayBuffer(4),e=new Float32Array(a),t=new Uint32Array(a),n=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(n[l]=0,n[256|l]=32768,i[l]=24,i[256|l]=24):c<-14?(n[l]=1024>>-c-14,n[256|l]=1024>>-c-14|32768,i[l]=-c-1,i[256|l]=-c-1):c<=15?(n[l]=c+15<<10,n[256|l]=c+15<<10|32768,i[l]=13,i[256|l]=13):c<128?(n[l]=31744,n[256|l]=64512,i[l]=24,i[256|l]=24):(n[l]=31744,n[256|l]=64512,i[l]=13,i[256|l]=13)}const o=new Uint32Array(2048),r=new Uint32Array(64),s=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,d=0;for(;!(8388608&c);)c<<=1,d-=8388608;c&=-8388609,d+=947912704,o[l]=c|d}for(let l=1024;l<2048;++l)o[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)r[l]=l<<23;r[31]=1199570944,r[32]=2147483648;for(let l=33;l<63;++l)r[l]=2147483648+(l-32<<23);r[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(s[l]=1024);return{floatView:e,uint32View:t,baseTable:n,shiftTable:i,mantissaTable:o,exponentTable:r,offsetTable:s}}function or(a){Math.abs(a)>65504&&console.warn("v3d.DataUtils.toHalfFloat(): Value out of range."),a=Ye(a,-65504,65504),qi.floatView[0]=a;const e=qi.uint32View[0],t=e>>23&511;return qi.baseTable[t]+((8388607&e)>>qi.shiftTable[t])}function _c(a){const e=a>>10;return qi.uint32View[0]=qi.mantissaTable[qi.offsetTable[e]+(1023&a)]+qi.exponentTable[e],qi.floatView[0]}var D4=Object.freeze({__proto__:null,fromHalfFloat:_c,toHalfFloat:or});class O1 extends ii{constructor(e,t,n){super(),this.damp=t,this.shader=De.afterimage,this.uniforms=hn.clone(this.shader.uniforms),this.uniforms.damp.value=this.damp,this.textureComp=new et(e.x,e.y,n),this.textureOld=new et(e.x,e.y,n),this.shaderMaterial=new vt({uniforms:this.uniforms,vertexShader:this.shader.vertexShader,fragmentShader:this.shader.fragmentShader}),this.compFsQuad=new hi(this.shaderMaterial);const i=new Xt;this.copyFsQuad=new hi(i)}dispose(){this.textureComp.dispose(),this.textureOld.dispose()}render(e,t,n){this.uniforms.tOld.value=this.textureOld.texture,this.uniforms.tNew.value=n.texture,this.uniforms.damp.value=this.damp,e.setRenderTarget(this.textureComp),this.compFsQuad.render(e),this.copyFsQuad.material.map=this.textureComp.texture,this.renderToScreen?(e.setRenderTarget(null),this.copyFsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(),this.copyFsQuad.render(e));const i=this.textureOld;this.textureOld=this.textureComp,this.textureComp=i}setSize(e,t){this.textureComp.setSize(e,t),this.textureOld.setSize(e,t)}}class Fo extends ii{constructor(e,t,n,i,o){super(),this.strength=t!==void 0?t:1,this.radius=Ye(n),this.threshold=i,this.resolution=e!==void 0?new te(e.x,e.y):new te(256,256),o=o||{minFilter:Le,magFilter:Le,format:Qe},this.clearColor=new me(0,0,0),this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let r=Math.round(this.resolution.x/2),s=Math.round(this.resolution.y/2);this.renderTargetBright=new et(r,s,o),this.renderTargetBright.texture.name="BloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let u=0;u<this.nMips;u++){const h=new et(r,s,o);h.texture.name="BloomPass.h"+u,h.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(h);const p=new et(r,s,o);p.texture.name="BloomPass.v"+u,p.texture.generateMipmaps=!1,this.renderTargetsVertical.push(p),r=Math.round(r/2),s=Math.round(s/2)}const l=De.bloomLumHighPass;this.highPassUniforms=hn.clone(l.uniforms),this.highPassUniforms.luminosityThreshold.value=i,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new vt({type:"BloomHighPass",uniforms:this.highPassUniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,defines:{}}),this.separableBlurMaterials=[];const c=[3,5,7,9,11];r=Math.round(this.resolution.x/2),s=Math.round(this.resolution.y/2);for(let u=0;u<this.nMips;u++)this.separableBlurMaterials.push(this.getSeparableBlurMaterial(c[u],c[u]/3)),this.separableBlurMaterials[u].uniforms.texSize.value=new te(r,s),r=Math.round(r/2),s=Math.round(s/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=t,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new b(1,1,1),new b(1,1,1),new b(1,1,1),new b(1,1,1),new b(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;const d=De.copy;this.copyUniforms=hn.clone(d.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new vt({type:"BloomCopy",defines:Object.assign({},d.defines),uniforms:this.copyUniforms,vertexShader:d.vertexShader,fragmentShader:d.fragmentShader,blending:no,blendEquation:tn,blendEquationAlpha:tn,blendSrc:xr,blendDst:ei,blendSrcAlpha:Ls,blendDstAlpha:ei,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new me,this.oldClearAlpha=1,this.basic=new Xt,this.fsQuad=new hi(null)}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()}setSize(e,t){let n=Math.round(e/2),i=Math.round(t/2);this.renderTargetBright.setSize(n,i);for(let o=0;o<this.nMips;o++)this.renderTargetsHorizontal[o].setSize(n,i),this.renderTargetsVertical[o].setSize(n,i),this.separableBlurMaterials[o].uniforms.texSize.value=new te(n,i),n=Math.round(n/2),i=Math.round(i/2)}render(e,t,n,i,o){e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const r=e.autoClear;e.autoClear=!1,e.setClearColor(this.clearColor,0),o&&e.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=n.texture,e.setRenderTarget(null),e.clear(),this.fsQuad.render(e)),this.highPassUniforms.tDiffuse.value=n.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,e.setRenderTarget(this.renderTargetBright),e.clear(),this.fsQuad.render(e);let s=this.renderTargetBright;for(let l=0;l<this.nMips;l++)this.fsQuad.material=this.separableBlurMaterials[l],this.separableBlurMaterials[l].uniforms.colorTexture.value=s.texture,this.separableBlurMaterials[l].uniforms.direction.value=Fo.BlurDirectionX,e.setRenderTarget(this.renderTargetsHorizontal[l]),e.clear(),this.fsQuad.render(e),this.separableBlurMaterials[l].uniforms.colorTexture.value=this.renderTargetsHorizontal[l].texture,this.separableBlurMaterials[l].uniforms.direction.value=Fo.BlurDirectionY,e.setRenderTarget(this.renderTargetsVertical[l]),e.clear(),this.fsQuad.render(e),s=this.renderTargetsVertical[l];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=Ye(this.radius),this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.renderTargetsHorizontal[0]),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,o&&e.state.buffers.stencil.setTest(!0),this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(n),this.fsQuad.render(e)),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=r}getSeparableBlurMaterial(e,t){return new vt({type:"BloomSeparableBlur",defines:{KERNEL_RADIUS:e,SIGMA:t},uniforms:{colorTexture:{value:null},texSize:{value:new te(.5,.5)},direction:{value:new te(.5,.5)}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_bloom_separable_blur_frag})}getCompositeMaterial(e){return new vt({type:"BloomComposite",defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_bloom_composite_frag})}}Fo.BlurDirectionX=new te(1,0),Fo.BlurDirectionY=new te(0,1);class _p extends ii{constructor(e,t,n){super(),this.scene=e,this.camera=t;const i=n.width||window.innerWidth||1,o=n.height||window.innerHeight||1,r=new et(i,o,{minFilter:Le,magFilter:Le,format:Qe});this.renderTargetDepth=r.clone(),this.renderTargetDepth.texture.name="BokehPass.depth",this.materialDepth=new vr,this.materialDepth.depthPacking=Hc,this.materialDepth.blending=En;const s=De.bokeh,l=hn.clone(s.uniforms);l.tDepth.value=this.renderTargetDepth.texture,l.focus.value=q(n.focus)?n.focus:1,l.aperture.value=q(n.aperture)?n.aperture:1,l.maxblur.value=q(n.maxblur)?n.maxblur:1,l.depthLeakThreshold.value=q(n.depthLeakThreshold)?n.depthLeakThreshold:.2,l.nearClip.value=t.near,l.farClip.value=t.far,l.aspect.value=t.aspect,Object.defineProperties(this,{focus:{get:function(){return this.uniforms.focus.value},set:function(c){this.uniforms.focus.value=c}},aperture:{get:function(){return this.uniforms.aperture.value},set:function(c){this.uniforms.aperture.value=c}},maxblur:{get:function(){return this.uniforms.maxblur.value},set:function(c){this.uniforms.maxblur.value=c}},depthLeakThreshold:{get:function(){return this.uniforms.depthLeakThreshold.value},set:function(c){this.uniforms.depthLeakThreshold.value=c}}}),this.materialBokeh=new vt({type:"Bokeh",defines:Object.assign({},s.defines),uniforms:l,vertexShader:s.vertexShader,fragmentShader:s.fragmentShader}),this.uniforms=l,this.camera2=new fi(-1,1,1,-1,0,1),this.scene2=new vn,this.quad2=new Ue(new ni(2,2),null),this.quad2.frustumCulled=!1,this.scene2.add(this.quad2),this.oldClearColor=new me,this.oldClearAlpha=1}render(e,t,n,i,o){this.quad2.material=this.materialBokeh,this.scene.overrideMaterial=this.materialDepth,e.getClearColor(this.oldClearColor),this.oldClearAlpha=e.getClearAlpha(),e.autoClear,e.autoClear=!1,e.setClearColor(16777215),e.setClearAlpha(1),e.setRenderTarget(this.renderTargetDepth),e.clear(),e.render(this.scene,this.camera),this.uniforms.tColor.value=n.texture,this.uniforms.nearClip.value=this.camera.near,this.uniforms.farClip.value=this.camera.far,this.uniforms.aspect.value=this.camera.aspect,this.renderToScreen?(e.setRenderTarget(null),e.render(this.scene2,this.camera2)):(e.setRenderTarget(t),e.clear(),e.render(this.scene2,this.camera2)),this.scene.overrideMaterial=null,e.setClearColor(this.oldClearColor),e.setClearAlpha(this.oldClearAlpha),e.autoClear=this.oldAutoClear}setCamera(e){this.camera=e}setSize(e,t){this.renderTargetDepth.setSize(e,t)}dispose(){this.renderTargetDepth.dispose()}}class oo extends ii{constructor(e,t){super(),this.textureID=t!==void 0?t:"tDiffuse",e instanceof vt?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=hn.clone(e.uniforms),this.material=new vt({type:"ShaderPass",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new hi(this.material)}render(e,t,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}dispose(){this.material.dispose()}}class Ap extends oo{constructor(){super(De.brightness_contrast),this.material.type="Grayscale"}get brightness(){return this.uniforms.brightness.value}set brightness(e){this.uniforms.brightness.value=e}get contrast(){return this.uniforms.contrast.value}set contrast(e){this.uniforms.contrast.value=e}}class Nc extends oo{constructor(e,t,n,i){super(De.fxaa),this.material.type="FXAA",this.width=n!==void 0?n:512,this.height=i!==void 0?i:256,this.needsSwap=!1}setSize(e,t){this.width=e,this.height=t,this.uniforms.resolution.value.set(1/e,1/t)}}class xp extends oo{constructor(){super(De.grayscale),this.material.type="Grayscale"}}class yp extends ii{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,n){const i=e.getContext(),o=e.state;let r,s;o.buffers.color.setMask(!1),o.buffers.depth.setMask(!1),o.buffers.color.setLocked(!0),o.buffers.depth.setLocked(!0),this.inverse?(r=0,s=1):(r=1,s=0),o.buffers.stencil.setTest(!0),o.buffers.stencil.setOp(i.REPLACE,i.REPLACE,i.REPLACE),o.buffers.stencil.setFunc(i.ALWAYS,r,4294967295),o.buffers.stencil.setClear(s),o.buffers.stencil.setLocked(!0),e.setRenderTarget(n),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),o.buffers.color.setLocked(!1),o.buffers.depth.setLocked(!1),o.buffers.stencil.setLocked(!1),o.buffers.stencil.setFunc(i.EQUAL,1,4294967295),o.buffers.stencil.setOp(i.KEEP,i.KEEP,i.KEEP),o.buffers.stencil.setLocked(!0)}setCamera(e){this.camera=e}}class F1 extends ii{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}function ai(){this.positions=[],this.previous=[],this.next=[],this.side=[],this.width=[],this.indices_array=[],this.uvs=[],this.counters=[],this.geometry=new Pe,this.widthCallback=null}function ld(a,e,t,n,i){var o;if(a=a.subarray||a.slice?a:a.buffer,t=t.subarray||t.slice?t:t.buffer,a=e?a.subarray?a.subarray(e,i&&e+i):a.slice(e,i&&e+i):a,t.set)t.set(a,n);else for(o=0;o<a.length;o++)t[o+n]=a[o];return t}function Um(a){this.headEdge=this.tailEdge=a,this.headIndex=a.index0,this.tailIndex=a.index1,this.indexCount=2}function zm(a,e){this.index0=a,this.index1=e,this.edge0=null,this.edge1=null}function bp(){this.geometry=new Pe}ai.prototype.setGeometry=function(a,e){if(this.widthCallback=e,this.positions=[],this.counters=[],a instanceof Float32Array||a instanceof Array)for(var t=0;t<a.length;t+=3)e=t/a.length,this.positions.push(a[t],a[t+1],a[t+2]),this.positions.push(a[t],a[t+1],a[t+2]),this.counters.push(e),this.counters.push(e);this.process()},ai.prototype.compareV3=function(a,e){var t=6*a,n=6*e;return this.positions[t]===this.positions[n]&&this.positions[t+1]===this.positions[n+1]&&this.positions[t+2]===this.positions[n+2]},ai.prototype.copyV3=function(a){var e=6*a;return[this.positions[e],this.positions[e+1],this.positions[e+2]]},ai.prototype.process=function(){var a,e,t=this.positions.length/6;this.previous=[],this.next=[],this.side=[],this.width=[],this.indices_array=[],this.uvs=[];for(var n=0;n<t;n++)this.side.push(1),this.side.push(-1);for(n=0;n<t;n++)a=this.widthCallback?this.widthCallback(n/(t-1)):1,this.width.push(a),this.width.push(a);for(n=0;n<t;n++)this.uvs.push(n/(t-1),0),this.uvs.push(n/(t-1),1);for(e=this.compareV3(0,t-1)?this.copyV3(t-2):this.copyV3(0),this.previous.push(e[0],e[1],e[2]),this.previous.push(e[0],e[1],e[2]),n=0;n<t-1;n++)e=this.copyV3(n),this.previous.push(e[0],e[1],e[2]),this.previous.push(e[0],e[1],e[2]);for(n=1;n<t;n++)e=this.copyV3(n),this.next.push(e[0],e[1],e[2]),this.next.push(e[0],e[1],e[2]);for(e=this.compareV3(t-1,0)?this.copyV3(1):this.copyV3(t-1),this.next.push(e[0],e[1],e[2]),this.next.push(e[0],e[1],e[2]),n=0;n<t-1;n++){var i=2*n;this.indices_array.push(i,i+1,i+2),this.indices_array.push(i+2,i+1,i+3)}this.attributes?(this.attributes.position.copyArray(new Float32Array(this.positions)),this.attributes.position.needsUpdate=!0,this.attributes.previous.copyArray(new Float32Array(this.previous)),this.attributes.previous.needsUpdate=!0,this.attributes.next.copyArray(new Float32Array(this.next)),this.attributes.next.needsUpdate=!0,this.attributes.side.copyArray(new Float32Array(this.side)),this.attributes.side.needsUpdate=!0,this.attributes.width.copyArray(new Float32Array(this.width)),this.attributes.width.needsUpdate=!0,this.attributes.uv.copyArray(new Float32Array(this.uvs)),this.attributes.uv.needsUpdate=!0,this.attributes.counters.copyArray(new Float32Array(this.counters)),this.attributes.counters.needsUpdate=!0,this.attributes.index.copyArray(new Uint16Array(this.indices_array)),this.attributes.index.needsUpdate=!0):this.attributes={position:new Te(new Float32Array(this.positions),3),previous:new Te(new Float32Array(this.previous),3),next:new Te(new Float32Array(this.next),3),side:new Te(new Float32Array(this.side),1),width:new Te(new Float32Array(this.width),1),uv:new Te(new Float32Array(this.uvs),2),counters:new Te(new Float32Array(this.counters),1),index:new Te(new Uint16Array(this.indices_array),1)},this.geometry.setAttribute("position",this.attributes.position),this.geometry.setAttribute("previous",this.attributes.previous),this.geometry.setAttribute("next",this.attributes.next),this.geometry.setAttribute("side",this.attributes.side),this.geometry.setAttribute("width",this.attributes.width),this.geometry.setAttribute("uv",this.attributes.uv),this.geometry.setAttribute("counters",this.attributes.counters),this.geometry.setIndex(this.attributes.index)},ai.prototype.advance=function(a){var e=this.attributes.position.array,t=this.attributes.previous.array,n=this.attributes.next.array,i=e.length;ld(e,0,t,0,i),ld(e,6,e,0,i-6),e[i-6]=a.x,e[i-5]=a.y,e[i-4]=a.z,e[i-3]=a.x,e[i-2]=a.y,e[i-1]=a.z,ld(e,6,n,0,i-6),n[i-6]=a.x,n[i-5]=a.y,n[i-4]=a.z,n[i-3]=a.x,n[i-2]=a.y,n[i-1]=a.z,this.attributes.position.needsUpdate=!0,this.attributes.previous.needsUpdate=!0,this.attributes.next.needsUpdate=!0},ai.updateAttributes=function(a){var e=a.attributes.position.array;a.attributes.previous.array,a.attributes.next.array;var t=new ai;t.positions=e,t.process(),a.attributes.previous=t.attributes.previous,a.attributes.previous.needsUpdate=!0,a.attributes.next=t.attributes.next,a.attributes.next.needsUpdate=!0},Object.assign(Um.prototype,{mergeStrip:function(a){var e=this.headIndex,t=a.headIndex,n=this.tailIndex,i=a.tailIndex;e==t?(this.headEdge.linkToEdge(a.headEdge),a.headEdge.linkToEdge(this.headEdge),this.headEdge=a.tailEdge,this.headIndex=a.tailIndex,this.indexCount+=a.indexCount-1):e==i?(this.headEdge.linkToEdge(a.tailEdge),a.tailEdge.linkToEdge(this.headEdge),this.headEdge=a.headEdge,this.headIndex=a.headIndex,this.indexCount+=a.indexCount-1):n==t?(this.tailEdge.linkToEdge(a.headEdge),a.headEdge.linkToEdge(this.tailEdge),this.tailEdge=a.tailEdge,this.tailIndex=a.tailIndex,this.indexCount+=a.indexCount-1):n==i&&(this.tailEdge.linkToEdge(a.tailEdge),a.tailEdge.linkToEdge(this.tailEdge),this.tailEdge=a.headEdge,this.tailIndex=a.headIndex,this.indexCount+=a.indexCount-1)},getIndicesFlat:function(){for(var a=new Float32Array(this.indexCount),e=0,t=null,n=this.headEdge,i=a[e++]=this.headIndex;n!==null;){i=n.index0==i?n.index1:n.index0,a[e++]=i;var o=n.edge0;o!=t&&o!==null||(o=n.edge1),o==t&&(o=null),t=n,n=o}return a}}),Object.assign(zm.prototype,{linkToEdge:function(a){this.edge0===null?this.edge0=a:this.edge1===null&&(this.edge1=a)}}),Object.assign(bp.prototype,{fromBufferGeometry:function(){function a(e,t,n){var i=e.headIndex,o=e.tailIndex;return t[i][0]||t[o][0]||n[i][0]||n[o][0]||null}return function(e){var t=e.getAttribute("position"),n=e.getIndex();if(t!==void 0){var i=[];if(n!==null)(function(g){for(var _=g.length%2?g.length-1:g.length,A={},x={},S=0;S<_;S+=2){var M=(V=new Um(new zm(g[S],g[S+1]))).headIndex,T=V.tailIndex;A[M]=A[M]||[],A[T]=A[T]||[],x[M]=x[M]||[],x[T]=x[T]||[],A[M].push(V),x[T].push(V)}var L=new Pc;for(var z in A)A[z].length&&L.push(new v1(A[z]),z);for(var W=[],V=L.first&&L.first.value[0];V;){A[M=V.headIndex].splice(A[M].indexOf(V),1),x[T=V.tailIndex].splice(x[T].indexOf(V),1),A[M].length==0&&L.removeNodeByKey(M);for(var N=a(V,A,x);N!==null;)A[M=N.headIndex].splice(A[M].indexOf(N),1),x[T=N.tailIndex].splice(x[T].indexOf(N),1),A[M].length==0&&L.removeNodeByKey(M),V.mergeStrip(N),N=a(V,A,x);W.push(V),V=L.first&&L.first.value[0]}return W})(n.array).forEach(function(g){var _=new ai,A=new Float32Array(3*g.indexCount);g.getIndicesFlat().forEach(function(x,S){A.set(t.array.subarray(3*x,3*x+3),3*S)}),_.setGeometry(A),i.push(_)});else{var o=new ai;o.setGeometry(t.array),i.push(o)}var r=[],s=[],l=[],c=[],d=[],u=[],h=[],p=[],m=0;i.forEach(function(g){r=r.concat(g.positions),s=s.concat(g.previous),l=l.concat(g.next),c=c.concat(g.side),d=d.concat(g.width),u=u.concat(g.uvs),h=h.concat(g.counters);var _=g.indices_array.map(function(A){return A+m});p=p.concat(_),m+=g.positions.length/3}),this.geometry.setAttribute("position",new Te(new Float32Array(r),3)),this.geometry.setAttribute("previous",new Te(new Float32Array(s),3)),this.geometry.setAttribute("next",new Te(new Float32Array(l),3)),this.geometry.setAttribute("side",new Te(new Float32Array(c),1)),this.geometry.setAttribute("width",new Te(new Float32Array(d),1)),this.geometry.setAttribute("uv",new Te(new Float32Array(u),2)),this.geometry.setAttribute("counters",new Te(new Float32Array(h),1));var f=Bg(p)>65535?Uint32Array:Uint16Array;this.geometry.setIndex(new Te(new f(p),1))}}}()});class hu extends Ca{constructor(e){super(),this.type="MeshLineMaterial",this.lineWidth=1,this.sizeAttenuation=1,this.color=new me(16777215),this.opacity=1,this.useMap=0,this.map=null,this.useAlphaMap=0,this.alphaMap=null,this.visibility=1,this.alphaTest=0,this.repeat=new te(1,1),this.uniforms={lineWidth:{value:1},sizeAttenuation:{value:1},color:{value:new me(16777215)},opacity:{value:1},useMap:{value:0},map:{value:null},alphaMap:{value:null},useAlphaMap:{value:0},visibility:{value:1},alphaTest:{value:0},repeat:{value:new te(1,1)}},this.vertexShader=Me.raw_meshline_vert,this.fragmentShader=Me.raw_meshline_frag,this.setValues(e)}copy(e){return super.copy(e),this.lineWidth=e.lineWidth,this.sizeAttenuation=e.sizeAttenuation,this.color.copy(e.color),this.opacity=e.opacity,this.useMap=e.useMap,this.map=e.map,this.useAlphaMap=e.useAlphaMap,this.alphaMap=e.alphaMap,this.visibility=e.visibility,this.alphaTest=e.alphaTest,this.repeat.copy(e.repeat),this}}hu.prototype.isMeshLineMaterial=!0;class Ti extends ii{constructor(e,t,n,i){super(),this.renderScene=t,this.renderCamera=n,this.selectedObjects=i!==void 0?i:[],this.visibleEdgeColor=new Re(1,1,1,1),this.hiddenEdgeColor=new Re(.1,.04,.02,1),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,this.renderToScreen=!1,this.resolution=e!==void 0?new te(e.x,e.y):new te(256,256);const o=Math.round(this.resolution.x/this.downSampleRatio),r=Math.round(this.resolution.y/this.downSampleRatio);this.renderTargetMaskBuffer=new et(this.resolution.x,this.resolution.y),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.renderTargetDepthBuffer=new et(this.resolution.x,this.resolution.y),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new et(o,r),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new et(o,r),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new et(Math.round(o/2),Math.round(r/2)),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new et(o,r),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new et(Math.round(o/2),Math.round(r/2)),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1,this.separableBlurMaterial1=this.getSeparableBlurMaterial(4),this.separableBlurMaterial1.uniforms.texSize.value=new te(o,r),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeparableBlurMaterial(4),this.separableBlurMaterial2.uniforms.texSize.value=new te(Math.round(o/2),Math.round(r/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=4,this.overlayMaterial=this.getOverlayMaterial();const s=De.copy;this.copyUniforms=hn.clone(s.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new vt({defines:Object.assign({},s.defines),uniforms:this.copyUniforms,vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,blending:En,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new me,this.oldClearAlpha=1,this.basic=new Xt({toneMapped:!1}),this.fsQuad=new hi(null),this.camera=new fi(-1,1,1,-1,0,1),this.tempPulseColor1=new Re,this.tempPulseColor2=new Re,this.textureMatrix=new Ae,this.visibilityState=new WeakMap,this._depthMaterial=new vr({blending:En,depthPacking:Hc,side:Tn}),this._maskMaterial=new rp({side:Tn})}dispose(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose()}setSize(e,t){this.renderTargetMaskBuffer.setSize(e,t);let n=Math.round(e/this.downSampleRatio),i=Math.round(t/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(n,i),this.renderTargetBlurBuffer1.setSize(n,i),this.renderTargetEdgeBuffer1.setSize(n,i),this.separableBlurMaterial1.uniforms.texSize.value=new te(n,i),n=Math.round(n/2),i=Math.round(i/2),this.renderTargetBlurBuffer2.setSize(n,i),this.renderTargetEdgeBuffer2.setSize(n,i),this.separableBlurMaterial2.uniforms.texSize.value=new te(n,i)}saveVisibilityState(){const e=this;e.renderScene.traverse(function(t){t instanceof Ue&&e.visibilityState.set(t,t.visible)})}restoreVisibilityState(){const e=this;e.renderScene.traverse(function(t){t instanceof Ue&&(t.visible=e.visibilityState.get(t))})}changeVisibilityOfSelectedObjects(e){const t=this;function n(i){i instanceof Ue&&t.visibilityState.get(i)&&(i.visible=e)}for(let i=0;i<t.selectedObjects.length;i++){const o=t.selectedObjects[i];n(o);const r=o.children;for(let s=0;s<r.length;s++){const l=r[s];l.isMesh&&l.isMaterialGeneratedMesh&&n(l)}}}changeVisibilityOfNonSelectedObjects(e){const t=this,n=[];function i(o){o instanceof Ue&&t.visibilityState.get(o)&&n.push(o)}for(let o=0;o<t.selectedObjects.length;o++){const r=t.selectedObjects[o];i(r);const s=r.children;for(let l=0;l<s.length;l++){const c=s[l];c.isMesh&&c.isMaterialGeneratedMesh&&i(c)}}t.renderScene.traverse(function(o){if(o instanceof Ue&&t.visibilityState.get(o)){let r=!1;for(let s=0;s<n.length;s++)if(n[s].id===o.id){r=!0;break}r||(o.visible=e)}})}updateTextureMatrix(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)}render(e,t,n,i,o){if(this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=n.texture,e.setRenderTarget(null),e.clear(),this.fsQuad.render(e)),this.selectedObjects.length===0)return;e.getClearColor(this.oldClearColor),this.oldClearAlpha=e.getClearAlpha();const r=e.autoClear;e.autoClear=!1,o&&e.context.disable(e.context.STENCIL_TEST),e.setClearColor(16777215,1);const s=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.traverse(function(l){l.isAnnotationControl&&(l._doUpdateSave=l.doUpdate,l.doUpdate=!1)}),this.saveVisibilityState(),e.setRenderTarget(this.renderTargetDepthBuffer),e.clear(),this.changeVisibilityOfSelectedObjects(!1),this.changeVisibilityOfNonSelectedObjects(!0),this.renderScene.overrideMaterial=this._depthMaterial,e.render(this.renderScene,this.renderCamera),this.updateTextureMatrix(),e.setRenderTarget(this.renderTargetMaskBuffer),e.clear(),this.changeVisibilityOfSelectedObjects(!0),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this._maskMaterial,this.renderScene.overrideMaterial.cameraNearFar=new te(this.renderCamera.near,this.renderCamera.far),this.renderScene.overrideMaterial.depthTexture=this.renderTargetDepthBuffer.texture,this.renderScene.overrideMaterial.textureMatrix=this.textureMatrix,e.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.restoreVisibilityState(),this.renderScene.background=s,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,e.setRenderTarget(this.renderTargetMaskDownSampleBuffer),e.clear(),this.fsQuad.render(e),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){const l=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2;this.tempPulseColor1.multiplyScalar(l),this.tempPulseColor2.multiplyScalar(l)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value=new te(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=Ti.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,e.setRenderTarget(this.renderTargetBlurBuffer1),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=Ti.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=Ti.BlurDirectionX,e.setRenderTarget(this.renderTargetBlurBuffer2),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=Ti.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer2),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,o&&e.context.enable(e.context.STENCIL_TEST),this.renderToScreen?e.setRenderTarget(null):e.setRenderTarget(n),this.fsQuad.render(e),e.setClearColor(this.oldClearColor,this.oldClearAlpha),e.autoClear=r,this.renderScene.traverse(function(l){l.isAnnotationControl&&(l.doUpdate=l._doUpdateSave)})}getEdgeDetectionMaterial(){return new vt({type:"OutlineEdgeDetection",defines:{HIDDEN_EDGE_ALPHA:1},uniforms:{maskTexture:{value:null},texSize:{value:new te(.5,.5)},visibleEdgeColor:{value:new Re(1,1,1,1)},hiddenEdgeColor:{value:new Re(1,1,1,1)}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_outline_edge_frag})}getSeparableBlurMaterial(e){return new vt({type:"OutlineSeparableBlur",defines:{MAX_RADIUS:e},uniforms:{colorTexture:{value:null},texSize:{value:new te(.5,.5)},direction:{value:new te(.5,.5)},kernelRadius:{value:1}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_outline_blur_frag})}getOverlayMaterial(){return new vt({type:"OutlineOverlay",uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_outline_overlay_frag,blending:no,blendEquation:tn,blendEquationAlpha:tn,blendSrc:xr,blendDst:Ri,blendSrcAlpha:ei,blendDstAlpha:ei,depthTest:!1,depthWrite:!1,transparent:!0})}setCamera(e){this.renderCamera=e}}Ti.BlurDirectionX=new te(1,0),Ti.BlurDirectionY=new te(0,1);class Oc extends ii{constructor(e,t,n,i,o){super(),this.scene=e,this.camera=t,this.overrideMaterial=n,this.clearColor=i,this.clearAlpha=o!==void 0?o:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new me}render(e,t,n){const i=e.autoClear;let o,r;e.autoClear=!1,this.overrideMaterial!==void 0&&(r=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),o=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:n),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,o),this.overrideMaterial!==void 0&&(this.scene.overrideMaterial=r),e.autoClear=i}setCamera(e){this.camera=e}}class ws extends ii{constructor(e,t,n,i){super(),this.scene=e,this.camera=t,this.sampleLevel=4,this.unbiased=!0,this.clearColor=n!==void 0?n:0,this.clearAlpha=i!==void 0?i:0,this._oldClearColor=new me;const o=De.copy;this.copyUniformsAccum=hn.clone(o.uniforms),this.copyMaterialAccum=new vt({type:"SSAACopyAccum",defines:Object.assign({},o.defines),uniforms:this.copyUniformsAccum,vertexShader:o.vertexShader,fragmentShader:o.fragmentShader,premultipliedAlpha:!0,transparent:!0,blending:os,depthTest:!1,depthWrite:!1}),this.fsQuadAccum=new hi(this.copyMaterialAccum),this.copyUniformsFinal=hn.clone(o.uniforms),this.copyMaterialFinal=new vt({type:"SSAACopyFinal",defines:Object.assign({},o.defines),uniforms:this.copyUniformsFinal,vertexShader:o.vertexShader,fragmentShader:o.fragmentShader,premultipliedAlpha:!1,transparent:!1,blending:En,depthTest:!1,depthWrite:!1}),this.fsQuadFinal=new hi(this.copyMaterialFinal),this.iterative=!1,this.iterativeFrame=0}_getJitterOffsets(){return N4[Math.max(0,Math.min(this.sampleLevel,5))]}_isLastIterativeFrame(){const e=this._getJitterOffsets();return this.iterativeFrame==e.length-1}dispose(){this.sampleRenderTarget&&(this.sampleRenderTarget.dispose(),this.sampleRenderTarget=null,this.accumRenderTarget.dispose(),this.accumRenderTarget=null)}setSize(e,t){this.sampleRenderTarget&&(this.sampleRenderTarget.setSize(e,t),this.accumRenderTarget.setSize(e,t))}render(e,t,n){this.sampleRenderTarget||(this.sampleRenderTarget=n.clone(),this.sampleRenderTarget.texture.name="SSAARenderPass.sample",this.accumRenderTarget=n.clone(),this.accumRenderTarget.texture.name="SSAARenderPass.accum");const i=this._getJitterOffsets(),o=e.autoClear;e.autoClear=!1,e.getClearColor(this._oldClearColor);const r=e.getClearAlpha(),s=1/i.length;this.copyUniformsAccum.tDiffuse.value=this.sampleRenderTarget.texture;const l=n.width,c=n.height,d=this.camera.view?this.camera.view.offsetX:0,u=this.camera.view?this.camera.view.offsetY:0;let h,p;this.iterative?(h=this.iterativeFrame,p=performance.now()):h=0;const m=i.length;for(let f=h;f<m;f++){this.dispatchEvent({type:"iteration",frame:f});const g=i[f];this.camera.setViewOffset&&this.camera.setViewOffset(l,c,d+.0625*g[0],u+.0625*g[1],l,c);let _=s;if(this.unbiased&&(_+=.03125*((f+.5)/i.length-.5)),this.copyUniformsAccum.opacity.value=_,e.setClearColor(this.clearColor,this.clearAlpha),e.setRenderTarget(this.sampleRenderTarget),e.clear(),e.render(this.scene,this.camera),this.iterative?e.setRenderTarget(this.accumRenderTarget):e.setRenderTarget(this.renderToScreen?null:t),f===0&&(e.setClearColor(0,0),e.clear()),this.fsQuadAccum.render(e),this.iterativeFrame=f,this.iterative&&performance.now()-p>4)break}this.iterative&&(this._isLastIterativeFrame()?(this.copyUniformsFinal.tDiffuse.value=this.accumRenderTarget.texture,e.setRenderTarget(this.renderToScreen?null:t),this.fsQuadFinal.render(e),this.iterativeFrame=0):this.iterativeFrame++),this.camera.setViewOffset&&this.camera.setViewOffset(l,c,d,u,l,c),e.autoClear=o,e.setClearColor(this._oldClearColor,r)}isLastIterativeFrame(){console.error("isLastIterativeFrame() deprectated, use pass event listener instead")}setCamera(e){this.camera=e}}const N4=[[[0,0]],[[4,4],[-4,-4]],[[-2,-6],[6,-2],[-6,2],[2,6]],[[1,-3],[-1,3],[5,1],[-3,-5],[-5,5],[-7,-1],[3,7],[7,-7]],[[1,1],[-1,-3],[-3,2],[4,-1],[-5,-2],[2,5],[5,3],[3,-5],[-2,6],[0,-7],[-4,-6],[-6,4],[-8,0],[7,-4],[6,7],[-7,-8]],[[-4,-7],[-7,-5],[-3,-5],[-5,-4],[-1,-4],[-2,-2],[-6,-1],[-4,0],[-7,1],[-1,2],[-6,3],[-3,3],[-7,6],[-3,6],[-5,7],[-1,7],[5,-7],[1,-6],[6,-5],[4,-4],[2,-3],[7,-2],[1,-1],[4,-1],[2,1],[6,2],[0,4],[4,4],[2,5],[7,5],[5,6],[3,7]]];class U1 extends ii{constructor(e,t,n){super(),this.enabled=!0,this.needsSwap=!1,n=n||{},this.objects=n.objects||[],this.steps=q(n.steps)||10,this.stride=q(n.stride)||30,this.binarySearchSteps=q(n.binarySearchSteps)||4,this.renderTargetScale=q(n.renderTargetScale)||.5,this.thickness=q(n.thickness)||.01,this.maxDistance=q(n.maxDistance)||100,this.jitter=q(n.jitter)||1,this.useRefract=q(n.useRefract)||!1,this.renderAfter=q(n.renderAfter)||[],this.simpleRefraction=q(n.simpleRefraction)||!1,this.scene=e,this.camera=t,this._prevClearColor=new me,this._depthBuffer=new et(256,256,{minFilter:st,magFilter:st,format:Qe,type:_t}),this._depthBuffer.texture.name="SSRPass.Depth",this._depthBuffer.texture.generateMipmaps=!1,this._depthMaterial=new vr,this._depthMaterial.depthPacking=3202,this._backfaceDepthBuffer=this._depthBuffer.clone(),this._backfaceDepthBuffer.texture.name="SSRPass.Depth",this._backfaceDepthMaterial=new vr,this._backfaceDepthMaterial.depthPacking=3202,this._backfaceDepthMaterial.side=nn,this.basic=new Xt,this.fsQuad=new hi(null)}_setLayer(e,t){e.layers.set(t),e.isMesh&&e.isMaterialGeneratedMesh&&e.parent.layers.enable(t)}dispose(){this._depthBuffer.dispose(),this._backfaceDepthBuffer.dispose();for(let e=0;e<this.objects.length;e++){const t=this.objects[e],n=t.material;n&&(this._setLayer(t,0),delete n.defines.USE_SSR,delete n.defines.USE_SSR_REFRACT,n.needsUpdate=!0)}this.objects.splice(0);for(let e=0;e<this.renderAfter.length;e++){const t=this.renderAfter[e];this._setLayer(t,0)}this.renderAfter.splice(0)}setCamera(e){this.camera=e}setSize(e,t){e*=this.renderTargetScale,t*=this.renderTargetScale,this._depthBuffer.setSize(e,t),this._backfaceDepthBuffer.setSize(e,t)}render(e,t,n,i,o){const r=this;e.getClearColor(this._prevClearColor);const s=e.getClearAlpha(),l=e.autoClear;e.autoClear=!0,e.setClearColor(new me(0,0,0),0);const c=this.scene.background;this.scene.background=null;const d=this.camera.layers.mask,u=this.camera.ignoreShadowLayers,h=this.scene.overrideMaterial;this.fsQuad.material=this.basic,this.basic.map=n.texture,e.setRenderTarget(t),e.clear(),this.fsQuad.render(e),this.useRefract||(this._depthMaterial.side=Tn),this.camera.layers.enable(this.useRefract?3:5),this.useRefract&&this.simpleRefraction||(this.scene.overrideMaterial=this._depthMaterial,e.setRenderTarget(this._depthBuffer),e.clear(),e.render(this.scene,this.camera)),this.useRefract||(this.scene.overrideMaterial=this._backfaceDepthMaterial,e.setRenderTarget(this._backfaceDepthBuffer),e.clear(),e.render(this.scene,this.camera)),this.scene.overrideMaterial=h,this.scene.traverse(function(p){p.isLight&&(p.userData.oldLayersMask=p.layers.mask,p.layers.enable(r.useRefract?5:3),r.renderAfter.length&&p.layers.enable(r.useRefract?6:4))});for(let p=0;p<this.objects.length;p++){const m=this.objects[p],f=m.material;f&&f.isMeshNodeMaterial&&(this._setLayer(m,this.useRefract?5:3),f.defines.USE_SSR="",this.useRefract&&(f.defines.USE_SSR_REFRACT="",this.simpleRefraction&&(f.defines.SSR_SIMPLE_REFRACT="")),f.ssrParams={invProjectionMatrix:new Ae().copy(this.camera.projectionMatrix).invert(),sourceBuffer:t,depthBuffer:this._depthBuffer,backfaceDepthBuffer:this._backfaceDepthBuffer,stride:this.stride,thickness:this.thickness,maxDistance:this.maxDistance,jitter:this.jitter},f.needsUpdate=!0,f.defines.MAX_STEPS!==this.steps&&(f.defines.MAX_STEPS=Math.floor(this.steps),f.needsUpdate=!0),f.defines.BINARY_SEARCH_ITERATIONS!==this.binarySearchSteps&&(f.defines.BINARY_SEARCH_ITERATIONS=Math.floor(this.binarySearchSteps),f.needsUpdate=!0))}for(let p=0;p<this.renderAfter.length;p++){const m=this.renderAfter[p];this._setLayer(m,this.useRefract?6:4)}this.camera.layers.set(this.useRefract?5:3),this.camera.ignoreShadowLayers=!0,e.autoClear=!1,e.setRenderTarget(n),e.render(this.scene,this.camera),this.renderAfter.length&&(this.camera.layers.set(this.useRefract?6:4),e.render(this.scene,this.camera)),this.scene.background=c,this.camera.layers.mask=d,this.camera.ignoreShadowLayers=u,this.scene.traverse(function(p){p.isLight&&"oldLayersMask"in p.userData&&(p.layers.mask=p.userData.oldLayersMask,delete p.userData.oldLayersMask)}),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=n.texture,e.setRenderTarget(null),e.clear(),this.fsQuad.render(e)),e.setClearColor(this._prevClearColor,s),e.autoClear=l}}class Cp extends oo{constructor(){super(De.tonemap),this.material.type="ToneMap"}}const O4="MADE WITH VERGE3D TRIAL",Vm={Afterimage:O1,Bloom:Fo,Bokeh:_p,"Brightness/Contrast":Ap,FXAA:Nc,Grayscale:xp,Mask:yp,Outline:Ti,Render:Oc,SSAA:ws,SSR:U1,ToneMapping:Cp,"Copy/Other":oo},F4={[Qe]:"RGBA",[ps]:"RGBA_BPTC",[hs]:"RGBA_ASTC_4x4",[ia]:"RGB_S3TC_DXT1",[oa]:"RGBA_S3TC_DXT5",[ls]:"RGB_PVRTC_4BPPV1",[cs]:"RGBA_PVRTC_4BPPV1",[Wc]:"RGB_ETC1",[us]:"RGB_ETC2",[ds]:"RGB_ETC2_EAC"},To={getPageParams:function(a){let e=(a=a||window).location.href.toString();const t={};if(e.indexOf("?")==-1)return t;const n=e.split("#")[0].split("?")[1].split("&");for(let i=0;i<n.length;i++){const o=n[i].split("="),r=decodeURIComponent(o[0]);o.length==1?t[r]="":t[r]=decodeURIComponent(o[1])}return t},updatePageParam:function(a,e,t){let n,i,o=null,r="",s=a.split("?"),l=s[0],c=s[1],d="";if(c){n=c.split("#"),i=n[0],o=n[1],o&&(c=i),s=c.split("&");for(let u=0;u<s.length;u++)s[u].split("=")[0]!=e&&(r+=d+s[u],d="&")}else n=l.split("#"),i=n[0],o=n[1],i&&(l=i);return o&&(t+="#"+o),l+"?"+r+(d+""+e+"="+t)},loadScript:function(a,e,t,n){function i(s){r.removeEventListener("load",i,!1),r.removeEventListener("error",o,!1),e.removeChild(r),t(s)}function o(s){r.removeEventListener("load",i,!1),r.removeEventListener("error",o,!1),e.removeChild(r),n(s)}const r=document.createElement("script");r.addEventListener("load",i,!1),r.addEventListener("error",o,!1),e.appendChild(r),r.src=a},drawWatermark:function(a){setTimeout(function(){typeof __V3D_DEVTOOLS__<"u"&&__V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:pr,v3dl:Ec}}))},0);const e=a.container;if(da(Ec)!=3483952072)return;const t=["color: #fff;","opacity: 0.5;","font-size: 18px;","font-family: sans-serif;","text-align: center;","text-decoration: none;","position: absolute;","bottom: 1%;","right: 1%;","user-select: none;","z-index: 9999;","text-shadow: 1px 1px #000;"].join(`
`),n=document.createElement("div");n.innerHTML=`<a href="https://www.soft8soft.com/verge3d-trial/" target="_blank" style="${t}">${O4}</a>`,e.appendChild(n),setTimeout(function(){e.contains(n)&&da(n.textContent)==890310108||a.dispose()},1e3)},isXML:function(a){return a.match(/.*\.xml$/)!==null},isJS:function(a){return a.match(/.*\.js$/)!==null},addToAppList:function(a){const e=_s();e.v3d&&(e.v3d.apps=e.v3d.apps||[],e.v3d.apps.indexOf(a)==-1&&e.v3d.apps.push(a))},removeFromAppList:function(a){const e=_s();if(e.v3d&&e.v3d.apps){const t=e.v3d.apps.indexOf(a);t>-1&&e.v3d.apps.splice(t,1)}},printPerformanceInfo:function(a,e){e=e||1;const t=a.renderer.info,n=t.autoReset;t.autoReset=!1,t.reset();const i=a.frame;for(let r=0;r<t.programs.length;r++)t.programs[r].profile.calcRenderTime=!0;function o(r,s){s?console.log("%c"+r,"color:red"):console.log(r)}setTimeout(function(){if(o("--- Verge3D Performance Profile ("+e+"s) ---"),!a.scene)return void o("Scene not loaded");const r=a.frame-i,s=Math.round(a._loadingTime);o(`Scene Loading Time: ${s}ms`,s>1e4);const l=a._loadSceneURL.indexOf(".xz",a._loadSceneURL.length-3)!=-1;o("Asset Compression: "+(l?"yes":"no"),l==0);const c=r/e;o("FPS: "+c,c<30);const d=t.render.calls/r;o("Render Calls: "+d,d>1e3);const u=t.render.triangles/r;o("Triangles Rendered: "+u,u>1e6),o("Geometry Buffers: "+t.memory.geometries,t.memory.geometries>200),o("HDR Rendering: "+(a.useHDR?"yes":"no")),o("Order-Independent Transparency: "+(a.renderer.useOIT?"yes":"no"));const h=a.renderer.getDrawingBufferSize(new te);o("Viewport Resolution: "+h.x+"x"+h.y),o(`Pixel Ratio: ${a.renderer.getPixelRatio()} (current) / ${window.devicePixelRatio} (device)`);let p="N/A";switch(a._envIBLMode){case 0:p="PMREM",p+=` ${a._pmremMaxTileSize} px`;break;case 2:p="Light Probe",p+=` ${a._pmremMaxTileSize} px`}o(`Image-Based Lighting: ${p}`);let m=0,f=0,g=0,_=0,A=0,x=0;a.scene.traverse(function(W){W.isLight&&(m++,W.castShadow&&W.shadow&&(_++,A=W.shadow.mapSize.width,x=W.shadow.mapSize.height)),W.isCubeReflectionProbe&&f++,W.isPlaneReflectionProbe&&g++}),o("Lights: "+m,m>10),o(`Reflection Probes: ${f} (cube) / ${g} (plane) `,f>3||g>1);const S=[];a.postprocessing&&(a.postprocessing.gtaoGenerator&&S.push("GTAO"),a.postprocessing.composer.passes.forEach(function(W){for(let V in Vm)if(W instanceof Vm[V])return void S.push(V);S.push("Undefined")})),o(`Post-Processing: ${S.length?S.join(","):"N/A"}`);let M="N/A";if(_&&a.renderer.shadowMap&&a.renderer.shadowMap.enabled){switch(a.renderer.shadowMap.type){case na:M="Basic";break;case sr:M="Bilinear";break;case Io:M="PCF";break;case Po:M="PCF (Bilinear)";break;case ar:M="PCF (Poisson Disk)";break;case Vn:M="ESM";break;default:M="Unknown"}M+=` ${_}x${A}x${x}`}o("Shadow Map: "+M,_>4||A>2048||x>2048);const T=t.programs.slice(0);o("Materials and Shaders: "+T.length,T>100),T.sort(function(W,V){return V.profile.renderTime-W.profile.renderTime});let L=0;for(let W=0;W<T.length;W++){const V=T[W];V.profile.calcRenderTime=!1;const N=V.profile.materials,j=V.profile.renderTime/r;o("    "+(N.length==0?"System Material":N.join(","))+" - "+V.name+" - "+String(Math.round(10*j)/10)+"ms",j>16),L+=j,V.profile.renderTime=0}o("Total Render Time: "+String(Math.round(10*L)/10)+"ms",L>16),o("Textures & Render Buffers: "+t.memory.textures,t.memory.textures>100);const z=Array.from(t.memory.textureSpecs.values());z.sort(function(W,V){return W.type<V.type?1:W.type>V.type?-1:W.width!=V.width?V.width-W.width:V.height-W.height});for(let W=0;W<z.length;W++){const V=z[W],N=V.type=="Texture"?"- "+F4[V.format]:"";o(`    ${V.name||"N/A"} - ${V.type} - ${V.width}x${V.height} ${N}`,V.width>=4096||V.height>=4096)}t.autoReset=n},1e3*e)}},z1={prepareRenderer:function(a){const e=Lt.getGPUVendor(a),t=Lt.getGPUModel(a),n=Lt.checkAndroid();n&&e==="ARM"&&t==="Mali-T760"&&(a.compatSettings.saturateSpecEnvBlenderApprox=!0),a.compatSettings.gtaoDisableBkgFix=n}};function Ts(a){this.sourceTexture=a,this.camera=new fi(-1,1,1,-1,0,1),this.shader=new vt({type:"CubeCopy",uniforms:{faceIdx:{value:0},cubemap:{value:null}},vertexShader:`
        uniform int faceIdx;

        varying vec3 vCubeDirection;

        vec3 uvToCubeDirection(vec2 uv, int face) {
            vec3 dir;
            uv = 2.0 * uv - 1.0;

            if (face == 0) {
                dir = vec3(1.0, -uv.y, -uv.x);
            } else if (face == 1) {
                dir = vec3(-1.0, -uv.y, uv.x);
            } else if (face == 2) {
                dir = vec3(uv.x, 1.0, uv.y);
            } else if (face == 3) {
                dir = vec3(uv.x, -1.0, -uv.y);
            } else if (face == 4) {
                dir = vec3(uv.x, -uv.y, 1.0);
            } else if (face == 5) {
                dir = vec3(-uv.x, -uv.y, -1.0);
            }
            return dir;
        }

        void main() {
            vCubeDirection = uvToCubeDirection(uv, faceIdx);
            gl_Position = vec4(position, 1.0);
        }
        `,fragmentShader:`
        uniform samplerCube cubemap;

        varying vec3 vCubeDirection;

        void main() {
            gl_FragColor = textureCube(cubemap, vCubeDirection);

            #include <tonemapping_fragment>

            gl_FragColor = linearToOutputTexel(gl_FragColor);
        }
        `}),this.shader.map=a,this.shader.uniforms.cubemap.value=a,this.planeMesh=new Ue(new ni(2,2),this.shader),this.scene=new vn,this.scene.add(this.camera),this.scene.add(this.planeMesh)}Ts.prototype={constructor:Ts,render:function(a,e,t=1){var n=a.toneMapping,i=a.toneMappingExposure,o=a.getRenderTarget();a.toneMapping=Gc,a.toneMappingExposure=t;for(var r=0;r<6;r++)a.setRenderTarget(e,r),this.shader.uniforms.faceIdx.value=r,a.render(this.scene,this.camera);a.toneMapping=n,a.toneMappingExposure=i,a.setRenderTarget(o)},dispose:function(){this.planeMesh.geometry.dispose(),this.planeMesh.material.dispose()}};var U4=["alphaMap","aoMap","bumpMap","displacementMap","emissiveMap","envMap","gradientMap","lightMap","map","metalnessMap","normalMap","roughnessMap","specularMap"],ph={disposeTextures:function(a){if(U4.forEach(function(t){a[t]&&a[t].isTexture&&a[t].dispose()}),a.type=="MeshNodeMaterial")for(var e in a.nodeTextures)a.nodeTextures[e]&&a.nodeTextures[e].dispose()}};function z4(a){return!!Lt.checkHalfFloatTex(a,!0)&&(!/Firefox/.test(navigator.userAgent)||!/Android/.test(navigator.userAgent))}function Sp(a,e,t,{camPos:n=new b,clipStart:i=.1,clipEnd:o=100}={}){z4(e)||(console.warn("v3d.RenderUtils: disabling half float cubemaps"),t.texture.type=Ft);const r=new Ic(i,o,t);r.position.copy(n);let s=a.worldMaterial;if(s!==null&&s.isMeshNodeMaterial){const l=new Ue(new ao(1,1,1),s);l.material.side=nn,l.material.defines.WORLD_NODES=1,new Ic(.1,10,t).update(e,l),l.geometry.disposeBoundsTree&&l.geometry.disposeBoundsTree(),l.geometry.dispose();const c=a.background;a.background=null;const d=e.autoClearColor;e.autoClearColor=!1,r.update(e,a),e.autoClearColor=d,a.background=c}else r.update(e,a);return r.renderTarget}function V1(a,e,t,n){e.isMeshNodeMaterial||console.error("v3d.RenderUtils.renderWorldNodeMatToCubemap(): material is not an instance of MeshNodeMaterial.");const i=new vn;return i.worldMaterial=e,Sp(i,a,new Us(t,n))}function V4(a){const e=a.layers.mask;return a.layers.set(0),a.isArrayCamera&&(a.layers.enable(1),a.layers.enable(2)),a.layers.enable(3),a.layers.enable(4),a.layers.enable(5),a.layers.enable(6),a.layers.enable(7),e}var G4=Object.freeze({__proto__:null,assignAllLayersMask:V4,renderSceneToCubemap:Sp,renderWorldNodeMatToCubemap:V1});const Ql=new At,ka=new Rn,k4=new Ae,Q4=new b,W4=new b;class pu extends ze{constructor(e=256){super(),this.type="CubeReflectionProbe",this.influenceType=1,this.influenceDistance=1,this.parallaxType=1,this.parallaxDistance=1,this.probeClipStart=.1,this.probeClipEnd=100,this.probeIntensity=1,this.visibilityGroup=null,this.visibilityGroupInv=!1,this.influenceGroup=null,this.influenceGroupInv=!1,this._renderTargetCube=new Us(e,{encoding:Ke,format:Qe,generateMipmaps:!0,minFilter:In,type:_t}),this._exposureRenderTargetCube=this._renderTargetCube.clone(),this.renderTarget=null,this.matrixWorldInverse=new Ae}setSize(e){this._renderTargetCube.setSize(e,e),this._exposureRenderTargetCube.setSize(e,e)}setEncoding(e){this._renderTargetCube.texture.encoding=e,this._exposureRenderTargetCube.texture.encoding=e}intersectsMesh(e){let t=!1;const n=e.geometry,i=n.boundsTree,o=k4;try{o.copy(e.matrixWorld).invert()}catch{return!1}switch(o.multiply(this.matrixWorld),this.influenceType){case 0:t=!0;break;case 1:ka.center.setScalar(0),ka.radius=this.influenceDistance,ka.applyMatrix4(o),i?t=i.intersectsSphere(e,ka):(n.boundingBox===null&&n.computeBoundingBox(),t=n.boundingBox.intersectsSphere(ka));break;case 2:const r=Q4.setScalar(0),s=W4.setScalar(2*this.influenceDistance);Ql.setFromCenterAndSize(r,s),i?t=i.intersectsBox(e,Ql,o):(Ql.applyMatrix4(o),n.boundingBox===null&&n.computeBoundingBox(),t=n.boundingBox.intersectsBox(Ql))}return t}update(e,t){const n={};e.traverse(l=>{!l.isCubeReflectionProbe&&this._isVisible(l)||(n[l.id]=l.layers.mask,l.layers.disableAll())});const i=e.worldMaterial,o=i!==null&&i.isMeshNodeMaterial&&i.needsLightPathDir();let r;o&&(r=i.defines.LIGHT_PATH_IS_CAM_RAY,i.defines.LIGHT_PATH_IS_CAM_RAY=0),Sp(e,t,this._renderTargetCube,{camPos:this.position,clipStart:this.probeClipStart,clipEnd:this.probeClipEnd}),this._exposureRenderTargetCube.texture.type=this._renderTargetCube.texture.type;const s=new Ts(this._renderTargetCube.texture);s.render(t,this._exposureRenderTargetCube,this.probeIntensity),s.dispose(),this.renderTarget=this.onUpdate(this._exposureRenderTargetCube),o&&(i.defines.LIGHT_PATH_IS_CAM_RAY=r),e.traverse(l=>{!l.isCubeReflectionProbe&&this._isVisible(l)||(l.layers.mask=n[l.id])})}onUpdate(e){return e}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}copy(e){return super.copy(e),this.influenceType=e.influenceType,this.influenceDistance=e.influenceDistance,this.parallaxType=e.parallaxType,this.parallaxDistance=e.parallaxDistance,this.probeClipStart=e.probeClipStart,this.probeClipEnd=e.probeClipEnd,this.probeIntensity=e.probeIntensity,this.visibilityGroup=e.visibilityGroup,this.visibilityGroupInv=e.visibilityGroupInv,this.influenceGroup=e.influenceGroup,this.influenceGroupInv=e.influenceGroupInv,this.setSize(e._renderTargetCube.width),this.matrixWorldInverse.copy(e.matrixWorldInverse),this}dispose(){this._renderTargetCube!==null&&this._renderTargetCube.dispose(),this._exposureRenderTargetCube!==null&&this._exposureRenderTargetCube.dispose(),this.renderTarget!==null&&(this.renderTarget.dispose(),this.renderTarget=null),this.dispatchEvent({type:"dispose"})}_isVisible(e){return this.visibilityGroup===null||!e.isMesh?!0:e.groupNames.indexOf(this.visibilityGroup)!==-1^this.visibilityGroupInv}}pu.prototype.isCubeReflectionProbe=!0;class fh{constructor(e,t){if(this.renderer=e,t===void 0){const n=e.getSize(new te);this._pixelRatio=e.getPixelRatio(),this._width=n.width,this._height=n.height,(t=new et(Math.floor(this._width*this._pixelRatio),Math.floor(this._height*this._pixelRatio))).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new oo(De.copy),this.clock=new Di}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(Math.floor(this._width*this._pixelRatio),Math.floor(this._height*this._pixelRatio))}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(Math.floor(this._width*this._pixelRatio),Math.floor(this._height*this._pixelRatio))}removePass(e){const t=this.passes.indexOf(e);t!==-1&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){e===void 0&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let n=!1;for(let i=0,o=this.passes.length;i<o;i++){const r=this.passes[i];if(r.enabled!==!1){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(i),r.render(this.renderer,this.writeBuffer,this.readBuffer,e,n),r.needsSwap){if(n){const s=this.renderer.getContext(),l=this.renderer.state.buffers.stencil;l.setFunc(s.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),l.setFunc(s.EQUAL,1,4294967295)}this.swapBuffers()}r instanceof yp?n=!0:r instanceof F1&&(n=!1)}}this.renderer.setRenderTarget(t)}reset(e){if(e===void 0){const t=this.renderer.getSize(new te);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(Math.floor(this._width*this._pixelRatio),Math.floor(this._height*this._pixelRatio))}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const n=Math.floor(this._width*this._pixelRatio),i=Math.floor(this._height*this._pixelRatio);this.renderTarget1.setSize(n,i),this.renderTarget2.setSize(n,i);for(let o=0;o<this.passes.length;o++)this.passes[o].setSize(n,i)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}getPixelRatio(){return this._pixelRatio}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}getActiveSSAAPass(){return this.passes[0]instanceof ws?this.passes[0]:null}insertPassAfter(e,t){let n=0;for(let i=0;i<this.passes.length;i++)t.indexOf(this.passes[i])>-1&&(n=i+1);this.insertPass(e,n)}enableAllPasses(){for(let e=0;e<this.passes.length;e++)this.passes[e].enabled=!0}disableAllPasses(){for(let e=0;e<this.passes.length;e++)this.passes[e].enabled=!1}setStencil(e){this.renderTarget1.stencilBuffer=e,this.renderTarget1.dispose(),this.renderTarget2.stencilBuffer=e,this.renderTarget2.dispose()}}var Ee={BACKSPACE:8,TAB:9,ENTER:13,SHIFT:16,CTRL:17,ALT:18,PAUSE_BREAK:19,CAPS_LOCK:20,ESCAPE:27,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT_ARROW:37,UP_ARROW:38,RIGHT_ARROW:39,DOWN_ARROW:40,INSERT:45,DELETE:46,0:48,1:49,2:50,3:51,4:52,5:53,6:54,7:55,8:56,9:57,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,LEFT_WINDOW_KEY:91,RIGHT_WINDOW_KEY:92,SELECT_KEY:93,NUMPAD_0:96,NUMPAD_1:97,NUMPAD_2:98,NUMPAD_3:99,NUMPAD_4:100,NUMPAD_5:101,NUMPAD_6:102,NUMPAD_7:103,NUMPAD_8:104,NUMPAD_9:105,MULTIPLY:106,ADD:107,SUBTRACT:109,DECIMAL_POINT:110,DIVIDE:111,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,NUM_LOCK:144,SCROLL_LOCK:145,SEMI_COLON:186,EQUAL_SIGN:187,COMMA:188,DASH:189,PERIOD:190,FORWARD_SLASH:191,GRAVE_ACCENT:192,OPEN_BRACKET:219,BACK_SLASH:220,CLOSE_BRAKET:221,SINGLE_QUOTE:222};class Mp{constructor(e,t=null){this.isKeyDown={};for(const n in Ee)this.isKeyDown[Ee[n]]=!1;if(this.onKeyDown=null,this.onKeyUp=null,this._domElement=e,this._keydownCb=(function(n){this.isKeyDown[n.keyCode]=!0,this.onKeyDown&&this.onKeyDown(n)}).bind(this),this._keyupCb=(function(n){this.isKeyDown[n.keyCode]=!1,this.onKeyUp&&this.onKeyUp(n)}).bind(this),this._mobileControlTouchStartCb=(function(n){this._keydownCb({keyCode:Ee.W})}).bind(this),this._mobileControlTouchEndCb=(function(n){this._keyupCb({keyCode:Ee.W})}).bind(this),this._domElement.addEventListener("keydown",this._keydownCb,!1),this._domElement.addEventListener("keyup",this._keyupCb,!1),t&&Lt.isTouchDevice()){const n=document.createElement("div");n.className="v3d-mobile-forward",t.appendChild(n),n.addEventListener("touchstart",this._mobileControlTouchStartCb),n.addEventListener("touchend",this._mobileControlTouchEndCb),this._mobileForwardElement=n}}dispose(){this._domElement.removeEventListener("keydown",this._keydownCb,!1),this._domElement.removeEventListener("keyup",this._keyupCb,!1),this._mobileForwardElement&&(this._mobileForwardElement.removeEventListener("touchstart",this._mobileControlTouchStartCb),this._mobileForwardElement.removeEventListener("touchend",this._mobileControlTouchEndCb),this._mobileForwardElement.remove())}}function Js(){this.posFrom=new b,this.targetFrom=new b,this.posTo=new b,this.targetTo=new b,this.sphericalFrom=new Bi,this.sphericalTo=new Bi,this.finishCb=function(){},this.movementType=wc,this.active=!1,this.duration=0,this.clock=new Di}function fu(){this.posFrom=new b,this.targetFrom=new b,this.posTo=new b,this.targetTo=new b,this.zoomFrom=0,this.zoomTo=0,this.finishCb=function(){},this.active=!1,this.duration=0,this.clock=new Di}Object.assign(Js.prototype,{setup:function(){var a=new b;return function({posFrom:e=new b,targetFrom:t=new b,posTo:n=new b,targetTo:i=new b,finishCb:o=function(){},movementType:r=wc}){if(this.posFrom.copy(e),this.targetFrom.copy(t),this.posTo.copy(n),this.targetTo.copy(i),this.finishCb=o,this.movementType=r,this.movementType===1){a.copy(this.posFrom).sub(this.targetFrom),this.sphericalFrom.setFromVector3(a),a.copy(this.posTo).sub(this.targetTo),this.sphericalTo.setFromVector3(a);var s=gs(this.sphericalFrom.theta),l=gs(this.sphericalTo.theta),c=Math.abs(s-l);c>Math.PI&&(l=s+Math.sign(s-l)*(2*Math.PI-c)),this.sphericalFrom.theta=s,this.sphericalTo.theta=l}return this}}(),start(a){this.active=!0,this.duration=a,this.clock.start()},update:function(){var a=new b,e=new b;return function(t=function(n,i,o){}){var n=this.clock.getElapsedTime()/this.duration;if(n=ih(n,0,1),e.lerpVectors(this.targetFrom,this.targetTo,n),this.movementType===wc)a.lerpVectors(this.posFrom,this.posTo,n);else if(this.movementType===1){var i=wi(this.sphericalFrom.radius,this.sphericalTo.radius,n),o=wi(this.sphericalFrom.phi,this.sphericalTo.phi,n),r=wi(this.sphericalFrom.theta,this.sphericalTo.theta,n);a.setFromSphericalCoords(i,o,r),a.add(e)}t(n,a,e),n>=1&&(this.active=!1,this.finishCb())}}()}),Object.assign(fu.prototype,{setup:function({posFrom:a=new b,targetFrom:e=new b,posTo:t=new b,targetTo:n=new b,zoomFrom:i=0,zoomTo:o=0,finishCb:r=function(){}}){return this.posFrom.copy(a),this.targetFrom.copy(e),this.posTo.copy(t),this.targetTo.copy(n),this.zoomFrom=i,this.zoomTo=o,this.finishCb=r,this},start(a){this.active=!0,this.duration=a,this.clock.start()},update:function(){new b;const a=new b;return function(e=function(t,n,i){}){let t=this.clock.getElapsedTime()/this.duration;t=ih(t,0,1),a.lerpVectors(this.targetFrom,this.targetTo,t);let n=wi(this.zoomFrom,this.zoomTo,t);e(t,a,n),t>=1&&(this.active=!1,this.finishCb())}}()});const Ot={enableCollisions:!0,gazeLevel:1.8,enablePan:!0,panInertia:.05,panSpeedKey:.15,enableRotate:!0,rotateInertia:.05,rotateInertiaTouch:.05,rotateSpeed:.9,rotateSpeedTouch:.75,storyHeight:3,enableZoom:!0,zoomInertia:.05,zoomSpeed:30,zoomSpeedKey:.2,enableDamping:!0,enableKeys:!0};var H4=60,Gm=.001,cd=.001,km=.001;class mh extends An{constructor(e,t){super();var n=this;this.object=e,this.domElement=t!==void 0?t:document,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.enableDamping=Ot.enableDamping,this.enableRotate=Ot.enableRotate,this.rotateSpeed=Ot.rotateSpeed,this.rotateSpeedTouch=Ot.rotateSpeedTouch,this.rotateInertia=Ot.rotateInertia,this.rotateInertiaTouch=Ot.rotateInertiaTouch,this.enableZoom=Ot.enableZoom,this.zoomSpeed=Ot.zoomSpeed,this.zoomSpeedKey=Ot.zoomSpeedKey,this.zoomInertia=Ot.zoomInertia,this.enablePan=Ot.enablePan,this.panSpeedKey=Ot.panSpeedKey,this.panInertia=Ot.panInertia,this.enableKeys=Ot.enableKeys,this.gazeLevel=Ot.gazeLevel,this.storyHeight=Ot.storyHeight,this.collisionMeshes=[],this._enableCollisions=Ot.enableCollisions;let i=!1;Object.defineProperty(this,"enablePointerLock",{get:()=>i,set($){i!==$&&(i=$,Y())}}),Object.defineProperty(this,"inTween",{get:()=>ne.active||le.active});var o,r=new Di,s=1e-6,l=new b,c=new b,d=new b,u=new b,h=new Ge,p=new b,m={};m[Ee.W]=m[Ee.S]=m[Ee.A]=m[Ee.D]=m[Ee.UP_ARROW]=m[Ee.DOWN_ARROW]=m[Ee.LEFT_ARROW]=m[Ee.RIGHT_ARROW]=0;var f=!1,g=new Bi,_=new Bi,A=new te,x=1,S=1,M=new te,T=new te,L=0,z=0,W=1,V=1,N=new te,j=new te,oe=new Jc(new b,new b(0,-1,0));oe.params.checkVisibility=!1;var H=!1,ne=new Js;const le=new fu;var re={type:"change"},ae={type:"start"},E={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{var $=this.domElement.getBoundingClientRect(),se=this.domElement.ownerDocument.documentElement;this.screen.left=$.left+window.pageXOffset-se.clientLeft,this.screen.top=$.top+window.pageYOffset-se.clientTop,this.screen.width=$.width,this.screen.height=$.height}},this.handleEvent=function($){typeof this[$.type]=="function"&&this[$.type]($)};var F,U=(F=new te,function($,se){return F.set(($-.5*n.screen.width-n.screen.left)/(.5*n.screen.width),(n.screen.height+2*(n.screen.top-se))/n.screen.width),F});const B=function(){const $=new te;return function(se,de){return $.set(se,-de).multiplyScalar(2/n.screen.width)}}();function Z($){n.enabled!==!1&&($.preventDefault(),n.enableRotate!==!1&&(T.copy(U($.pageX,$.pageY).negate()),M.copy(T),f=!0,document.addEventListener("mousemove",k),document.addEventListener("mouseup",X),document.addEventListener("mouseleave",X),n.dispatchEvent(ae)))}function k($){if(n.enabled!==!1&&($.preventDefault(),f)){if(n.enableRotate===!1)return;T.copy(U($.pageX,$.pageY).negate()),A.add(T).sub(M),M.copy(T),x=n.rotateSpeed,S=n.rotateInertia}}function X($){n.enabled!==!1&&($.preventDefault(),f=!1,document.removeEventListener("mousemove",k),document.removeEventListener("mouseup",X),document.removeEventListener("mouseleave",X),n.dispatchEvent(E))}function P($){if(n.enabled!==!1&&n.enableZoom!==!1){switch($.preventDefault(),$.stopPropagation(),$.deltaMode){case 2:z-=.025*$.deltaY,W=n.zoomSpeed,V=n.zoomInertia;break;case 1:z-=.01*$.deltaY,W=n.zoomSpeed,V=n.zoomInertia;break;default:z-=25e-5*$.deltaY,W=n.zoomSpeed,V=n.zoomInertia}n.dispatchEvent(ae),n.dispatchEvent(E)}}function v($){if(n.enabled!==!1){var se=$.targetTouches[0];f=!0,T.copy(U(se.pageX,se.pageY).negate()),M.copy(T),n.dispatchEvent(ae)}}function y($){if(n.enabled!==!1){$.preventDefault();var se=$.targetTouches[0];n.enableRotate!==!1&&(T.copy(U(se.pageX,se.pageY).negate()),A.add(T).sub(M),M.copy(T),x=n.rotateSpeedTouch,S=n.rotateInertiaTouch)}}function R($){if(n.enabled!==!1){if($.targetTouches.length===0)f=!1;else{if(n.enableRotate===!1)return;f=!0,T.copy(U($.targetTouches[0].pageX,$.targetTouches[0].pageY).negate()),M.copy(T)}n.dispatchEvent(E)}}function w($){n.enabled!==!1&&$.preventDefault()}function I($){n.domElement.requestPointerLock()}function C($){document.pointerLockElement===n.domElement?(n.dispatchEvent(ae),document.addEventListener("mousemove",O)):(n.dispatchEvent(E),document.removeEventListener("mousemove",O))}function D($){console.error("Pointer lock failed")}function O($){$.preventDefault(),n.enabled&&n.enableRotate&&(A.add(B($.movementX,$.movementY).negate()),x=n.rotateSpeed,S=n.rotateInertia)}function Y(){J(),n.domElement.addEventListener("contextmenu",w),n.enablePointerLock?(n.domElement.addEventListener("click",I),document.addEventListener("pointerlockchange",C),document.addEventListener("pointerlockerror",D)):n.domElement.addEventListener("mousedown",Z),n.domElement.addEventListener("wheel",P,{passive:!1}),n.domElement.addEventListener("touchstart",v,{passive:!0}),n.domElement.addEventListener("touchend",R),n.domElement.addEventListener("touchmove",y,{passive:!1}),(o=new Mp(window,n.domElement.parentElement)).onKeyDown=function($){$.keyCode in m&&(m[$.keyCode]=1)}}function J(){n.domElement.removeEventListener("contextmenu",w),n.domElement.removeEventListener("click",I),document.removeEventListener("pointerlockchange",C),document.removeEventListener("pointerlockerror",D),document.removeEventListener("mousemove",O),n.domElement.removeEventListener("mousedown",Z),n.domElement.removeEventListener("wheel",P),n.domElement.removeEventListener("touchstart",v),n.domElement.removeEventListener("touchend",R),n.domElement.removeEventListener("touchmove",y),document.removeEventListener("mousemove",k),document.removeEventListener("mouseup",X),document.removeEventListener("mouseleave",X),o&&o.dispose()}var G,K,ie;this.update=(new b,function(){if(ne.active?ne.update(function(he,ee,ge){if(n.object.position.copy(ee),n.object.lookAt(ge),he>=1){for(var ve in _.set(0,0,0),A.set(0,0),L=0,z=0,N.set(0,0),j.set(0,0),m)m[ve]=0;r.getDelta()}}):le.active?le.update(function(he,ee,ge){if(n.object.lookAt(ee),n.object.zoom=ge,n.object.updateProjectionMatrix(),he>=1){_.set(0,0,0),A.set(0,0),L=0,z=0,N.set(0,0),j.set(0,0);for(let ve in m)m[ve]=0;r.getDelta()}}):(n.object.getLocalDirection(p),g.setFromVector3(p),g.theta+=_.theta*x,g.phi+=_.phi*x,g.makeSafe(),p.setFromSpherical(g),l.copy(p).add(n.object.position),n.object.lookAtLocal(l),n.object.isPerspectiveCamera?n.object.position.addScaledVector(p,L):n.object.isOrthographicCamera&&(n.object.zoom*=1+.15*L,n.object.updateProjectionMatrix()),c.copy(p).cross(n.object.up).setLength(-N.x),c.add(d.copy(n.object.up).setLength(N.y)),n.object.position.add(c),function(){var he=r.getDelta();for(var ee in _.set(_.radius,A.y,A.x),A.x=n.enableDamping?Ht(A.x,0,he,S,Gm):0,A.y=n.enableDamping?Ht(A.y,0,he,S,Gm):0,_.set(_.radius,_.phi-A.y,_.theta-A.x),N.copy(j),j.x=n.enableDamping?Ht(j.x,0,he,1,cd):0,j.y=n.enableDamping?Ht(j.y,0,he,1,cd):0,N.sub(j),N.multiplyScalar(1),L=z,z=n.enableDamping?Ht(z,0,he,V,km):0,L-=z,L*=W,m){var ge=ee==Ee.A||ee==Ee.LEFT_ARROW||ee==Ee.D||ee==Ee.RIGHT_ARROW,ve=ee==Ee.W||ee==Ee.UP_ARROW||ee==Ee.S||ee==Ee.DOWN_ARROW,_e=ge?n.panInertia:n.zoomInertia,we=ge?n.panSpeedKey:n.zoomSpeedKey,Be=ge?cd:km;if(o.isKeyDown[ee])var ke=m[ee]=1;else{var ht=m[ee];m[ee]=Ht(m[ee],0,he,_e,Be),ke=ht-m[ee]}n.enabled&&n.enableKeys&&(ge&&!n.enablePan||ve&&!n.enableZoom||(ke*=he*H4*we,ee==Ee.A||ee==Ee.LEFT_ARROW?N.x+=ke:ee==Ee.D||ee==Ee.RIGHT_ARROW?N.x-=ke:ee==Ee.W||ee==Ee.UP_ARROW?L+=ke:ee!=Ee.S&&ee!=Ee.DOWN_ARROW||(L-=ke)))}}()),this._enableCollisions&&n.collisionMeshes.length){oe.ray.origin.copy(n.object.position),oe.far=n.storyHeight;var $=oe.intersectObjects(n.collisionMeshes,!1);if($.length>0){var se=$[0];n.object.position.y=se.point.y+n.gazeLevel,H=!0}else H&&n.object.position.copy(u)}var de=!1;u.distanceToSquared(n.object.position)>s&&(u.copy(n.object.position),de=!0),h.dot(n.object.quaternion)<1-s&&(h.copy(n.object.quaternion),de=!0),de&&n.dispatchEvent(re)}),this.forceMouseUp=function(){X({preventDefault:function(){}})},this.dispose=J,this.releaseFromCollision=function(){H=!1},this.tween=(G=new b,K=new b,ie=new b,function($,se,de,he,ee){n.object.parent&&($=G.copy($),n.object.parent.worldToLocal($));var ge=n.object.getWorldPosition(K),ve=ie.subVectors(se,ge).length(),_e=n.object.getWorldDirection(ie).multiplyScalar(ve).add(ge),we=1e-5;$.manhattanDistanceTo(n.object.position)<we&&se.manhattanDistanceTo(_e)<we?he!==void 0&&he():ne.setup({posFrom:n.object.position,targetFrom:_e,posTo:$,targetTo:se,finishCb:he,movementType:ee}).start(de)}),this.tweenZoomTo=function(){const $=new b,se=new b;return function(de,he,ee,ge){if(!n.object.isOrthographicCamera)return void console.warn("v3d.FirstPersonControls: .tweenZoomTo() works only for orthographic camera");const ve=n.object.getWorldPosition($);let _e=se.subVectors(de,ve).length();const we=n.object.getWorldDirection(se).multiplyScalar(_e).add(ve);le.setup({zoomFrom:n.object.zoom,targetFrom:we,zoomTo:he,targetTo:de,finishCb:ge}).start(ee)}}(),Y(),this.handleResize(),this.update()}set enableCollisions(e){this._enableCollisions=e,e||this.releaseFromCollision()}get enableCollisions(){return this._enableCollisions}}const bt={panInertia:.05,panInertiaTouch:.05,panSpeed:20,panSpeedKey:.15,panSpeedTouch:15,rotateInertia:.05,rotateInertiaTouch:.05,rotateSpeed:.9,rotateSpeedTouch:.75,zoomInertia:.05,zoomInertiaTouch:.05,zoomSpeed:150,zoomSpeedKey:.5,zoomSpeedTouch:20,enableDamping:!0,enableRotate:!0,enableZoom:!0,enablePan:!0,enableKeys:!0,minAzimuthAngle:-1/0,maxAzimuthAngle:1/0,minPolarAngle:0,maxPolarAngle:Math.PI};var X4=60,Qm=.001,ud=.001,Wm=.001;class gh extends An{constructor(e,t){super();var n=this,i=-1,o=0,r=1,s=2,l=3,c=4;this.object=e,this.domElement=t!==void 0?t:document,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.enableDamping=bt.enableDamping,this.enableRotate=bt.enableRotate,this.rotateSpeed=bt.rotateSpeed,this.rotateSpeedTouch=bt.rotateSpeedTouch,this.rotateInertia=bt.rotateInertia,this.rotateInertiaTouch=bt.rotateInertiaTouch,this.enableZoom=bt.enableZoom,this.zoomSpeed=bt.zoomSpeed,this.zoomSpeedKey=bt.zoomSpeedKey,this.zoomSpeedTouch=bt.zoomSpeedTouch,this.zoomInertia=bt.zoomInertia,this.zoomInertiaTouch=bt.zoomInertiaTouch,this.enablePan=bt.enablePan,this.panSpeed=bt.panSpeed,this.panSpeedKey=bt.panSpeedKey,this.panSpeedTouch=bt.panSpeedTouch,this.panInertia=bt.panInertia,this.panInertiaTouch=bt.panInertiaTouch,this.enableKeys=bt.enableKeys,this.minAzimuthAngle=bt.minAzimuthAngle,this.maxAzimuthAngle=bt.maxAzimuthAngle,this.minPolarAngle=bt.minPolarAngle,this.maxPolarAngle=bt.maxPolarAngle,this.mouseButtons={ROTATE:rr.LEFT,ZOOM:rr.MIDDLE,PAN:rr.RIGHT},Object.defineProperty(this,"inTween",{get:()=>X.active||P.active});var d=new Di,u=1e-6,h=new b,p=new b,m=new b,f=new te,g=new b,_=new Ge,A=i,x=new b,S={};S[Ee.W]=S[Ee.S]=S[Ee.A]=S[Ee.D]=S[Ee.UP_ARROW]=S[Ee.DOWN_ARROW]=S[Ee.LEFT_ARROW]=S[Ee.RIGHT_ARROW]=0;var M=new Mp(window);M.onKeyDown=function(ee){ee.keyCode in S&&(S[ee.keyCode]=1)};var T=new Bi,L=new Bi,z=new te,W=1,V=1,N=new te,j=new te,oe=0,H=0,ne=1,le=1,re=0,ae=0,E=new te,F=new te,U=1,B=1,Z=new te,k=new te,X=new Js;const P=new fu;var v={type:"change"},y={type:"start"},R={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{var ee=this.domElement.getBoundingClientRect(),ge=this.domElement.ownerDocument.documentElement;this.screen.left=ee.left+window.pageXOffset-ge.clientLeft,this.screen.top=ee.top+window.pageYOffset-ge.clientTop,this.screen.width=ee.width,this.screen.height=ee.height}},this.handleEvent=function(ee){typeof this[ee.type]=="function"&&this[ee.type](ee)};var w,I,C,D,O=(w=new te,function(ee,ge){return w.set((ee-n.screen.left)/n.screen.width,(ge-n.screen.top)/n.screen.height),w}),Y=function(){var ee=new te;return function(ge,ve){return ee.set((ge-.5*n.screen.width-n.screen.left)/(.5*n.screen.width),(n.screen.height+2*(n.screen.top-ve))/n.screen.width),ee}}();function J(ee){if(n.enabled!==!1){switch(ee.preventDefault(),ee.button){case n.mouseButtons.ROTATE:if(n.enableRotate===!1)return;j.copy(Y(ee.pageX,ee.pageY).negate()),N.copy(j),A=o;break;case n.mouseButtons.ZOOM:case n.mouseButtons.PAN:if(n.enablePan===!1)return;Z.copy(O(ee.pageX,ee.pageY)),k.copy(Z),A=ee.button==n.mouseButtons.PAN?s:r}document.addEventListener("mousemove",G),document.addEventListener("mouseup",K),document.addEventListener("mouseleave",K),n.dispatchEvent(y)}}function G(ee){if(n.enabled!==!1){if(ee.preventDefault(),A===o){if(n.enableRotate===!1)return;j.copy(Y(ee.pageX,ee.pageY).negate()),z.add(j).sub(N),N.copy(j),W=n.rotateSpeed,V=n.rotateInertia}else if(A===s||A===r){if(n.enablePan===!1)return;k.copy(O(ee.pageX,ee.pageY)),F.add(k).sub(Z),Z.copy(k),U=n.panSpeed,B=n.panInertia}}}function K(ee){n.enabled!==!1&&(ee.preventDefault(),A=i,document.removeEventListener("mousemove",G),document.removeEventListener("mouseup",K),document.removeEventListener("mouseleave",K),n.dispatchEvent(R))}function ie(ee){if(n.enabled!==!1&&n.enableZoom!==!1){switch(ee.preventDefault(),ee.stopPropagation(),ee.deltaMode){case 2:H-=.025*ee.deltaY,ne=n.zoomSpeed,le=n.zoomInertia;break;case 1:H-=.01*ee.deltaY,ne=n.zoomSpeed,le=n.zoomInertia;break;default:H-=25e-5*ee.deltaY,ne=n.zoomSpeed,le=n.zoomInertia}n.dispatchEvent(y),n.dispatchEvent(R)}}function $(ee){if(n.enabled!==!1){var ge=ee.touches[0],ve=ee.touches[1];if(ee.touches.length===1){if(n.enableRotate===!1)return;A=l,j.copy(Y(ge.pageX,ge.pageY).negate()),N.copy(j)}else{if(n.enableZoom===!1&&n.enablePan===!1)return;if(A=c,n.enableZoom){var _e=O(ge.pageX-ve.pageX,ge.pageY-ve.pageY);re=ae=_e.length()}if(n.enablePan){var we=O((ge.pageX+ve.pageX)/2,(ge.pageY+ve.pageY)/2);Z.copy(we),k.copy(Z)}}n.dispatchEvent(y)}}function se(ee){if(n.enabled!==!1){ee.preventDefault();var ge=ee.touches[0],ve=ee.touches[1];if(ee.touches.length===1){if(n.enableRotate===!1)return;j.copy(Y(ge.pageX,ge.pageY).negate()),z.add(j).sub(N),N.copy(j),W=n.rotateSpeedTouch,V=n.rotateInertiaTouch}else{if(n.enableZoom===!1&&n.enablePan===!1)return;var _e=O(ge.pageX-ve.pageX,ge.pageY-ve.pageY),we=(ae=_e.length())-re;re=ae;var Be=O((ge.pageX+ve.pageX)/2,(ge.pageY+ve.pageY)/2);k.copy(Be);var ke=f.subVectors(k,Z),ht=ke.length();Z.copy(k),n.enableZoom&&Math.abs(we)>Math.abs(ht)&&(H+=we,ne=n.zoomSpeedTouch,le=n.zoomInertiaTouch),n.enablePan&&Math.abs(we)<=Math.abs(ht)&&(F.add(ke),U=n.panSpeedTouch,B=n.panInertiaTouch)}}}function de(ee){if(n.enabled!==!1){switch(ee.touches.length){case 0:A=i;break;case 1:if(n.enableRotate===!1)return;A=l,j.copy(Y(ee.touches[0].pageX,ee.touches[0].pageY).negate()),N.copy(j)}n.dispatchEvent(R)}}function he(ee){n.enabled!==!1&&ee.preventDefault()}this.update=(new b,function(){X.active?X.update(function(ge,ve,_e){if(n.object.position.copy(ve),n.object.lookAt(_e),ge>=1){for(var we in L.set(0,0,0),z.set(0,0),oe=0,H=0,E.set(0,0),F.set(0,0),S)S[we]=0;d.getDelta()}}):P.active?P.update(function(ge,ve,_e){if(n.object.lookAt(ve),n.object.zoom=_e,n.object.updateProjectionMatrix(),ge>=1){L.set(0,0,0),z.set(0,0),oe=0,H=0,E.set(0,0),F.set(0,0);for(let we in S)S[we]=0;d.getDelta()}}):(n.object.getLocalDirection(x),T.setFromVector3(x),T.theta+=L.theta*W,T.phi+=L.phi*W,T.theta=Math.max(n.minAzimuthAngle,Math.min(n.maxAzimuthAngle,T.theta)),T.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,T.phi)),T.makeSafe(),x.setFromSpherical(T),h.copy(x).add(n.object.position),n.object.lookAtLocal(h),n.object.isPerspectiveCamera?n.object.position.addScaledVector(x,oe):n.object.isOrthographicCamera&&(n.object.zoom*=1+.15*oe,n.object.updateProjectionMatrix()),p.copy(x).cross(n.object.up).setLength(-E.x),p.add(m.copy(n.object.up).setLength(E.y)),n.object.position.add(p),function(){var ge=d.getDelta();for(var ve in L.set(L.radius,z.y,z.x),z.x=n.enableDamping?Ht(z.x,0,ge,V,Qm):0,z.y=n.enableDamping?Ht(z.y,0,ge,V,Qm):0,L.set(L.radius,L.phi-z.y,L.theta-z.x),E.copy(F),F.x=n.enableDamping?Ht(F.x,0,ge,B,ud):0,F.y=n.enableDamping?Ht(F.y,0,ge,B,ud):0,E.sub(F),E.multiplyScalar(U),oe=H,H=n.enableDamping?Ht(H,0,ge,le,Wm):0,oe-=H,oe*=ne,S){var _e=ve==Ee.A||ve==Ee.LEFT_ARROW||ve==Ee.D||ve==Ee.RIGHT_ARROW,we=ve==Ee.W||ve==Ee.UP_ARROW||ve==Ee.S||ve==Ee.DOWN_ARROW,Be=_e?n.panInertia:n.zoomInertia,ke=_e?n.panSpeedKey:n.zoomSpeedKey,ht=_e?ud:Wm;if(M.isKeyDown[ve])var tt=S[ve]=1;else{var pt=S[ve];S[ve]=Ht(S[ve],0,ge,Be,ht),tt=pt-S[ve]}n.enabled&&n.enableKeys&&(_e&&!n.enablePan||we&&!n.enableZoom||(tt*=ge*X4*ke,ve==Ee.A||ve==Ee.LEFT_ARROW?E.x+=tt:ve==Ee.D||ve==Ee.RIGHT_ARROW?E.x-=tt:ve==Ee.W||ve==Ee.UP_ARROW?oe+=tt:ve!=Ee.S&&ve!=Ee.DOWN_ARROW||(oe-=tt)))}}());var ee=!1;g.distanceToSquared(n.object.position)>u&&(g.copy(n.object.position),ee=!0),_.dot(n.object.quaternion)<1-u&&(_.copy(n.object.quaternion),ee=!0),ee&&n.dispatchEvent(v)}),this.forceMouseUp=function(){K({preventDefault:function(){}})},this.dispose=function(){this.domElement.removeEventListener("contextmenu",he),this.domElement.removeEventListener("mousedown",J),this.domElement.removeEventListener("wheel",ie),this.domElement.removeEventListener("touchstart",$),this.domElement.removeEventListener("touchend",de),this.domElement.removeEventListener("touchmove",se),document.removeEventListener("mousemove",G),document.removeEventListener("mouseup",K),document.removeEventListener("mouseleave",K),M.dispose()},this.tween=(I=new b,C=new b,D=new b,function(ee,ge,ve,_e,we){n.object.parent&&(ee=I.copy(ee),n.object.parent.worldToLocal(ee));var Be=n.object.getWorldPosition(C),ke=D.subVectors(ge,Be).length(),ht=n.object.getWorldDirection(D).multiplyScalar(ke).add(Be),tt=1e-5;ee.manhattanDistanceTo(n.object.position)<tt&&ge.manhattanDistanceTo(ht)<tt?_e!==void 0&&_e():X.setup({posFrom:n.object.position,targetFrom:ht,posTo:ee,targetTo:ge,finishCb:_e,movementType:we}).start(ve)}),this.tweenZoomTo=function(){const ee=new b,ge=new b;return function(ve,_e,we,Be){if(!n.object.isOrthographicCamera)return void console.warn("v3d.FlyingControls: .tweenZoomTo() works only for orthographic camera");const ke=n.object.getWorldPosition(ee);let ht=ge.subVectors(ve,ke).length();const tt=n.object.getWorldDirection(ge).multiplyScalar(ht).add(ke);P.setup({zoomFrom:n.object.zoom,targetFrom:tt,zoomTo:_e,targetTo:ve,finishCb:Be}).start(we)}}(),this.domElement.addEventListener("contextmenu",he),this.domElement.addEventListener("mousedown",J),this.domElement.addEventListener("wheel",ie,{passive:!1}),this.domElement.addEventListener("touchstart",$,{passive:!0}),this.domElement.addEventListener("touchend",de),this.domElement.addEventListener("touchmove",se,{passive:!1}),this.handleResize(),this.update()}}var G1=(()=>{var a=import.meta.url;return function(e){e=(e=e||{})!==void 0?e:{};var t,n,i=Object.assign;e.ready=new Promise(function(G,K){t=G,n=K});var o,r,s,l,c,d,u=i({},e),h=typeof window=="object",p=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f="";m?(f=p?require("path").dirname(f)+"/":__dirname+"/",d=()=>{c||(l=require("fs"),c=require("path"))},o=function(G,K){var ie=R(G);return ie?K?ie:ie.toString():(d(),G=c.normalize(G),l.readFileSync(G,K?null:"utf8"))},s=G=>{var K=o(G,!0);return K.buffer||(K=new Uint8Array(K)),K},r=(G,K,ie)=>{var $=R(G);$&&K($),d(),G=c.normalize(G),l.readFile(G,function(se,de){se?ie(se):K(de.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(G){if(!(G instanceof Y))throw G}),process.on("unhandledRejection",function(G){throw G}),e.inspect=function(){return"[Emscripten Module object]"}):(h||p)&&(p?f=self.location.href:typeof document<"u"&&document.currentScript&&(f=document.currentScript.src),a&&(f=a),f=f.indexOf("blob:")!==0?f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=G=>{try{var K=new XMLHttpRequest;return K.open("GET",G,!1),K.send(null),K.responseText}catch($){var ie=R(G);if(ie)return function(se){for(var de=[],he=0;he<se.length;he++){var ee=se[he];ee>255&&(ee&=255),de.push(String.fromCharCode(ee))}return de.join("")}(ie);throw $}},p&&(s=G=>{try{var K=new XMLHttpRequest;return K.open("GET",G,!1),K.responseType="arraybuffer",K.send(null),new Uint8Array(K.response)}catch($){var ie=R(G);if(ie)return ie;throw $}}),r=(G,K,ie)=>{var $=new XMLHttpRequest;$.open("GET",G,!0),$.responseType="arraybuffer",$.onload=()=>{if($.status==200||$.status==0&&$.response)K($.response);else{var se=R(G);se?K(se.buffer):ie()}},$.onerror=ie,$.send(null)}),e.print||console.log.bind(console);var g,_,A=e.printErr||console.warn.bind(console);i(e,u),u=null,e.arguments&&e.arguments,e.thisProgram&&e.thisProgram,e.quit&&e.quit,e.wasmBinary&&(g=e.wasmBinary),e.noExitRuntime,typeof WebAssembly!="object"&&re("no native wasm support detected");var x=!1;function S(G){return e["_"+G]}function M(G,K,ie,$,se){var de={string:function(ke){var ht=0;if(ke!=null&&ke!==0){var tt=1+(ke.length<<2);(function(pt,Kt,pe){(function(gi,St,qe,qt){if(!(qt>0))return 0;for(var Ni=qe,Zt=qe+qt-1,yn=0;yn<gi.length;++yn){var Mt=gi.charCodeAt(yn);if(Mt>=55296&&Mt<=57343&&(Mt=65536+((1023&Mt)<<10)|1023&gi.charCodeAt(++yn)),Mt<=127){if(qe>=Zt)break;St[qe++]=Mt}else if(Mt<=2047){if(qe+1>=Zt)break;St[qe++]=192|Mt>>6,St[qe++]=128|63&Mt}else if(Mt<=65535){if(qe+2>=Zt)break;St[qe++]=224|Mt>>12,St[qe++]=128|Mt>>6&63,St[qe++]=128|63&Mt}else{if(qe+3>=Zt)break;St[qe++]=240|Mt>>18,St[qe++]=128|Mt>>12&63,St[qe++]=128|Mt>>6&63,St[qe++]=128|63&Mt}}St[qe]=0})(pt,z,Kt,pe)})(ke,ht=O(tt),tt)}return ht},array:function(ke){var ht=O(ke.length);return function(tt,pt){L.set(tt,pt)}(ke,ht),ht}};function he(ke){return K==="string"?(ht=ke)?function(pt,Kt,pe){for(var gi=Kt+pe,St=Kt;pt[St]&&!(St>=gi);)++St;if(St-Kt>16&&pt.subarray&&V)return V.decode(pt.subarray(Kt,St));for(var qe="";Kt<St;){var qt=pt[Kt++];if(128&qt){var Ni=63&pt[Kt++];if((224&qt)!=192){var Zt=63&pt[Kt++];if((qt=(240&qt)==224?(15&qt)<<12|Ni<<6|Zt:(7&qt)<<18|Ni<<12|Zt<<6|63&pt[Kt++])<65536)qe+=String.fromCharCode(qt);else{var yn=qt-65536;qe+=String.fromCharCode(55296|yn>>10,56320|1023&yn)}}else qe+=String.fromCharCode((31&qt)<<6|Ni)}else qe+=String.fromCharCode(qt)}return qe}(z,ht,tt):"":K==="boolean"?!!ke:ke;var ht,tt}var ee=S(G),ge=[],ve=0;if($)for(var _e=0;_e<$.length;_e++){var we=de[ie[_e]];we?(ve===0&&(ve=C()),ge[_e]=we($[_e])):ge[_e]=$[_e]}var Be=ee.apply(null,ge);return Be=function(ke){return ve!==0&&D(ve),he(ke)}(Be)}var T,L,z,W,V=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function N(G){T=G,e.HEAP8=L=new Int8Array(G),e.HEAP16=new Int16Array(G),e.HEAP32=new Int32Array(G),e.HEAPU8=z=new Uint8Array(G),e.HEAPU16=new Uint16Array(G),e.HEAPU32=new Uint32Array(G),e.HEAPF32=new Float32Array(G),e.HEAPF64=new Float64Array(G)}e.INITIAL_MEMORY;var j=[],oe=[],H=[],ne=0,le=null;function re(G){e.onAbort&&e.onAbort(G),A(G="Aborted("+G+")"),x=!0,G+=". Build with -s ASSERTIONS=1 for more info.";var K=new WebAssembly.RuntimeError(G);throw n(K),K}e.preloadedImages={},e.preloadedAudios={};var ae,E,F="data:application/octet-stream;base64,";function U(G){return G.startsWith(F)}function B(G){return G.startsWith("file://")}function Z(G){try{if(G==ae&&g)return new Uint8Array(g);var K=R(G);if(K)return K;if(s)return s(G);throw"both async and sync fetching of the wasm failed"}catch(ie){re(ie)}}function k(G){for(;G.length>0;){var K=G.shift();if(typeof K!="function"){var ie=K.func;typeof ie=="number"?K.arg===void 0?P(ie)():P(ie)(K.arg):ie(K.arg===void 0?null:K.arg)}else K(e)}}U(ae="data:application/octet-stream;base64,AGFzbQEAAAABIwdgAX8AYAABf2ABfwF/YAN/f38Bf2ADf39/AGACf38AYAAAAg0CAWEBYQACAWEBYgADAxoZBAMCAAIFBgQCAAQDAQEBAQIAAQEBAAAAAAQFAXABAQEFBwEBgAKAgAIGCQF/AUHQpIADCwdBEAFjAgABZAAIAWUAEQFmABABZwAPAWgADgFpABoBagAZAWsAGAFsABcBbQAWAW4AFQFvAQABcAAUAXEAEwFyABIKl6QBGf0DAQJ/IAJBgARPBEAgACABIAIQARoPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgBBwABJDQAgAiAAQUBqIgRLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAETQ0ACwsgACACTQ0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgAEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCwujAQEBfyACQX9zIQICQCABRQ0AIAFBAXEEfyAALQAAIAJB/wFxc0ECdEGwCGooAgAgAkEIdnMhAiAAQQFqIQAgAUEBawUgAQshAyABQQFGDQADQCAALQABIAAtAAAgAkH/AXFzQQJ0QbAIaigCACACQQh2cyIBQf8BcXNBAnRBsAhqKAIAIAFBCHZzIQIgAEECaiEAIANBAmsiAw0ACwsgAkF/cwtRAQJ/QaAIKAIAIgEgAEEDakF8cSICaiEAAkAgAkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQAEUNAQtBoAggADYCACABDwtB1KDAAEEwNgIAQX8L8QwBB38CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACIBayIDQeigwAAoAgBJDQEgACABaiEAIANB7KDAACgCAEcEQCABQf8BTQRAIAMoAggiAiABQQN2IgRBA3RBgKHAAGpGGiACIAMoAgwiAUYEQEHYoMAAQdigwAAoAgBBfiAEd3E2AgAMAwsgAiABNgIMIAEgAjYCCAwCCyADKAIYIQYCQCADIAMoAgwiAUcEQCADKAIIIgIgATYCDCABIAI2AggMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEBDAELA0AgAiEHIAQiAUEUaiICKAIAIgQNACABQRBqIQIgASgCECIEDQALIAdBADYCAAsgBkUNAQJAIAMgAygCHCICQQJ0QYijwABqIgQoAgBGBEAgBCABNgIAIAENAUHcoMAAQdygwAAoAgBBfiACd3E2AgAMAwsgBkEQQRQgBigCECADRhtqIAE2AgAgAUUNAgsgASAGNgIYIAMoAhAiAgRAIAEgAjYCECACIAE2AhgLIAMoAhQiAkUNASABIAI2AhQgAiABNgIYDAELIAUoAgQiAUEDcUEDRw0AQeCgwAAgADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAMgBU8NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVB8KDAACgCAEYEQEHwoMAAIAM2AgBB5KDAAEHkoMAAKAIAIABqIgA2AgAgAyAAQQFyNgIEIANB7KDAACgCAEcNA0HgoMAAQQA2AgBB7KDAAEEANgIADwsgBUHsoMAAKAIARgRAQeygwAAgAzYCAEHgoMAAQeCgwAAoAgAgAGoiADYCACADIABBAXI2AgQgACADaiAANgIADwsgAUF4cSAAaiEAAkAgAUH/AU0EQCAFKAIIIgIgAUEDdiIEQQN0QYChwABqRhogAiAFKAIMIgFGBEBB2KDAAEHYoMAAKAIAQX4gBHdxNgIADAILIAIgATYCDCABIAI2AggMAQsgBSgCGCEGAkAgBSAFKAIMIgFHBEAgBSgCCCICQeigwAAoAgBJGiACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEGIo8AAaiIEKAIARgRAIAQgATYCACABDQFB3KDAAEHcoMAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQeygwAAoAgBHDQFB4KDAACAANgIADwsgBSABQX5xNgIEIAMgAEEBcjYCBCAAIANqIAA2AgALIABB/wFNBEAgAEEDdiIBQQN0QYChwABqIQACf0HYoMAAKAIAIgJBASABdCIBcUUEQEHYoMAAIAEgAnI2AgAgAAwBCyAAKAIICyECIAAgAzYCCCACIAM2AgwgAyAANgIMIAMgAjYCCA8LQR8hAiADQgA3AhAgAEH///8HTQRAIABBCHYiASABQYD+P2pBEHZBCHEiAXQiAiACQYDgH2pBEHZBBHEiAnQiBCAEQYCAD2pBEHZBAnEiBHRBD3YgASACciAEcmsiAUEBdCAAIAFBFWp2QQFxckEcaiECCyADIAI2AhwgAkECdEGIo8AAaiEBAkACQAJAQdygwAAoAgAiBEEBIAJ0IgdxRQRAQdygwAAgBCAHcjYCACABIAM2AgAgAyABNgIYDAELIABBAEEZIAJBAXZrIAJBH0YbdCECIAEoAgAhAQNAIAEiBCgCBEF4cSAARg0CIAJBHXYhASACQQF0IQIgBCABQQRxaiIHQRBqKAIAIgENAAsgByADNgIQIAMgBDYCGAsgAyADNgIMIAMgAzYCCAwBCyAEKAIIIgAgAzYCDCAEIAM2AgggA0EANgIYIAMgBDYCDCADIAA2AggLQfigwABB+KDAACgCAEEBayIAQX8gABs2AgALC5IvAQt/IwBBEGsiCyQAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQdigwAAoAgAiBkEQIABBC2pBeHEgAEELSRsiB0EDdiICdiIBQQNxBEAgAUF/c0EBcSACaiIDQQN0IgFBiKHAAGooAgAiBEEIaiEAAkAgBCgCCCICIAFBgKHAAGoiAUYEQEHYoMAAIAZBfiADd3E2AgAMAQsgAiABNgIMIAEgAjYCCAsgBCADQQN0IgFBA3I2AgQgASAEaiIBIAEoAgRBAXI2AgQMDAsgB0HgoMAAKAIAIgpNDQEgAQRAAkBBAiACdCIAQQAgAGtyIAEgAnRxIgBBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2aiIDQQN0IgBBiKHAAGooAgAiBCgCCCIBIABBgKHAAGoiAEYEQEHYoMAAIAZBfiADd3EiBjYCAAwBCyABIAA2AgwgACABNgIICyAEQQhqIQAgBCAHQQNyNgIEIAQgB2oiAiADQQN0IgEgB2siA0EBcjYCBCABIARqIAM2AgAgCgRAIApBA3YiAUEDdEGAocAAaiEFQeygwAAoAgAhBAJ/IAZBASABdCIBcUUEQEHYoMAAIAEgBnI2AgAgBQwBCyAFKAIICyEBIAUgBDYCCCABIAQ2AgwgBCAFNgIMIAQgATYCCAtB7KDAACACNgIAQeCgwAAgAzYCAAwMC0HcoMAAKAIAIglFDQEgCUEAIAlrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QYijwABqKAIAIgEoAgRBeHEgB2shAyABIQIDQAJAIAIoAhAiAEUEQCACKAIUIgBFDQELIAAoAgRBeHEgB2siAiADIAIgA0kiAhshAyAAIAEgAhshASAAIQIMAQsLIAEoAhghCCABIAEoAgwiBEcEQCABKAIIIgBB6KDAACgCAEkaIAAgBDYCDCAEIAA2AggMCwsgAUEUaiICKAIAIgBFBEAgASgCECIARQ0DIAFBEGohAgsDQCACIQUgACIEQRRqIgIoAgAiAA0AIARBEGohAiAEKAIQIgANAAsgBUEANgIADAoLQX8hByAAQb9/Sw0AIABBC2oiAEF4cSEHQdygwAAoAgAiCUUNAEEAIAdrIQMCQAJAAkACf0EAIAdBgAJJDQAaQR8gB0H///8HSw0AGiAAQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgByAAQRVqdkEBcXJBHGoLIgZBAnRBiKPAAGooAgAiAkUEQEEAIQAMAQtBACEAIAdBAEEZIAZBAXZrIAZBH0YbdCEBA0ACQCACKAIEQXhxIAdrIgUgA08NACACIQQgBSIDDQBBACEDIAIhAAwDCyAAIAIoAhQiBSAFIAIgAUEddkEEcWooAhAiAkYbIAAgBRshACABQQF0IQEgAg0ACwsgACAEckUEQEEAIQRBAiAGdCIAQQAgAGtyIAlxIgBFDQMgAEEAIABrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QYijwABqKAIAIQALIABFDQELA0AgACgCBEF4cSAHayIBIANJIQIgASADIAIbIQMgACAEIAIbIQQgACgCECIBBH8gAQUgACgCFAsiAA0ACwsgBEUNACADQeCgwAAoAgAgB2tPDQAgBCgCGCEGIAQgBCgCDCIBRwRAIAQoAggiAEHooMAAKAIASRogACABNgIMIAEgADYCCAwJCyAEQRRqIgIoAgAiAEUEQCAEKAIQIgBFDQMgBEEQaiECCwNAIAIhBSAAIgFBFGoiAigCACIADQAgAUEQaiECIAEoAhAiAA0ACyAFQQA2AgAMCAsgB0HgoMAAKAIAIgJNBEBB7KDAACgCACEDAkAgAiAHayIBQRBPBEBB4KDAACABNgIAQeygwAAgAyAHaiIANgIAIAAgAUEBcjYCBCACIANqIAE2AgAgAyAHQQNyNgIEDAELQeygwABBADYCAEHgoMAAQQA2AgAgAyACQQNyNgIEIAIgA2oiACAAKAIEQQFyNgIECyADQQhqIQAMCgsgB0HkoMAAKAIAIghJBEBB5KDAACAIIAdrIgE2AgBB8KDAAEHwoMAAKAIAIgIgB2oiADYCACAAIAFBAXI2AgQgAiAHQQNyNgIEIAJBCGohAAwKC0EAIQAgB0EvaiIJAn9BsKTAACgCAARAQbikwAAoAgAMAQtBvKTAAEJ/NwIAQbSkwABCgKCAgICABDcCAEGwpMAAIAtBDGpBcHFB2KrVqgVzNgIAQcSkwABBADYCAEGUpMAAQQA2AgBBgCALIgFqIgZBACABayIFcSICIAdNDQlBkKTAACgCACIEBEBBiKTAACgCACIDIAJqIgEgA00NCiABIARLDQoLQZSkwAAtAABBBHENBAJAAkBB8KDAACgCACIDBEBBmKTAACEAA0AgAyAAKAIAIgFPBEAgASAAKAIEaiADSw0DCyAAKAIIIgANAAsLQQAQBCIBQX9GDQUgAiEGQbSkwAAoAgAiA0EBayIAIAFxBEAgAiABayAAIAFqQQAgA2txaiEGCyAGIAdNDQUgBkH+////B0sNBUGQpMAAKAIAIgQEQEGIpMAAKAIAIgMgBmoiACADTQ0GIAAgBEsNBgsgBhAEIgAgAUcNAQwHCyAGIAhrIAVxIgZB/v///wdLDQQgBhAEIgEgACgCACAAKAIEakYNAyABIQALAkAgAEF/Rg0AIAdBMGogBk0NAEG4pMAAKAIAIgEgCSAGa2pBACABa3EiAUH+////B0sEQCAAIQEMBwsgARAEQX9HBEAgASAGaiEGIAAhAQwHC0EAIAZrEAQaDAQLIAAiAUF/Rw0FDAMLQQAhBAwHC0EAIQEMBQsgAUF/Rw0CC0GUpMAAQZSkwAAoAgBBBHI2AgALIAJB/v///wdLDQEgAhAEIQFBABAEIQAgAUF/Rg0BIABBf0YNASAAIAFNDQEgACABayIGIAdBKGpNDQELQYikwABBiKTAACgCACAGaiIANgIAQYykwAAoAgAgAEkEQEGMpMAAIAA2AgALAkACQAJAQfCgwAAoAgAiBQRAQZikwAAhAANAIAEgACgCACIDIAAoAgQiAmpGDQIgACgCCCIADQALDAILQeigwAAoAgAiAEEAIAAgAU0bRQRAQeigwAAgATYCAAtBACEAQZykwAAgBjYCAEGYpMAAIAE2AgBB+KDAAEF/NgIAQfygwABBsKTAACgCADYCAEGkpMAAQQA2AgADQCAAQQN0IgNBiKHAAGogA0GAocAAaiICNgIAIANBjKHAAGogAjYCACAAQQFqIgBBIEcNAAtB5KDAACAGQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBB8KDAACAAIAFqIgA2AgAgACACQQFyNgIEIAEgA2pBKDYCBEH0oMAAQcCkwAAoAgA2AgAMAgsgAC0ADEEIcQ0AIAMgBUsNACABIAVNDQAgACACIAZqNgIEQfCgwAAgBUF4IAVrQQdxQQAgBUEIakEHcRsiAGoiAjYCAEHkoMAAQeSgwAAoAgAgBmoiASAAayIANgIAIAIgAEEBcjYCBCABIAVqQSg2AgRB9KDAAEHApMAAKAIANgIADAELQeigwAAoAgAgAUsEQEHooMAAIAE2AgALIAEgBmohAkGYpMAAIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQZikwAAhAANAIAUgACgCACICTwRAIAIgACgCBGoiBCAFSw0DCyAAKAIIIQAMAAsACyAAIAE2AgAgACAAKAIEIAZqNgIEIAFBeCABa0EHcUEAIAFBCGpBB3EbaiIJIAdBA3I2AgQgAkF4IAJrQQdxQQAgAkEIakEHcRtqIgYgByAJaiIIayECIAUgBkYEQEHwoMAAIAg2AgBB5KDAAEHkoMAAKAIAIAJqIgA2AgAgCCAAQQFyNgIEDAMLIAZB7KDAACgCAEYEQEHsoMAAIAg2AgBB4KDAAEHgoMAAKAIAIAJqIgA2AgAgCCAAQQFyNgIEIAAgCGogADYCAAwDCyAGKAIEIgBBA3FBAUYEQCAAQXhxIQUCQCAAQf8BTQRAIAYoAggiAyAAQQN2IgBBA3RBgKHAAGpGGiADIAYoAgwiAUYEQEHYoMAAQdigwAAoAgBBfiAAd3E2AgAMAgsgAyABNgIMIAEgAzYCCAwBCyAGKAIYIQcCQCAGIAYoAgwiAUcEQCAGKAIIIgAgATYCDCABIAA2AggMAQsCQCAGQRRqIgAoAgAiAw0AIAZBEGoiACgCACIDDQBBACEBDAELA0AgACEEIAMiAUEUaiIAKAIAIgMNACABQRBqIQAgASgCECIDDQALIARBADYCAAsgB0UNAAJAIAYgBigCHCIDQQJ0QYijwABqIgAoAgBGBEAgACABNgIAIAENAUHcoMAAQdygwAAoAgBBfiADd3E2AgAMAgsgB0EQQRQgBygCECAGRhtqIAE2AgAgAUUNAQsgASAHNgIYIAYoAhAiAARAIAEgADYCECAAIAE2AhgLIAYoAhQiAEUNACABIAA2AhQgACABNgIYCyAFIAZqIQYgAiAFaiECCyAGIAYoAgRBfnE2AgQgCCACQQFyNgIEIAIgCGogAjYCACACQf8BTQRAIAJBA3YiAEEDdEGAocAAaiECAn9B2KDAACgCACIBQQEgAHQiAHFFBEBB2KDAACAAIAFyNgIAIAIMAQsgAigCCAshACACIAg2AgggACAINgIMIAggAjYCDCAIIAA2AggMAwtBHyEAIAJB////B00EQCACQQh2IgAgAEGA/j9qQRB2QQhxIgN0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgA3IgAHJrIgBBAXQgAiAAQRVqdkEBcXJBHGohAAsgCCAANgIcIAhCADcCECAAQQJ0QYijwABqIQQCQEHcoMAAKAIAIgNBASAAdCIBcUUEQEHcoMAAIAEgA3I2AgAgBCAINgIAIAggBDYCGAwBCyACQQBBGSAAQQF2ayAAQR9GG3QhACAEKAIAIQEDQCABIgMoAgRBeHEgAkYNAyAAQR12IQEgAEEBdCEAIAMgAUEEcWoiBCgCECIBDQALIAQgCDYCECAIIAM2AhgLIAggCDYCDCAIIAg2AggMAgtB5KDAACAGQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBB8KDAACAAIAFqIgA2AgAgACACQQFyNgIEIAEgA2pBKDYCBEH0oMAAQcCkwAAoAgA2AgAgBSAEQScgBGtBB3FBACAEQSdrQQdxG2pBL2siACAAIAVBEGpJGyICQRs2AgQgAkGgpMAAKQIANwIQIAJBmKTAACkCADcCCEGgpMAAIAJBCGo2AgBBnKTAACAGNgIAQZikwAAgATYCAEGkpMAAQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgASAESQ0ACyACIAVGDQMgAiACKAIEQX5xNgIEIAUgAiAFayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAEEDdEGAocAAaiECAn9B2KDAACgCACIBQQEgAHQiAHFFBEBB2KDAACAAIAFyNgIAIAIMAQsgAigCCAshACACIAU2AgggACAFNgIMIAUgAjYCDCAFIAA2AggMBAtBHyEAIAVCADcCECAEQf///wdNBEAgBEEIdiIAIABBgP4/akEQdkEIcSICdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIAJyIAByayIAQQF0IAQgAEEVanZBAXFyQRxqIQALIAUgADYCHCAAQQJ0QYijwABqIQMCQEHcoMAAKAIAIgJBASAAdCIBcUUEQEHcoMAAIAEgAnI2AgAgAyAFNgIAIAUgAzYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBTYCECAFIAI2AhgLIAUgBTYCDCAFIAU2AggMAwsgAygCCCIAIAg2AgwgAyAINgIIIAhBADYCGCAIIAM2AgwgCCAANgIICyAJQQhqIQAMBQsgAigCCCIAIAU2AgwgAiAFNgIIIAVBADYCGCAFIAI2AgwgBSAANgIIC0HkoMAAKAIAIgAgB00NAEHkoMAAIAAgB2siATYCAEHwoMAAQfCgwAAoAgAiAiAHaiIANgIAIAAgAUEBcjYCBCACIAdBA3I2AgQgAkEIaiEADAMLQdSgwABBMDYCAEEAIQAMAgsCQCAGRQ0AAkAgBCgCHCICQQJ0QYijwABqIgAoAgAgBEYEQCAAIAE2AgAgAQ0BQdygwAAgCUF+IAJ3cSIJNgIADAILIAZBEEEUIAYoAhAgBEYbaiABNgIAIAFFDQELIAEgBjYCGCAEKAIQIgAEQCABIAA2AhAgACABNgIYCyAEKAIUIgBFDQAgASAANgIUIAAgATYCGAsCQCADQQ9NBEAgBCADIAdqIgBBA3I2AgQgACAEaiIAIAAoAgRBAXI2AgQMAQsgBCAHQQNyNgIEIAQgB2oiBSADQQFyNgIEIAMgBWogAzYCACADQf8BTQRAIANBA3YiAEEDdEGAocAAaiECAn9B2KDAACgCACIBQQEgAHQiAHFFBEBB2KDAACAAIAFyNgIAIAIMAQsgAigCCAshACACIAU2AgggACAFNgIMIAUgAjYCDCAFIAA2AggMAQtBHyEAIANB////B00EQCADQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgAyAAQRVqdkEBcXJBHGohAAsgBSAANgIcIAVCADcCECAAQQJ0QYijwABqIQECQAJAIAlBASAAdCICcUUEQEHcoMAAIAIgCXI2AgAgASAFNgIADAELIANBAEEZIABBAXZrIABBH0YbdCEAIAEoAgAhBwNAIAciASgCBEF4cSADRg0CIABBHXYhAiAAQQF0IQAgASACQQRxaiICKAIQIgcNAAsgAiAFNgIQCyAFIAE2AhggBSAFNgIMIAUgBTYCCAwBCyABKAIIIgAgBTYCDCABIAU2AgggBUEANgIYIAUgATYCDCAFIAA2AggLIARBCGohAAwBCwJAIAhFDQACQCABKAIcIgJBAnRBiKPAAGoiACgCACABRgRAIAAgBDYCACAEDQFB3KDAACAJQX4gAndxNgIADAILIAhBEEEUIAgoAhAgAUYbaiAENgIAIARFDQELIAQgCDYCGCABKAIQIgAEQCAEIAA2AhAgACAENgIYCyABKAIUIgBFDQAgBCAANgIUIAAgBDYCGAsCQCADQQ9NBEAgASADIAdqIgBBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQMAQsgASAHQQNyNgIEIAEgB2oiAiADQQFyNgIEIAIgA2ogAzYCACAKBEAgCkEDdiIAQQN0QYChwABqIQVB7KDAACgCACEEAn9BASAAdCIAIAZxRQRAQdigwAAgACAGcjYCACAFDAELIAUoAggLIQAgBSAENgIIIAAgBDYCDCAEIAU2AgwgBCAANgIIC0HsoMAAIAI2AgBB4KDAACADNgIACyABQQhqIQALIAtBEGokACAAC9YCAQF/AkAgAUUNACAAQQA6AAAgACABaiICQQFrQQA6AAAgAUEDSQ0AIABBADoAAiAAQQA6AAEgAkEDa0EAOgAAIAJBAmtBADoAACABQQdJDQAgAEEAOgADIAJBBGtBADoAACABQQlJDQAgAEEAIABrQQNxIgJqIgBBADYCACAAIAEgAmtBfHEiAmoiAUEEa0EANgIAIAJBCUkNACAAQQA2AgggAEEANgIEIAFBCGtBADYCACABQQxrQQA2AgAgAkEZSQ0AIABBADYCGCAAQQA2AhQgAEEANgIQIABBADYCDCABQRBrQQA2AgAgAUEUa0EANgIAIAFBGGtBADYCACABQRxrQQA2AgAgAiAAQQRxQRhyIgJrIgFBIEkNACAAIAJqIQADQCAAQgA3AxggAEIANwMQIABCADcDCCAAQgA3AwAgAEEgaiEAIAFBIGsiAUEfSw0ACwsLAwABC7AEAQd/AkAgACgCACIGQYCAgAhPBEAgACgCBCEEDAELIAAgBkEIdCIGNgIAIAAgACgCECIDQQFqNgIQIAAgAyAAKAIMai0AACAAKAIEQQh0ciIENgIECwJ/IAEvAQAiBSAGQQt2bCIDIARLBEAgASAFQYAQIAVrQQV2ajsBACABIAJBBHRqQQRqIQhBAiEFQQgMAQsgACAEIANrIgQ2AgQgASAFIAVBBXZrOwEAIAYgA2siBkH///8HTQRAIAAgBkEIdCIGNgIAIAAgACgCECIDQQFqNgIQIAAgAyAAKAIMai0AACAEQQh0ciIENgIECyABLwECIgUgBkELdmwiAyAESwRAIAEgBUGAECAFa0EFdmo7AQIgASACQQR0akGEAmohCEEKIQVBCAwBCyAAIAQgA2siBDYCBCABIAUgBUEFdms7AQIgAUGEBGohCCAGIANrIQNBEiEFQYACCyEGIAAgBTYCaEEBIQEDQCAIIAFBAXQiAWohCQJAIANB////B0sEQCADIQIMAQsgACADQQh0IgI2AgAgACAAKAIQIgNBAWo2AhAgACADIAAoAgxqLQAAIARBCHRyIgQ2AgQLAkAgCS8BACIHIAJBC3ZsIgMgBE0EQCAAIAQgA2siBDYCBCAAIAIgA2siAzYCACAJIAcgB0EFdms7AQAgAUEBciEBDAELIAAgAzYCACAJIAdBgBAgB2tBBXZqOwEACyABIAZJDQALIAAgASAGayAFajYCaAvIHwEQfwJAIAAoAigiASAAKAIgIglNDQAgACgCaCICRQ0AIAAoAlQiAyAAKAIkTw0AIAAoAjAgA00NACAAIAIgASAJayIBIAIgASACSRsiBms2AmggCSADQX9zaiEEIAMgCU8EQCAAKAIsIARqIQQLIAAoAhgiAyAEai0AACEBIAAgCUEBajYCICADIAlqIAE6AAACQCAGQQFrIgdFDQAgB0EBcQRAIAAoAhgiAkEAIARBAWoiASABIAAoAixGGyIEai0AACEDIAAgACgCICIBQQFqNgIgIAEgAmogAzoAACAGQQJrIQcLIAZBAkYNAANAIAAoAhgiAkEAIARBAWoiASABIAAoAixGGyIGai0AACEDIAAgACgCICIBQQFqNgIgIAEgAmogAzoAACAAKAIYIgJBACAGQQFqIgEgASAAKAIsRhsiBGotAAAhAyAAIAAoAiAiAUEBajYCICABIAJqIAM6AAAgB0ECayIHDQALCyAAKAIgIgkgACgCJE0NACAAIAk2AiQLAkACQCAJIAAoAihPDQAgAEHcDWohDiAAQeAVaiEPIABB1ABqIRADQCAAKAIQIgMgACgCFEsNASAAIAAoAmQiCkEFdGogACgCdCAJcSIIQQF0aiIMIQYCQCAAKAIAIgVBgICACE8EQCAAKAIEIQQMAQsgACAFQQh0IgU2AgAgACADQQFqIgE2AhAgACAAKAIMIANqLQAAIAAoAgRBCHRyIgQ2AgQgASEDCwJAIAYvAXgiASAFQQt2bCICIARLBEAgACACNgIAIAYgAUGAECABa0EFdmo7AXggCUEBayEFIAlFBEAgACgCLCAFaiEFCyAAKAJwIAlxIAAoAmwiAXQgACgCJCIGBH8gACgCGCAFai0AAAVBAAtBCCABa3ZqIQ1BASEFAkAgCkEGTQRAA0AgBUEBdCIFIAAgDUGADGxqakHkHWohBgJAIAJB////B0sEQCACIQEMAQsgACACQQh0IgE2AgAgACADQQFqIgI2AhAgACAAKAIMIANqLQAAIARBCHRyIgQ2AgQgAiEDCwJAIAYvAQAiCCABQQt2bCICIARNBEAgACAEIAJrIgQ2AgQgACABIAJrIgI2AgAgBiAIIAhBBXZrOwEAIAVBAXIhBQwBCyAAIAI2AgAgBiAIQYAQIAhrQQV2ajsBAAsgBUGAAkkNAAwCCwALIAkgACgCVCIBQX9zaiEFIAEgCU8EQCAAKAIsIAVqIQULIAYEfyAAKAIYIAVqLQAABUEACyEGQQEhBUGAAiEHA0AgACANQYAMbGogBkEBdCIGIAdxIgwgB2ogBWpBAXRqQeQdaiELAkAgAkH///8HSwRAIAIhCAwBCyAAIAJBCHQiCDYCACAAIANBAWoiATYCECAAIAAoAgwgA2otAAAgBEEIdHIiBDYCBCABIQMLIAsCfyAEIAsvAQAiASAIQQt2bCICTyIKRQRAIAAgAjYCACABQYAQIAFrQQV2agwBCyAAIAQgAmsiBDYCBCAAIAggAmsiAjYCAEEAIQcgASABQQV2aws7AQAgByAMcyEHIAVBAXQgCnIiBUGAAkkNAAsLIAAgCUEBajYCICAAKAIYIAlqIAU6AAAgACgCICIJIAAoAiRLBEAgACAJNgIkC0EAIQIgACAAKAJkIgFBBE8EfyABQQlNBEAgACABQQNrNgJkDAMLIAFBBmsFQQALNgJkDAELIAAgBCACayIENgIEIAAgBSACayICNgIAIAYgASABQQV2azsBeCAAIApBAXRqIgshBgJAIAJB////B0sEQCADIQEMAQsgACACQQh0IgI2AgAgACADQQFqIgE2AhAgACAAKAIMIANqLQAAIARBCHRyIgQ2AgQLAkAgBi8B+AMiCiACQQt2bCIDIARNBEAgACAEIANrIgQ2AgQgACACIANrIgI2AgAgBiAKIApBBXZrOwH4AwJAIAJB////B0sEQCABIQYMAQsgACACQQh0IgI2AgAgACABQQFqIgY2AhAgACAAKAIMIAFqLQAAIARBCHRyIgQ2AgQLAkAgCy8BkAQiASACQQt2bCIFIARLBEAgCyABQYAQIAFrQQV2ajsBkAQgBUH///8HTQRAIAAgBUEIdCIFNgIAIAAgBkEBajYCECAAIAAoAgwgBmotAAAgBEEIdHIiBDYCBAsgDC8B2AQiAyAFQQt2bCIBIARNBEAgACAEIAFrNgIEIAAgBSABazYCACAMIAMgA0EFdms7AdgEDAILIAAgATYCACAMIANBgBAgA2tBBXZqOwHYBCAAQQE2AmggAEEJQQsgACgCZEEHSRs2AmQMAwsgACAEIAVrIgQ2AgQgCyABIAFBBXZrOwGQBAJAIAIgBWsiAkH///8HSwRAIAYhAQwBCyAAIAJBCHQiAjYCACAAIAZBAWoiATYCECAAIAAoAgwgBmotAAAgBEEIdHIiBDYCBAsCQCALLwGoBCIGIAJBC3ZsIgMgBEsEQCAAIAM2AgAgCyAGQYAQIAZrQQV2ajsBqAQgACgCWCECDAELIAAgBCADayIENgIEIAsgBiAGQQV2azsBqAQgAiADayICQf///wdNBEAgACACQQh0IgI2AgAgACABQQFqNgIQIAAgACgCDCABai0AACAEQQh0ciIENgIECwJAIAsvAcAEIgMgAkELdmwiASAESwRAIAAgATYCACALIANBgBAgA2tBBXZqOwHABCAAKAJcIQIMAQsgACAEIAFrNgIEIAAgAiABazYCACALIAMgA0EFdms7AcAEIAAoAmAhAiAAIAAoAlw2AmALIAAgACgCWDYCXAsgACAAKAJUNgJYIAAgAjYCVAsgAEEIQQsgACgCZEEHSRs2AmQgACAPIAgQCQwBCyAAIAM2AgAgBiAKQYAQIAprQQV2ajsB+AMgACAAKAJcNgJgIAAgACkCVDcCWCAAQQdBCiAAKAJkQQdJGzYCZCAAIA4gCBAJIAAoAmgiAUECa0EDIAFBBkkbIQMgACgCACECQQEhBANAIARBAXQiBCAAIANBB3RqaiEGAkAgAkGAgIAITwRAIAAoAgQhBQwBCyAAIAJBCHQiAjYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgACgCBEEIdHIiBTYCBAsCQCAGLwHYByIIIAJBC3ZsIgEgBU0EQCAAIAUgAWsiBTYCBCAAIAIgAWsiAjYCACAGIAggCEEFdms7AdgHIARBAXIhBAwBCyAAIAE2AgAgBiAIQYAQIAhrQQV2ajsB2AcgASECCyAEQcAASQ0ACyAEQUBqIgNBA00EQCAAIAM2AlQMAQsgACAEQQFxQQJyIgc2AlQgA0EBdiEBIANBDU0EQCAAIAcgAUEBayIKdCIINgJUQQEhByAQIAhBAXRqQQAgBGtBAXRqQYIMaiEGQQAhCwNAIAYgB0EBdCIHaiEMAkAgAkH///8HSwRAIAIhAQwBCyAAIAJBCHQiATYCACAAIAAoAhAiA0EBajYCECAAIAMgACgCDGotAAAgBUEIdHIiBTYCBAsCQCAMLwEAIgMgAUELdmwiAiAFTQRAIAAgBSACayIFNgIEIAAgASACayICNgIAIAwgAyADQQV2azsBACAAQQEgC3QgCGoiCDYCVCAHQQFyIQcMAQsgACACNgIAIAwgA0GAECADa0EFdmo7AQALIAtBAWoiCyAKRw0ACwwBCyABQQVrIQQDQAJAIAJB////B0sEQCACIQMMAQsgACACQQh0IgM2AgAgACAAKAIQIgFBAWo2AhAgASAAKAIMai0AACAFQQh0ciEFCyAAIANBAXYiAjYCACAAIAUgAmsiBkEfdSIBIAdBAXRqQQFqIgc2AlQgACABIAJxIAZqIgU2AgQgBEEBayIEDQALIAAgB0EEdCIHNgJUIANB////D00EQCAAIAJBCHQiAjYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgBUEIdHIiBTYCBAsgAAJ/IAAvAb4NIgEgAkELdmwiBCAFTQRAIAAgBSAEayIFNgIEIAAgB0EBciIHNgJUIAAgASABQQV2azsBvg0gAiAEayEEQQMMAQsgACABQYAQIAFrQQV2ajsBvg1BAgtBAXQiA2pBvA1qIQYgBEH///8HTQRAIAAgBEEIdCIENgIAIAAgACgCECIBQQFqNgIQIAAgASAAKAIMai0AACAFQQh0ciIFNgIECwJAIAYvAQAiASAEQQt2bCICIAVNBEAgACAFIAJrIgU2AgQgBiABIAFBBXZrOwEAIAAgB0ECaiIHNgJUIAQgAmshAiADQQFyIQMMAQsgBiABQYAQIAFrQQV2ajsBAAsgACADQQF0IgNqQbwNaiEGIAJB////B00EQCAAIAJBCHQiAjYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgBUEIdHIiBTYCBAsCQCAGLwEAIgEgAkELdmwiBCAFTQRAIAAgBSAEayIFNgIEIAYgASABQQV2azsBACAAIAdBBGoiBzYCVCACIARrIQQgA0EBciEDDAELIAYgAUGAECABa0EFdmo7AQALIARB////B00EQCAAIARBCHQiBDYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgBUEIdHIiBTYCBAsgACADQQF0akG8DWoiAS8BACICIARBC3ZsIgMgBU0EQCAAIAUgA2s2AgQgACAEIANrNgIAIAEgAiACQQV2azsBACAAIAdBCGo2AlQMAQsgACADNgIAIAEgAkGAECACa0EFdmo7AQALQQAhAiAAKAJUIgYgACgCJE8NAyAAKAIwIAZNDQMgACAAKAJoIgMgACgCKCAAKAIgIgprIgEgAyABIANJGyIIazYCaCAKIAZBf3NqIQIgBiAKTwRAIAAoAiwgAmohAgsgACgCGCIDIAJqLQAAIQEgACAKQQFqNgIgIAMgCmogAToAAAJAIAhBAWsiBUUNACAFQQFxBEAgACgCGCIGQQAgAkEBaiIBIAEgACgCLEYbIgJqLQAAIQMgACAAKAIgIgFBAWo2AiAgASAGaiADOgAAIAhBAmshBQsgCEECRg0AA0AgACgCGCIGQQAgAkEBaiIBIAEgACgCLEYbIgJqLQAAIQMgACAAKAIgIgFBAWo2AiAgASAGaiADOgAAIAAoAhgiBkEAIAJBAWoiASABIAAoAixGGyICai0AACEDIAAgACgCICIBQQFqNgIgIAEgBmogAzoAACAFQQJrIgUNAAsLIAAoAiAiCSAAKAIkTQ0AIAAgCTYCJAsgCSAAKAIoSQ0ACwtBASECIAAoAgAiAUH///8HSw0AIAAgAUEIdDYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgACgCBEEIdHI2AgQLIAILJgEBfyAABEAgACgCsAkiASgCPARAIAEoAhgQBQsgARAFIAAQBQsLMgEBfyAAIAApA4ABIAIgACgCECICayIDrXw3A4ABIAAgASACaiADIAAoAhgQA603AxgLgQEBAn8CQAJAIAJBBE8EQCAAIAFyQQNxDQEDQCAAKAIAIAEoAgBHDQIgAUEEaiEBIABBBGohACACQQRrIgJBA0sNAAsLIAJFDQELA0AgAC0AACIDIAEtAAAiBEYEQCABQQFqIQEgAEEBaiEAIAJBAWsiAg0BDAILCyADIARrDwtBAAsJAEG8oCAoAgALCQBBsKAgKAIAC9QzAhR/An4CQAJAAkACQAJAAkACQAJAAn8Cf0HQoMAAKAIAIgEoAiQEQCABKAIADAELIAFBADoAKCABQgA3AwAgAUIANwMYIAFByABqQeQAEAcgAUEMNgKsAUEACyEAQcCgICgCACENIAFBtKAgKAIAIg42AhAgAUHgAGohDyABQbYBaiEQIAFBsAFqIREgAUGoAWohCANAAkACQAJAAkACQAJAAkACQAJAAkAgCAJ/AkACQAJAIAAOCgECAAoLDAQFBgcOC0GwoCAoAgAhAyABKAKsASECQbSgICgCACEAQbigICgCACEGIAEoAqgBDAILIAggASgCqAEiAGpBCGpBtKAgKAIAIgJBsKAgKAIAakG4oCAoAgAgAmsiAiABKAKsASAAayIAIAAgAksbIgAQAkG0oCBBtKAgKAIAIABqNgIAQQAhAyABQQAgASgCqAEgAGoiACAAIAEoAqwBIgJGGzYCqAEgACACRw0LIAFBATYCACARQYAIQQYQDQRAQQUhAwwMCyAQQQJBABADIAEoALgBRwRAQQchAwwMC0EGIQMgEC0AAA0LIAEgAS0AtwEiADYCICAAQQ9LDQtBAiEDIABBBEsNC0EBIAB0QRNxRQ0LC0G0oCAoAgAiAEG4oCAoAgAiBkYEQEEAIQMMCwtBsKAgKAIAIgMgAGotAAAiAkUEQEG0oCAgAEEBajYCACABIAA2AhBBBiEAIAFBBjYCAAwMCyABQQA2AqgBIAFBAjYCACABIAJBAnRBBGoiAjYCrAEgASACNgJAQQALIgVqQQhqIAAgA2ogBiAAayIAIAIgBWsiAiAAIAJJGyIAEAJBtKAgIABBtKAgKAIAajYCAEEAIQMgAUEAIAEoAqgBIABqIgAgACABKAKsASICRhs2AqgBIAAgAkcNCSABIABBBGsiADYCrAEgESAAQQAQAyABIAEoAqwBIgVqKACwAUcEQEEHIQMMCgsgAUECNgKoASABLACxASIEQT9xBEBBBiEDDAoLQQIhAEJ/IRVCfyEUIARBwABxRQ0FIAEoAgQiAkUEQCABQgA3AwgLIAVBAiAFQQJLGyEGA0AgACAGRgRAQQchAwwLCyAAIAhqLQAIIQMgASAAQQFqIgA2AqgBIAEgASkDCCADQf8Aca0gAq2GhCIUNwMIIANBgAFxRQRAAkAgAw0AIAJFDQBBByEDDAwLIAFBADYCBAwHC0EHIQMgASACQQdqIgI2AgQgAkE/Rw0ACwwJCwJ/IAFBkAFqIQYDQEG4oCAoAgAhAkGwoCAoAgAhBCABKAIEIgVFBEAgAUIANwMIC0G0oCAoAgAiACACIAAgAksbIQICQANAAkAgACACRgRAQQAhAyACIQAMAQsgACAEai0AACEDQbSgICAAQQFqIgA2AgAgASABKQMIIANB/wBxrSAFrYaEIhQ3AwggA0GAAXFFBEAgAw0DIAVFDQNBByEDDAELQQchAyABIAVBB2oiBTYCBCAFQT9HDQELCyABIAEpA4ABIAAgASgCECIAayICrXw3A4ABIAEgACAEaiACIAEoAhgQA603AxggAwwCCyABQQA2AgQCQAJAAkACQAJAIAEoAngOAwACAQMLIAEgFDcDiAFBByABKQNYIBRSDQUaIAFBATYCeAwDCyABIAEpA5gBIBR8NwOYASABIAZBGCABKAKgARADNgKgASABQQE2AnggASABKQOIAUIBfSIUNwOIAQwCCyABQQI2AnggASABKQOQASAUfDcDkAELIAEpA4gBIRQLIBRCAFINAAtBAQsiA0EBRw0IIAFBBzYCAAsCQCABKQOAASIUQbSgICgCACIAIAEoAhAiBGutfEIDg1ANAEGwoCAoAgAhBkG4oCAoAgAgAEYEQCAAIQIMBAtBtKAgIABBAWoiAjYCAEEHIQMgACAGai0AAA0IAkAgFCACIARrrXxCA4NQDQBBsKAgKAIAIQYgAkG4oCAoAgBGDQRBtKAgIABBAmoiBTYCACACIAZqLQAADQkgFCAFIARrrXxCA4NQBEAgBSEADAILQbCgICgCACEGQbigICgCACAFRgRAIAUhAgwFC0G0oCAgAEEDaiICNgIAIAUgBmotAAANCSAUIAIgBGutfEIDg1ANAEG4oCAoAgAgAkYEQEGwoCAoAgAhBgwFC0G0oCAgAEEEajYCAAwJCyACIQALIAFBsKAgKAIAIAAQDEEHIQMgDyABQZABakEYEA0NByABQQg2AgALAn9BtKAgKAIAIQBBuKAgKAIAIQUDQEEAIAAgBUYNARogASkDGCEUIAEoAgQhA0G0oCAgAEEBaiICNgIAQQdBsKAgKAIAIABqLQAAIBQgA62Ip0H/AXFHDQEaIAEgA0EIaiIDNgIEIAIhACADQSBJDQALIAFBADYCBCABQgA3AxhBAQsiA0EBRw0GIAFBCTYCACABQQw2AqwBC0EAIQMgASABKAKoASIAakGwAWpBtKAgKAIAIgJBsKAgKAIAakG4oCAoAgAgAmsiAiABKAKsASAAayIAIAAgAksbIgAQAkG0oCBBtKAgKAIAIABqNgIAIAFBACABKAKoASAAaiIAIAAgASgCrAFGIgAbNgKoASAARQ0FQQchAAJAIAEvALoBQdm0AUcNACABQbQBakEGQQAQAyABKACwAUcNACABNQC0ASABKQOAAUICiFINACABLQC4AQ0AQQFBByABKAIgIAEtALkBRhshAAsgACEDDAULIAEgBiACEAxBACEDDAQLIAEgFDcDMCAEQQBIBEAgASgCBCICRQRAIAFCADcDCAsgACAFIAAgBUsbIQQDQCAAIARGBEBBByEDDAYLIAAgCGotAAghAyABIABBAWoiADYCqAEgASABKQMIIANB/wBxrSACrYaEIhU3AwgCQCADQYABcUUEQCADDQEgAkUNAUEHIQMMBwtBByEDIAEgAkEHaiICNgIEIAJBP0cNAQwGCwsgAUEANgIECyABIBU3AzggBSAAa0ECSQRAQQchAwwECyABIABBAWoiAjYCqAEgACAIai0ACEEhRwRAQQYhAwwECyABIABBAmoiBDYCqAEgAiAIai0ACEEBRwRAQQYhAwwEC0EHIQMgBCAFRg0DIAEgAEEDajYCqAEgASgCsAkhAEEGIQICQCAEIAhqLQAIIgNBJ0sNACAAIANBAXFBAnIgA0EBdkELanQiBTYCMAJ/AkAgACgCPCIDRQ0AQQQhAiAFIAAoAjRLDQIgACAFNgIsIANBAkcNACAFIABBOGoiAygCAE0NACAAKAIYEAUgACAAKAIwEAYiAjYCGCACDQBBAwwBCyAAQQA2AkAgAEEBOgBQIABBADYCaCAAQeTdAWohA0EACyECIANBADYCAAsgAiIDDQMgASgCqAEiACABKAKsASICIAAgAksbIQMCQANAIAAgA0YNASABIABBAWoiAjYCqAEgACAIaiEFIAIhACAFLQAIRQ0AC0EGIQMMBAsgAUEANgKoASABQgA3A1AgAUIANwNIIAFBAzYCAAsgAUG0oCAoAgA2AhAgAUHAoCAoAgA2AhQCfyABKAKwCSIEQejdAWohBSAEQfgAaiEKIARB5N0BaiELA38gBCgCQCEDAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAQbSgICgCACIAQbigICgCACICTwRAIANBB0YNAUEADBELIAMOCQECAwQFBgcACQ8LIAQoAkwhAwwHC0EBIQZBtKAgIABBAWo2AgBBsKAgKAIAIABqLQAAIgBFDQggAEEBRyAAQd8BTXFFBEAgBEGAAjsBUCAEKAI8RQRAIARBwKAgKAIAIgJBvKAgKAIAajYCGCAEQcSgICgCACACazYCLAsgBEIANwIcIARCADcCJAwLCyAELQBQRQ0KQQcMDgtBtKAgIABBAWo2AgBBsKAgKAIAIABqLQAAIQAgBEECNgJAIAQgBCgCSCAAQQh0ajYCSAwMC0G0oCAgAEEBajYCAEGwoCAoAgAgAGotAAAhACAEQQM2AkAgBCAAIAQoAkhqQQFqNgJIDAsLQbSgICAAQQFqNgIAQbCgICgCACAAai0AACEAIARBBDYCQCAEIABBCHQ2AkwMCgtBtKAgIABBAWo2AgBBsKAgKAIAIABqLQAAIQAgBCAEKAJENgJAIAQgACAEKAJMakEBajYCTAwJC0G0oCAgAEEBajYCAEEHIQZBsKAgKAIAIABqLQAAIgBB4AFLDQNBACEDIARBfyAAQS1JBH9BAAUgAEEtayIAIABB/wFxQS1uIgJBLWxrIQAgAkEBagt0QX9zNgJ0IABB/wFxQQlPBEAgAEEJayIAIABB/wFxQQluIgJBCWxrIQAgAkEBaiEDCyAEIAM2AnAgBCAAQf8BcSIANgJsIAAgA2pBBEsNAyAEQX8gA3RBf3M2AnBBACEAIARBADYCZCAEQgA3AlwgBEIANwJUA0AgCiAAQQF0IgJqQYAIOwEAIAogAkECcmpBgAg7AQAgAEECaiIAQbbuAEcNAAsgBEEGNgJAIARBBTYCCCAEQv////8PNwIAC0EHIAQoAkwiBkEFSQ0IGiAEKAIIIgMEQEG0oCAoAgAhAEG4oCAoAgAhBwNAQQAgACAHRg0KGiAEKAIEIQxBtKAgIABBAWoiAjYCAEGwoCAoAgAgAGotAAAhACAEIANBAWsiAzYCCCAEIAAgDEEIdHI2AgQgAiEAIAMNAAsLIARBBzYCQCAEIAZBBWsiAzYCTAsgBCAEKAIgIgBBxKAgKAIAQcCgICgCAGsiAiAEKAJIIgYgAiAGSRsiAmogBCgCLCIGIAYgAGsgAksbNgIoQbigICgCACIGQbSgICgCACICayEAAkACQCAEKALk3QEiB0UEQCADDQFBACEDCyAHIAtqQQRqQbCgICgCACACaiAAIAMgB2siAkEqIAdrIgMgAiADSRsiAiAAIAJJGyIAEAICfyAAIAQoAuTdASIDaiICIAQoAkxGBEAgAyALaiAAakEEakE/IAJrEAcgBCgC5N0BIABqDAELIAJBFE0EQCAEIAI2AuTdAUG0oCBBtKAgKAIAIABqNgIADAMLIAJBFWsLIQIgBEEANgIQIAQgBTYCDCAEIAI2AhRBByEGIAQQCkUNAyAEKAIQIgcgACAEKALk3QEiAmpLDQMgBCAEKAJMIAdrIgM2AkwgAiAHSwRAIAQgAiAHayIANgLk3QECQCAFIgIgByALakEEaiIDRg0AIAMgACACaiIHa0EAIABBAXRrTQRAIAIgAyAAEAIMAQsgAiADc0EDcSEGAkACQCACIANJBEAgBg0CIAJBA3FFDQEDQCAARQ0EIAIgAy0AADoAACADQQFqIQMgAEEBayEAIAJBAWoiAkEDcQ0ACwwBCwJAIAYNACAHQQNxBEADQCAARQ0FIAIgAEEBayIAaiIGIAAgA2otAAA6AAAgBkEDcQ0ACwsgAEEDTQ0AA0AgAiAAQQRrIgBqIAAgA2ooAgA2AgAgAEEDSw0ACwsgAEUNAgNAIAIgAEEBayIAaiAAIANqLQAAOgAAIAANAAsMAgsgAEEDTQ0AA0AgAiADKAIANgIAIANBBGohAyACQQRqIQIgAEEEayIAQQNLDQALCyAARQ0AA0AgAiADLQAAOgAAIAJBAWohAiADQQFqIQMgAEEBayIADQALCwwCC0G0oCBBtKAgKAIAIAcgAmtqIgI2AgAgBEEANgLk3QFBuKAgKAIAIgYgAmshAAsgAEEVTwRAQbCgICgCACEHIAQgAjYCECAEIAc2AgwgBCAGQRVrIAIgA2ogACADQRVqSRs2AhRBByEGIAQQCkUNAyAEKAJMIgAgBCgCECICQbSgICgCAGsiA0kNAyAEIAAgA2siAzYCTEG0oCAgAjYCAEG4oCAoAgAgAmsiAEEUSw0BCyAFQbCgICgCACACaiADIAAgACADSxsiABACIAQgADYC5N0BQbSgIEG0oCAoAgAgAGo2AgALIAQoAiAiAiAEKAIcIgNrIQAgBCAEKAI8BH8gBCgCLCACRgRAIARBADYCIAtBvKAgKAIAQcCgICgCAGogBCgCGCADaiAAEAIgBCgCIAUgAgs2AhxBwKAgQcCgICgCACAAaiICNgIAIAQgBCgCSCAAayIANgJIIABFBEBBByEGIAQoAkwNAiAEKAJoDQIgBCgCBA0CIARBADYCQAwFC0EAIQYgAkHEoCAoAgBGDQFBtKAgKAIAQbigICgCAEcNBiAEKALk3QEgBCgCTE8NBgwBCyAEKAJMIgNFDQFBACEGIAAgAk8NAANAQcSgICgCACIHQcCgICgCACIMTQ0BIAQgAyADIAQoAiwgBCgCICISayITIAIgAGsiAiAHIAxrIgcgAiAHSRsiAiACIBNLGyICIAIgA0sbIgJrNgJMIBIgBCgCGGpBsKAgKAIAIABqIAIQAiAEIAQoAiAgAmoiADYCICAAIAQoAiRLBEAgBCAANgIkCyAEIAQoAjwEfyAEKAIsIABGBEAgBEEANgIgC0G8oCAoAgBBwKAgKAIAakGwoCAoAgBBtKAgKAIAaiACEAIgBCgCIAUgAAs2AhxBwKAgQcCgICgCACACajYCAEG0oCBBtKAgKAIAIAJqIgA2AgAgBCgCTCIDRQ0CQbigICgCACICIABLDQALCyAGDAULIARBADYCQAwDCyAAQRh0QRh1QQBODQEgBEEBNgJAIAQgAEEQdEGAgPwAcTYCSCAAQcABTwRAIARBBTYCRCAEQQA6AFEMAwtBByAELQBRDQMaIARBBjYCRCAAQaABSQ0CIARCADcCVEEAIQAgBEEANgJkIARCADcCXANAIAogAEEBdCICakGACDsBACAKIAJBAnJqQYAIOwEAIABBAmoiAEG27gBHDQALCyAEQQU2AgggBEL/////DzcCAAwBCyAAQQJLBH9BBwUgBEKDgICAgAE3AkAMAQsLCyEDIAEgASkDSEG0oCAoAgAgASgCEGutfCIUNwNIIAEgASkDUEHAoCAoAgAgASgCFCICayIArXwiFTcDUCABKQMwIBRUBEBBByEDDAMLIAEpAzggFVQEQEEHIQMMAwsCQCABAn4CQAJAIAEoAiBBAWsOBAADAwEDC0G8oCAoAgAgAmogACABKAIYEAOtDAELQbygICgCACACaiEFIAEpAxhCf4UhFAJAIABFDQAgAEEBcQR/IAUxAAAgFEL/AYOFp0EDdEGwEGopAwAgFEIIiIUhFCAFQQFqIQUgAEEBawUgAAshAiAAQQFGDQADQCAFMQABIAUxAAAgFEL/AYOFp0EDdEGwEGopAwAgFEIIiIUiFEL/AYOFp0EDdEGwEGopAwAgFEIIiIUhFCAFQQJqIQUgAkECayICDQALCyAUQn+FCzcDGAsgA0EBRw0CAkAgASkDMCIUQn9RDQAgFCABKQNIUQ0AQQchAwwDCyABKQNQIRUCQCABKQM4IhRCf1EEQCAVIRQMAQtBByEDIBQgFVINAwsgASABKQNoIBR8NwNoIAEgASgCIEGQCGoxAAAgASkDYCABKQNIIAE1AkB8fHw3A2AgASAPQRggASgCcBADNgJwIAFBBDYCACABIAEpA1hCAXw3A1gLAkAgASkDSCIUQgODUA0AQQAhA0G0oCAoAgAiAEG4oCAoAgAiAkYNAkG0oCAgAEEBaiIFNgIAQbCgICgCACAAai0AAARAQQchAwwDCyABIBRCAXwiFTcDSCAVQgODUA0AIAIgBUYNAkG0oCAgAEECaiIENgIAQbCgICgCACAFai0AAARAQQchAwwDCyABIBRCAnwiFTcDSCAVQgODUA0AIAIgBEYNAkG0oCAgAEEDaiIFNgIAQbCgICgCACAEai0AAARAQQchAwwDCyABIBRCA3wiFTcDSCAVQgODUA0AIAIgBUYNAkG0oCAgAEEEajYCAEEHIQNBsKAgKAIAIAVqLQAADQIgASAUQgR8NwNICyABQQU2AgALAkACQAJAAkACQCABKAIgIgBBAWsOBAACAgECC0G0oCAoAgAhAEG4oCAoAgAhBQNAIAAgBUYEQEEAIQMMBgsgASkDGCEUIAEoAgQhA0G0oCAgAEEBaiICNgIAQbCgICgCACAAai0AACAUIAOtiKdB/wFxRwRAQQchAwwGCyABIANBCGoiAzYCBCACIQAgA0EgSQ0ACyABQgA3AxgMAgtBtKAgKAIAIQBBuKAgKAIAIQUDQCAAIAVGBEBBACEDDAULIAEpAxghFCABKAIEIQNBtKAgIABBAWoiAjYCAEGwoCAoAgAgAGotAAAgFCADrYinQf8BcUcEQEEHIQMMBQsgASADQQhqIgM2AgQgAiEAIANBwABJDQALIAFCADcDGAwBCyABKAIEIgIgAEGQCGotAAAiBU8NAEEAIQNBtKAgKAIAIgBBuKAgKAIAIgRGDQIDQAJAIABBAWohACACQQFqIgIgBUYNACAAIARHDQEMAwsLQbSgICAANgIACyABQQA2AgRBASEAIAFBATYCAAwCC0G0oCAgBDYCACABIAI2AgRBASEAIAIgBUkNACABQQE2AgAMAQsLAkAgASgCJEUEQAJAAkAgAw4CAAMBC0EHQQhBtKAgKAIAQbigICgCAEYbIQMLQcCgICANNgIAQbSgICAONgIAIAMMAgsCQCADDQAgDkG0oCAoAgBHDQAgDUHAoCAoAgBHDQAgAS0AKCEAIAFBAToAKCAAQQN0DAILIAFBADoAKAsgAwsOCQcGBwABAgMEBAULQQEhCQwFC0ECIQkMBAtBBCEJDAMLQQUhCQwCC0EGIQkMAQtBByEJC0HQoMAAKAIAEAsLIAkL9wQCA38DfkHAoCBCgICAgICAgAQ3AgBBvKAgQdCgIDYCAEG0oCBCADcCAEGwoCBBsCA2AgADQCAAQQJ0QbAIakEAQQBBAEEAIABBAXYiAUEBcWtBoIbi7X5xQQAgAEEBcWtBoIbi7X5xIAFzQQF2IgFzQQF2IgJBAXFrQaCG4u1+cUEAIAFBAXFrQaCG4u1+cSACc0EBdiIBc0EBdiICQQFxa0GghuLtfnFBACABQQFxa0GghuLtfnEgAnNBAXYiAXNBAXYiAkEBcWtBoIbi7X5xQQAgAUEBcWtBoIbi7X5xIAJzQQF2czYCACAAQQFqIgBBgAJHDQALA0AgBadBA3RBsBBqQgBCAEIAQgAgBUIBiCIDQgGDfULCnpy83fKVtkmDQgAgBUIBg31Cwp6cvN3ylbZJgyADhUIBiCIDhUIBiCIEQgGDfULCnpy83fKVtkmDQgAgA0IBg31Cwp6cvN3ylbZJgyAEhUIBiCIDhUIBiCIEQgGDfULCnpy83fKVtkmDQgAgA0IBg31Cwp6cvN3ylbZJgyAEhUIBiCIDhUIBiCIEQgGDfULCnpy83fKVtkmDQgAgA0IBg31Cwp6cvN3ylbZJgyAEhUIBiIU3AwAgBUIBfCIFQoACUg0AC0HQoMAAAn9BuAkQBiIABEAgAEECNgIkIABBqN4BEAYiAQR/IAFBgICABDYCNCABQQI2AjwgAUEANgIYIAFBADYCOCABBUEACyIBNgKwCSABBEAgAEEAOgAoIABCADcDACAAQgA3AxggAEHIAGpB5AAQByAAQQw2AqwBIAAMAgsgABAFC0EACyIANgIAIAAEf0EABUEAEAtBAQsLEAAjACAAa0FwcSIAJAAgAAsGACAAJAALBAAjAAsRAEG0oCAoAgBBuKAgKAIARgsJAEHAoCAoAgALFwBBxKAgIABBgIAgIABBgIAgSRs2AgALCwBBwKAgIAA2AgALFwBBuKAgIABBgIAgIABBgIAgSRs2AgALCwBBtKAgIAA2AgALCyoDAEGACAsF/Td6WFoAQZEICw8EBAQICAgQEBAgICBAQEAAQaAICwNQEmA=")||(E=ae,ae=e.locateFile?e.locateFile(E,f):f+E);var X=[];function P(G){var K=X[G];return K||(G>=X.length&&(X.length=G+1),X[G]=K=W.get(G)),K}function v(G){try{return _.grow(G-T.byteLength+65535>>>16),N(_.buffer),1}catch{}}var y=typeof atob=="function"?atob:function(G){var K,ie,$,se,de,he,ee="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",ge="",ve=0;G=G.replace(/[^A-Za-z0-9\+\/\=]/g,"");do K=ee.indexOf(G.charAt(ve++))<<2|(se=ee.indexOf(G.charAt(ve++)))>>4,ie=(15&se)<<4|(de=ee.indexOf(G.charAt(ve++)))>>2,$=(3&de)<<6|(he=ee.indexOf(G.charAt(ve++))),ge+=String.fromCharCode(K),de!==64&&(ge+=String.fromCharCode(ie)),he!==64&&(ge+=String.fromCharCode($));while(ve<G.length);return ge};function R(G){if(U(G))return function(K){if(typeof m=="boolean"&&m){var ie=Buffer.from(K,"base64");return new Uint8Array(ie.buffer,ie.byteOffset,ie.byteLength)}try{for(var $=y(K),se=new Uint8Array($.length),de=0;de<$.length;++de)se[de]=$.charCodeAt(de);return se}catch{throw new Error("Converting base64 string to bytes failed.")}}(G.slice(F.length))}var w={b:function(G,K,ie){z.copyWithin(G,K,K+ie)},a:function(G){var K,ie,$=z.length,se=2147483648;if((G>>>=0)>se)return!1;for(var de=1;de<=4;de*=2){var he=$*(1+.2/de);if(he=Math.min(he,G+100663296),v(Math.min(se,((K=Math.max(G,he))%(ie=65536)>0&&(K+=ie-K%ie),K))))return!0}return!1}};(function(){var G={a:w};function K(se,de){var he,ee=se.exports;e.asm=ee,N((_=e.asm.c).buffer),W=e.asm.o,he=e.asm.d,oe.unshift(he),function(ge){if(ne--,e.monitorRunDependencies&&e.monitorRunDependencies(ne),ne==0&&le){var ve=le;le=null,ve()}}()}function ie(se){K(se.instance)}function $(se){return function(){if(!g&&(h||p)){if(typeof fetch=="function"&&!B(ae))return fetch(ae,{credentials:"same-origin"}).then(function(de){if(!de.ok)throw"failed to load wasm binary file at '"+ae+"'";return de.arrayBuffer()}).catch(function(){return Z(ae)});if(r)return new Promise(function(de,he){r(ae,function(ee){de(new Uint8Array(ee))},he)})}return Promise.resolve().then(function(){return Z(ae)})}().then(function(de){return WebAssembly.instantiate(de,G)}).then(function(de){return de}).then(se,function(de){A("failed to asynchronously prepare wasm: "+de),re(de)})}if(ne++,e.monitorRunDependencies&&e.monitorRunDependencies(ne),e.instantiateWasm)try{return e.instantiateWasm(G,K)}catch(se){return A("Module.instantiateWasm callback failed with error: "+se),!1}(g||typeof WebAssembly.instantiateStreaming!="function"||U(ae)||B(ae)||typeof fetch!="function"?$(ie):fetch(ae,{credentials:"same-origin"}).then(function(se){return WebAssembly.instantiateStreaming(se,G).then(ie,function(de){return A("wasm streaming compile failed: "+de),A("falling back to ArrayBuffer instantiation"),$(ie)})})).catch(n)})(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.d).apply(null,arguments)},e._init_decompressor=function(){return(e._init_decompressor=e.asm.e).apply(null,arguments)},e._decompress=function(){return(e._decompress=e.asm.f).apply(null,arguments)},e._get_in_buffer_ptr=function(){return(e._get_in_buffer_ptr=e.asm.g).apply(null,arguments)},e._get_out_buffer_ptr=function(){return(e._get_out_buffer_ptr=e.asm.h).apply(null,arguments)},e._in_buffer_set_pos=function(){return(e._in_buffer_set_pos=e.asm.i).apply(null,arguments)},e._in_buffer_set_size=function(){return(e._in_buffer_set_size=e.asm.j).apply(null,arguments)},e._out_buffer_set_pos=function(){return(e._out_buffer_set_pos=e.asm.k).apply(null,arguments)},e._out_buffer_set_size=function(){return(e._out_buffer_set_size=e.asm.l).apply(null,arguments)},e._get_curr_output_length=function(){return(e._get_curr_output_length=e.asm.m).apply(null,arguments)},e._is_input_end_reached=function(){return(e._is_input_end_reached=e.asm.n).apply(null,arguments)};var I,C=e.stackSave=function(){return(C=e.stackSave=e.asm.p).apply(null,arguments)},D=e.stackRestore=function(){return(D=e.stackRestore=e.asm.q).apply(null,arguments)},O=e.stackAlloc=function(){return(O=e.stackAlloc=e.asm.r).apply(null,arguments)};function Y(G){this.name="ExitStatus",this.message="Program terminated with exit("+G+")",this.status=G}function J(G){function K(){I||(I=!0,e.calledRun=!0,x||(k(oe),t(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),function(){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;)ie=e.postRun.shift(),H.unshift(ie);var ie;k(H)}()))}ne>0||(function(){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)ie=e.preRun.shift(),j.unshift(ie);var ie;k(j)}(),ne>0||(e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),K()},1)):K()))}if(e.cwrap=function(G,K,ie,$){var se=(ie=ie||[]).every(function(de){return de==="number"});return K!=="string"&&se&&!$?S(G):function(){return M(G,K,ie,arguments)}},le=function G(){I||J(),I||(le=G)},e.run=J,e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();return J(),e.ready}})();const Hm=["","Memory allocation failed","Memory usage limit reached","Unsupported check; not verifying file integrity","Not an .xz file","Unsupported options in the .xz headers","File is corrupt","Unknown decompression bug"];class Is{constructor(e){this.manager=e!==void 0?e:up,this.crossOrigin="Anonymous",this.xz=null}init(){return this.xz?Promise.resolve():G1().then(e=>{this._emInitDecompressor=e.cwrap("init_decompressor","number"),this._emDecompress=e.cwrap("decompress","number"),this._emGetInBufferPtr=e.cwrap("get_in_buffer_ptr","number"),this._emGetOutBufferPtr=e.cwrap("get_out_buffer_ptr","number"),this._emInBufferSetPos=e.cwrap("in_buffer_set_pos",null,["number"]),this._emInBufferSetSize=e.cwrap("in_buffer_set_size",null,["number"]),this._emOutBufferSetPos=e.cwrap("out_buffer_set_pos",null,["number"]),this._emOutBufferSetSize=e.cwrap("out_buffer_set_size",null,["number"]),this._emGetCurrOutputLength=e.cwrap("get_curr_output_length","number"),this._emIsInputEndReached=e.cwrap("is_input_end_reached","number"),this.xz=e})}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e);const o=this,r=pi.get(e);if(r!==void 0)return o.manager.itemStart(e),setTimeout(function(){t&&t(r),o.manager.itemEnd(e)},0),r;const s=this.init(),l=new XMLHttpRequest;return l.open("GET",e,!0),l.addEventListener("load",function(c){const d=c.target.response;this.status===200||this.status===0?(this.status===0&&console.warn("v3d.XZLoader: HTTP Status 0 received."),s.then(()=>{o.decompressArrayBuffer(d,function(u){setTimeout(function(){t&&t(u),o.manager.itemEnd(e),pi.add(e,u)},1)},function(u){n&&n((2+1*u)/3)},function(u){i&&i(u),o.manager.itemEnd(e),o.manager.itemError(e)})})):(i&&i(c),o.manager.itemEnd(e),o.manager.itemError(e))},!1),n&&l.addEventListener("progress",function(c){let d;d=c.lengthComputable?c.loaded/c.total:1,n(2*d/3)},!1),l.addEventListener("error",function(c){i&&i(c),o.manager.itemEnd(e),o.manager.itemError(e)},!1),l.responseType="arraybuffer",l.send(null),o.manager.itemStart(e),l}setCrossOrigin(e){return this.crossOrigin=e,this}setPath(e){return this.path=e,this}decompressArrayBuffer(e,t,n,i){const o=this;function r(f){const g=o._emGetInBufferPtr();o.xz.HEAPU8.set(f,g),o._emInBufferSetPos(0),o._emInBufferSetSize(f.length),s()}function s(){o._emOutBufferSetPos(0)}const l=o._emInitDecompressor();if(l!=0)return console.error("XZLoader._emInitDecompressor: error code "+l+" ("+Hm[l]+")"),void(i&&i(l));const c=new Uint8Array(e),d=c.length,u=[];let h=0,p=Math.min(524288,d),m=0;r(c.subarray(h,p)),function f(){const g=o._emDecompress();if(g)console.error("XZLoader._emDecompress: error code "+g+" ("+Hm[g]+")"),i&&i(g);else{const _=o._emGetCurrOutputLength();if(u.push(function(A){const x=o._emGetOutBufferPtr();return new Uint8Array(o.xz.HEAPU8.subarray(x,x+A))}(_)),s(),o._emIsInputEndReached()&&(h=p,p=Math.min(p+524288,d),r(c.subarray(h,p))),n&&n(h/d),h==p){const A=u.reduce(function(M,T,L,z){return M+T.length},0),x=new Uint8Array(A);let S=0;u.forEach(function(M){x.set(M,S),S+=M.length}),t&&t(x.buffer)}else m++,m%2==0?setTimeout(f,1):f()}}()}}class k1 extends pn{constructor(e){super(e),this.reversed=!1}load(e,t,n,i){const o=this,r=new cn(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.load(e,function(s){t(o.parse(s))},n,i)}parse(e){function t(n){var i,o=[];n.forEach(function(s){s.type.toLowerCase()==="m"?(i=[s],o.push(i)):s.type.toLowerCase()!=="z"&&i.push(s)});var r=[];return o.forEach(function(s){var l={type:"m",x:s[s.length-1].x,y:s[s.length-1].y};r.push(l);for(var c=s.length-1;c>0;c--){var d=s[c];l={type:d.type},d.x2!==void 0&&d.y2!==void 0?(l.x1=d.x2,l.y1=d.y2,l.x2=d.x1,l.y2=d.y1):d.x1!==void 0&&d.y1!==void 0&&(l.x1=d.x1,l.y1=d.y1),l.x=s[c-1].x,l.y=s[c-1].y,r.push(l)}}),r}return typeof opentype>"u"?(console.warn("v3d.TTFLoader: The loader requires opentype.js. Make sure it's included before using the loader."),null):function(n,i){for(var o=Math.round,r={},s=1e3/(n.unitsPerEm||2048),l=n.encoding.cmap.glyphIndexMap,c=Object.keys(l),d=0;d<c.length;d++){var u=c[d],h=n.glyphs.glyphs[l[u]];if(u!==void 0){var p={ha:o(h.advanceWidth*s),x_min:o(h.xMin*s),x_max:o(h.xMax*s),o:""};i&&(h.path.commands=t(h.path.commands)),h.path.commands.forEach(function(m){m.type.toLowerCase()==="c"&&(m.type="b"),p.o+=m.type.toLowerCase()+" ",m.x!==void 0&&m.y!==void 0&&(p.o+=o(m.x*s)+" "+o(m.y*s)+" "),m.x1!==void 0&&m.y1!==void 0&&(p.o+=o(m.x1*s)+" "+o(m.y1*s)+" "),m.x2!==void 0&&m.y2!==void 0&&(p.o+=o(m.x2*s)+" "+o(m.y2*s)+" ")}),r[String.fromCodePoint(h.unicode)]=p}}return{glyphs:r,familyName:n.getEnglishName("fullName"),ascender:o(n.tables.os2.sTypoAscender*s),descender:o(n.tables.os2.sTypoDescender*s),lineGap:n.tables.os2.sTypoLineGap*s,underlinePosition:n.tables.post.underlinePosition,underlineThickness:n.tables.post.underlineThickness,boundingBox:{xMin:n.tables.head.xMin*s,xMax:n.tables.head.xMax*s,yMin:n.tables.head.yMin*s,yMax:n.tables.head.yMax*s},resolution:1e3,original_font_information:n.tables.name}}(opentype.parse(e),this.reversed)}}class vh extends C1{constructor(e){super(e),this.type=_t,Lt.isSafariWithUint16Bug()&&(console.warn("Safari 11/12 detected. Applying workaround for half-float texture bug"),this.type=Ct)}parse(e){const t=function(l,c){switch(l){case 1:console.error("v3d.RGBELoader Read Error: "+(c||""));break;case 2:console.error("v3d.RGBELoader Write Error: "+(c||""));break;case 3:console.error("v3d.RGBELoader Bad File Format: "+(c||""));break;default:console.error("v3d.RGBELoader: Error: "+(c||""))}return-1},n=function(l,c,d){c=c||1024;let u=l.pos,h=-1,p=0,m="",f=String.fromCharCode.apply(null,new Uint16Array(l.subarray(u,u+128)));for(;0>(h=f.indexOf(`
`))&&p<c&&u<l.byteLength;)m+=f,p+=f.length,u+=128,f+=String.fromCharCode.apply(null,new Uint16Array(l.subarray(u,u+128)));return-1<h&&(d!==!1&&(l.pos+=p+h+1),m+f.slice(0,h))},i=function(l,c,d,u){const h=l[c+3],p=Math.pow(2,h-128)/255;d[u+0]=l[c+0]*p,d[u+1]=l[c+1]*p,d[u+2]=l[c+2]*p,d[u+3]=1},o=function(l,c,d,u){const h=l[c+3],p=Math.pow(2,h-128)/255;d[u+0]=or(Math.min(l[c+0]*p,65504)),d[u+1]=or(Math.min(l[c+1]*p,65504)),d[u+2]=or(Math.min(l[c+2]*p,65504)),d[u+3]=or(1)},r=new Uint8Array(e);r.pos=0;const s=function(l){const c=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,d=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,u=/^\s*FORMAT=(\S+)\s*$/,h=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,p={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let m,f;if(l.pos>=l.byteLength||!(m=n(l)))return t(1,"no header found");if(!(f=m.match(/^#\?(\S+)/)))return t(3,"bad initial token");for(p.valid|=1,p.programtype=f[1],p.string+=m+`
`;m=n(l),m!==!1;)if(p.string+=m+`
`,m.charAt(0)!=="#"){if((f=m.match(c))&&(p.gamma=parseFloat(f[1])),(f=m.match(d))&&(p.exposure=parseFloat(f[1])),(f=m.match(u))&&(p.valid|=2,p.format=f[1]),(f=m.match(h))&&(p.valid|=4,p.height=parseInt(f[1],10),p.width=parseInt(f[2],10)),2&p.valid&&4&p.valid)break}else p.comments+=m+`
`;return 2&p.valid?4&p.valid?p:t(3,"missing image size specifier"):t(3,"missing format specifier")}(r);if(s!==-1){const l=s.width,c=s.height,d=function(u,h,p){const m=h;if(m<8||m>32767||u[0]!==2||u[1]!==2||128&u[2])return new Uint8Array(u);if(m!==(u[2]<<8|u[3]))return t(3,"wrong scanline width");const f=new Uint8Array(4*h*p);if(!f.length)return t(4,"unable to allocate buffer space");let g=0,_=0;const A=4*m,x=new Uint8Array(4),S=new Uint8Array(A);let M=p;for(;M>0&&_<u.byteLength;){if(_+4>u.byteLength)return t(1);if(x[0]=u[_++],x[1]=u[_++],x[2]=u[_++],x[3]=u[_++],x[0]!=2||x[1]!=2||(x[2]<<8|x[3])!=m)return t(3,"bad rgbe scanline format");let T,L=0;for(;L<A&&_<u.byteLength;){T=u[_++];const W=T>128;if(W&&(T-=128),T===0||L+T>A)return t(3,"bad scanline data");if(W){const V=u[_++];for(let N=0;N<T;N++)S[L++]=V}else S.set(u.subarray(_,_+T),L),L+=T,_+=T}const z=m;for(let W=0;W<z;W++){let V=0;f[g]=S[W+V],V+=m,f[g+1]=S[W+V],V+=m,f[g+2]=S[W+V],V+=m,f[g+3]=S[W+V],g+=4}M--}return f}(r.subarray(r.pos),l,c);if(d!==-1){let u,h,p;switch(this.type){case Ct:p=d.length/4;const m=new Float32Array(4*p);for(let g=0;g<p;g++)i(d,4*g,m,4*g);u=m,h=Ct;break;case _t:p=d.length/4;const f=new Uint16Array(4*p);for(let g=0;g<p;g++)o(d,4*g,f,4*g);u=f,h=_t;break;default:console.error("v3d.RGBELoader: unsupported type: ",this.type)}return{width:l,height:c,data:u,header:s.string,gamma:s.gamma,exposure:s.exposure,type:h}}}return null}setDataType(e){return this.type=e,this}load(e,t,n,i){return super.load(e,function(o,r){switch(o.type){case Ct:case _t:o.encoding=_n,o.minFilter=Le,o.magFilter=Le,o.generateMipmaps=!1,o.flipY=!0}t&&t(o,r)},n,i)}}const Wl=new At,Y4=new Ae,j4=new b,K4=new b,Qa=new Re;class Q1 extends ze{constructor(){super(),this.type="PlaneReflectionProbe",this.influenceDistance=1,this.falloff=.5,this.probeClipStart=.1,this.planeSize=new te(1,1),this.qualityFactor=.75,this.visibilityGroup=null,this.visibilityGroupInv=!1,this.reflectorPlane=new Gn,this.normal=new b,this.reflectorWorldPosition=new b,this.cameraWorldPosition=new b,this.rotationMatrix=new Ae,this.lookAtPosition=new b(0,0,-1),this.clipPlane=new Re,this.view=new b,this.target=new b,this.textureMatrix=new Ae,this.virtualCamera=new Qt;const e={minFilter:Le,magFilter:Le,format:Qe,encoding:Ke};this.renderTarget=new et(1024,1024,e),this.matrixWorldInverse=new Ae,this.boundingBox=new At}_calcLocalBounding(){const e=j4.setScalar(0),t=K4.set(2*this.planeSize.x,2*this.influenceDistance/this.scale.y,2*this.planeSize.y);this.boundingBox.setFromCenterAndSize(e,t)}makeMultisampleRenderTarget(e){this.renderTarget.samples=e}setSize(e,t){this.renderTarget.setSize(this.qualityFactor*e,this.qualityFactor*t)}setEncoding(e){this.renderTarget.texture.encoding=e}intersectsMesh(e){let t=!1;const n=e.geometry,i=n.boundsTree,o=Y4;try{o.copy(e.matrixWorld).invert()}catch{return!1}return o.multiply(this.matrixWorld),Wl.copy(this.boundingBox),i?t=i.intersectsBox(e,Wl,o):(Wl.applyMatrix4(o),n.boundingBox===null&&n.computeBoundingBox(),t=n.boundingBox.intersectsBox(Wl)),t}update(e,t,n){const i={};e.traverse(T=>{!T.isPlaneReflectionProbe&&this._isVisible(T)||(i[T.id]=T.layers.mask,T.layers.disableAll())});const o=this.reflectorWorldPosition;o.setFromMatrixPosition(this.matrixWorld);const r=this.cameraWorldPosition;r.setFromMatrixPosition(t.matrixWorld);const s=this.rotationMatrix;s.extractRotation(this.matrixWorld);const l=this.normal;l.set(0,1,0),l.applyMatrix4(s);const c=this.view;if(c.subVectors(o,r),c.dot(l)>0)return void e.traverse(T=>{!T.isPlaneReflectionProbe&&this._isVisible(T)||(T.layers.mask=i[T.id])});c.reflect(l).negate(),c.add(o),s.extractRotation(t.matrixWorld);const d=this.lookAtPosition;d.set(0,0,-1),d.applyMatrix4(s),d.add(r);const u=this.target;u.subVectors(o,d),u.reflect(l).negate(),u.add(o);const h=this.virtualCamera;h.position.copy(c),h.up.set(0,1,0),h.up.applyMatrix4(s),h.up.reflect(l),h.lookAt(u),h.far=t.far,h.updateMatrixWorld();const p=h.projectionMatrix;p.copy(t.projectionMatrix);const m=this.textureMatrix;m.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),m.multiply(p),m.multiply(h.matrixWorldInverse);const f=this.reflectorPlane;f.setFromNormalAndCoplanarPoint(l,o),f.applyMatrix4(h.matrixWorldInverse);const g=this.clipPlane;g.set(f.normal.x,f.normal.y,f.normal.z,f.constant),Qa.x=(Math.sign(g.x)+p.elements[8])/p.elements[0],Qa.y=(Math.sign(g.y)+p.elements[9])/p.elements[5],Qa.z=-1,Qa.w=(1+p.elements[10])/p.elements[14],g.multiplyScalar(2/g.dot(Qa)),p.elements[2]=g.x,p.elements[6]=g.y,p.elements[10]=g.z+1-this.probeClipStart,p.elements[14]=g.w;const _=n.getRenderTarget(),A=n.xr.enabled,x=n.shadowMap.autoUpdate,S=n.useOIT;n.xr.enabled=!1,n.shadowMap.autoUpdate=!1,n.useOIT=!1,n.setRenderTarget(this.renderTarget),n.state.buffers.depth.setMask(!0),n.autoClear===!1&&n.clear(),n.render(e,h),n.xr.enabled=A,n.shadowMap.autoUpdate=x,n.useOIT=S,n.setRenderTarget(_);const M=t.viewport;M!==void 0&&n.state.viewport(M),e.traverse(T=>{!T.isPlaneReflectionProbe&&this._isVisible(T)||(T.layers.mask=i[T.id])}),this._calcLocalBounding()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}copy(e){return super.copy(e),this.influenceDistance=e.influenceDistance,this.probeClipStart=e.probeClipStart,this.visibilityGroup=e.visibilityGroup,this.visibilityGroupInv=e.visibilityGroupInv,this}dispose(){this.renderTarget!==null&&(this.renderTarget.dispose(),this.renderTarget=null),this.dispatchEvent({type:"dispose"})}_isVisible(e){return this.visibilityGroup===null||!e.isMesh?!0:e.groupNames.indexOf(this.visibilityGroup)!==-1^this.visibilityGroupInv}}Q1.prototype.isPlaneReflectionProbe=!0;class W1{static init(e,t){e!==void 0&&t!==void 0||console.error("RectAreaLightUniformsLib: Missing LTC data (required in Verge3D)");const n=new Float32Array(e),i=new Float32Array(t);xe.LTC_FLOAT_1=new Jn(n,64,64,Qe,Ct,300,mt,mt,Le,st,1),xe.LTC_FLOAT_2=new Jn(i,64,64,Qe,Ct,300,mt,mt,Le,st,1),xe.LTC_FLOAT_1.needsUpdate=!0,xe.LTC_FLOAT_2.needsUpdate=!0;const o=new Uint16Array(e.length);e.forEach(function(s,l){o[l]=or(s)});const r=new Uint16Array(t.length);t.forEach(function(s,l){r[l]=or(s)}),xe.LTC_HALF_1=new Jn(o,64,64,Qe,_t,300,mt,mt,Le,st,1),xe.LTC_HALF_2=new Jn(r,64,64,Qe,_t,300,mt,mt,Le,st,1),xe.LTC_HALF_1.needsUpdate=!0,xe.LTC_HALF_2.needsUpdate=!0}}class Ep{constructor(e){this.type="Font",this.data=e}generateShapes(e,t=100,n="left",i="topBaseline",o=-1,r=!1){const s=[],l=q4(e,t,this.data,n,i,o,r);for(let c=0,d=l.length;c<d;c++)Array.prototype.push.apply(s,l[c].toShapes());return s}}function q4(a,e,t,n,i,o,r){const s=String(a).split(`
`),l=[];for(let g=0;g<s.length;g++){let _=s[g];l[g]=Array.from?Array.from(_):String(_).split("")}let c=e/t.resolution;r&&(c*=(t.ascender-t.descender)/(t.boundingBox.yMax-t.boundingBox.yMin)),t.lineGap=t.lineGap||0,o===-1?o=(t.ascender-t.descender+t.lineGap)*c:o*=e;const d=[];let u=0,h=0;const p=l.length,m=o*p,f=o-o*Math.abs(t.descender)/t.ascender;switch(i){case"topBaseline":default:h=0;break;case"top":h=-f;break;case"center":h=p>1?.5*m-f:-t.ascender/2*c;break;case"bottom":h=m-o-t.descender*c;break;case"bottomBaseline":h=m-o}for(let g=0;g<l.length;g++){const _=l[g];switch(n){case"left":default:u=0;break;case"center":u=-Xm(_,c,t)/2;break;case"right":u=-Xm(_,c,t)}for(let A=0;A<_.length;A++){const x=Z4(_[A],c,u,h,t);u+=x.offsetX,d.push(x.path)}h-=o}return d}function Z4(a,e,t,n,i){const o=i.glyphs[a]||i.glyphs["?"];if(!o)return void console.error('v3d.Font: character "'+a+'" does not exists in font family '+i.familyName+".");const r=new N1;let s,l,c,d,u,h,p,m;if(o.o){const f=o._cachedOutline||(o._cachedOutline=o.o.split(" "));for(let g=0,_=f.length;g<_;)switch(f[g++]){case"m":s=f[g++]*e+t,l=f[g++]*e+n,r.moveTo(s,l);break;case"l":s=f[g++]*e+t,l=f[g++]*e+n,r.lineTo(s,l);break;case"q":c=f[g++]*e+t,d=f[g++]*e+n,u=f[g++]*e+t,h=f[g++]*e+n,r.quadraticCurveTo(u,h,c,d);break;case"b":c=f[g++]*e+t,d=f[g++]*e+n,u=f[g++]*e+t,h=f[g++]*e+n,p=f[g++]*e+t,m=f[g++]*e+n,r.bezierCurveTo(u,h,p,m,c,d)}}return{offsetX:o.ha*e,path:r}}function Xm(a,e,t){let n=0;for(var i=0;i<a.length;i++){const o=a[i];n+=(t.glyphs[o]||t.glyphs["?"]).ha*e}return n}Ep.prototype.isFont=!0;const Ym=new b,jm=new b;class H1 extends ze{constructor(){super(),this.type="ClippingPlaneObject",this.plane=new Gn,this.clippingGroup=null,this.clipShadows=!1,this.negated=!1,this.clipIntersection=!1,this.crossSection=!1,this.crossSectionColor=new me(16711680),this.crossSectionOpacity=1,this.crossSectionRenderSide=kn,this.crossSectionSize=100,this._crossMatProfile="blender"}updatePlane(){this.updateWorldMatrix(!0,!1),this.getWorldPosition(Ym);const e=this.matrixWorld.elements;jm.set(e[4],e[5],e[6]).normalize(),this.plane.setFromNormalAndCoplanarPoint(jm,Ym),this.negated&&this.plane.negate()}updateMatrixWorld(e){ze.prototype.updateMatrixWorld.call(this,e),this.updatePlane()}needsClippingPlane(e){return e.isMesh&&(e.groupNames.indexOf(this.clippingGroup)>=0||this.clippingGroup===null)&&!e.isAuxClippingMesh}assignToObject(e,t=0){const n=this.plane,i=e.material,o=e.geometry;if(i.clippingPlanes=i.clippingPlanes||[],i.clippingPlanes.indexOf(n)==-1&&i.clippingPlanes.push(n),i.clipShadows=this.clipShadows,i.clipIntersection=this.clipIntersection,this.crossSection){this.cleanupAuxMeshes(e);const r=new Xt;r.depthWrite=!1,r.depthTest=!1,r.colorWrite=!1,r.stencilWrite=!0,r.stencilFunc=519,r.clipShadows=this.clipShadows,r.clipIntersection=this.clipIntersection;const s=!!e.isSkinnedMesh,l=e.morphTargetInfluences,c=q(l)&&l.length>0,d=r.clone();let u;d.name="ClipCrossSectionStencilBack",d.side=nn,d.clippingPlanes=[n],d.stencilFail=34055,d.stencilZFail=34055,d.stencilZPass=34055,s?(u=new xs(o,d),u.skeleton=e.skeleton):u=new Ue(o,d),u.renderOrder=t,u.name="ClipCrossSectionStencilBack",u.isAuxClippingMesh=!0,c&&(u.morphTargetInfluences=l.slice(),u.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),e.add(u);const h=r.clone();let p;h.name="ClipCrossSectionStencilFront",h.side=kn,h.clippingPlanes=[n],h.stencilFail=34056,h.stencilZFail=34056,h.stencilZPass=34056,s?(p=new xs(o,h),p.skeleton=e.skeleton):p=new Ue(o,h),p.renderOrder=t+.1,p.name="ClipCrossSectionStencilFront",p.isAuxClippingMesh=!0,c&&(p.morphTargetInfluences=l.slice(),p.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),e.add(p),i.isMeshNodeMaterial&&(this._crossMatProfile=i.profile)}}createCrossSectionPlane(e,t){this.cleanupAuxMeshes();const n=new wt({name:"ClipCrossSectionColor",nodeGraph:wt.nodeGraphDiffuse(this.crossSectionColor,this.crossSectionOpacity,this._crossMatProfile),profile:this._crossMatProfile,clippingPlanes:e.filter(r=>r!==this.plane),clipShadows:this.clipShadows,clipIntersection:this.clipIntersection,stencilWrite:!0,stencilRef:0,stencilFunc:517,stencilFail:7681,stencilZFail:7681,stencilZPass:7681,side:this.crossSectionRenderSide});this.crossSectionOpacity<1&&(n.transparent=!0,n.premultipliedAlpha=!0,n.blending=no,n.blendEquation=tn,n.blendSrc=ei,n.blendDst=Ri);const i=new ni(this.crossSectionSize,this.crossSectionSize);this.negated?i.rotateX(-Math.PI/2):i.rotateX(Math.PI/2);const o=new Ue(i,n);o.name="ClipCrossSectionColor",o.isAuxClippingMesh=!0,o.renderOrder=t,o.onAfterRender=function(r){r.clearStencil()},this.add(o)}cleanupAuxMeshes(e=null){if(e)for(let t=e.children.length-1;t>=0;t--){const n=e.children[t];n.isAuxClippingMesh&&n.material.clippingPlanes[0]==this.plane&&(n.geometry.dispose(),n.material.dispose(),e.remove(n))}else for(let t=this.children.length-1;t>=0;t--){const n=this.children[t];n.isAuxClippingMesh&&(n.geometry.dispose(),n.material.dispose(),this.remove(n))}}copy(e){return super.copy(e),this.plane=e.plane,this.clippingGroup=e.clippingGroup,this.clipShadows=e.clipShadows,this.negated=e.negated,this.clipIntersection=e.clipIntersection,this.crossSection=e.crossSection,this.crossSectionColor.copy(e.crossSectionColor),this.crossSectionOpacity=e.crossSectionOpacity,this.crossSectionRenderSide=e.crossSectionRenderSide,this.crossSectionSize=e.crossSectionSize,this._crossMatProfile=e._crossMatProfile,this}}H1.prototype.isClippingPlaneObject=!0;const Je={minDistance:0,maxDistance:1/0,minZoom:0,maxZoom:1/0,minPolarAngle:0,maxPolarAngle:Math.PI,minAzimuthAngle:-1/0,maxAzimuthAngle:1/0,autoRotate:!1,autoRotateSpeed:2,enablePan:!0,panInertia:.05,panSpeed:1.3,panSpeedKey:15,screenSpacePanning:!0,enableRotate:!0,rotateInertia:.05,rotateInertiaTouch:.05,rotateSpeed:1.2,rotateSpeedTouch:.7,enableZoom:!0,zoomInertia:.05,zoomInertiaTouch:.05,zoomSpeed:5,zoomSpeedTouch:1,enableDamping:!0,enableTurnover:!1,enableKeys:!0},J4=new b(0,1,0),$4=new Ge().setFromAxisAngle(new b(0,0,1),Math.PI),Nt={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY_PAN:4},Km=1e-6,Un=new b,qm=new b,eI=new Ge,tI=new Ge,Zm={type:"change"},dd={type:"start"},hd={type:"end"};class Fc extends An{constructor(e,t){super(),t===void 0&&console.warn('v3d.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('v3d.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.targetObj=new ze,this.minDistance=Je.minDistance,this.maxDistance=Je.maxDistance,this.minZoom=Je.minZoom,this.maxZoom=Je.maxZoom,this.minPolarAngle=Je.minPolarAngle,this.maxPolarAngle=Je.maxPolarAngle,this.minAzimuthAngle=Je.minAzimuthAngle,this.maxAzimuthAngle=Je.maxAzimuthAngle,this.enableDamping=Je.enableDamping,this.enableZoom=Je.enableZoom,this.zoomSpeed=Je.zoomSpeed,this.zoomSpeedTouch=Je.zoomSpeedTouch,this.zoomInertia=Je.zoomInertia,this.zoomInertiaTouch=Je.zoomInertiaTouch,this.enableRotate=Je.enableRotate,this.rotateSpeed=Je.rotateSpeed,this.rotateSpeedTouch=Je.rotateSpeedTouch,this.rotateInertia=Je.rotateInertia,this.rotateInertiaTouch=Je.rotateInertiaTouch,this.enablePan=Je.enablePan,this.panSpeed=Je.panSpeed,this.screenSpacePanning=Je.screenSpacePanning,this.panSpeedKey=Je.panSpeedKey,this.panInertia=Je.panInertia,this.autoRotate=Je.autoRotate,this.autoRotateSpeed=Je.autoRotateSpeed,this.enableTurnover=Je.enableTurnover,this.enableKeys=Je.enableKeys,this.mouseButtons={ROTATE:rr.LEFT,ZOOM:rr.MIDDLE,PAN:rr.RIGHT},this.target0=this.targetObj.position.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,Object.defineProperty(this,"inTween",{get:()=>oe.active||H.active,set(I){oe.active=I}}),this.getPolarAngle=function(){return o.phi},this.getAzimuthalAngle=function(){return o.theta},this.getDistance=function(){return this.object.position.distanceTo(this.targetObj.position)},this.saveState=function(){n.targetObj.updateWorldMatrix(!0,!1),n.target0.setFromMatrixPosition(n.targetObj.matrixWorld),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.forceMouseUp=function(){X()},this.reset=function(){n.targetObj.updateWorldMatrix(!0,!1);const I=Un.copy(n.target0);n.targetObj.worldToLocal(I),n.targetObj.position.add(I),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(Zm),n.update(),i=Nt.NONE},this.update=function(){const I=new b,C=new b,D=new b,O=new Ge;let Y=!1,J=!1;return function(){const G=n.object.position;if(n.targetObj.updateWorldMatrix(!0,!1),oe.active)oe.update(function(K,ie,$){if(G.copy(ie),I.copy($),n.object.lookAt(I),K>=1){r.set(0,0,0),l.set(0,0,0),s=1,M.set(0,0);for(let se in d)d[se]=0;f.set(0,0),j.getDelta()}});else if(H.active)H.update(function(K,ie,$){if(I.copy(ie),n.object.lookAt(I),n.object.zoom=$,n.object.updateProjectionMatrix(),K>=1){r.set(0,0,0),l.set(0,0,0),s=1,M.set(0,0);for(let se in d)d[se]=0;f.set(0,0),j.getDelta()}});else{I.setFromMatrixPosition(n.targetObj.matrixWorld),C.copy(G).sub(I);const K=eI.setFromUnitVectors(n.object.up,J4),ie=tI.copy(K).invert();if(C.applyQuaternion(K),o.setFromVector3(C),n.autoRotate&&i===Nt.NONE&&le(2*Math.PI/60/60*n.autoRotateSpeed),o.theta+=r.theta,o.phi+=r.phi,n.enableTurnover){Y&&(o.phi-=2*r.phi),J!=Y&&i==Nt.NONE&&(J=Y),J&&(o.theta-=2*r.theta);const $=o.phi;($<=0||$>=Math.PI)&&(Y=!Y,o.theta+=Math.PI,o.phi=$>0?2*Math.PI-$:Math.abs($))}else isFinite(n.minAzimuthAngle)&&isFinite(n.maxAzimuthAngle)&&(o.theta=Vh(o.theta,n.minAzimuthAngle,n.maxAzimuthAngle)),o.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,o.phi));o.makeSafe(),n.object.isPerspectiveCamera?(o.radius*=s,o.radius=Math.max(n.minDistance,Math.min(n.maxDistance,o.radius))):n.object.isOrthographicCamera&&(n.object.zoom/=s,n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom)),n.object.updateProjectionMatrix()),I.add(l),C.setFromSpherical(o),C.applyQuaternion(ie),G.copy(I).add(C),n.object.lookAt(I),Y&&(n.enableTurnover?n.object.quaternion.multiply($4):Y=!1),r.set(0,0,0),l.set(0,0,0),function(){const $=j.getDelta();let se,de;m.copy(f),f.x=n.enableDamping?Ht(f.x,0,$,_,.1):0,f.y=n.enableDamping?Ht(f.y,0,$,_,.1):0,m.sub(f),function(){const he=n.domElement===document?n.domElement.body:n.domElement,ee=he.clientWidth,ge=he.clientHeight;if(!(!ee||!ge)){le(2*Math.PI*m.x/ee*g),ve=2*Math.PI*m.y/ge*g,r.phi-=ve;var ve}}(),S.copy(M),M.x=n.enableDamping?Ht(M.x,0,$,n.panInertia,.1):0,M.y=n.enableDamping?Ht(M.y,0,$,n.panInertia,.1):0,S.sub(M),S.multiplyScalar(n.panSpeed);for(let he in d)u.isKeyDown[he]?se=d[he]=1:(de=d[he],d[he]=Ht(d[he],0,$,n.panInertia,.1),se=de-d[he]),n.enabled&&n.enableKeys&&n.enablePan&&(se*=60*$*n.panSpeedKey,he==Ee.A||he==Ee.LEFT_ARROW?S.x+=se:he==Ee.D||he==Ee.RIGHT_ARROW?S.x-=se:he==Ee.W||he==Ee.UP_ARROW?S.y+=se:he!=Ee.S&&he!=Ee.DOWN_ARROW||(S.y-=se));(function(he,ee){const ge=n.domElement===document?n.domElement.body:n.domElement,ve=ge.clientWidth,_e=ge.clientHeight;if(!(!ve||!_e))if(n.object.isPerspectiveCamera){n.targetObj.updateWorldMatrix(!0,!1);const we=Un.setFromMatrixPosition(n.targetObj.matrixWorld),Be=n.object.position;let ke=qm.copy(Be).sub(we).length();ke*=Math.tan(n.object.fov/2*eo),ae(2*he*ke/_e,n.object.matrix),E(2*ee*ke/_e,n.object.matrix)}else n.object.isOrthographicCamera?(ae(he*(n.object.right-n.object.left)/n.object.zoom/ve,n.object.matrix),E(ee*(n.object.top-n.object.bottom)/n.object.zoom/_e,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)})(S.x,S.y),s=W,W=n.enableDamping?Ht(W,1,$,N,.001):1,s/=W}()}return n.targetObj.position.copy(I),!!(c||D.distanceToSquared(n.object.position)>Km||8*(1-O.dot(n.object.quaternion))>Km)&&(n.dispatchEvent(Zm),D.copy(n.object.position),O.copy(n.object.quaternion),c=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",w),n.domElement.removeEventListener("mousedown",Z),n.domElement.removeEventListener("wheel",P),n.domElement.removeEventListener("touchstart",v),n.domElement.removeEventListener("touchend",R),n.domElement.removeEventListener("touchmove",y),document.removeEventListener("mousemove",k),document.removeEventListener("mouseup",X),document.removeEventListener("mouseleave",X),u.dispose()},this.tween=function(){return function(C,D,O,Y,J){n.targetObj.updateWorldMatrix(!0,!1);const G=Un.setFromMatrixPosition(n.targetObj.matrixWorld);n.object.parent&&(C=qm.copy(C),n.object.parent.worldToLocal(C)),C.manhattanDistanceTo(n.object.position)<1e-5&&D.manhattanDistanceTo(G)<1e-5?Y!==void 0&&Y():oe.setup({posFrom:n.object.position,targetFrom:G,posTo:C,targetTo:D,finishCb:Y,movementType:J}).start(O)}}(),this.tweenZoomTo=function(I,C,D,O){if(!n.object.isOrthographicCamera)return void console.warn("v3d.OrbitControls: .tweenZoomTo() works only for orthographic camera");n.targetObj.updateWorldMatrix(!0,!1);const Y=Un.setFromMatrixPosition(n.targetObj.matrixWorld);H.setup({zoomFrom:n.object.zoom,targetFrom:Y,zoomTo:C,targetTo:I,finishCb:O}).start(D)};const n=this;let i=Nt.NONE;const o=new Bi,r=new Bi;let s=1;const l=new b;let c=!1;const d={};d[Ee.W]=d[Ee.S]=d[Ee.A]=d[Ee.D]=d[Ee.UP_ARROW]=d[Ee.DOWN_ARROW]=d[Ee.LEFT_ARROW]=d[Ee.RIGHT_ARROW]=0;const u=new Mp(window);u.onKeyDown=function(I){I.keyCode in d&&(d[I.keyCode]=1)};const h=new te,p=new te,m=new te,f=new te;let g=1,_=1;const A=new te,x=new te,S=new te,M=new te,T=new te,L=new te,z=new te;let W=1,V=1,N=1;const j=new Di,oe=new Js,H=new fu;function ne(I=1){return Math.pow(.95,V*I)}function le(I){r.theta-=I}function re(I,C){p.set(I,C),f.add(p).sub(h),h.copy(p)}function ae(I,C){Un.setFromMatrixColumn(C,0),Un.multiplyScalar(-I),l.add(Un)}function E(I,C){n.screenSpacePanning===!0?Un.setFromMatrixColumn(C,1):(Un.setFromMatrixColumn(C,0),Un.crossVectors(n.object.up,Un)),Un.multiplyScalar(I),l.add(Un)}function F(I){n.object.isPerspectiveCamera?W/=I:n.object.isOrthographicCamera?(W/=I,c=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function U(I){n.object.isPerspectiveCamera?W*=I:n.object.isOrthographicCamera?(W*=I,c=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function B(I){var C,D;C=I.clientX,D=I.clientY,x.set(C,D),M.add(x).sub(A),A.copy(x)}function Z(I){if(n.enabled!==!1){switch(I.preventDefault(),I.button){case n.mouseButtons.ROTATE:if(n.enableRotate===!1)return;(function(C){h.set(C.clientX,C.clientY)})(I),i=Nt.ROTATE;break;case n.mouseButtons.ZOOM:case n.mouseButtons.PAN:if(n.enablePan===!1)return;(function(C){A.set(C.clientX,C.clientY)})(I),i=Nt.PAN}i!==Nt.NONE&&(document.addEventListener("mousemove",k),document.addEventListener("mouseup",X),document.addEventListener("mouseleave",X),n.dispatchEvent(dd))}}function k(I){if(n.enabled!==!1)switch(I.preventDefault(),i){case Nt.ROTATE:if(n.enableRotate===!1)return;(function(C){re(C.clientX,C.clientY),g=n.rotateSpeed,_=n.rotateInertia})(I);break;case Nt.DOLLY:if(n.enableZoom===!1)return;(function(C){L.set(C.clientX,C.clientY),z.subVectors(L,T),z.y>0?F(ne()):z.y<0&&U(ne()),T.copy(L),n.update()})(I);break;case Nt.PAN:if(n.enablePan===!1)return;B(I)}}function X(I){n.enabled!==!1&&(document.removeEventListener("mousemove",k),document.removeEventListener("mouseup",X),document.removeEventListener("mouseleave",X),n.dispatchEvent(hd),i=Nt.NONE)}function P(I){n.enabled===!1||n.enableZoom===!1||i!==Nt.NONE&&i!==Nt.ROTATE||(I.preventDefault(),I.stopPropagation(),n.dispatchEvent(dd),function(C){V=n.zoomSpeed,N=n.zoomInertia,C.deltaY<0?U(ne(Math.abs(C.deltaY)/100)):C.deltaY>0&&F(ne(Math.abs(C.deltaY)/100)),n.update()}(I),n.dispatchEvent(hd))}function v(I){if(n.enabled!==!1){switch(I.touches.length){case 1:if(n.enableRotate===!1)return;(function(C){h.set(C.touches[0].pageX,C.touches[0].pageY)})(I),i=Nt.TOUCH_ROTATE;break;case 2:if(n.enableZoom===!1&&n.enablePan===!1)return;(function(C){if(n.enableZoom){V=n.zoomSpeedTouch,N=n.zoomInertiaTouch;let D=C.touches[0].pageX-C.touches[1].pageX,O=C.touches[0].pageY-C.touches[1].pageY,Y=Math.sqrt(D*D+O*O);T.set(0,Y)}if(n.enablePan){let D=.5*(C.touches[0].pageX+C.touches[1].pageX),O=.5*(C.touches[0].pageY+C.touches[1].pageY);A.set(D,O)}n.update()})(I),i=Nt.TOUCH_DOLLY_PAN;break;default:i=Nt.NONE}i!==Nt.NONE&&n.dispatchEvent(dd)}}function y(I){if(n.enabled!==!1)switch(I.preventDefault(),I.touches.length){case 1:if(n.enableRotate===!1||i!==Nt.TOUCH_ROTATE)return;(function(C){re(C.touches[0].pageX,C.touches[0].pageY),g=n.rotateSpeedTouch,_=n.rotateInertiaTouch})(I);break;case 2:if(n.enableZoom===!1&&n.enablePan===!1||i!==Nt.TOUCH_DOLLY_PAN)return;(function(C){let D=C.touches[0].pageX-C.touches[1].pageX,O=C.touches[0].pageY-C.touches[1].pageY,Y=Math.sqrt(D*D+O*O);L.set(0,Y),z.subVectors(L,T),T.copy(L);let J=.5*(C.touches[0].pageX+C.touches[1].pageX),G=.5*(C.touches[0].pageY+C.touches[1].pageY);x.set(J,G),S.subVectors(x,A),A.copy(x),n.enableZoom&&Math.abs(z.length())>Math.abs(S.length())&&(z.y>0?U(ne()):z.y<0&&F(ne())),n.enablePan&&Math.abs(z.length())<Math.abs(S.length())&&M.add(S),n.update()})(I);break;default:i=Nt.NONE}}function R(I){n.enabled!==!1&&(n.dispatchEvent(hd),i=Nt.NONE)}function w(I){n.enabled!==!1&&I.preventDefault()}n.domElement.addEventListener("contextmenu",w),n.domElement.addEventListener("mousedown",Z),n.domElement.addEventListener("wheel",P,{passive:!1}),n.domElement.addEventListener("touchstart",v,{passive:!0}),n.domElement.addEventListener("touchend",R),n.domElement.addEventListener("touchmove",y,{passive:!1}),this.update()}set target(e){console.warn("v3d.OrbitControls: .target has been deprecated, use .targetObj instead")}get target(){return console.warn("v3d.OrbitControls: .target has been deprecated, use .targetObj instead"),new b}}Fc.prototype.isOrbitControls=!0;const nI={ORBIT:Je,FIRST_PERSON:Ot,FLYING:bt};class X1{constructor(e="ORBIT",t=!0,n=1,i=1){this.type=e,this.enablePan=t,this.enableZoom=!0,this.enableKeys=!0,this.rotateSpeed=n,this.moveSpeed=i,this.orbitMinDistance=Je.minDistance,this.orbitMaxDistance=Je.maxDistance,this.orbitMinZoom=Je.minZoom,this.orbitMaxZoom=Je.maxZoom,this.orbitMinPolarAngle=Je.minPolarAngle,this.orbitMaxPolarAngle=Je.maxPolarAngle,this.orbitMinAzimuthAngle=Je.minAzimuthAngle,this.orbitMaxAzimuthAngle=Je.maxAzimuthAngle,this.orbitEnableTurnover=Je.enableTurnover,this.orbitTarget=null,this.enableCollisions=Ot.enableCollisions,this.collisionMaterial=null,this.gazeLevel=Ot.gazeLevel,this.storyHeight=Ot.storyHeight,this.enablePointerLock=!1}copy(e){return this.type=e.type,this.enablePan=e.enablePan,this.enableZoom=e.enableZoom,this.enableKeys=e.enableKeys,this.rotateSpeed=e.rotateSpeed,this.moveSpeed=e.moveSpeed,this.orbitMinDistance=e.orbitMinDistance,this.orbitMaxDistance=e.orbitMaxDistance,this.orbitMinZoom=e.orbitMinZoom,this.orbitMaxZoom=e.orbitMaxZoom,this.orbitMinPolarAngle=e.orbitMinPolarAngle,this.orbitMaxPolarAngle=e.orbitMaxPolarAngle,this.orbitMinAzimuthAngle=e.orbitMinAzimuthAngle,this.orbitMaxAzimuthAngle=e.orbitMaxAzimuthAngle,this.orbitEnableTurnover=e.orbitEnableTurnover,this.orbitTarget=e.orbitTarget,this.enableCollisions=e.enableCollisions,this.collisionMaterial=e.collisionMaterial,this.gazeLevel=e.gazeLevel,this.storyHeight=e.storyHeight,this.enablePointerLock=e.enablePointerLock,this}clone(){return new this.constructor().copy(this)}assignToControls(e,t){const n=nI[this.type];switch(this.type){case"ORBIT":e.targetObj=this.orbitTarget,e.minDistance=this.orbitMinDistance,e.maxDistance=this.orbitMaxDistance,e.minZoom=this.orbitMinZoom,e.maxZoom=this.orbitMaxZoom,e.minPolarAngle=this.orbitMinPolarAngle,e.maxPolarAngle=this.orbitMaxPolarAngle,e.minAzimuthAngle=this.orbitMinAzimuthAngle,e.maxAzimuthAngle=this.orbitMaxAzimuthAngle,e.enableTurnover=this.orbitEnableTurnover;break;case"FLYING":e.panSpeedTouch=n.panSpeedTouch*this.moveSpeed,e.zoomSpeedKey=n.zoomSpeedKey*this.moveSpeed;break;case"FIRST_PERSON":e.enableCollisions=this.enableCollisions,e.gazeLevel=this.gazeLevel,e.storyHeight=this.storyHeight,e.zoomSpeedKey=n.zoomSpeedKey*this.moveSpeed,e.enablePointerLock=this.enablePointerLock;const i=this;e.collisionMeshes=[],t.traverse(function(o){const r=o.material;r&&i.collisionMaterial&&r.name==i.collisionMaterial.name&&e.collisionMeshes.push(o)});break;default:return void console.error("ControlSettings: unsupported control type")}e.enablePan=this.enablePan,e.enableZoom=this.enableZoom,e.enableKeys=this.enableKeys,e.rotateSpeed=n.rotateSpeed*this.rotateSpeed,e.rotateSpeedTouch=n.rotateSpeedTouch*this.rotateSpeed,e.panSpeed=n.panSpeed*this.moveSpeed,e.panSpeedKey=n.panSpeedKey*this.moveSpeed,e.zoomSpeed=n.zoomSpeed*this.moveSpeed,e.zoomSpeedTouch=n.zoomSpeedTouch*this.moveSpeed}}class br{constuctor(){this.name="",this.type="Constraint",this.mute=!1}_updateObjMatrixWorld(e){e.matrixAutoUpdate&&e.matrix.compose(e.position,e.quaternion,e.scale),e.parent==null?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(e.parent.matrixWorld,e.matrix)}update(e){this.mute}copy(e){return this.name=e.name,this.mute=e.mute,this}clone(){return new this.constructor().copy(this)}}br.prototype.isConstraint=!0;class xn extends br{constructor(e){super(),this.type="TargetConstraint",this.target=e}copy(e){return super.copy(e),this.target=e.target,this}clone(){return new this.constructor(this.target).copy(this)}}xn.prototype.isTargetConstraint=!0;const Jm=new Ae,iI=new Ge().setFromAxisAngle(new b(1,0,0),-Math.PI/2);class wp extends xn{constructor(e){super(e),this.type="ChildOfConstraint",this.offsetMatrix=new Ae,this.fixCameraLightRotation=!1}copy(e){return super.copy(e),this.offsetMatrix.copy(e.offsetMatrix),this.fixCameraLightRotation=e.fixCameraLightRotation,this}update(e){super.update(e),this.mute||(Jm.multiplyMatrices(this.target.matrixWorld,this.offsetMatrix),Jm.decompose(e.position,e.quaternion,e.scale),this.fixCameraLightRotation&&(e.isCamera||e.isLight)&&e.quaternion.multiply(iI))}}wp.prototype.isChildOfConstraint=!0;const mn=new b,oI=new Ge,rI=new b;class Tp extends xn{constructor(e){super(e),this.type="CopyLocationConstraint",this.useX=!0,this.useY=!0,this.useZ=!0,this.invertX=!1,this.invertY=!1,this.invertZ=!1,this.useOffset=!1,this.influence=1,this._firstIteration=!0,this._objPosInit=new b,this._offset=new b}copy(e){return super.copy(e),this.useX=e.useX,this.useY=e.useY,this.useZ=e.useZ,this.invertX=e.invertX,this.invertY=e.invertY,this.invertZ=e.invertZ,this.useOffset=e.useOffset,this.influence=e.influence,this._firstIteration=!1,this}update(e){super.update(e),this.mute||(this.target.matrixWorld.decompose(mn,oI,rI),this._firstIteration&&(this._updateObjMatrixWorld(e),e.getWorldPositionNU(this._objPosInit),this._offset.subVectors(mn,this._objPosInit),this._firstIteration=!1),this.useX?(this.invertX&&(mn.x=-mn.x),this.useOffset&&(mn.x-=this._offset.x)):mn.x=this._objPosInit.x,this.useY?(this.invertY&&(mn.y=-mn.y),this.useOffset&&(mn.y-=this._offset.y)):mn.y=this._objPosInit.y,this.useZ?(this.invertZ&&(mn.z=-mn.z),this.useOffset&&(mn.z-=this._offset.z)):mn.z=this._objPosInit.z,e.position.lerpVectors(this._objPosInit,mn,this.influence),e.parent&&e.parent.worldToLocal(e.position))}}Tp.prototype.isCopyLocationConstraint=!0;const aI=new Ge().setFromAxisAngle(new b(1,0,0),-Math.PI/2),pd=new b,Qr=new Ge,fd=new b;class Ip extends xn{constructor(e){super(e),this.type="CopyRotationConstraint",this.useX=!0,this.useY=!0,this.useZ=!0,this.invertX=!1,this.invertY=!1,this.invertZ=!1,this.mixMode="REPLACE",this.influence=1,this.fixCameraLightRotation=!1,this._firstIteration=!0,this._objQuatInit=new Ge}copy(e){return super.copy(e),this.useX=e.useX,this.useY=e.useY,this.useZ=e.useZ,this.invertX=e.invertX,this.invertY=e.invertY,this.invertZ=e.invertZ,this.mixMode=e.mixMode,this.influence=e.influence,this.fixCameraLightRotation=e.fixCameraLightRotation,this._firstIteration=!1,this}update(e){super.update(e),this.mute||(this.target.matrixWorld.decompose(pd,Qr,fd),this._firstIteration&&(this._updateObjMatrixWorld(e),e.matrixWorld.decompose(pd,this._objQuatInit,fd),this._firstIteration=!1),e.quaternion.copy(this._objQuatInit),(this.useX||this.useY||this.useZ)&&(this.mixMode=="REPLACE"||this.mixMode=="ADD"||(this.mixMode=="BEFORE"?Qr.multiply(e.quaternion):this.mixMode=="AFTER"?Qr.premultiply(e.quaternion):this.mixMode),e.quaternion.slerp(Qr,this.influence)),e.parent&&(e.parent.matrixWorld.decompose(pd,Qr,fd),e.quaternion.premultiply(Qr.invert())),this.fixCameraLightRotation&&(e.isCamera||e.isLight)&&e.quaternion.multiply(aI))}}Ip.prototype.isCopyRotationConstraint=!0;const $m=new b,e0=new Ge,lt=new b;class Rp extends xn{constructor(e){super(e),this.type="CopyScaleConstraint",this.useX=!0,this.useY=!0,this.useZ=!0,this.power=1,this.useMakeUniform=!1,this.useOffset=!1,this.useAdd=!1,this.influence=1,this._objInitScale=new b,this._volumeScaleFactor=new b,this._firstIteration=!0}copy(e){return super.copy(e),this.useX=e.useX,this.useY=e.useY,this.useZ=e.useZ,this.power=e.power,this.useMakeUniform=e.useMakeUniform,this.useOffset=e.useOffset,this.useAdd=e.useAdd,this.influence=e.influence,this._firstIteration=!1,this}update(e){if(super.update(e),!this.mute){if(this.target.matrixWorld.decompose($m,e0,lt),this._firstIteration&&(this._updateObjMatrixWorld(e),e.matrixWorld.decompose($m,e0,this._objInitScale),this._volumeScaleFactor.set(Math.pow(lt.x-this._objInitScale.x,3),Math.pow(lt.y-this._objInitScale.y,3),Math.pow(lt.z-this._objInitScale.z,3)),this._firstIteration=!1),this.useMakeUniform){let t=1;this.useX&&(t*=lt.x),this.useY&&(t*=lt.y),this.useZ&&(t*=lt.z),t=Math.pow(Math.cbrt(t),this.power),lt.set(t,t,t),this.useOffset&&(this.useAdd?(lt.add(this._objInitScale),lt.addScalar(-1)):lt.multiply(this._objInitScale))}else lt.set(this.useX?Math.pow(lt.x,this.power):this._objInitScale.x,this.useY?Math.pow(lt.y,this.power):this._objInitScale.y,this.useZ?Math.pow(lt.z,this.power):this._objInitScale.z),this.useOffset&&(this.useAdd?lt.set(this.useX?lt.x+this._objInitScale.x-1:lt.x,this.useY?lt.y+this._objInitScale.y-1:lt.y,this.useZ?lt.z+this._objInitScale.z-1:lt.z):lt.set(this.useX?lt.x*this._objInitScale.x:lt.x,this.useY?lt.y*this._objInitScale.y:lt.y,this.useZ?lt.z*this._objInitScale.z:lt.z));e.scale.copy(this._objInitScale),e.scale.lerp(lt,this.influence)}}}Rp.prototype.isCopyScaleConstraint=!0;const sI=new Ge().setFromAxisAngle(new b(1,0,0),-Math.PI/2),Hl=new Ae,t0=new b,n0=new Ge,i0=new b;class Lp extends xn{constructor(e){super(e),this.type="CopyTransformsConstraint",this.mixMode="REPLACE",this.influence=1,this.fixCameraLightRotation=!1,this._firstIteration=!0,this._objMatrixWorldInit=new Ae}copy(e){return super.copy(e),this.mixMode=e.mixMode,this.influence=e.influence,this.fixCameraLightRotation=e.fixCameraLightRotation,this._firstIteration=!0,this}update(e){super.update(e),this.mute||(this._firstIteration&&(this._updateObjMatrixWorld(e),this._objMatrixWorldInit.copy(e.matrixWorld),this._firstIteration=!1),Hl.copy(this.target.matrixWorld),this.mixMode=="REPLACE"||(this.mixMode=="BEFORE"?Hl.multiply(this._objMatrixWorldInit):this.mixMode=="AFTER"&&Hl.premultiply(this._objMatrixWorldInit)),Hl.decompose(t0,n0,i0),this._objMatrixWorldInit.decompose(e.position,e.quaternion,e.scale),e.position.lerp(t0,this.influence),e.quaternion.slerp(n0,this.influence),e.scale.lerp(i0,this.influence),this.fixCameraLightRotation&&(e.isCamera||e.isLight)&&e.quaternion.multiply(sI))}}Lp.prototype.isCopyTransformsConstraint=!0;const lI=new Ge().setFromAxisAngle(new b(1,0,0),-Math.PI/2),md=new b,Zo=new Ge,gd=new b,o0=new b,xo=new b,yo=new b,Wr=new b,vd={X:0,Y:1,Z:2,"-X":3,"-Y":4,"-Z":5},_d={0:new b(1,0,0),1:new b(0,1,0),2:new b(0,0,1),3:new b(-1,0,0),4:new b(0,-1,0),5:new b(0,0,-1)};class Pp extends xn{constructor(e){super(e),this.type="DampedTrackConstraint",this.trackAxis="X",this.influence=1,this.fixCameraLightRotation=!1,this._firstIteration=!0}copy(e){return super.copy(e),this.trackAxis=e.trackAxis,this.influence=e.influence,this.fixCameraLightRotation=e.fixCameraLightRotation,this._firstIteration=!1,this}update(e){if(super.update(e),!this.mute&&(this.target.matrixWorld.decompose(md,Zo,gd),this._firstIteration&&(this._updateObjMatrixWorld(e),this._firstIteration=!1),e.matrixWorld.decompose(o0,Zo,gd),xo.subVectors(md,o0),xo.length()!=0)){let t;if(xo.normalize(),yo.copy(_d[vd[this.trackAxis]]),yo.applyQuaternion(Zo),yo.length()==0&&yo.copy(_d[vd[this.trackAxis]]),yo.normalize(),Wr.crossVectors(yo,xo),t=yo.angleTo(xo),Wr.length()<Number.EPSILON&&(Math.abs(t)<Math.PI-.01||(t=Math.PI,xo.copy(_d[(vd[this.trackAxis]+2)%6]),xo.applyQuaternion(Zo),Wr.crossVectors(yo,xo),Wr.length()==0)))return;Wr.normalize(),e.quaternion.premultiply(Zo.setFromAxisAngle(Wr,t)),e.parent&&(e.parent.matrixWorld.decompose(md,Zo,gd),e.quaternion.premultiply(Zo.invert())),this.fixCameraLightRotation&&(e.isCamera||e.isLight)&&e.quaternion.multiply(lI)}}}Pp.prototype.isDampedTrackConstraint=!0;const cI={X:new b(1,0,0),Y:new b(0,1,0),Z:new b(0,0,1),"-X":new b(-1,0,0),"-Y":new b(0,-1,0),"-Z":new b(0,0,-1)},kt=new b,$t=new b,en=new b,at=new b;class Bp extends xn{constructor(e){super(e),this.type="FloorConstraint",this.floorLocation="Y",this.offset=0,this.useRotation=!1}copy(e){return super.copy(e),this.floorLocation=e.floorLocation,this.offset=e.offset,this.useRotation=e.useRotation,this}update(e){if(super.update(e),this.mute)return;const t=e.position;at.copy(this.target.position);const n=this.target.scale,i=this.offset;if(this.useRotation){let o;switch(kt.copy(cI[this.floorLocation]),kt.applyQuaternion(this.target.quaternion),this.floorLocation){case"X":at.x+=i*n.x,en.subVectors(t,at),o=kt.dot(en),kt.multiplyScalar(o),$t.subVectors(en,kt).add(at),$t.x>t.x?t.copy($t):t.x=Math.max(t.x,at.x);break;case"Y":at.y+=i*n.y,en.subVectors(t,at),o=kt.dot(en),kt.multiplyScalar(o),$t.subVectors(en,kt).add(at),$t.y>t.y?t.copy($t):t.y=Math.max(t.y,at.y);break;case"Z":at.z+=i*n.z,en.subVectors(t,at),o=kt.dot(en),kt.multiplyScalar(o),$t.subVectors(en,kt).add(at),$t.z>t.z?t.copy($t):t.z=Math.max(t.z,at.z);break;case"-X":at.x+=i*n.x,en.subVectors(t,at),o=kt.dot(en),kt.multiplyScalar(o),$t.subVectors(en,kt).add(at),$t.x<t.x?t.copy($t):t.x=Math.min(t.x,at.x);break;case"-Y":at.y+=i*n.y,en.subVectors(t,at),o=kt.dot(en),kt.multiplyScalar(o),$t.subVectors(en,kt).add(at),$t.y<t.y?t.copy($t):t.y=Math.min(t.y,at.y);break;case"-Z":at.z+=i*n.z,en.subVectors(t,at),o=kt.dot(en),kt.multiplyScalar(o),$t.subVectors(en,kt).add(at),$t.z<t.z?t.copy($t):t.z=Math.min(t.z,at.z)}}else switch(this.floorLocation){case"X":t.x=Math.max(t.x,at.x+i);break;case"Y":t.y=Math.max(t.y,at.y+i);break;case"Z":t.z=Math.max(t.z,at.z+i);break;case"-X":t.x=Math.min(t.x,at.x+i);break;case"-Y":t.y=Math.min(t.y,at.y+i);break;case"-Z":t.z=Math.min(t.z,at.z+i)}}}Bp.prototype.isFloorConstraint=!0;const Ad=new b,uI=new Ge,dI=new b,r0=new b;class Dp extends xn{constructor(e){super(e),this.type="LimitDistanceConstraint",this.distance=0,this.limitMode="LIMITDIST_ONSURFACE",this.useTransformLimit=!1,this.influence=1,this._objPosInit=new b,this._distInit=0,this._sfac=1,this._clampSurf=0}copy(e){return super.copy(e),this.distance=e.distance,this.limitMode=e.limitMode,this.useTransformLimit=e.useTransformLimit,this.influence=e.influence,this}update(e){super.update(e),this.mute||(this._sfac=1,this._clampSurf=0,this.target.matrixWorld.decompose(Ad,uI,dI),this._updateObjMatrixWorld(e),e.getWorldPositionNU(this._objPosInit),r0.subVectors(this._objPosInit,Ad),this._distInit=r0.length(),this.limitMode=="LIMITDIST_INSIDE"?this._distInit>=this.distance&&(this._clampSurf=1,this._distInit!=0&&(this._sfac=this.distance/this._distInit)):this.limitMode=="LIMITDIST_OUTSIDE"?this._distInit<=this.distance&&(this._clampSurf=1,this._distInit!=0&&(this._sfac=this.distance/this._distInit)):this.limitMode=="LIMITDIST_ONSURFACE"&&this._distInit-this.distance!=0&&(this._clampSurf=1,this._distInit!=0&&(this._sfac=this.distance/this._distInit)),this._clampSurf&&(e.position.lerpVectors(this._objPosInit,Ad,(1-this._sfac)*this.influence),e.parent&&e.parent.worldToLocal(e.position)))}}Dp.prototype.isLimitDistanceConstraint=!0;const bo=new b,Xl=new b,Hr=new b,xd=new Ae;class Np extends xn{constructor(e=null){super(e),this.type="LimitLocationConstraint",this.space=2,this.min=new b().setScalar(-1/0),this.max=new b().setScalar(1/0)}copy(e){return super.copy(e),this.min.copy(e.min),this.max.copy(e.max),this.space=e.space,this}update(e){if(super.update(e),!this.mute)switch(this.space){case 0:this._updateObjMatrixWorld(e),bo.setFromMatrixPosition(e.matrixWorld),bo.clamp(this.min,this.max),Hr.copy(bo),e.parent!==null&&Hr.applyMatrix4(xd.copy(e.parent.matrixWorld).invert()),e.position.copy(Hr);break;case 1:this.target!==null&&(this._updateObjMatrixWorld(e),this._updateObjMatrixWorld(this.target),bo.setFromMatrixPosition(e.matrixWorld),Xl.copy(bo),Xl.applyMatrix4(xd.copy(this.target.matrixWorld).invert()),Xl.clamp(this.min,this.max),bo.copy(Xl),bo.applyMatrix4(this.target.matrixWorld),Hr.copy(bo),e.parent!==null&&Hr.applyMatrix4(xd.copy(e.parent.matrixWorld).invert()),e.position.copy(Hr));break;default:e.position.clamp(this.min,this.max)}}}Np.prototype.isLimitLocationConstraint=!0;const xi=new gr;class Op extends br{constructor(){super(),this.type="LimitRotationConstraint",this.axis="Y",this.min=0,this.max=2*Math.PI}copy(e){return super.copy(e),this.axis=e.axis,this.min=e.min,this.max=e.max,this}update(e){super.update(e),this.mute||(this.axis=="X"?(xi.setFromQuaternion(e.quaternion,"XYZ"),xi.x=this._clampAngle(xi.x,this.min,this.max)):this.axis=="Y"?(xi.setFromQuaternion(e.quaternion,"YZX"),xi.y=this._clampAngle(xi.y,this.min,this.max)):this.axis=="Z"&&(xi.setFromQuaternion(e.quaternion,"ZXY"),xi.z=this._clampAngle(xi.z,this.min,this.max)),e.quaternion.setFromEuler(xi))}_clampAngle(e,t,n){return Math.abs(n-t)<2*Math.PI&&(e=Vh(e,t,n)),e}}Op.prototype.isLimitRotationConstraint=!0;class Fp extends br{constructor(){super(),this.type="LimitScaleConstraint",this.min=new b().setScalar(-1/0),this.max=new b().setScalar(1/0)}copy(e){return super.copy(e),this.min.copy(e.min),this.max.copy(e.max),this}update(e){super.update(e),this.mute||e.scale.clamp(this.min,this.max)}}Fp.prototype.isLimitScaleConstraint=!0;const hI=new Ge().setFromAxisAngle(new b(1,0,0),-Math.PI/2),yd=new b,a0=new b,Yl=new b,jl=new b,bd=new b,Cd=new Gn,pI=new b,s0=new b,l0=new Ge;class Up extends xn{constructor(e){super(e),this.type="LockedTrackConstraint",this.trackAxis="X",this.lockAxis="Y",this.fixCameraLightRotation=!1}copy(e){return super.copy(e),this.trackAxis=e.trackAxis,this.lockAxis=e.lockAxis,this.fixCameraLightRotation=e.fixCameraLightRotation,this}update(e){if(super.update(e),this.mute||(Yl.set(this.trackAxis=="X"?1:this.trackAxis=="-X"?-1:0,this.trackAxis=="Y"?1:this.trackAxis=="-Y"?-1:0,this.trackAxis=="Z"?1:this.trackAxis=="-Z"?-1:0),jl.set(this.lockAxis=="X"?1:0,this.lockAxis=="Y"?1:0,this.lockAxis=="Z"?1:0),Math.abs(Yl.dot(jl))==1))return;yd.setFromMatrixPosition(e.matrixWorld),a0.setFromMatrixPosition(this.target.matrixWorld),Cd.setFromNormalAndCoplanarPoint(jl,yd),Cd.projectPoint(a0,bd).sub(yd);const t=pI.crossVectors(Yl,bd).dot(jl)>0?1:-1;e.setRotationFromAxisAngle(Cd.normal,t*Yl.angleTo(bd)),e.parent&&(e.parent.matrixWorld.decompose(s0,l0,s0),e.quaternion.premultiply(l0.invert())),this.fixCameraLightRotation&&(e.isCamera||e.isLight)&&e.quaternion.multiply(hI)}}Up.prototype.isLockedTrackConstraint=!0;const c0=new b(0,1,0),fI=new Ge().setFromAxisAngle(new b(1,0,0),-Math.PI/2),u0=new Gn,d0=new b,h0=new b,yi=new b,Xr=new b,Sd=new b,p0=new Ae,f0=new b,m0=new Ge;class zp extends xn{constructor(e){super(e),this.type="TrackToConstraint",this.trackAxis="X",this.upAxis="Y",this.fixCameraLightRotation=!1}copy(e){return super.copy(e),this.trackAxis=e.trackAxis,this.upAxis=e.upAxis,this.fixCameraLightRotation=e.fixCameraLightRotation,this}update(e){if(super.update(e),this.mute)return;const t=this.trackAxis[this.trackAxis.length-1],n=this.upAxis[this.upAxis.length-1],i=this.trackAxis[0]=="-",o=this.upAxis[0]=="-";if(t==n)return;d0.setFromMatrixPosition(e.matrixWorld),h0.setFromMatrixPosition(this.target.matrixWorld),yi.subVectors(h0,d0),yi.lengthSq()?yi.normalize():yi.set(0,-1,0),u0.set(yi,0),Math.abs(yi.dot(c0))!=1?u0.projectPoint(c0,Xr).normalize():Xr.set(0,0,-1),i&&yi.negate(),o&&Xr.negate();let r=t=="X"?yi:n=="X"?Xr:null,s=t=="Y"?yi:n=="Y"?Xr:null,l=t=="Z"?yi:n=="Z"?Xr:null;r?s?l||(l=Sd.crossVectors(r,s)):s=Sd.crossVectors(l,r):r=Sd.crossVectors(s,l),p0.makeBasis(r,s,l),e.setRotationFromMatrix(p0),e.parent&&(e.parent.matrixWorld.decompose(f0,m0,f0),e.quaternion.premultiply(m0.invert())),this.fixCameraLightRotation&&(e.isCamera||e.isLight)&&e.quaternion.multiply(fI)}}zp.prototype.isTrackToConstraint=!0;class Vp extends xn{constructor(e){super(e),this._orthoZoom=1}copy(e){super.copy(e),this._orthoZoom=e._orthoZoom}update(e){if(super.update(e),this.mute)return;const t=this.target;if(e.parent!==t||!t.isOrthographicCamera)return void console.error("FixOrthoZoom: object should be a direct child of the orthographic camera");const n=this._orthoZoom/t.zoom;e.position.multiplyScalar(n),e.scale.multiplyScalar(n),this._orthoZoom=t.zoom}}Vp.prototype.isFixOrthoZoomConstraint=!0;const g0=new b,mI=new b,Kl=new Ge,Yr=new At,jn=new Rn;class Gp extends xn{constructor(e){super(e),this.type="CanvasFitConstraint",this.edgeH="NONE",this.edgeV="NONE",this.offset=0,this.fitShape="BOX",this.xr=null}copy(e){return super.copy(e),this.edgeH=e.edgeH,this.edgeV=e.edgeV,this.offset=e.offset,this.fitShape=e.fitShape,this.xr=e.xr,this}update(e){if(super.update(e),this.mute)return;if(e.parent!==this.target)return void console.error(`CanvasFitConstraint: object ${e.name} should be a direct child of the camera`);let t,n,i,o;t=this.xr&&this.xr.enabled&&this.xr.isPresenting?this.xr.getCamera():this.target;const r=this.edgeH=="LEFT"?-1:this.edgeH=="RIGHT"?1:0,s=this.edgeV=="BOTTOM"?-1:this.edgeV=="TOP"?1:0;t.isPerspectiveCamera&&(i=Ds(t.fov/2),n=Math.atan(t.aspect*Math.tan(i)),this.edgeH=="LEFT"&&(n*=r),this.edgeV=="BOTTOM"&&(i*=s),o=Math.abs(e.position.z)),e.geometry;let l=0,c=0,d=0,u=0;if(e.matrix.compose(e.position,e.quaternion,e.scale),this.fitShape=="BOX")if(Yr.makeEmpty(),e.resolveMultiMaterial().forEach(function(h){h.geometry&&(h.geometry.boundingBox==null&&h.geometry.computeBoundingBox(),Yr.union(h.geometry.boundingBox))}),Yr.isEmpty())l=-r*this.offset,c=-s*this.offset;else{Yr.applyMatrix4(e.matrix);const h=Yr.getCenter(g0).sub(e.position),p=Yr.getSize(mI).addScalar(2*this.offset);l=-(.5*p.x*r+h.x),c=-(.5*p.y*s+h.y),d=p.x,u=p.y}else if(this.fitShape=="SPHERE")if(jn.makeEmpty(),e.resolveMultiMaterial().forEach(function(h){h.geometry&&(h.geometry.boundingSphere===null&&h.geometry.computeBoundingSphere(),jn.isEmpty()?jn.copy(h.geometry.boundingSphere):jn.union(h.geometry.boundingSphere))}),jn.isEmpty())l=-r*this.offset,c=-s*this.offset;else{jn.applyMatrix4(e.matrix),jn.radius+=this.offset;const h=g0.copy(jn.center).sub(e.position);l=-(jn.radius*r+h.x),c=-(jn.radius*s+h.y),t.isPerspectiveCamera&&(l/=Math.cos(n),c/=Math.cos(i)),d=2*jn.radius,u=2*jn.radius}else l=-r*this.offset,c=-s*this.offset;this.edgeH=="STRETCH"?(e.position.x=l,d!==0&&(e.scale.applyQuaternion(Kl.copy(e.quaternion)),t.isPerspectiveCamera?e.scale.x*=2*o*Math.tan(n)/d:e.scale.x*=(t.right-t.left)/t.zoom/d,e.scale.applyQuaternion(Kl.copy(e.quaternion).invert()))):this.edgeH!=="NONE"&&(t.isPerspectiveCamera?e.position.x=o*Math.tan(n)+l:e.position.x=(r<0?t.left:t.right)/t.zoom+l),this.edgeV=="STRETCH"?(e.position.y=c,u!==0&&(e.scale.applyQuaternion(Kl.copy(e.quaternion)),t.isPerspectiveCamera?e.scale.y*=2*o*Math.tan(i)/u:e.scale.y*=(t.top-t.bottom)/t.zoom/u,e.scale.applyQuaternion(Kl.copy(e.quaternion).invert()))):this.edgeV!=="NONE"&&(t.isPerspectiveCamera?e.position.y=o*Math.tan(i)+c:e.position.y=(s<0?t.bottom:t.top)/t.zoom+c)}}Gp.prototype.isCanvasFitConstraint=!0;class kp extends br{constructor(){super(),this.type="CanvasBreakpointsConstraint",this.minWidth=0,this.maxWidth=1/0,this.minHeight=0,this.maxHeight=1/0,this.orientation="ALL",this.appInstance=null}copy(e){return super.copy(e),this.minWidth=e.minWidth,this.maxWidth=e.maxWidth,this.minHeight=e.minHeight,this.maxHeight=e.maxHeight,this.orientation=e.orientation,this.appInstance=e.appInstance,this}update(e){if(super.update(e),this.mute||!this.appInstance)return;const t=this.appInstance.getWidth(),n=this.appInstance.getHeight();let i;switch(this.orientation){case"ALL":i=!0;break;case"LANDSCAPE":i=t/n>=1;break;case"PORTRAIT":i=t/n<1}if(this.appInstance.getCamera()!==e||t>=this.minWidth&&t<=this.maxWidth&&n>=this.minHeight&&n<=this.maxHeight&&i)t>=this.minWidth&&t<=this.maxWidth&&n>=this.minHeight&&n<=this.maxHeight&&i?e.traverse(o=>{o.internVisible=!0}):e.traverse(o=>{o.internVisible=!1});else{let o=this.findAlternativeCamera(e,this.appInstance.scene,t,n);o&&this.appInstance.setCamera(o)}}findAlternativeCamera(e,t,n,i){let o,r,s=!1;return e&&t.traverse(function(l){if(!s&&l.isCamera&&l!=e)for(let c=0;c<l.constraints.length;c++){let d=l.constraints[c];if(d.isCanvasBreakpointsConstraint){switch(d.orientation){case"ALL":o=!0;break;case"LANDSCAPE":o=n/i>=1;break;case"PORTRAIT":o=n/i<1}n>=d.minWidth&&n<=d.maxWidth&&i>=d.minHeight&&i<=d.maxHeight&&o&&(r?(console.error("CanvasBreakpointsConstraint: two or more alternative cameras"),s=!0):r=l)}}}),r}}kp.prototype.isCanvasBreakpointsConstraint=!0;const Y1=function(a){return!!a&&!!a.dtype&&new RegExp("function View[0-9]+d(:?"+a.dtype+")+").test(String(a.constructor))},Qp=function(a){return!!a&&a.data!==void 0&&Array.isArray(a.shape)&&a.offset!==void 0&&a.stride!==void 0};function sn(a){return Array.isArray(a)||ArrayBuffer.isView(a)}function dt(a){if(a){if(Y1(a)||Qp(a))return a.dtype==="generic"?dt.GENERIC_NDARRAY:dt.NDARRAY;if(sn(a))return dt.ARRAY_OF_ARRAYS;throw new Error("Unhandled data type. Got type: "+typeof a)}}function gI(a){return a[0].toUpperCase()+a.slice(1)}dt.ARRAY_OF_ARRAYS="Arr",dt.NDARRAY="Nd",dt.GENERIC_NDARRAY="GenNd",dt.PACKED="PackArr";const vI=function(a,e,t,n,i,o){var r,s=[],l=!1;for(r=0;r<a.splineDimension;r++){var c=sn(a.knots)&&sn(a.knots[r]);c&&(l=!0),s.push("Deg"+a.degree[r]+(c?"":"Uniform")+gI(a.boundary[r]))}var d=[[l?"NU":"",a.weights?"RBS":"BS"].join("")+a.dimension+"D",s.join("_")];return n&&d.push(n+"Pts"),i&&d.push(i+"Wts"),o&&d.push(o+"Kts"),e&&d.push("debug"),t&&d.push("chk"),d.join("_")},Sn=function(a,e){return function(t,n){t===void 0||Array.isArray(t)||(t=[t]);for(var i=[],o=0;o<t.length;o++)i.push(Sn.sum(t[o]));if(n)for(t=0;t<i.length;t++)n[t]!==void 0&&(i[t]="("+i[t]+" + "+n[t]+") % "+n[t]);return a+i.join("_")}};function Md(a){return function(e,t){e===void 0||Array.isArray(e)||(e=[e]);for(var n=[],i=0;i<e.length;i++)n.push(Sn.sum(e[i]));if(t)for(e=0;e<n.length;e++)t[e]!==void 0&&(n[e]="("+n[e]+" + "+t[e]+") % "+t[e]);return a(n)}}function Ed(a,e){var t;if(e)switch(dt(e)){case dt.ARRAY_OF_ARRAYS:return Md(function(n){return a+"["+n.join("][")+"]"});case dt.GENERIC_NDARRAY:return Md(function(n){return a+".get("+n.join(",")+")"});case dt.NDARRAY:return Md(function(n){var i=[a+"Offset"];for(t=0;t<n.length;t++)i.push(a+"Stride"+t+" * ("+n[t]+")");return a+"["+i.join(" + ")+"]"});case dt.PACKED:default:return}}Sn.sum=function(a){return(a=(a=Array.isArray(a)?a:[a]).filter(function(e){return e!==void 0&&e!==0})).length===0&&a.push(0),a.join(" + ")};const _I=function(a){var e,t={};return(e=Ed("x",a.points))&&(t.point=e),(e=Ed("w",a.weights))&&(t.weight=e),(e=Ed("k",a.knots))&&(t.knot=e),t};var Xi=[],v0=[];const AI=function(a,e,t){if(e!==1)throw new Error("Numerical derivative not implemented for order n = "+e+".");var n,i=arguments[this.splineDimension+3]===void 0?1e-4:arguments[this.splineDimension+3];for(Xi.length=this.splineDimension,n=0;n<this.splineDimension;n++)Xi[n+1]=arguments[n+3];var o,r,s,l=this.domain,c=l[t][0],d=l[t][1],u=Xi[t+1],h=(d-c)*i;for(this.boundary[t]==="closed"?(o=c+(u-c-h+(s=d-c))%s,r=c+(u-c+h+s)%s,h*=2):(o=Math.min(d,Math.max(c,u-h)),h=(r=Math.min(d,Math.max(c,u+h)))-o),Xi[t+1]=o,Xi[0]=v0,this.evaluate.apply(null,Xi),Xi[t+1]=r,Xi[0]=a,this.evaluate.apply(null,Xi),n=0;n<this.dimension;n++)a[n]=(a[n]-v0[n])/h;return a},qa=function(a,e){for(var t=1,n=0,i=[];n<a.length;n++)t*=Array.isArray(a[n])?a[n][1]-a[n][0]:a[n],i[n]=Array.isArray(a[n])?a[n][0]:0;for(var o=0;o<t;o++)for(e(i.slice()),n=a.length-1;n>=0;n--){if(i[n]!==(Array.isArray(a[n])?a[n][1]:a[n])-1){i[n]++;break}i[n]=Array.isArray(a[n])?a[n][0]:0}},ts=function(a,e,t,n){var i,o=[];switch(dt(n)){case dt.NDARRAY:for(o.push("  const "+e+" = "+t+".data;"),o.push("  const "+e+"Offset = "+t+".offset;"),i=0;i<n.dimension;i++)o.push("  const "+e+"Stride"+i+" = "+t+".stride["+i+"];");break;case dt.ARRAY_OF_ARRAYS:o.push("  const "+e+" = "+t+";")}return o.join(`
`)},Wp=function(a,e,t){if(a){if(Qp(a))return e+".shape["+t+"]";for(var n=e,i=0;i<t;i++)n+="[0]";return n+".length"}return"this.size["+t+"]"};var _0={},A0={};const x0=function(a,e,t,n,i,o,r){var s,l,c,d,u,h,p=e.splineDimension,m=e.points,f=e.degree,g=e.weights,_=g!==void 0,A=e.knots,x=e.dimension,S=e.boundary;if(r!=null){Array.isArray(r)||(r=[r]);var M=0;for(s=0;s<p;s++)r[s]===void 0&&(r[s]=0),M+=r[s];if(_&&M>1)throw new Error("Analytical derivative not implemented for rational b-splines with order n = "+M+".")}o&&(a="Basis"+a),r&&(a="Der"+r.join("_")+"_"+a);var T=_0[a];if(n)var L=typeof n=="function"?n:console.log;if(T)return n&&L(A0[a]),T.bind(e);var z=[],W="evaluate"+a,V=t.point;o&&(V=function(I,C){for(var D=[],O=0;O<I.length;O++){for(var Y=I[O],J=[],G=0;G<Y.length;G++)Y[G]!==0&&J.push(Y[G]);Y=J.join(" + "),C[O]&&(Y="("+Y+" + "+C[O]+") % "+C[O]),D.push(Y+" === "+le(O))}return"(("+D.join(" && ")+") ? 1 : 0)"});var N=t.weight,j=t.knot,oe=Sn("k"),H=Sn("x"),ne=Sn("w"),le=Sn("i"),re=Sn("t"),ae=n?"domain":"d",E=Sn(n?"size":"s"),F=Sn(n?"knotIndex":"j"),U=!0;for(u=0;u<p;u++)sn(A)&&sn(A[u])&&(U=!1);function B(I){z.push("  "+(I||""))}function Z(I){n&&B(I)}if(o)var k=[];var X=[];for(s=0;s<p;s++)o&&k.push(le([s])),X.push(re([s]));for(z.push("function "+W+" ("+(o?"":"out, ")+X.join(", ")+(o?", "+k.join(", "):"")+") {"),B("let h, m, a, b;"),i&&(B("const "+ae+" = this.domain;"),B("for (let i = 0; i < this.splineDimension; i++) {"),B("  a = arguments[i + 1];"),B("  if (a < "+ae+"[i][0] || a > "+ae+"[i][1] || a === undefined || isNaN(a)) {"),B("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+"+ae+"[i][0]+', '+"+ae+"[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');"),B("  }"),B("}")),u=0;u<p;u++)B("let "+E(u)+" = "+Wp(m,"this.points",u)+";");function P(I,C,D){return"("+I+") ? ("+C+") : ("+D+")"}z.push(ts(0,"x","this.points",m)),_&&z.push(ts(0,"w","this.weights",g)),U||z.push(ts(0,"k","this.knots",A));var v=[];for(u=0;u<p;u++)switch(dt(A)){case dt.NDARRAY:v[u]=!0;break;case dt.ARRAY_OF_ARRAYS:v[u]=sn(A[u])}for(u=0;u<p;u++)if(v[u])for(Z(`
  // Bisect to locate the knot interval in dimension `+u+`
`),B("let "+F(u)+" = 0;"),B("h = "+E(u)+";"),B("while(h > "+F(u)+" + 1) {"),B("  m = 0.5 * (h + "+F(u)+") | 0;"),B("  if ("+j([u,"m"])+" > "+re(u)+") h = m;"),B("  else "+F(u)+" = m;"),B("}"),Z(`
  // Fetch knots for dimension `+u+`
`),s=1-f[u];s<=f[u];s++)S[u]==="closed"?B(s<0?"let "+oe([u,s+f[u]-1])+" = "+P(F(u)+" < "+-s,j([u,0])+" + "+j([u,[E(u),F(u),s]])+" - "+j([u,[E(u)]]),j([u,[F(u),s]]))+";":s>0?"let "+oe([u,s+f[u]-1])+" = "+P(F(u)+" + "+s+" > "+E(u),j([u,E(u)])+" + "+j([u,s+" + "+F(u)+" - "+E(u)])+" - "+j([u,0]),j([u,[F(u),s]]))+";":"let "+oe([u,s+f[u]-1])+" = "+j([u,[F(u),s]])+";"):B("let "+oe([u,s+f[u]-1])+" = "+j([u,[F(u),s]])+";");else{for(Z(`
  // Directly compute knot interval for dimension `+u+`
`),S[u]==="closed"?B(F(u)+" = ("+re(u)+" | 0) % "+E(u)+";"):(B(F(u)+" = ("+re(u)+" | 0);"),B("if ("+F(u)+" < "+f[u]+") "+F(u)+" = "+f[u]+";"),B("if ("+F(u)+" > "+E(u)+" - 1) "+F(u)+" = "+E(u)+" - 1;")),Z(`
  // Compute and clamp knots for dimension `+u+`
`),s=1-f[u];s<=f[u];s++)B("let "+(h=oe([u,s+f[u]-1]))+" = "+F(u)+" + "+s+";");if(S[u]==="clamped")for(s=1-f[u];s<=f[u];s++)h=oe([u,s+f[u]-1]),s<0&&B("if ("+h+" < "+f[u]+") "+h+" = "+f[u]+";"),s>0&&B("if ("+h+" > "+E(u)+") "+h+" = "+E(u)+";");S[u]==="closed"&&(Z(`
  // Wrap the B-Spline parameter for closed boundary`),B(re(u)+" %= "+E(u)+";"))}for(u=0,c=[];u<p;u++)c[u]=f[u]+1;for(_&&(Z(`
  // Fetch weights
`),qa(c,function(I){for(var C=[],D=[],O=0;O<p;O++)C[O]=[F(O),I[O]-f[O]],S[O]==="closed"&&I[O]-f[O]<0&&(D[O]=E(O));B("let "+ne(I)+" = "+N(C,D)+";")})),n&&B(_?`
  // Fetch points and project into homogeneous (weighted) coordinates
`:`
  // Fetch points
`),qa(c,function(I){for(var C=[],D=[],O=0;O<p;O++)C[O]=[F(O),I[O]-f[O]],S[O]==="closed"&&I[O]-f[O]<0&&(D[O]=E(O));if(o)B(_?"let "+H(I)+" = "+V(C,D)+" * "+ne(I)+";":"let "+H(I)+" = "+V(C,D)+";");else for(O=0;O<x;O++){var Y=I.concat(O);C[p]=O,B(_?"let "+H(Y)+" = "+V(C,D)+" * "+ne(I)+";":"let "+H(Y)+" = "+V(C,D)+";")}}),Z(`
`),Z("// Perform De Boor's algorithm"),u=c.length-1;u>=0;u--)for(c[u]=[f[u],f[u]+1],s=0;s<f[u];s++)for(Z(`
  // Degree `+f[u]+" evaluation in dimension "+u+", step "+(s+1)+`
`),l=f[u];l>s;l--){var y=r&&f[u]-s-r[u]<=0;y?(B("m = 1 / ("+oe([u,l-s+f[u]-1])+" - "+oe([u,l-1])+");"),_&&(B("a = ("+re(u)+" - "+oe([u,l-1])+") * m;"),B("b = 1 - a;"))):(B("a = ("+re(u)+" - "+oe([u,l-1])+") / ("+oe([u,l-s+f[u]-1])+" - "+oe([u,l-1])+");"),B("b = 1 - a;")),_&&qa(c,function(I){var C=I.slice(),D=I.slice();C[u]=l,D[u]=l-1,y&&_&&B("h = "+ne(C)+";"),B(ne(C)+" = b * "+ne(D)+" + a * "+ne(C)+";")}),qa(c,function(I){var C,D,O,Y=I.slice(),J=I.slice();if(Y[u]=l,J[u]=l-1,y){var G=s+1;if(o)C=_?"h * "+ne(J)+" / "+ne(Y)+" * ":"",D=H(Y)+(_?" / h":""),O=H(J)+(_?" / "+ne(J):""),B(H(Y)+" = "+G+" * "+C+"("+D+" - "+O+") * m;");else{var K=Y.slice(),ie=J.slice();for(d=0;d<x;d++)K[p]=ie[p]=d,C=_?"h * "+ne(J)+" / "+ne(Y)+" * ":"",D=H(K)+(_?" / h":""),O=H(ie)+(_?" / "+ne(J):""),B(H(K)+" = "+G+" * "+C+"("+D+" - "+O+") * m;")}}else if(o)B(H(Y)+" = b * "+H(J)+" + a * "+H(Y)+";");else for(d=0;d<x;d++)Y[p]=J[p]=d,B(H(Y)+" = b * "+H(J)+" + a * "+H(Y)+";")}),Z(`
`)}if(n&&B(_?`
  // Project back from homogeneous coordinates and return final output
`:`
  // Return final output
`),o)B(_?"return "+H(f)+" / "+ne(f)+";":"return "+H(f)+";");else for(u=0;u<x;u++)B(_?"out["+u+"] = "+H(f.concat([u]))+" / "+ne(f)+";":"out["+u+"] = "+H(f.concat([u]))+";");if(o||B("return out;"),z.push("}"),n){var R=z.join(`
`);L(R),A0[a]=R}const w=new Function([z.join(`
`),"; return ",W].join(""))();return _0[a]=w,w.bind(e)};var y0={};const xI=function(a,e,t,n){var i,o,r,s,l,c,d,u,h=y0[a];if(h)return h.bind(e);var p=[],m="transform"+a;p.push("function "+m+"(m) {"),p.push("let i, w;"),p.push(ts(0,"x","this.points",e.points));var f=Sn(n?"size":"s");for(i=0;i<e.splineDimension;i++)p.push("let "+f(i)+" = "+Wp(e.points,"this.points",i)+";");for(s=[],i=0;i<e.splineDimension;i++)r="i"+i,s.push(r),p.push("for ("+r+" = "+f(i)+"- 1; "+r+" >= 0; "+r+"--) {");for(i=0;i<e.dimension;i++)p.push("x"+i+" = "+t.point(s.concat([i])));for(l=[],i=0;i<e.dimension;i++)l.push("m["+((e.dimension+1)*(i+1)-1)+"] * x"+i);for(l.push("m["+((e.dimension+1)*(e.dimension+1)-1)+"]"),p.push("const w = ("+l.join(" + ")+") || 1.0;"),i=0;i<e.dimension;i++){for(l=[],c=e.dimension,o=0;o<c;o++)l.push("m["+(o*(c+1)+i)+"] * x"+o);l.push("m["+(o*(c+1)+i)+"]"),u=t.point(s.concat([i])),d="("+l.join(" + ")+") / w",p.push(u+" = "+d+";")}for(i=e.splineDimension-1;i>=0;i--)p.push("}");p.push("return this;"),p.push("}");const g=new Function([p.join(`
`),"; return ",m].join(""))();return n&&console.log(p.join(`
`)),y0[a]=g,g.bind(e)};var b0={};const yI=function(a,e,t,n,i){var o=b0[a];if(o)return o.bind(e);var r,s,l,c=e.degree,d=e.knots,u=e.splineDimension,h=e.boundary,p=[],m="support"+a,f=t.knot,g=Sn("t"),_=n?"domain":"d",A=Sn(n?"size":"s"),x=Sn(n?"knotIndex":"i"),S=!0;for(l=0;l<u;l++)sn(d)&&sn(d[l])&&(S=!1);function M(N){p.push("  "+(N||""))}var T=[];for(r=0;r<u;r++)T.push(g([r]));p.push("function "+m+" (out, "+T.join(", ")+") {");var L=0;function z(N,j){M(j===void 0?"out["+L+++"] = "+N.join(" + ")+";":"out["+L+++"] = ("+N.join(" + ")+" + "+j+") % "+j+";")}for(M("let h, m;"),M("let c = 0;"),i&&(M("const "+_+" = this.domain;"),M("for (let i = 0; i < this.splineDimension; i++) {"),M("  a = arguments[i + 1];"),M("  if (a < "+_+"[i][0] || a > "+_+"[i][1] || a === undefined || isNaN(a)) {"),M("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+"+_+"[i][0]+', '+"+_+"[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');"),M("  }"),M("}")),l=0;l<u;l++)M("let "+A(l)+" = "+Wp(e.points,"this.points",l)+";");S||p.push(ts(0,"k","this.knots",d));var W=[];for(l=0;l<u;l++)switch(dt(d)){case dt.NDARRAY:W[l]=!0;break;case dt.ARRAY_OF_ARRAYS:W[l]=sn(d[l])}for(l=0;l<u;l++)W[l]?(M("let "+x(l)+" = 0;"),M("h = "+A(l)+";"),M("while(h > "+x(l)+" + 1) {"),M("  m = 0.5 * (h + "+x(l)+") | 0;"),M("  if ("+f([l,"m"])+" > "+g(l)+") h = m;"),M("  else "+x(l)+" = m;"),M("}")):h[l]==="closed"?M(x(l)+" = ("+g(l)+" | 0) % "+A(l)+";"):(M(x(l)+" = ("+g(l)+" | 0);"),M("if ("+x(l)+" < "+c[l]+") "+x(l)+" = "+c[l]+";"),M("if ("+x(l)+" > "+A(l)+" - 1) "+x(l)+" = "+A(l)+" - 1;"));for(l=0,s=[];l<u;l++)s[l]=c[l]+1;qa(s,function(N){for(var j=[],oe=[],H=0;H<u;H++)j[H]=[x(H),N[H]-c[H]],h[H]==="closed"&&N[H]-c[H]<0&&(oe[H]=A(H));for(H=0;H<u;H++)z(j[H],oe[H])}),M("out.length = "+L+";"),M("return out;"),p.push("}"),n&&console.log(p.join(`
`));const V=new Function([p.join(`
`),"; return ",m].join(""))();return b0[a]=V,V.bind(e)};var ql={open:"open",closed:"closed",clamped:"clamped"};function Zl(a){return a==null}function bI(a,e,t,n,i,o){var r,s;!a||sn(a)||Y1(a)?(o=o||{},this.weights=n,this.knots=t,this.degree=e,this.points=a,this.boundary=i,this.debug=o.debug,this.checkBounds=!!o.checkBounds,Object.defineProperty(this,"size",{value:o.size,writable:!0,configurable:!0})):(o=a,this.debug=a.debug,this.checkBounds=!!a.checkBounds,this.weights=a.weights,this.knots=a.knots,this.degree=a.degree,this.boundary=a.boundary,this.points=a.points,Object.defineProperty(this,"size",{value:o.size,writable:!0,configurable:!0}));var l=dt(this.points),c=dt(this.weights),d=dt(this.knots);if(this.points)switch(l){case dt.GENERIC_NDARRAY:case dt.NDARRAY:Object.defineProperties(this,{splineDimension:{value:this.points.shape.length-1,writable:!1,configurable:!0},dimension:{value:this.points.shape[this.points.shape.length-1],writable:!1,configurable:!0},size:{get:function(){return this.points.shape.slice(0,this.points.shape.length-1)},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case dt.ARRAY_OF_ARRAYS:var u=0,h=this.size||[];h.length=0;for(var p=this.points;sn(p[0]);p=p[0])u++,h.push(p.length);if(u===0)throw new Error("Expected an array of points");Object.defineProperties(this,{splineDimension:{value:u,writable:!1,configurable:!0},dimension:{value:p.length,writable:!1,configurable:!0},size:{get:function(){var A=[];A.length=0;for(var x=0,S=this.points;x<this.splineDimension;x++,S=S[0])A[x]=S.length;return A},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case dt.PACKED:default:throw new Error("Expected either a packed array, array of arrays, or ndarray of points")}else{if(this.size===void 0||this.size===null)throw new Error("Either points or a control hull size must be provided.");if(sn(this.size)||Object.defineProperty(this,"size",{value:[this.size],writable:!0,configurable:!0}),this.size.length===0)throw new Error("`size` must be a number or an array of length at least one.");Object.defineProperties(this,{splineDimension:{value:this.size.length,writable:!1,configurable:!0},dimension:{value:0,writable:!1,configurable:!0}})}if(sn(this.degree)){for(r=0;r<this.splineDimension;r++)if(Zl(this.degree[r]))throw new Error("Missing degree in dimension "+(r+1))}else{var m=!Zl(this.degree),f=Zl(this.degree)?2:this.degree;for(this.degree=[],r=0;r<this.splineDimension;r++)if(this.size[r]<=f){if(m)throw new Error("Expected at least "+(f+1)+" points for degree "+f+" spline in dimension "+(r+1)+" but got only "+this.size[r]);this.degree[r]=this.size[r]-1}else this.degree[r]=f}if(s=typeof this.boundary!="string"?"open":this.boundary,!ql[s])throw new Error("Boundary type must be one of "+Object.keys(ql)+". Got "+s);for(this.boundary=sn(this.boundary)?this.boundary:[],this.boundary.length=this.splineDimension,r=0;r<this.splineDimension;r++)if(this.boundary[r]=Zl(this.boundary[r])?s:this.boundary[r],!ql[s])throw new Error("Boundary type must be one of "+Object.keys(ql)+". Got "+s+" for dimension "+(r+1));if(d===dt.ARRAY_OF_ARRAYS)for(sn(this.knots)&&this.knots.length>0&&!sn(this.knots[0])&&(this.knots=[this.knots]),r=0;r<this.splineDimension;r++){if(this.size[r]<=this.degree[r])throw new Error("Expected at least "+(this.degree[r]+1)+" points in dimension "+(r+1)+" but got "+this.size[r]+".");if(sn(this.knots[r])){if(this.boundary[r]!=="closed"&&this.knots[r].length!==this.degree[r]+this.size[r]+1)throw new Error("Expected "+(this.degree[r]+this.size[r]+1)+" knots in dimension "+(r+1)+" but got "+this.knots[r].length+".");if(this.boundary[r]==="closed"&&this.knots[r].length!==this.size[r]+1&&this.knots[r].length!==this.size[r]+this.degree[r]+1)throw new Error("Expected "+(this.size[r]+1)+" knots for closed spline in dimension "+(r+1)+" but got "+this.knots[r].length+".")}}var g=vI(this,this.debug,this.checkBounds,l,c,d);if(g!==this.__cacheKey){this.__cacheKey=g;var _=_I(this);this.evaluate=x0(this.__cacheKey,this,_,this.debug,this.checkBounds,!1),this.transform=xI(this.__cacheKey,this,_,this.debug),this.support=yI(this.__cacheKey,this,_,this.debug,this.checkBounds),this.evaluator=function(A,x){return x0(this.__cacheKey,this,_,this.debug,this.checkBounds,x,A)}}return this.numericalDerivative=AI.bind(this),this}function CI(){var a,e=[],t=this.points;t?Qp(t)&&(a=t.shape):a=this.size;for(var n=0;n<this.splineDimension;n++){var i=a?a[n]:t.length,o=this.degree[n],r=this.boundary[n]==="closed";if(this.knots&&this.knots[n]){var s=this.knots[n];e[n]=[s[r?0:o],s[i]]}else e[n]=[r?0:o,i];t&&(t=t[0])}return e}function Jl(a,e,t,n,i,o){const r=function(l,c,d,u,h,p){return s(l,c,d,u,h,p),r},s=bI.bind(r);return Object.defineProperty(r,"domain",{get:CI}),s(a,e,t,n,i,o),r}const SI=new Ge().setFromAxisAngle(new b(1,0,0),-Math.PI/2),Jo={X:new b(1,0,0),Y:new b(0,1,0),Z:new b(0,0,1),"-X":new b(-1,0,0),"-Y":new b(0,-1,0),"-Z":new b(0,0,-1)},MI=new b(0,1,0),C0=new b(0,0,1),wd={DEFAULT:0,MATRIX:1},$l={ONLY_CONSTRAINT:0,CONSTRAINT_FIRST:1},Wa=new b,bi=new Ge,S0=new b,ec=new b,M0=new b,EI=new b,jr=new b,Kr=new b,wI=new b,Ha=new Ae,tc=new Ge,Cn=[0,0,0];class Hp extends br{constructor(){super(),this.type="MotionPathConstraint",this.curve=null,this.firstDerivativeEvaluator=null,this.secondDerivativeEvaluatorForNonUniformBSplines=null,this.derivativeEvaluatorForWeights0=null,this.derivativeEvaluatorForWeights1=null,this.derivativeEvaluatorForWeights2=null,this.degree=3,this.cvs=[],this.knots=[],this.weights=[],this.value=0,this.follow=!0,this.frontAxis="Z",this.upAxis="Y",this.worldUpVector=new b(0,1,0),this.useChordLength=!1,this.chordsNum=0,this.chordLengths=[],this.bank=!1,this.bankScale=1,this.bankLimit=1/0,this.useFixedLocation=!1,this.fixedValue=0,this.usePointsTilt=!1,this.pointsTilt=[],this.pointsTiltEvaluator=null,this.offsetValue=0,this.useClampValue=!1,this.useCyclic=!1,this.useObjOffset=!1,this.useRelative=!1,this.usePosOffset=!0,this.objOffsetMode=wd.DEFAULT,this.objOffsetRotMode=$l.ONLY_CONSTRAINT,this.influence=1,this.fixCameraLightRotation=!1,this._firstIteration=!0,this._objMatrixWorldInit=new Ae,this._objPosWorldInit=new b,this._objRotWorldInit=new Ge}copy(e){super.copy(e),this.degree=e.degree,this.cvs=[];for(let t=0;t<e.cvs.length;++t)this.cvs.push(e.cvs[t]);this.knots=[];for(let t=0;t<e.knots.length;++t)this.knots.push(e.knots[t]);this.weights=[];for(let t=0;t<e.weights.length;++t)this.weights.push(e.weights[t]);this.value=e.value,this.follow=e.follow,this.frontAxis=e.frontAxis,this.upAxis=e.upAxis,this.worldUpVector.copy(e.worldUpVector),this.useChordLength=e.useChordLength,this.chordsNum=e.chordsNum,this.bank=e.bank,this.bankScale=e.bankScale,this.bankLimit=e.bankLimit,this.useFixedLocation=e.useFixedLocation,this.fixedValue=e.fixedValue,this.usePointsTilt=e.usePointsTilt,this.pointsTilt=[];for(let t=0;t<e.pointsTilt.length;++t)this.pointsTilt.push(e.pointsTilt[t]);return this.offsetValue=e.offsetValue,this.useClampValue=e.useClampValue,this.useCyclic=e.useCyclic,this.useObjOffset=e.useObjOffset,this.useRelative=e.useRelative,this.usePosOffset=e.usePosOffset,this.objOffsetMode=e.objOffsetMode,this.objOffsetRotMode=e.objOffsetRotMode,this.influence=e.influence,this.fixCameraLightRotation=e.fixCameraLightRotation,this._firstIteration=!0,this}init(){const e=[],t=this.cvs;for(let r=0;r<t.length;r+=3)e.push([t[r],t[r+1],t[r+2]]);this.curve=Jl({points:e,knots:this.knots,weights:this.weights,degree:this.degree}),this.firstDerivativeEvaluator=this.curve.evaluator(1);let n=Jl({points:e,knots:this.knots,degree:this.degree});this.secondDerivativeEvaluatorForNonUniformBSplines=n.evaluator(2);const i=[];for(let r=0;r<this.weights.length;++r)i.push([this.weights[r]]);let o=Jl({points:i,knots:this.knots,degree:this.degree});if(this.derivativeEvaluatorForWeights0=o.evaluator(0),this.derivativeEvaluatorForWeights1=o.evaluator(1),this.derivativeEvaluatorForWeights2=o.evaluator(2),this.usePointsTilt){const r=[];for(let l=0;l<this.pointsTilt.length;++l)r.push([this.pointsTilt[l]]);const s=Jl({points:r,knots:this.knots,weights:this.weights,degree:this.degree});this.pointsTiltEvaluator=s.evaluator(0)}else this.pointsTiltEvaluator=null;if(this.useChordLength)if(this.chordLengths=[],this.chordsNum<=0){let r=this.degree==1?1:32;this._calcChordLengths(this.chordLengths,this.cvs.length/3*r)}else this._calcChordLengths(this.chordLengths,this.chordsNum)}update(e){if(super.update(e),this.mute)return;this._firstIteration&&(this._updateObjMatrixWorld(e),e.matrixWorld.decompose(this._objPosWorldInit,this._objRotWorldInit,S0),this._objMatrixWorldInit.copy(e.matrixWorld),this.useRelative&&(this._calcPosition(Wa,0),this._objPosWorldInit.sub(Wa),this._objMatrixWorldInit.setPosition(this._objPosWorldInit)),this.usePosOffset||(this._objPosWorldInit.set(0,0,0),this._objMatrixWorldInit.setPosition(this._objPosWorldInit)),this._firstIteration=!1);let t=this.useFixedLocation?this.fixedValue:this.value+this.offsetValue;this.useCyclic?t-=Math.floor(t):t=this.useClampValue?Ye(t,0,1):Math.max(0,t),this.useChordLength&&(t=this._convertParamToChordLength(t,this.chordLengths));const n=this.curve.domain,i=t*(n[0][1]-n[0][0])+n[0][0];if(this._calcPosition(e.position,i),!this.follow&&this.useObjOffset&&(ec.addVectors(e.position,this._objPosWorldInit),e.position.lerpVectors(this._objPosWorldInit,ec,this.influence)),this.follow&&Math.abs(Jo[this.frontAxis].dot(Jo[this.upAxis]))!=1){const o=this._calcTangent(ec,i),r=M0.copy(o).normalize();if(this._calcCurveRotMat(Ha,r,this.worldUpVector),this._calcFrontAndUpVecsRotQuat(bi,Jo[this.frontAxis],Jo[this.upAxis]),e.quaternion.setFromRotationMatrix(Ha).multiply(bi),this.bank){const s=this._calcSecondDerivative(M0,i,e.position,o),l=this._calcCurvature(o,s),c=EI.copy(Jo[this.upAxis]).applyQuaternion(e.quaternion);let d=this._calcBankAngle(l,o,s,c);d=this._limitAngle(d*this.bankScale,this.bankLimit),bi.setFromAxisAngle(Jo[this.frontAxis],d),e.quaternion.multiply(bi)}else if(this.usePointsTilt){this.pointsTiltEvaluator(Cn,i);let s=Cn[0];bi.setFromAxisAngle(Jo[this.frontAxis],s),e.quaternion.multiply(bi)}if(this.useObjOffset){if(this.objOffsetMode==wd.MATRIX){const s=ec.setScalar(1);Ha.compose(e.position,e.quaternion,s),this.objOffsetRotMode==$l.CONSTRAINT_FIRST&&Ha.multiply(this._objMatrixWorldInit),Ha.decompose(Wa,bi,S0)}else this.objOffsetMode==wd.DEFAULT&&(Wa.addVectors(e.position,this._objPosWorldInit),this.objOffsetRotMode==$l.ONLY_CONSTRAINT?bi.copy(e.quaternion):this.objOffsetRotMode==$l.CONSTRAINT_FIRST&&bi.multiplyQuaternions(e.quaternion,this._objRotWorldInit));e.position.lerpVectors(this._objPosWorldInit,Wa,this.influence),e.quaternion.slerpQuaternions(this._objRotWorldInit,bi,this.influence)}this.fixCameraLightRotation&&(e.isCamera||e.isLight)&&e.quaternion.multiply(SI)}}_calcPosition(e,t){return this.curve.evaluate(Cn,t),e.fromArray(Cn)}_calcTangent(e,t){return this.firstDerivativeEvaluator(Cn,t),e.fromArray(Cn)}_calcCurveRotMat(e,t,n){const i=jr.copy(n),o=Kr.crossVectors(i,t).normalize();return i.crossVectors(t,o),e.makeBasis(o,i,t),e}_calcFrontAndUpVecsRotQuat(e,t,n){e.setFromUnitVectors(t,C0);const i=jr.copy(MI),o=Kr.copy(n).applyQuaternion(e),r=o.dot(i);if(Math.abs(r)!=1){const s=wI.crossVectors(o,i).dot(C0)>0?1:-1;tc.setFromAxisAngle(t,o.angleTo(i)*s),e.multiply(tc)}else r<0&&(tc.setFromAxisAngle(t,Math.PI),e.multiply(tc));return e}_calcBankAngle(e,t,n,i){const o=jr.copy(t).add(n).normalize();return e*(Kr.crossVectors(o,t).normalize().dot(i)>0?1:-1)}_calcCurvature(e,t){return jr.crossVectors(e,t).length()/Math.pow(e.length(),3)}_calcSecondDerivative(e,t,n,i){this.secondDerivativeEvaluatorForNonUniformBSplines(Cn,t);const o=jr.fromArray(Cn);this.derivativeEvaluatorForWeights1(Cn,t);const r=Cn[0];this.derivativeEvaluatorForWeights2(Cn,t);const s=Cn[0];this.derivativeEvaluatorForWeights0(Cn,t);const l=Cn[0];return e.copy(o).sub(Kr.copy(i).multiplyScalar(2*r)),e.sub(Kr.copy(n).multiplyScalar(s)),e.divideScalar(l),e}_limitAngle(e,t){return e>0?Math.min(e,t):Math.max(e,-t)}_calcChordLengths(e,t){let n=1/Math.max(1,t-1),i=0,o=0;const r=this.curve.domain;let s=r[0][0],l=r[0][1]-r[0][0];const c=jr,d=Kr;this._calcPosition(c,s);for(let u=0;u<t;++u)this._calcPosition(d,i*l+s),o+=c.subVectors(d,c).length(),e.push(o),c.copy(d),i+=n;return e}_convertParamToChordLength(e,t){if(e<=0)return 0;if(e>=1)return 1;let n=e*t[t.length-1],i=0,o=0,r=t.length-1;for(;i<r;)o=i+Math.floor((r-i)/2),n>t[o]?i=o+1:r=o-1;return n>t[r]?r+=(n-t[r])/(t[r+1]-t[r]):r-=1-(n-t[r-1])/(t[r]-t[r-1]),r/(t.length-1)}}Hp.prototype.isMotionPathConstraint=!0;const E0=["IMAGE_AR","SKYDOME_LIGHT_AR","TEXTURE_BL","TEX_IMAGE_BL","TEX_ENVIRONMENT_BL","BITMAP_MX","BITMAP_ENV_MX","REFLECT_REFRACT_MX","FILE_MY","AI_SKYDOME_LIGHT_MY","OSL_NODE"];class j1 extends pn{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new PI(t)}),this.register(function(t){return new zI(t)}),this.register(function(t){return new VI(t)}),this.register(function(t){return new DI(t)}),this.register(function(t){return new NI(t)}),this.register(function(t){return new OI(t)}),this.register(function(t){return new FI(t)}),this.register(function(t){return new LI(t)}),this.register(function(t){return new UI(t)}),this.register(function(t){return new BI(t)}),this.register(function(t){return new II(t)}),this.register(function(t){return new GI(t)}),this.register(function(t){return new kI(t)}),this.register(function(t){return new YI(t)}),this.register(function(t){return new jI(t)}),this.register(function(t){return new KI(t)}),this.register(function(t){return new qI(t)}),this.register(function(t){return new ZI(t)}),this.register(function(t){return new JI(t)}),this.register(function(t){return new $I(t)}),this.register(function(t){return new eR(t)}),this.register(function(t){return new tR(t)}),this.onProgress=null}load(e,t,n,i){const o=this;let r;o.onProgress=n||function(){},r=this.resourcePath!==""?this.resourcePath:this.path!==""?this.path:ti.extractUrlBase(e);const s=e.indexOf(".xz",e.length-3)!=-1;let l;s?l=new Is(o.manager):(l=new cn(o.manager),l.setResponseType("arraybuffer"));const c=function(u){o.onProgress&&o.onProgress(.3*u*100)};let d=c;l instanceof cn&&(d=function(u){const h=u.lengthComputable?u.loaded/u.total:1;c(h)}),l.load(e,function(u){try{o.parse(u,r,t,i,s)}catch(h){i!==void 0&&i(h.constructor===Error?h:new Error("v3d.GLTFLoader: Unable to parse model."))}},d,i)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('v3d.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,i,o){let r;const s={},l={};if(typeof e=="string")r=e;else if(ti.decodeText(new Uint8Array(e,0,4))===K1){try{s[Fe.KHR_BINARY_GLTF]=new QI(e)}catch(h){return void(i&&i(h))}r=s[Fe.KHR_BINARY_GLTF].content}else r=ti.decodeText(new Uint8Array(e));const c=JSON.parse(r);if(c.asset===void 0||c.asset.version[0]<2)return void(i&&i(new Error("v3d.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const d=this;dR(c);const u=new cR(c,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder,loadBinXZ:o,onProgress:function(h){d.onProgress&&d.onProgress(h)}});for(let h=0;h<this.pluginCallbacks.length;h++){const p=this.pluginCallbacks[h](u);l[p.name]=p,s[p.name]=!0}if(c.extensionsUsed)for(let h=0;h<c.extensionsUsed.length;++h){const p=c.extensionsUsed[h],m=c.extensionsRequired||[];switch(p){case Fe.KHR_MATERIALS_UNLIT:s[p]=new RI;break;case Fe.KHR_DRACO_MESH_COMPRESSION:s[p]=new WI(c,this.dracoLoader);break;case Fe.KHR_TEXTURE_TRANSFORM:s[p]=new HI;break;case Fe.KHR_MESH_QUANTIZATION:s[p]=new XI;break;default:m.indexOf(p)>=0&&l[p]===void 0&&console.warn('v3d.GLTFLoader: Unknown extension "'+p+'".')}}u.setExtensions(s),u.setPlugins(l),u.parse(function(h){d.onProgress&&d.onProgress(100),n(h)},i)}parseAsync(e,t){const n=this;return new Promise(function(i,o){n.parse(e,t,i,o)})}}function TI(){let a={};return{get:function(e){return a[e]},add:function(e,t){a[e]=t},remove:function(e){delete a[e]},removeAll:function(){a={}}}}const Fe={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing",S8S_V3D_ANIMATION:"S8S_v3d_animation",S8S_V3D_CAMERA:"S8S_v3d_camera",S8S_V3D_MATERIALS:"S8S_v3d_materials",S8S_V3D_MESH:"S8S_v3d_mesh",S8S_V3D_NODE:"S8S_v3d_node",S8S_V3D_SCENE:"S8S_v3d_scene",S8S_V3D_TEXTURE:"S8S_v3d_texture",S8S_V3D_LIGHTS:"S8S_v3d_lights",S8S_V3D_LIGHT_PROBES:"S8S_v3d_light_probes",S8S_V3D_CURVES:"S8S_v3d_curves",S8S_V3D_CLIPPING_PLANES:"S8S_v3d_clipping_planes"};class II{constructor(e){this.parser=e,this.name=Fe.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,i=t.length;n<i;n++){const o=t[n];o.extensions&&o.extensions[this.name]&&o.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,o.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let i=t.cache.get(n);if(i)return i;const o=t.json,r=((o.extensions&&o.extensions[this.name]||{}).lights||[])[e];let s;const l=new me(16777215);r.color!==void 0&&l.fromArray(r.color);const c=r.range!==void 0?r.range:0;switch(r.type){case"directional":s=new uu(l),s.target.position.set(0,0,-1),s.add(s.target);break;case"point":s=new lu(l),s.distance=c;break;case"spot":s=new su(l),s.distance=c,r.spot=r.spot||{},r.spot.innerConeAngle=r.spot.innerConeAngle!==void 0?r.spot.innerConeAngle:0,r.spot.outerConeAngle=r.spot.outerConeAngle!==void 0?r.spot.outerConeAngle:Math.PI/4,s.angle=r.spot.outerConeAngle,s.penumbra=1-r.spot.innerConeAngle/r.spot.outerConeAngle,s.target.position.set(0,0,-1),s.add(s.target);break;default:throw new Error("v3d.GLTFLoader: Unexpected light type: "+r.type)}return s.position.set(0,0,0),s.decay=2,wo(s,r),r.intensity!==void 0&&(s.intensity=r.intensity),s.name=t.createUniqueName(r.name||"light_"+e),i=Promise.resolve(s),t.cache.add(n,i),i}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,i=n.json.nodes[e],o=(i.extensions&&i.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(r){return n._getNodeRef(t.cache,o,r)})}}let RI=class{constructor(){this.name=Fe.KHR_MATERIALS_UNLIT}getMaterialType(){return Xt}extendParams(a,e,t){const n=[];a.color=new me(1,1,1),a.opacity=1;const i=e.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const o=i.baseColorFactor;a.color.fromArray(o),a.opacity=o[3]}i.baseColorTexture!==void 0&&n.push(t.assignTexture(a,"map",i.baseColorTexture,Ke))}return Promise.all(n)}};class LI{constructor(e){this.parser=e,this.name=Fe.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}}let PI=class{constructor(a){this.parser=a,this.name=Fe.KHR_MATERIALS_CLEARCOAT}getMaterialType(a){const e=this.parser.json.materials[a];return e.extensions&&e.extensions[this.name]?lo:null}extendMaterialParams(a,e){const t=this.parser,n=t.json.materials[a];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];if(o.clearcoatFactor!==void 0&&(e.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&i.push(t.assignTexture(e,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(e.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&i.push(t.assignTexture(e,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(i.push(t.assignTexture(e,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const r=o.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new te(r,r)}return Promise.all(i)}},BI=class{constructor(a){this.parser=a,this.name=Fe.KHR_MATERIALS_IRIDESCENCE}getMaterialType(a){const e=this.parser.json.materials[a];return e.extensions&&e.extensions[this.name]?lo:null}extendMaterialParams(a,e){const t=this.parser,n=t.json.materials[a];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];return o.iridescenceFactor!==void 0&&(e.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&i.push(t.assignTexture(e,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(e.iridescenceIOR=o.iridescenceIor),e.iridescenceThicknessRange===void 0&&(e.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(e.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(e.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&i.push(t.assignTexture(e,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(i)}};class DI{constructor(e){this.parser=e,this.name=Fe.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?lo:null}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=[];t.sheenColor=new me(0,0,0),t.sheenRoughness=0,t.sheen=1;const r=i.extensions[this.name];return r.sheenColorFactor!==void 0&&t.sheenColor.fromArray(r.sheenColorFactor),r.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&o.push(n.assignTexture(t,"sheenColorMap",r.sheenColorTexture,Ke)),r.sheenRoughnessTexture!==void 0&&o.push(n.assignTexture(t,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(o)}}let NI=class{constructor(a){this.parser=a,this.name=Fe.KHR_MATERIALS_TRANSMISSION}getMaterialType(a){const e=this.parser.json.materials[a];return e.extensions&&e.extensions[this.name]?lo:null}extendMaterialParams(a,e){const t=this.parser,n=t.json.materials[a];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];return o.transmissionFactor!==void 0&&(e.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&i.push(t.assignTexture(e,"transmissionMap",o.transmissionTexture)),Promise.all(i)}},OI=class{constructor(a){this.parser=a,this.name=Fe.KHR_MATERIALS_VOLUME}getMaterialType(a){const e=this.parser.json.materials[a];return e.extensions&&e.extensions[this.name]?lo:null}extendMaterialParams(a,e){const t=this.parser,n=t.json.materials[a];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];e.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&i.push(t.assignTexture(e,"thicknessMap",o.thicknessTexture)),e.attenuationDistance=o.attenuationDistance||1/0;const r=o.attenuationColor||[1,1,1];return e.attenuationColor=new me(r[0],r[1],r[2]),Promise.all(i)}};class FI{constructor(e){this.parser=e,this.name=Fe.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?lo:null}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class UI{constructor(e){this.parser=e,this.name=Fe.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?lo:null}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=[],r=i.extensions[this.name];t.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&o.push(n.assignTexture(t,"specularIntensityMap",r.specularTexture));const s=r.specularColorFactor||[1,1,1];return t.specularColor=new me(s[0],s[1],s[2]),r.specularColorTexture!==void 0&&o.push(n.assignTexture(t,"specularColorMap",r.specularColorTexture,Ke)),Promise.all(o)}}class zI{constructor(e){this.parser=e,this.name=Fe.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,i=n.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const o=i.extensions[this.name],r=t.options.ktx2Loader;if(!r){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("v3d.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,o.source,r)}}class VI{constructor(e){this.parser=e,this.name=Fe.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,i=n.json,o=i.textures[e];if(!o.extensions||!o.extensions[t])return null;const r=o.extensions[t],s=i.images[r.source];let l=n.textureLoader;if(s.uri){const c=n.options.manager.getHandler(s.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return n.loadTextureImage(e,r.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("v3d.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class GI{constructor(e){this.name=Fe.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const i=n.extensions[this.name],o=this.parser.getDependency("buffer",i.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("v3d.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([o,r.ready]).then(function(s){const l=i.byteOffset||0,c=i.byteLength||0,d=i.count,u=i.byteStride,h=new ArrayBuffer(d*u),p=new Uint8Array(s[0],l,c);return r.decodeGltfBuffer(new Uint8Array(h),d,u,p,i.mode,i.filter),h})}return null}}class kI{constructor(e){this.name=Fe.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const i=t.meshes[n.mesh];for(const l of i.primitives)if(l.mode!==Kn.TRIANGLES&&l.mode!==Kn.TRIANGLE_STRIP&&l.mode!==Kn.TRIANGLE_FAN&&l.mode!==void 0)return null;const o=n.extensions[this.name].attributes,r=[],s={};for(const l in o)r.push(this.parser.getDependency("accessor",o[l]).then(c=>(s[l]=c,s[l])));return r.length<1?null:(r.push(this.parser.createNodeMesh(e)),Promise.all(r).then(l=>{const c=l.pop(),d=c.isGroup?c.children:[c],u=l[0].count,h=[];for(const p of d){const m=new Ae,f=new b,g=new Ge,_=new b(1,1,1),A=new InstancedMesh(p.geometry,p.material,u);for(let x=0;x<u;x++)s.TRANSLATION&&f.fromBufferAttribute(s.TRANSLATION,x),s.ROTATION&&g.fromBufferAttribute(s.ROTATION,x),s.SCALE&&_.fromBufferAttribute(s.SCALE,x),A.setMatrixAt(x,m.compose(f,g,_));for(const x in s)x!=="TRANSLATION"&&x!=="ROTATION"&&x!=="SCALE"&&p.geometry.setAttribute(x,s[x]);ze.prototype.copy.call(A,p),A.frustumCulled=!1,this.parser.assignFinalMaterial(A),h.push(A)}return c.isGroup?(c.clear(),c.add(...h),c):h[0]}))}}const K1="glTF",w0={JSON:1313821514,BIN:5130562};class QI{constructor(e){this.name=Fe.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,12);if(this.header={magic:ti.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==K1)throw new Error("v3d.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("v3d.GLTFLoader: Legacy binary file detected.");const n=this.header.length-12,i=new DataView(e,12);let o=0;for(;o<n;){const r=i.getUint32(o,!0);o+=4;const s=i.getUint32(o,!0);if(o+=4,s===w0.JSON){const l=new Uint8Array(e,12+o,r);this.content=ti.decodeText(l)}else if(s===w0.BIN){const l=12+o;this.body=e.slice(l,l+r)}o+=r}if(this.content===null)throw new Error("v3d.GLTFLoader: JSON content not found.")}}class WI{constructor(e,t){if(!t)throw new Error("v3d.GLTFLoader: No DRACOLoader instance provided.");this.name=Fe.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,i=this.dracoLoader,o=e.extensions[this.name].bufferView,r=e.extensions[this.name].attributes,s={},l={},c={};for(const d in r){const u=_h[d]||xh(d)||d.toLowerCase();s[u]=r[d]}for(const d in e.attributes){const u=_h[d]||xh(d)||d.toLowerCase();if(r[d]!==void 0){const h=n.accessors[e.attributes[d]],p=sa[h.componentType];c[u]=p,l[u]=h.normalized===!0}}return t.getDependency("bufferView",o).then(function(d){return new Promise(function(u){i.decodeDracoFile(d,function(h){for(const p in h.attributes){const m=h.attributes[p],f=l[p];f!==void 0&&(m.normalized=f)}u(h)},s,c)})})}}class HI{constructor(){this.name=Fe.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return t.texCoord!==void 0&&console.warn('v3d.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class XI{constructor(){this.name=Fe.KHR_MESH_QUANTIZATION}}class YI{constructor(e){this.parser=e,this.name=Fe.S8S_V3D_LIGHTS,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,i=t.length;n<i;n++){const o=t[n];o.extensions&&o.extensions[this.name]&&o.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,o.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let i=t.cache.get(n);if(i)return i;const o=t.json,r=((o.extensions&&o.extensions[this.name]||{}).lights||[])[e];let s;const l=new me().fromArray(r.color),c=r.intensity??1;switch(r.type){case"point":s=new lu(l,c);break;case"directional":s=new uu(l,c);break;case"spot":s=new su(l,c);break;case"area":s=new fp(l,c,r.width,r.height);break;case"hemisphere":s=new hp(l,new me(0,0,0),c);break;case"ambient":s=new pp(l,c)}let d;return q(r.distance)&&(s.distance=r.distance),q(r.decay)&&(s.decay=r.decay,r.profile!="blender"||q(r.power)||(s.userData.usePowerUnits=!0,s.power=c)),q(r.power)&&(s.userData.usePowerUnits=!0,s.power=r.power),q(r.angle)&&(s.angle=r.angle),q(r.penumbra)&&(s.penumbra=r.penumbra),s.isRectAreaLight&&W1.init(r.ltcMat1,r.ltcMat2),q(r.shadow)?(q(r.shadow.enabled)||(r.shadow.enabled=!0),s.castShadow=r.shadow.enabled,s.shadow.bias=r.shadow.bias,q(r.shadow.expBias)&&(s.shadow.expBias=r.shadow.expBias),q(r.shadow.slopeScaledBias)&&(s.shadow.slopeScaledBias=r.shadow.slopeScaledBias),s.shadow.radius=r.shadow.radius,s.shadow.mapSize.width=r.shadow.mapSize,s.shadow.mapSize.height=r.shadow.mapSize,s.shadow.camera.near=r.shadow.cameraNear,s.shadow.camera.far=r.shadow.cameraFar,s.isSpotLight?(s.shadow.camera.fov=Xc(r.shadow.cameraFov),s.shadow.useMinFov90=r.profile==="blender"):s.isDirectionalLight&&(q(r.shadow.cameraOrthoLeft)&&q(r.shadow.cameraOrthoRight)&&q(r.shadow.cameraOrthoBottom)&&q(r.shadow.cameraOrthoTop)&&(s.shadow.camera.left=r.shadow.cameraOrthoLeft,s.shadow.camera.right=r.shadow.cameraOrthoRight,s.shadow.camera.bottom=r.shadow.cameraOrthoBottom,s.shadow.camera.top=r.shadow.cameraOrthoTop),s.shadow.maxDistance=r.shadow.cameraFar,q(r.shadow.csm)&&(q(r.shadow.csm.count)&&(s.shadow.numCascades=r.shadow.csm.count),q(r.shadow.csm.maxDistance)&&(s.shadow.maxDistance=r.shadow.csm.maxDistance),q(r.shadow.csm.fade)&&(s.shadow.fade=r.shadow.csm.fade),q(r.shadow.csm.exponent)&&(s.shadow.exponent=r.shadow.csm.exponent),q(r.shadow.csm.lightMargin)&&(s.shadow.lightMargin=r.shadow.csm.lightMargin)),s.shadow.createCascades()),s.shadow.camera.updateProjectionMatrix()):s.castShadow=!1,s.name=t.createUniqueName(r.name||"light_"+e),(s.isDirectionalLight||s.isSpotLight)&&q(r.target)?(s.isFreeLight=!1,d=t.getDependency("node",r.target)):((s.isDirectionalLight||s.isSpotLight)&&(s.isFreeLight=!0),d=Promise.resolve()),d.then(u=>(u&&(s.target=u),i=Promise.resolve(s),t.cache.add(n,i),i))}createNodeAttachment(e){const t=this,n=this.parser,i=n.json.nodes[e],o=(i.extensions&&i.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(r){return n._getNodeRef(t.cache,o,r)})}}class jI{constructor(e){this.parser=e,this.name=Fe.S8S_V3D_LIGHT_PROBES,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,i=t.length;n<i;n++){const o=t[n];o.extensions&&o.extensions[this.name]&&o.extensions[this.name].lightProbe!==void 0&&e._addNodeRef(this.cache,o.extensions[this.name].lightProbe)}}_loadLightProbe(e){const t=this.parser,n="lightProbe:"+e;let i=t.cache.get(n);if(i)return i;const o=t.json,r=((o.extensions&&o.extensions[this.name]||{}).lightProbes||[])[e];let s;const l=r.type||"CUBEMAP";if(l=="CUBEMAP"||l=="SPHERE"){switch(s=new pu,r.influenceType){case"ELIPSOID":s.influenceType=1;break;case"BOX":s.influenceType=2}switch(r.parallaxType){case"ELIPSOID":s.parallaxType=1;break;case"BOX":s.parallaxType=2}s.parallaxDistance=r.parallaxDistance,s.probeClipEnd=r.clipEnd,s.probeIntensity=r.intensity,q(r.influenceGroup)&&(s.influenceGroup=r.influenceGroup),q(r.influenceGroupInv)&&(s.influenceGroupInv=r.influenceGroupInv)}else s=new Q1,s.falloff=r.falloff,q(r.planeSize)&&s.planeSize.set(r.planeSize[0],r.planeSize[1]);return s.influenceDistance=r.influenceDistance,s.probeClipStart=r.clipStart,s.visibilityGroup=r.visibilityGroup,s.visibilityGroupInv=r.visibilityGroupInv,s.name=t.createUniqueName(r.name||"lightProbe_"+e),i=Promise.resolve(s),t.cache.add(n,i),i}createNodeAttachment(e){const t=this,n=this.parser,i=n.json.nodes[e],o=(i.extensions&&i.extensions[this.name]||{}).lightProbe;return o===void 0?null:this._loadLightProbe(o).then(function(r){return n._getNodeRef(t.cache,o,r)})}}class KI{constructor(e){this.parser=e,this.name=Fe.S8S_V3D_CURVES,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,i=t.length;n<i;n++){const o=t[n];o.extensions&&o.extensions[this.name]&&o.extensions[this.name].curve!==void 0&&e._addNodeRef(this.cache,o.extensions[this.name].curve)}}_loadOpenType(){return new Promise(function(e){Fg("opentype.js",function(){e()},function(){console.error("GLTFLoader: opentype.js module not found, please copy it to your app directory"),e()})})}_loadFont(e){const t=this.parser,n="curve:"+e;let i=t.cache.get(n);if(i)return i;const o=t.json,r=((o.extensions&&o.extensions[this.name]||{}).fonts||[])[e];let s=r.uri,l=!1;return r.bufferView!==void 0&&(s=t.getDependency("bufferView",r.bufferView).then(function(c){l=!0;const d=new Blob([c],{type:r.mimeType});return s=URL.createObjectURL(d),s})),Promise.all([this._loadOpenType(),s]).then(function(c){if(s=c[1],typeof opentype>"u")return null;const d=new k1;return d.setCrossOrigin(t.options.crossOrigin),new Promise(function(u,h){d.load(ti.resolveURL(s,t.options.path),u,void 0,h)}).then(function(u){return new Ep(u)},function(u){return null})}).then(function(c){return l===!0&&URL.revokeObjectURL(s),i=Promise.resolve(c),t.cache.add(n,i),i})}_loadCurve(e){const t=this.parser,n="curve:"+e;let i=t.cache.get(n);if(i)return i;const o=t.json,r=((o.extensions&&o.extensions[this.name]||{}).curves||[])[e];let s,l=r.type;const c=[];return c.push(this._loadFont(r.font)),r.material!==void 0?c.push(t.getDependency("material",r.material)):c.push(J1(t.cache)),Promise.all(c).then(function(d){const u=d[0],h=d[1];if(u===null&&(l="empty"),l==="font"){const p=r.bevelSize>0||r.bevelThickness>0,m=new Ra(r.text,{font:u,size:r.size,height:r.height,curveSegments:r.curveSegments,bevelEnabled:p,bevelThickness:r.bevelThickness,bevelSize:r.bevelSize,bevelSegments:r.bevelSegments,alignX:r.alignX,alignY:r.alignY,lineHeight:r.lineHeight,scaledEmSize:r.scaledEmSize});s=new Ue(m,h)}else s=new ze;return s.name=t.createUniqueName(r.name||"curve_"+e),i=Promise.resolve(s),t.cache.add(n,i),i})}createNodeAttachment(e){const t=this,n=this.parser,i=n.json.nodes[e],o=(i.extensions&&i.extensions[this.name]||{}).curve;return o===void 0?null:this._loadCurve(o).then(function(r){return n._getNodeRef(t.cache,o,r)})}}class qI{constructor(e){this.parser=e,this.name=Fe.S8S_V3D_CLIPPING_PLANES,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,i=t.length;n<i;n++){const o=t[n];o.extensions&&o.extensions[this.name]&&o.extensions[this.name].clippingPlane!==void 0&&e._addNodeRef(this.cache,o.extensions[this.name].clippingPlane)}}_loadClippingPlane(e){const t=this.parser,n="clippingPlane:"+e;let i=t.cache.get(n);if(i)return i;const o=t.json,r=((o.extensions&&o.extensions[this.name]||{}).clippingPlanes||[])[e],s=new H1;return s.clippingGroup=r.clippingGroup,s.clipShadows=r.clipShadows,s.negated=r.negated,s.clipIntersection=r.clipIntersection,s.crossSection=r.crossSection,s.crossSectionColor=new me().fromArray(r.color),s.crossSectionOpacity=r.opacity,s.crossSectionSize=r.size,q(r.renderSide)&&(s.crossSectionRenderSide=Z1[r.renderSide]),s.name=t.createUniqueName(r.name||"clippingPlane_"+e),i=Promise.resolve(s),t.cache.add(n,i),i}createNodeAttachment(e){const t=this,n=this.parser,i=n.json.nodes[e],o=(i.extensions&&i.extensions[this.name]||{}).clippingPlane;return o===void 0?null:this._loadClippingPlane(o).then(function(r){return n._getNodeRef(t.cache,o,r)})}}class ZI{constructor(e){this.name=Fe.S8S_V3D_SCENE,this.parser=e}beforeRoot(){let e=this.parser.json.asset.generator||"";e.indexOf("Verge3D")>-1&&(e.match(/(\d+).(\d+).(\d+)/)||(e+=" v0.0.0"),Og(e,pr,2)<0&&console.warn("Loading glTF asset in older version of Verge3D runtime. Please update your application."))}afterRoot(e){const t=this.parser,n=t.json,i=n.scenes[n.scene||0],o=e.scene,r=q(i.extensions)?i.extensions[Fe.S8S_V3D_SCENE]:void 0,s=[],l=[],c=[];let d;return d=i&&r&&q(r.worldMaterial)?t.getDependency("material",r.worldMaterial):Promise.resolve(),d.then(u=>{const h={};u&&(h.material=u),e.world=h}).then(()=>(t.assignedMaterials.forEach(function(u){u.isMeshNodeMaterial&&u.traverseNodes(function(h){h.originData.type==="TEX_COORD_BL"&&q(h.originData.object)&&h.originData.object>-1&&(s.push(t.getDependency("node",h.originData.object)),l.push(h),c.push(u))})}),Promise.all(s))).then(u=>{for(let m=0;m<u.length;m++){const f=u[m],g=l[m],_=c[m],A=_.nodeTexCoordObjectMap[g.originData.name];_.nodeTexCoordObject[A]=f}const h=[];for(let m=0;m<e.cameras.length;m++){const f=e.cameras[m];let g=!1;f.traverseAncestors(function(_){_==o&&(g=!0)}),g&&h.push(f)}e.cameras=h;for(let m=0;m<e.animations.length;m++){const f=e.animations[m];f.clip&&f.clip.name!==void 0&&(f.clip.name=f.clip.name)}const p={};if(i){const m=q(i.extensions)?i.extensions[Fe.S8S_V3D_SCENE]:void 0;if(m){if(q(m.shadowMap)){switch(p.shadowMap={enabled:!0},m.shadowMap.type){case"BASIC":p.shadowMap.type=na;break;case"BILINEAR":p.shadowMap.type=sr;break;case"PCF":p.shadowMap.type=Io;break;case"PCFSOFT":p.shadowMap.type=Po;break;case"PCFPOISSON":p.shadowMap.type=ar;break;case"ESM":p.shadowMap.type=Vn}let f;f=m.shadowMap.renderSingleSided?m.shadowMap.renderReverseSided?nn:kn:Tn,o.traverse(function(g){const _=g.material;_&&(_.shadowSide=f)}),p.esmDistanceScale=m.shadowMap.esmDistanceScale}if(q(m.physicallyCorrectLights)&&(p.physicallyCorrectLights=m.physicallyCorrectLights),q(m.aaMethod)&&(p.aaMethod=m.aaMethod),q(m.useHDR)&&(p.useHDR=m.useHDR),q(m.useOIT)&&(p.useOIT=m.useOIT),q(m.unitsScaleFactor)&&(p.unitsScaleFactor=m.unitsScaleFactor),q(m.toneMapping)){switch(m.toneMapping.type){case"logarithmicMax":p.toneMapping=kc,p.toneMappingBrightness=m.toneMapping.brightness,p.toneMappingContrast=m.toneMapping.contrast,p.toneMappingMidTones=m.toneMapping.midTones,p.toneMappingPhysicalScale=m.toneMapping.physicalScale,p.toneMappingChromaticAdaptation=m.toneMapping.chromaticAdaptation,p.toneMappingWhiteColor=new me().fromArray(m.toneMapping.whiteColor),p.toneMappingColorDifferentiation=m.toneMapping.colorDifferentiation,p.toneMappingExteriorDaylight=m.toneMapping.exteriorDaylight;break;case"physicalMax":p.toneMapping=Qc,p.toneMappingWhiteBalance=new me().fromArray(m.toneMapping.whiteBalance),p.toneMappingHighlights=m.toneMapping.highlights,p.toneMappingMidTones=m.toneMapping.midTones,p.toneMappingShadows=m.toneMapping.shadows,p.toneMappingSaturation=m.toneMapping.saturation,p.toneMappingPhysicalScale=m.toneMapping.physicalScale,p.toneMappingAperture=m.toneMapping.aperture,p.toneMappingShutter=m.toneMapping.shutter,p.toneMappingISO=m.toneMapping.iso,p.toneMappingVignetting=m.toneMapping.vignetting;break;case"filmicBlender":p.toneMapping=Ph;break;case"agxBlender":p.toneMapping=Bh}switch(m.toneMapping.look){case"NONE":p.toneMappingLook=rs;break;case"AGX_PUNCHY":p.toneMappingLook=Dh;break;default:m.toneMapping.type==="agxBlender"&&console.warn(`v3d.GLTFLoader: ${m.toneMapping.look} look is not supported, fallback to None`),p.toneMappingLook=rs}}if(q(m.pmremMaxTileSize)&&(p.pmremMaxTileSize=m.pmremMaxTileSize),q(m.iblEnvironmentMode))switch(m.iblEnvironmentMode){case"PMREM":default:p.iblEnvironmentMode=0;break;case"PROBE_CUBEMAP":console.warn("v3d.GLTFLoader: Cubemap probes deprecated since Verge3D 4.3, using PMREM instead"),p.iblEnvironmentMode=0;break;case"PROBE":p.iblEnvironmentMode=2;break;case"NONE":p.iblEnvironmentMode=3}q(m.postprocessing)&&(o.postprocessing=m.postprocessing)}}e.renderer=p})}}class JI{constructor(e){this.name=Fe.S8S_V3D_NODE,this.parser=e}extendNodeParams(e,t){const n=t.extensions&&t.extensions[this.name];if(!n)return e;if(n.hidden&&(e.visible=!1),e.isMesh&&(q(n.useCastShadows)?e.castShadow=n.useCastShadows:q(e.material.castShadow)&&(e.castShadow=e.material.castShadow),q(n.useShadows)?e.receiveShadow=n.useShadows:q(e.material.receiveShadow)&&(e.receiveShadow=e.material.receiveShadow)),q(n.objectIndex)&&(e.objectIndex=n.objectIndex),q(n.objectColor)&&(e.objectColor=new me().fromArray(n.objectColor),e.objectAlpha=q(n.objectColor[3])?n.objectColor[3]:1),e.renderOrder=n.renderOrder,e.frustumCulled=n.frustumCulling,q(n.groupNames)&&(e.groupNames=n.groupNames),q(n.hidpiCompositing)&&(e.hidpiCompositing=n.hidpiCompositing),e.isMesh&&e.material.isMeshNodeMaterial){const i=e.material;(i.hasNode("MATTE_SHADOW_MX")||i.hasNode("SHADOW_MATTE_AR")||i.hasNode("AI_SHADOW_MATTE_MY"))&&(i.transparent=!1,i.premultipliedAlpha=!0,nv(i),e.renderOrder-=1e3,e.castShadow=!1,e.receiveShadow=!0)}return this.processConstraints(e,n.constraints)}processConstraints(e,t=[]){if(e.isMaterialGeneratedMesh)return e;const n=this.parser,i=[];for(let o=0;o<t.length;o++){const r=t[o];q(r.target)?i.push(n.getDependency("node",r.target)):i.push(Promise.resolve(null))}return Promise.all(i).then(function(o){for(let r=0;r<t.length;r++){const s=t[r],l=o[r];let c;switch(s.type){case"copyLocation":c=new Tp(l),c.useX=!q(s.useX)||s.useX,c.useY=!q(s.useY)||s.useY,c.useZ=!q(s.useZ)||s.useZ,c.invertX=!!q(s.invertX)&&s.invertX,c.invertY=!!q(s.invertY)&&s.invertY,c.invertZ=!!q(s.invertZ)&&s.invertZ,c.useOffset=!q(s.useOffset)||s.useOffset,c.influence=q(s.influence)?s.influence:1;break;case"copyRotation":c=new Ip(l),c.useX=!q(s.useX)||s.useX,c.useY=!q(s.useY)||s.useY,c.useZ=!q(s.useZ)||s.useZ,c.invertX=!!q(s.invertX)&&s.invertX,c.invertY=!!q(s.invertY)&&s.invertY,c.invertZ=!!q(s.invertZ)&&s.invertZ,c.mixMode=q(s.mixMode)?s.mixMode:"REPLACE",c.influence=q(s.influence)?s.influence:1,c.fixCameraLightRotation=!!q(s.fixCameraLightRotation)&&s.fixCameraLightRotation;break;case"copyScale":c=new Rp(l),c.useX=!q(s.useX)||s.useX,c.useY=!q(s.useY)||s.useY,c.useZ=!q(s.useZ)||s.useZ,c.power=q(s.power)?s.power:1,c.useMakeUniform=!!q(s.useMakeUniform)&&s.useMakeUniform,c.useOffset=!!q(s.useOffset)&&s.useOffset,c.useAdd=!!q(s.useAdd)&&s.useAdd,c.influence=q(s.influence)?s.influence:1;break;case"copyTransforms":c=new Lp(l),c.mixMode=q(s.mixMode)?s.mixMode:"REPLACE",c.influence=q(s.influence)?s.influence:1,c.fixCameraLightRotation=!!q(s.fixCameraLightRotation)&&s.fixCameraLightRotation;break;case"dampedTrack":c=new Pp(l),c.trackAxis=s.trackAxis,c.influence=q(s.influence)?s.influence:1,c.fixCameraLightRotation=!!q(s.fixCameraLightRotation)&&s.fixCameraLightRotation;break;case"limitDistance":c=new Dp(l),c.distance=q(s.distance)?s.distance:0,c.limitMode=q(s.limitMode)?s.limitMode:"LIMITDIST_INSIDE",c.useTransformLimit=!!q(s.useTransformLimit)&&s.useTransformLimit,c.influence=q(s.influence)?s.influence:1;break;case"limitLocation":switch(c=new Np(l),s.space){case"CUSTOM":c.space=1;break;case"WORLD":c.space=0;break;default:c.space=2}c.min.set(Number(s.minX),Number(s.minY),Number(s.minZ)),c.max.set(Number(s.maxX),Number(s.maxY),Number(s.maxZ));break;case"limitRotation":c=new Op,c.axis=s.axis,c.min=s.min,c.max=s.max;break;case"limitScale":c=new Fp,c.min.set(Number(s.minX),Number(s.minY),Number(s.minZ)),c.max.set(Number(s.maxX),Number(s.maxY),Number(s.maxZ));break;case"lockedTrack":c=new Up(l),c.trackAxis=s.trackAxis,c.lockAxis=s.lockAxis,c.fixCameraLightRotation=!!q(s.fixCameraLightRotation)&&s.fixCameraLightRotation;break;case"trackTo":c=new zp(l),c.trackAxis=s.trackAxis,c.upAxis=s.upAxis,c.fixCameraLightRotation=!!q(s.fixCameraLightRotation)&&s.fixCameraLightRotation;break;case"childOf":c=new wp(l),c.offsetMatrix=new Ae().fromArray(s.offsetMatrix),c.fixCameraLightRotation=!!q(s.fixCameraLightRotation)&&s.fixCameraLightRotation;break;case"floor":c=new Bp(l),c.floorLocation=s.floorLocation,c.offset=s.offset,c.useRotation=!!q(s.useRotation)&&s.useRotation;break;case"fixOrthoZoom":c=new Vp(l);break;case"canvasFit":c=new Gp(l),c.edgeH=s.edgeH,c.edgeV=s.edgeV,c.fitShape=s.fitShape,c.offset=s.offset,s.fitShape=="SPHERE"&&e.resolveMultiMaterial().forEach(function(d){d.geometry&&d.geometry.computeBoundingSphere()});break;case"canvasBreakpoints":c=new kp,c.minWidth=Number(s.minWidth),c.maxWidth=Number(s.maxWidth),c.minHeight=Number(s.minHeight),c.maxHeight=Number(s.maxHeight),c.orientation=s.orientation;break;case"motionPath":c=new Hp,c.degree=s.degree,c.cvs=[];for(let d=0;d<s.cvs.length;++d)c.cvs.push(Number(s.cvs[d]));c.knots=[];for(let d=0;d<s.knots.length;++d)c.knots.push(Number(s.knots[d]));c.weights=[];for(let d=0;d<s.weights.length;++d)c.weights.push(Number(s.weights[d]));if(c.value=q(s.value)?s.value:0,c.follow=!!q(s.follow)&&s.follow,c.frontAxis=q(s.frontAxis)?s.frontAxis:"Z",c.upAxis=q(s.upAxis)?s.upAxis:"Y",c.worldUpVector=q(s.worldUpVector)?new b().fromArray(s.worldUpVector).normalize():new b(0,1,0),c.useChordLength=!!q(s.useChordLength)&&s.useChordLength,c.bank=!!q(s.bank)&&s.bank,c.bankScale=q(s.bankScale)?s.bankScale:1,c.bankLimit=q(s.bankLimit)?s.bankLimit:1/0,c.useFixedLocation=!!q(s.useFixedLocation)&&s.useFixedLocation,c.fixedValue=q(s.fixedValue)?s.fixedValue:0,c.usePointsTilt=!!q(s.usePointsTilt)&&s.usePointsTilt,c.pointsTilt=[],q(s.pointsTilt))for(let d=0;d<s.pointsTilt.length;++d)c.pointsTilt.push(Number(s.pointsTilt[d]));c.offsetValue=q(s.offsetValue)?s.offsetValue:0,c.useClampValue=!!q(s.useClampValue)&&s.useClampValue,c.useCyclic=!!q(s.useCyclic)&&s.useCyclic,c.useObjOffset=!!q(s.useObjOffset)&&s.useObjOffset,c.useRelative=!!q(s.useRelative)&&s.useRelative,c.usePosOffset=!q(s.usePosOffset)||s.usePosOffset,c.objOffsetMode=q(s.objOffsetMode)?s.objOffsetMode:0,c.objOffsetRotMode=q(s.objOffsetRotMode)?s.objOffsetRotMode:0,c.influence=q(s.influence)?s.influence:1,c.fixCameraLightRotation=!!q(s.fixCameraLightRotation)&&s.fixCameraLightRotation,c.init()}c&&(c.name=s.name,c.mute=s.mute,e.constraints.push(c))}return e})}}class $I{constructor(e){this.name=Fe.S8S_V3D_CAMERA,this.parser=e}extendCameraParams(e,t){const n=this.parser,i=t.extensions&&t.extensions[this.name];if(!i)return Promise.resolve(e);if(e.controls=new X1(i.controls,i.enablePan,i.rotateSpeed,i.moveSpeed),e.viewportFit.type=3,q(i.viewportFitType))switch(i.viewportFitType){case"VERTICAL":e.viewportFit.type=1;break;case"HORIZONTAL":e.viewportFit.type=2;break;case"AUTO":e.viewportFit.type=3;break;case"FILL":e.viewportFit.type=4;break;case"OVERSCAN":e.viewportFit.type=5}q(i.viewportFitInitialAspect)&&(e.viewportFit.initialAspect=i.viewportFitInitialAspect),q(i.orbitMinDistance)&&(e.controls.orbitMinDistance=i.orbitMinDistance),q(i.orbitMaxDistance)&&(e.controls.orbitMaxDistance=i.orbitMaxDistance),q(i.orbitMinZoom)&&(e.controls.orbitMinZoom=i.orbitMinZoom),q(i.orbitMaxZoom)&&(e.controls.orbitMaxZoom=i.orbitMaxZoom),q(i.orbitMinPolarAngle)&&(e.controls.orbitMinPolarAngle=i.orbitMinPolarAngle),q(i.orbitMaxPolarAngle)&&(e.controls.orbitMaxPolarAngle=i.orbitMaxPolarAngle),q(i.orbitMinAzimuthAngle)&&(e.controls.orbitMinAzimuthAngle=i.orbitMinAzimuthAngle),q(i.orbitMaxAzimuthAngle)&&(e.controls.orbitMaxAzimuthAngle=i.orbitMaxAzimuthAngle);const o=[];if(q(i.orbitTarget))if(i.orbitTarget instanceof Array){const r=new ze;r.position.fromArray(i.orbitTarget),o.push(Promise.resolve(r))}else o.push(n.getDependency("node",i.orbitTarget));else o.push(Promise.resolve());return q(i.fpsCollisionMaterial)?o.push(n.getDependency("material",i.fpsCollisionMaterial)):o.push(Promise.resolve()),q(i.fpsGazeLevel)&&(e.controls.gazeLevel=i.fpsGazeLevel),q(i.fpsStoryHeight)&&(e.controls.storyHeight=i.fpsStoryHeight),q(i.enablePointerLock)&&(e.controls.enablePointerLock=i.enablePointerLock),Promise.all(o).then(r=>(r[0]&&(e.controls.orbitTarget=r[0]),r[1]&&(e.controls.collisionMaterial=r[1]),e))}}class eR{constructor(e){this.name=Fe.S8S_V3D_MATERIALS,this.parser=e}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?wt:null}extendMaterialParams(e,t){const n=this.parser.json,i=n.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=i.extensions[this.name],r=[];if(q(o.nodeGraph)){const s=wt.nodeGraphFromExtGraph(o.nodeGraph);t.nodeGraph=s,wt.nodeGraphTraverse(s,c=>{const d=c.originData;if(E0.indexOf(d.type)>-1&&q(d.texture)){const u=wt.nodeTexUniName(d.type,d.texture);r.push(this.assignTextureNode(t,u,d.texture))}else d.type=="RAMP_MY"&&(d.wrapS=Uc[d.wrapS]||Qn,d.wrapT=Uc[d.wrapT]||Qn)});const l=n.extensions&&n.extensions[this.name]||{};if(l&&l.nodeGraphs){t.additionalNodeGraphs={};for(let c in l.nodeGraphs){const d=wt.nodeGraphFromExtGraph(l.nodeGraphs[c]);t.additionalNodeGraphs[c]=d,wt.nodeGraphTraverse(d,u=>{const h=u.originData;if(E0.indexOf(h.type)>-1){const p=wt.nodeTexUniName(h.type,h.texture);r.push(this.assignTextureNode(t,p,h.texture))}})}}}return q(o.profile)&&(t.profile=o.profile),q(o.renderSide)&&(t.side=Z1[o.renderSide]),q(o.useShadows)&&(t.receiveShadow=o.useShadows),q(o.useCastShadows)&&(t.castShadow=o.useCastShadows),q(o.depthWrite)&&(t.depthWrite=o.depthWrite),q(o.depthPrepass)&&(t.depthPrepass=o.depthPrepass),q(o.depthTest)&&(t.depthTest=o.depthTest),q(o.dithering)&&(t.dithering=o.dithering),q(o.materialIndex)&&(t.materialIndex=o.materialIndex),o.alphaToCoverage===!0&&(t.alphaToCoverage=!0),q(o.gtaoVisible)&&(t.gtaoVisible=o.gtaoVisible),delete t.metalness,delete t.roughness,Promise.all(r)}assignTextureNode(e,t,n){return this.parser.getDependency("texture",n).then(function(i){e.nodeTextures=e.nodeTextures||{},e.nodeTextures[t]=i})}assignTransparency(e,t,n){const i=t.extensions[this.name]||{};if(e.premultipliedAlpha=n==ns.BLEND,n==ns.BLEND)if(q(i.blendMode)){const o=i.blendMode;e.blending=no,q(o.blendEquation)&&(e.blendEquation=I0[o.blendEquation]),q(o.blendEquationAlpha)&&(e.blendEquationAlpha=I0[o.blendEquationAlpha]),q(o.srcRGB)&&(e.blendSrc=nc[o.srcRGB]),q(o.dstRGB)&&(e.blendDst=nc[o.dstRGB]),q(o.srcAlpha)&&(e.blendSrcAlpha=nc[o.srcAlpha]),q(o.dstAlpha)&&(e.blendDstAlpha=nc[o.dstAlpha])}else e.useAddTransparency()?e.blending=os:nv(e)}}class tR{constructor(e){this.parser=e,this.name=Fe.S8S_V3D_TEXTURE,this.textureLoaderRGBE=new vh,this.textureLoaderRGBE.setCrossOrigin(this.parser.options.crossOrigin),this.textureLoaderRGBE.setRequestHeader(this.parser.options.requestHeader)}loadTexture(e){const t=this.name,n=this.parser,i=n.json,o=i.textures[e];if(!o.extensions||!o.extensions[t])return null;const r=o.extensions[t];if(!q(r.source))return null;const s=i.images[r.source];let l=n.textureLoader;if((s.uri||"").split(".").pop()=="hdr"||s.mimeType=="image/vnd.radiance"?l=this.textureLoaderRGBE:(s.uri||"").split(".").pop()!="xz"&&s.mimeType!="application/x-xz"||(l=new Is),s.uri){const c=n.options.manager.getHandler(s.uri);c!==null&&(l=c)}return n.loadTextureImage(e,r.source,l)}extendTextureParams(e,t,n){const i=this.name;if(!t.extensions||!t.extensions[i])return null;const o=t.extensions[i],r=o.colorSpace=="linear"||o.colorSpace=="linear rec.709"||o.colorSpace=="non-color"?_n:Ke;e.encoding=r,(n instanceof vh||n instanceof Is)&&(e.minFilter=Le),q(o.anisotropy)&&(e.anisotropy=o.anisotropy),q(o.uvTransform)&&(e.matrix=new ln().fromArray(o.uvTransform),e.matrixAutoUpdate=!1)}}class q1 extends La{constructor(e,t,n,i){super(e,t,n,i)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,o=e*i*3+i;for(let r=0;r!==i;r++)t[r]=n[o+r];return t}interpolate_(e,t,n,i){const o=this.resultBuffer,r=this.sampleValues,s=this.valueSize,l=2*s,c=3*s,d=i-t,u=(n-t)/d,h=u*u,p=h*u,m=e*c,f=m-c,g=-2*p+3*h,_=p-h,A=1-g,x=_-h+u;for(let S=0;S!==s;S++){const M=r[f+S+s],T=r[f+S+l]*d,L=r[m+S+s],z=r[m+S]*d;o[S]=A*M+x*T+g*L+_*z}return o}}const nR=new Ge;class iR extends q1{interpolate_(e,t,n,i){const o=super.interpolate_(e,t,n,i);return nR.fromArray(o).normalize().toArray(o),o}}const Kn={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},sa={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},T0={9728:st,9729:Le,9984:ca,9985:Bs,9986:cr,9987:In},Uc={33071:mt,33648:fr,10497:Qn},I0={32774:tn,32778:Ch,32779:Sh},nc={0:Ls,1:ei,768:Mh,769:Eh,770:xr,771:Ri,772:wh,773:Th,774:Ih,775:Rh,776:Lh},Td={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},_h={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Yi={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences",intensity:"intensity",power:"power"},oR={CUBICSPLINE:void 0,LINEAR:2301,STEP:2300},ns={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"},Z1={FRONT:kn,BACK:nn,DOUBLE:Tn};function J1(a){return a.DefaultMaterial===void 0&&(a.DefaultMaterial=new Zs({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:kn,receiveShadow:!0,castShadow:!0})),a.DefaultMaterial}function Xa(a,e,t){for(const n in t.extensions)a[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function wo(a,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(a.userData,e.extras):console.warn("v3d.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function rR(a,e,t){let n=!1,i=!1,o=!1;for(let c=0,d=e.length;c<d;c++){const u=e[c];if(u.POSITION!==void 0&&(n=!0),u.NORMAL!==void 0&&(i=!0),u.COLOR_0!==void 0&&(o=!0),n&&i&&o)break}if(!n&&!i&&!o)return Promise.resolve(a);const r=[],s=[],l=[];for(let c=0,d=e.length;c<d;c++){const u=e[c];if(n){const h=u.POSITION!==void 0?t.getDependency("accessor",u.POSITION):a.attributes.position;r.push(h)}if(i){const h=u.NORMAL!==void 0?t.getDependency("accessor",u.NORMAL):a.attributes.normal;s.push(h)}if(o){const h=u.COLOR_0!==void 0?t.getDependency("accessor",u.COLOR_0):a.attributes.color;l.push(h)}}return Promise.all([Promise.all(r),Promise.all(s),Promise.all(l)]).then(function(c){const d=c[0],u=c[1],h=c[2];return n&&(a.morphAttributes.position=d),i&&(a.morphAttributes.normal=u),o&&(a.morphAttributes.color=h),a.morphTargetsRelative=!0,a})}function aR(a,e){if(a.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)a.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(a.morphTargetInfluences.length===t.length){a.morphTargetDictionary={};for(let n=0,i=t.length;n<i;n++)a.morphTargetDictionary[t[n]]=n}else console.warn("v3d.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function sR(a){const e=a.extensions&&a.extensions[Fe.KHR_DRACO_MESH_COMPRESSION];let t;return t=e?"draco:"+e.bufferView+":"+e.indices+":"+R0(e.attributes):a.indices+":"+R0(a.attributes)+":"+a.mode,t}function R0(a){let e="";const t=Object.keys(a).sort();for(let n=0,i=t.length;n<i;n++)e+=t[n]+":"+a[t[n]]+";";return e}function Ah(a){switch(a){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("v3d.GLTFLoader: Unsupported normalized accessor component type.")}}function lR(a){return a.search(/\.jpe?g($|\?)/i)>0||a.search(/^data\:image\/jpeg/)===0?"image/jpeg":a.search(/\.webp($|\?)/i)>0||a.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}new Ae;class cR{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.onProgress=t.onProgress||function(){},this.cache=new TI,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,i=!1,o=-1;typeof navigator<"u"&&(n=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,i=navigator.userAgent.indexOf("Firefox")>-1,o=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||n||i&&o<98?this.textureLoader=new dp(this.options.manager):this.textureLoader=new R1(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new cn(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0),this.assignedMaterials=[]}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,i=this.json,o=this.extensions;this.cache.removeAll(),this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(r){const s={scene:r[0][i.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:i.asset,parser:n,userData:{}};Xa(o,s,i),wo(s,i),Promise.all(n._invokeAll(function(l){return l.afterRoot&&l.afterRoot(s)})).then(function(){e(s)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let i=0,o=t.length;i<o;i++){const r=t[i].joints;for(let s=0,l=r.length;s<l;s++)e[r[s]].isBone=!0}for(let i=0,o=e.length;i<o;i++){const r=e[i];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(n[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const i=n.clone(),o=(r,s)=>{const l=this.associations.get(r);l!=null&&this.associations.set(s,l);for(const[c,d]of r.children.entries())o(d,s.children[c])};return o(n,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const i=e(t[n]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let i=0;i<t.length;i++){const o=e(t[i]);o&&n.push(o)}return n}getDependency(e,t){const n=e+":"+t;let i=this.cache.get(n);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this.loadNode(t);break;case"mesh":i=this._invokeOne(function(o){return o.loadMesh&&o.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(o){return o.loadBufferView&&o.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(o){return o.loadMaterial&&o.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(o){return o.loadTexture&&o.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this.loadAnimation(t);break;case"camera":i=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(n,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(i.map(function(o,r){return n.getDependency(e,r)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this,n=this.json.buffers[e];if(n.type&&n.type!=="arraybuffer")throw new Error("v3d.GLTFLoader: "+n.type+" buffer type is not supported.");if(n.uri===void 0&&e===0)return Promise.resolve(this.extensions[Fe.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(o){let r,s;i.loadBinXZ?(r=ti.resolveURL(n.uri,i.path)+".xz",s=new Is):(r=ti.resolveURL(n.uri,i.path),s=t.fileLoader);const l=function(d){if(t.onProgress){const u=100*(.3+.7*d);t.onProgress(u)}};let c=l;s instanceof cn&&(c=function(d){const u=d.lengthComputable?d.loaded/d.total:1;l(u)}),s.load(r,o,c)})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const i=t.byteLength||0,o=t.byteOffset||0;return n.slice(o,o+i)})}loadAccessor(e){const t=this,n=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const r=Td[i.type],s=sa[i.componentType],l=i.normalized===!0,c=new s(i.count*r);return Promise.resolve(new Te(c,r,l))}const o=[];return i.bufferView!==void 0?o.push(this.getDependency("bufferView",i.bufferView)):o.push(null),i.sparse!==void 0&&(o.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),o.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(o).then(function(r){const s=r[0],l=Td[i.type],c=sa[i.componentType],d=c.BYTES_PER_ELEMENT,u=d*l,h=i.byteOffset||0,p=i.bufferView!==void 0?n.bufferViews[i.bufferView].byteStride:void 0,m=i.normalized===!0;let f,g;if(p&&p!==u){const _=Math.floor(h/p),A="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+_+":"+i.count;let x=t.cache.get(A);x||(f=new c(s,_*p,i.count*p/d),x=new Ma(f,p/d),t.cache.add(A,x)),g=new io(x,l,h%p/d,m)}else f=s===null?new c(i.count*l):new c(s,h,i.count*l),g=new Te(f,l,m);if(i.sparse!==void 0){const _=Td.SCALAR,A=sa[i.sparse.indices.componentType],x=i.sparse.indices.byteOffset||0,S=i.sparse.values.byteOffset||0,M=new A(r[1],x,i.sparse.count*_),T=new c(r[2],S,i.sparse.count*l);s!==null&&(g=new Te(g.array.slice(),g.itemSize,g.normalized));for(let L=0,z=M.length;L<z;L++){const W=M[L];if(g.setX(W,T[L*l]),l>=2&&g.setY(W,T[L*l+1]),l>=3&&g.setZ(W,T[L*l+2]),l>=4&&g.setW(W,T[L*l+3]),l>=5)throw new Error("v3d.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return g})}loadTexture(e){const t=this.json,n=this.options,i=t.textures[e].source,o=t.images[i];let r=this.textureLoader;if(o.uri){const s=n.manager.getHandler(o.uri);s!==null&&(r=s)}return this.loadTextureImage(e,i,r)}loadTextureImage(e,t,n){const i=this,o=this.json,r=o.textures[e],s=o.images[t],l=(s.uri||s.bufferView)+":"+r.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(t,n).then(function(d){d.flipY=!1,d.name=r.name||s.name||"";const u=(o.samplers||{})[r.sampler]||{};return d.magFilter=T0[u.magFilter]||Le,d.minFilter=T0[u.minFilter]||In,d.wrapS=Uc[u.wrapS]||Qn,d.wrapT=Uc[u.wrapT]||Qn,i._invokeAll(function(h){return h.extendTextureParams&&h.extendTextureParams(d,r,n)}),i.associations.set(d,{textures:e}),d}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,t){const n=this,i=this.json,o=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(u=>u.clone());const r=i.images[e],s=self.URL||self.webkitURL;let l=r.uri||"",c=!1;if(r.bufferView!==void 0)l=n.getDependency("bufferView",r.bufferView).then(function(u){c=!0;const h=new Blob([u],{type:r.mimeType});return l=s.createObjectURL(h),l});else if(r.uri===void 0)throw new Error("v3d.GLTFLoader: Image "+e+" is missing URI and bufferView");const d=Promise.resolve(l).then(function(u){return new Promise(function(h,p){let m=h;t.isImageBitmapLoader===!0&&(m=function(f){const g=new yt(f);g.needsUpdate=!0,h(g)}),t.load(ti.resolveURL(u,o.path),m,void 0,p)})}).then(function(u){return u instanceof ArrayBuffer?n.plugins[Fe.S8S_V3D_TEXTURE].textureLoaderRGBE.loadAsync(s.createObjectURL(new Blob([u],{type:"image/vnd.radiance"}))):Promise.resolve(u)}).then(function(u){return c===!0&&s.revokeObjectURL(l),u.userData.mimeType=r.mimeType||lR(r.uri),u}).catch(function(u){return console.error("v3d.GLTFLoader: Couldn't load texture",l),new yt});return this.sourceCache[e]=d,d}assignTexture(e,t,n,i){const o=this;return this.getDependency("texture",n.index).then(function(r){if(!r)return null;if(n.texCoord===void 0||n.texCoord==0||t==="aoMap"&&n.texCoord==1||console.warn("v3d.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+t+" not yet supported."),o.extensions[Fe.KHR_TEXTURE_TRANSFORM]){const s=n.extensions!==void 0?n.extensions[Fe.KHR_TEXTURE_TRANSFORM]:void 0;if(s){const l=o.associations.get(r);r=o.extensions[Fe.KHR_TEXTURE_TRANSFORM].extendTexture(r,s),o.associations.set(r,l)}}return i!==void 0&&(r.encoding=i),e[t]=r,r})}assignFinalMaterial(e,t,n){const i=e.geometry;let o=e.material;const r=i.attributes.tangent===void 0,s=i.attributes.color!==void 0&&!o.isMeshNodeMaterial,l=i.attributes.normal===void 0,c=o.isMeshNodeMaterial&&(o.nodeValue.length||o.nodeRGB.length),d=o.isMeshNodeMaterial&&o.hasNode("TEX_COORD_BL"),u=o.isMeshNodeMaterial&&Object.getOwnPropertyNames(t).length>0&&o.hasNode("UVMAP_BL"),h=o.isMeshNodeMaterial&&Object.getOwnPropertyNames(n).length>0&&(o.hasNode("ATTRIBUTE_BL")||o.hasNode("VERTEX_COLOR_BL"));if(e.isPoints){const p="PointsMaterial:"+o.uuid;let m=this.cache.get(p);m||(m=new PointsMaterial,Ut.prototype.copy.call(m,o),m.color.copy(o.color),m.map=o.map,m.sizeAttenuation=!1,this.cache.add(p,m)),o=m}else if(e.isLine){const p="LineBasicMaterial:"+o.uuid;let m=this.cache.get(p);m||(m=new LineBasicMaterial,Ut.prototype.copy.call(m,o),m.color.copy(o.color),this.cache.add(p,m)),o=m}if(r||s||l||c||d||u||h){let p="ClonedMaterial:"+o.uuid+":";r&&(p+="derivative-tangents:"),s&&(p+="vertex-colors:"),l&&(p+="flat-shading:");const m=wn();c&&(p=m),d&&(p=m),u&&(p=m),h&&(p=m);let f=this.cache.get(p);f||(f=o.clone(),s&&(f.vertexColors=!0),l&&(f.flatShading=!0),r&&(f.normalScale&&(f.normalScale.y*=-1),f.clearcoatNormalScale&&(f.clearcoatNormalScale.y*=-1)),f.isMeshNodeMaterial&&(Object.assign(f.nodeUVAliases,t),Object.assign(f.nodeVCAliases,n),f.updateNodeGraph()),this.cache.add(p,f),this.associations.set(f,this.associations.get(o))),o=f}o.aoMap&&i.attributes.uv2===void 0&&i.attributes.uv!==void 0&&i.setAttribute("uv2",i.attributes.uv),e.material=o,this.assignedMaterials.includes(o)||this.assignedMaterials.push(o)}getMaterialType(){return Zs}loadMaterial(e){const t=this,n=this.json,i=this.extensions,o=n.materials[e];let r;const s={},l=[];if((o.extensions||{})[Fe.KHR_MATERIALS_UNLIT]){const d=i[Fe.KHR_MATERIALS_UNLIT];r=d.getMaterialType(),l.push(d.extendParams(s,o,t))}else{const d=o.pbrMetallicRoughness||{};if(s.color=new me(1,1,1),s.opacity=1,Array.isArray(d.baseColorFactor)){const u=d.baseColorFactor;s.color.fromArray(u),s.opacity=u[3]}d.baseColorTexture!==void 0&&l.push(t.assignTexture(s,"map",d.baseColorTexture,Ke)),s.metalness=d.metallicFactor!==void 0?d.metallicFactor:1,s.roughness=d.roughnessFactor!==void 0?d.roughnessFactor:1,d.metallicRoughnessTexture!==void 0&&(l.push(t.assignTexture(s,"metalnessMap",d.metallicRoughnessTexture)),l.push(t.assignTexture(s,"roughnessMap",d.metallicRoughnessTexture))),r=this._invokeOne(function(u){return u.getMaterialType&&u.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(u){return u.extendMaterialParams&&u.extendMaterialParams(e,s)})))}o.doubleSided===!0&&(s.side=Tn);const c=o.alphaMode||ns.OPAQUE;if(c===ns.BLEND?(s.transparent=!0,r!==wt&&(s.depthWrite=!1)):(s.transparent=!1,c===ns.MASK&&(s.alphaTest=o.alphaCutoff!==void 0?o.alphaCutoff:.5)),o.normalTexture!==void 0&&r!==Xt&&(l.push(t.assignTexture(s,"normalMap",o.normalTexture)),s.normalScale=new te(1,1),o.normalTexture.scale!==void 0)){const d=o.normalTexture.scale;s.normalScale.set(d,d)}return o.occlusionTexture!==void 0&&r!==Xt&&(l.push(t.assignTexture(s,"aoMap",o.occlusionTexture)),o.occlusionTexture.strength!==void 0&&(s.aoMapIntensity=o.occlusionTexture.strength)),o.emissiveFactor!==void 0&&r!==Xt&&(s.emissive=new me().fromArray(o.emissiveFactor)),o.emissiveTexture!==void 0&&r!==Xt&&l.push(t.assignTexture(s,"emissiveMap",o.emissiveTexture,Ke)),Promise.all(l).then(function(){const d=new r(s);o.name&&(d.name=o.name),d.map&&(d.map.encoding=Ke),d.emissiveMap&&(d.emissiveMap.encoding=Ke);const u=t.plugins[Fe.S8S_V3D_MATERIALS];return d.isMeshNodeMaterial&&u.assignTransparency(d,o,c),d.isMeshStandardMaterial&&d.normalScale&&u&&q(u.profile)&&u.profile=="max"&&(d.normalScale.y=-d.normalScale.y),wo(d,o),t.associations.set(d,{materials:e}),o.extensions&&Xa(i,d,o),d})}createUniqueName(e){const t=e;let n=t;for(let i=1;this.nodeNamesUsed[n];++i)n=t+"_"+i;return this.nodeNamesUsed[n]=!0,n}loadGeometries(e){const t=this,n=this.extensions,i=this.primitiveCache;function o(s){return n[Fe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(s,t).then(function(l){return L0(l,s,t)})}const r=[];for(let s=0,l=e.length;s<l;s++){const c=e[s],d=sR(c),u=i[d];if(u)r.push(u.promise);else{let h;h=c.extensions&&c.extensions[Fe.KHR_DRACO_MESH_COMPRESSION]?o(c):L0(new Pe,c,t),i[d]={primitive:c,promise:h},r.push(h)}}return Promise.all(r)}loadMesh(e){const t=this,n=this.json,i=this.extensions,o=n.meshes[e],r=o.primitives,s=[],l=q(o.extensions)?o.extensions[Fe.S8S_V3D_MESH]:void 0;for(let c=0,d=r.length;c<d;c++){const u=r[c].material===void 0?J1(this.cache):this.getDependency("material",r[c].material);s.push(u)}return s.push(t.loadGeometries(r)),Promise.all(s).then(function(c){const d=c.slice(0,c.length-1),u=c[c.length-1],h=[];for(let m=0,f=u.length;m<f;m++){const g=u[m],_=r[m];let A;const x=d[m];if(_.mode===Kn.TRIANGLES||_.mode===Kn.TRIANGLE_STRIP||_.mode===Kn.TRIANGLE_FAN||_.mode===void 0)A=o.isSkinnedMesh===!0?new xs(g,x):new Ue(g,x),A.isSkinnedMesh!==!0||A.geometry.attributes.skinWeight.normalized||A.normalizeSkinWeights(),_.mode===Kn.TRIANGLE_STRIP?A.geometry=P0(A.geometry,Fh):_.mode===Kn.TRIANGLE_FAN&&(A.geometry=P0(A.geometry,fs));else if(_.mode===Kn.LINES)if(l){const T=new bp;T.fromBufferGeometry(g);const L=new hu({color:q(l.lineColor)?new me().fromArray(l.lineColor):new me(1,1,1),lineWidth:q(l.lineWidth)?l.lineWidth:1,sizeAttenuation:0});A=new Ue(T.geometry,L),A.userData.originalLineGeom=g}else A=new Wn(g,x);else if(_.mode===Kn.LINE_STRIP)A=new Pi(g,x);else if(_.mode===Kn.LINE_LOOP)A=new Kh(g,x);else{if(_.mode!==Kn.POINTS)throw new Error("v3d.GLTFLoader: Primitive mode unsupported: "+_.mode);A=new Zh(g,x)}Object.keys(A.geometry.morphAttributes).length>0&&aR(A,o),A.name=t.createUniqueName(o.name||"mesh_"+e),wo(A,o),_.extensions&&Xa(i,A,_);const S={},M={};if(A.material.isMeshNodeMaterial&&l){if(l.uvLayers)for(let T in l.uvLayers)S[T]=ev(l.uvLayers[T]);if(l.colorLayers)for(let T in l.colorLayers)M[T]=tv(l.colorLayers[T])}t.assignFinalMaterial(A,S,M),h.push(A)}for(let m=0,f=h.length;m<f;m++)t.associations.set(h[m],{meshes:e,primitives:m});if(h.length===1)return h[0];const p=new Zn;t.associations.set(p,{meshes:e});for(let m=0,f=h.length;m<f;m++)h[m].name+="_"+m,h[m].isMaterialGeneratedMesh=!0,p.add(h[m]);return p})}loadCamera(e){let t;const n=this.json.cameras[e],i=n[n.type];if(i)return n.type==="perspective"?t=new Qt(Xc(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):n.type==="orthographic"&&(t=new fi(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),n.name&&(t.name=n.name),wo(t,n),this._invokeOne(function(o){return o.extendCameraParams&&o.extendCameraParams(t,n)});console.warn("v3d.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],n=[];for(let i=0,o=t.joints.length;i<o;i++)n.push(this.getDependency("node",t.joints[i]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(i){const o=i.pop(),r=i,s=[],l=[];for(let c=0,d=r.length;c<d;c++){const u=r[c];if(u){s.push(u);const h=new Ae;o!==null&&h.fromArray(o.array,16*c),l.push(h)}else console.warn('v3d.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new zs(s,l)})}loadAnimation(e){const t=this.json.animations[e],n=[],i=[],o=[],r=[],s=[];for(let l=0,c=t.channels.length;l<c;l++){const d=t.channels[l],u=t.samplers[d.sampler],h=d.target,p=h.node,m=t.parameters!==void 0?t.parameters[u.input]:u.input,f=t.parameters!==void 0?t.parameters[u.output]:u.output;n.push(this.getDependency("node",p)),i.push(this.getDependency("accessor",m)),o.push(this.getDependency("accessor",f)),r.push(u),s.push(h)}return Promise.all([Promise.all(n),Promise.all(i),Promise.all(o),Promise.all(r),Promise.all(s),this.getDependencies("material")]).then(function(l){const c=l[0],d=l[1],u=l[2],h=l[3],p=l[4],m=[];for(let A=0,x=c.length;A<x;A++){const S=c[A],M=d[A],T=u[A],L=h[A],z=p[A];if(S===void 0)continue;let W;S.updateMatrix();let V="";switch(Yi[z.path]){case Yi.weights:W=No;break;case Yi.rotation:W=Oo;break;case Yi.translation:case Yi.scale:W=Ar;break;case Yi.intensity:W=No;break;default:if(z.path.indexOf("constraint")>-1)W=No,V="constraints["+z.path.match(/".*"/g)[0]+"]."+z.path.match(/[^\\.]*$/g)[0];else{let ne;W=Ar,z.path.indexOf("nodeValue")>-1?(ne=z.path.match(/".*"/g)[0],V="material.nodeValue["+ne+"]"):z.path.indexOf("nodeRGB")>-1&&(ne=z.path.match(/".*"/g)[0],V="material.nodeRGB["+ne+"]")}}const N=S.name?S.name:S.uuid,j=L.interpolation!==void 0?oR[L.interpolation]:2301,oe=[];if(Yi[z.path]===Yi.weights)S.traverse(function(ne){ne.morphTargetInfluences&&oe.push(ne.name?ne.name:ne.uuid)});else if(z.path.indexOf("material")>-1){const ne=l[5];S.traverse(function(le){if(!le.isMesh||!le.material.isMeshNodeMaterial)return;let re=!1;if(z.extras){re=ne[z.extras.material].name===le.material.name;const ae=z.path.match(/\["(.*)"\]/);re=re&&ae!==null&&le.material.findNodeByName(ae[1])!==null}else re=!0;re&&oe.push(le.name?le.name:le.uuid)})}else oe.push(N);let H=T.array;if(T.normalized){const ne=Ah(H.constructor),le=new Float32Array(H.length);for(let re=0,ae=H.length;re<ae;re++)le[re]=H[re]*ne;H=le}for(let ne=0,le=oe.length;ne<le;ne++){const re=new W(oe[ne]+"."+(V!==""?V:Yi[z.path]),M.array,H,j);L.interpolation==="CUBICSPLINE"&&(re.createInterpolant=function(ae){return new(this instanceof Oo?iR:q1)(this.times,this.values,this.getValueSize()/3,ae)},re.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push(re)}}const f=t.name?t.name:"animation_"+e,g={clip:new ma(f,void 0,m),nodeId:c[0].id,auto:!0,loop:2201,repetitions:1/0,startAt:0},_=q(t.extensions)?t.extensions[Fe.S8S_V3D_ANIMATION]:void 0;if(_){g.auto=_.auto;const A=_.repeatInfinite?1/0:_.repeatCount;switch(_.loop){case"ONCE":g.loop=2200;break;case"REPEAT":g.loop=2201,g.repetitions=A;break;case"PING_PONG":g.loop=2202,g.repetitions=A}g.startAt=_.offset}return g})}createNodeMesh(e){const t=this.json,n=this,i=t.nodes[e];return i.mesh===void 0?null:n.getDependency("mesh",i.mesh).then(function(o){const r=n._getNodeRef(n.meshCache,i.mesh,o);return i.weights!==void 0&&r.traverse(function(s){if(s.isMesh)for(let l=0,c=i.weights.length;l<c;l++)s.morphTargetInfluences[l]=i.weights[l]}),r})}loadNode(e){const t=this.json,n=this.extensions,i=this,o=t.nodes[e],r=o.name?i.createUniqueName(o.name):"";return function(){const s=[],l=i._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&s.push(l),o.camera!==void 0&&s.push(i.getDependency("camera",o.camera).then(function(c){return i._getNodeRef(i.cameraCache,o.camera,c)})),i._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){s.push(c)}),Promise.all(s)}().then(function(s){let l;if(l=o.isBone===!0?new nu:s.length>1?new Zn:s.length===1?s[0]:new ze,l!==s[0])for(let c=0,d=s.length;c<d;c++)l.add(s[c]);if(o.name&&(l.userData.name=o.name,l.name=r),wo(l,o),o.extensions&&Xa(n,l,o),o.matrix!==void 0){const c=new Ae;c.fromArray(o.matrix),l.applyMatrix4(c)}else o.translation!==void 0&&l.position.fromArray(o.translation),o.rotation!==void 0&&l.quaternion.fromArray(o.rotation),o.scale!==void 0&&l.scale.fromArray(o.scale);return i.associations.has(l)||i.associations.set(l,{}),i.associations.get(l).nodes=e,l}).then(function(s){return s.resolveMultiMaterial().forEach(l=>{i._invokeOne(function(c){if(l!==s)return c.extendNodeParams&&c.extendNodeParams(l,o)})}),i._invokeOne(function(l){return l.extendNodeParams&&l.extendNodeParams(s,o)})})}loadScene(e){const t=this.json,n=this.extensions,i=this.json.scenes[e],o=this,r=new vn;i.name&&(r.name=o.createUniqueName(i.name)),wo(r,i),i.extensions&&Xa(n,r,i);const s=i.nodes||[],l=[];for(let c=0,d=s.length;c<d;c++)l.push($1(s[c],r,t,o));return Promise.all(l).then(function(){return o.associations=(c=>{const d=new Map;for(const[u,h]of o.associations)(u instanceof Ut||u instanceof yt)&&d.set(u,h);return c.traverse(u=>{const h=o.associations.get(u);h!=null&&d.set(u,h)}),d})(r),r})}}function $1(a,e,t,n){const i=t.nodes[a];return n.getDependency("node",a).then(function(o){return i.skin===void 0?o:n.getDependency("skin",i.skin).then(function(r){return o.traverse(function(s){s.isSkinnedMesh&&s.bind(r,s.matrixWorld)}),o})}).then(function(o){e.add(o),(o.isDirectionalLight||o.isSpotLight)&&o.isFreeLight&&e.add(o.target);const r=[];if(i.children){const s=i.children;for(let l=0,c=s.length;l<c;l++){const d=s[l];r.push($1(d,o,t,n))}}return Promise.all(r)})}function uR(a,e,t){const n=e.attributes,i=new At;if(n.POSITION===void 0)return;{const s=t.json.accessors[n.POSITION],l=s.min,c=s.max;if(l===void 0||c===void 0)return void console.warn("v3d.GLTFLoader: Missing min/max properties for accessor POSITION.");if(i.set(new b(l[0],l[1],l[2]),new b(c[0],c[1],c[2])),s.normalized){const d=Ah(sa[s.componentType]);i.min.multiplyScalar(d),i.max.multiplyScalar(d)}}const o=e.targets;if(o!==void 0){const s=new b,l=new b;for(let c=0,d=o.length;c<d;c++){const u=o[c];if(u.POSITION!==void 0){const h=t.json.accessors[u.POSITION],p=h.min,m=h.max;if(p!==void 0&&m!==void 0){if(l.setX(Math.max(Math.abs(p[0]),Math.abs(m[0]))),l.setY(Math.max(Math.abs(p[1]),Math.abs(m[1]))),l.setZ(Math.max(Math.abs(p[2]),Math.abs(m[2]))),h.normalized){const f=Ah(sa[h.componentType]);l.multiplyScalar(f)}s.max(l)}else console.warn("v3d.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(s)}a.boundingBox=i;const r=new Rn;i.getCenter(r.center),r.radius=i.min.distanceTo(i.max)/2,a.boundingSphere=r}function L0(a,e,t){const n=e.attributes,i=[];function o(r,s){return t.getDependency("accessor",r).then(function(l){a.setAttribute(s,l)})}for(const r in n){const s=_h[r]||xh(r)||r.toLowerCase();s in a.attributes||i.push(o(n[r],s))}if(e.indices!==void 0&&!a.index){const r=t.getDependency("accessor",e.indices).then(function(s){a.setIndex(s)});i.push(r)}return wo(a,e),uR(a,e,t),Promise.all(i).then(function(){return e.targets!==void 0?rR(a,e.targets,t):a})}function P0(a,e){let t=a.getIndex();if(t===null){const r=[],s=a.getAttribute("position");if(s===void 0)return console.error("v3d.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),a;for(let l=0;l<s.count;l++)r.push(l);a.setIndex(r),t=a.getIndex()}const n=t.count-2,i=[];if(e===fs)for(let r=1;r<=n;r++)i.push(t.getX(0)),i.push(t.getX(r)),i.push(t.getX(r+1));else for(let r=0;r<n;r++)r%2==0?(i.push(t.getX(r)),i.push(t.getX(r+1)),i.push(t.getX(r+2))):(i.push(t.getX(r+2)),i.push(t.getX(r+1)),i.push(t.getX(r)));i.length/3!==n&&console.error("v3d.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const o=a.clone();return o.setIndex(i),o}function dR(a){const e=["S8S_v3d_lights","S8S_v3d_light_probes","S8S_v3d_curves","S8S_v3d_clipping_planes"],t=a.extensionsUsed||[];t.includes("S8S_v3d_animation_data")&&(Co("S8S_v3d_animation_data","S8S_v3d_animation",t),(a.animations||[]).forEach(n=>{So("S8S_v3d_animation_data","S8S_v3d_animation",n)}),Mo("S8S_v3d_animation_data")),t.includes("S8S_v3d_node_data")&&(Co("S8S_v3d_node_data","S8S_v3d_node",t),(a.nodes||[]).forEach(n=>{So("S8S_v3d_node_data",[].concat(["S8S_v3d_node"],e),n)}),Mo("S8S_v3d_node_data")),t.includes("S8S_v3d_material_data")&&(Co("S8S_v3d_material_data","S8S_v3d_materials",t),(a.materials||[]).forEach(n=>{n.extensions&&n.extensions.S8S_v3d_material_data&&n.pbrMetallicRoughness?delete n.extensions.S8S_v3d_material_data:So("S8S_v3d_material_data","S8S_v3d_materials",n)}),Mo("S8S_v3d_material_data")),t.includes("S8S_v3d_mesh_data")&&(Co("S8S_v3d_mesh_data","S8S_v3d_mesh",t),(a.meshes||[]).forEach(n=>{So("S8S_v3d_mesh_data","S8S_v3d_mesh",n)}),Mo("S8S_v3d_mesh_data")),t.includes("S8S_v3d_camera_data")&&(Co("S8S_v3d_camera_data","S8S_v3d_camera",t),(a.cameras||[]).forEach(n=>{So("S8S_v3d_camera_data","S8S_v3d_camera",n)}),Mo("S8S_v3d_camera_data")),t.includes("S8S_v3d_scene_data")&&(Co("S8S_v3d_scene_data","S8S_v3d_scene",t),(a.scenes||[]).forEach(n=>{So("S8S_v3d_scene_data","S8S_v3d_scene",n)}),Mo("S8S_v3d_scene_data")),t.includes("S8S_v3d_texture_data")&&(Co("S8S_v3d_texture_data","S8S_v3d_texture",t),(a.textures||[]).forEach(n=>{So("S8S_v3d_texture_data","S8S_v3d_texture",n)}),Mo("S8S_v3d_texture_data")),t.includes("S8S_v3d_data")&&(Co("S8S_v3d_data",e,t),So("S8S_v3d_data",[].concat(e,["S8S_v3d_materials"]),a),Mo("S8S_v3d_data")),(a.textures||[]).forEach(n=>{if(q(n.source)){const i=a.images[n.source],o=i.uri||"",r=i.mimeType;if(o.split(".").pop()=="hdr"||r=="image/vnd.radiance"||o.split(".").pop()=="xz"||r=="application/x-xz"){n.extensions=n.extensions||{};const s=n.extensions.S8S_v3d_texture||{};s.source=n.source,delete n.source,n.extensions.S8S_v3d_texture=s,console.warn("Placing HDR map to S8S_v3d_texture extension, please reexport your scene file")}}})}function Co(a,e,t){const n=t.indexOf(a);n>-1&&t.splice(n,1),Array.isArray(e)?e.forEach(i=>{t.push(i)}):t.push(e)}function So(a,e,t){const n=t.extensions||{};Array.isArray(e)?e.forEach(i=>{n[i]=n[a]}):n[e]=n[a],delete n[a]}function Mo(a){console.warn(`Deprecated '${a}' extension found, please reexport your scene file`)}function xh(a){return a.indexOf("TEXCOORD_")>-1?ev(a):a.indexOf("COLOR_")>-1?tv(a):""}function ev(a){return a=="TEXCOORD_0"?"uv":"uv"+String(Number(a.split("TEXCOORD_")[1])+1)}function tv(a){return a=="COLOR_0"?"color":"color"+String(Number(a.split("COLOR_")[1])+1)}function nv(a){a.blending=no,a.blendEquation=tn,a.blendSrc=ei,a.blendDst=Ri}const B0=new me;class iv extends An{constructor(e,t,n=512,i=512){super(),this.scene=e,this.camera=t,this.width=n,this.height=i,this.distance=.1,this.factor=1,this.precision=1,this.bentNormals=!1,this.bounceApprox=!1,this.noiseTexture=this.createNoiseTexture(),this.fsQuad=new hi(null);const o=new Xh;o.type=Zi,this.renderTargetNormalDepth=new et(this.width,this.height,{format:Qe,depthTexture:o,depthBuffer:!0}),this.renderTargetGTAO=new et(this.width,this.height),this.renderTargetBlurX=new et(this.width,this.height),this.renderTarget=new et(this.width,this.height),this.materialNormal=new op({}),this.materialGTAO=new vt({type:"GTAO",defines:{ORTHO_CAMERA:0,CALC_BENT_NORMALS:0},extensions:{derivatives:!0},uniforms:{tNormal:{value:null},tDepth:{value:null},tNoise:{value:null},occlDistance:{value:.1},factor:{value:1},occlPrecision:{value:1},bounceApprox:{value:0},mainCameraProjMat:{value:new Ae},resolution:{value:new te}},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_gtao_frag}),this.materialBlur=new vt({type:"GTAOBlur",defines:{},uniforms:{tDiffuse:{value:null},tNormal:{value:null},direction:{value:new te},resolution:{value:new te}},customPrepTokens:{BLUR_RADIUS_PX:2},vertexShader:Me.pp_plane_vert,fragmentShader:Me.pp_gtao_blur_frag}),this._layerMasks={}}setCamera(e){this.camera=e}setSize(e,t){this.width=e,this.height=t,this.renderTargetNormalDepth.setSize(e,t),this.renderTargetGTAO.setSize(e,t),this.renderTargetBlurX.setSize(e,t),this.renderTarget.setSize(e,t),this.materialGTAO.uniforms.mainCameraProjMat.value.copy(this.camera.projectionMatrix),this.materialGTAO.uniforms.resolution.value.set(this.renderTargetGTAO.width,this.renderTargetGTAO.height),this.materialBlur.uniforms.resolution.value.set(this.renderTargetGTAO.width,this.renderTargetGTAO.height)}dispose(){this.dispatchEvent({type:"dispose"}),this.renderTargetNormalDepth.dispose(),this.renderTargetGTAO.dispose(),this.renderTargetBlurX.dispose(),this.renderTarget.dispose(),this.materialNormal.dispose(),this.materialGTAO.dispose(),this.materialBlur.dispose(),this.noiseTexture.dispose()}_saveLayers(){this.scene.traverse(e=>this._layerMasks[e.id]=e.layers.mask)}_setupLayers(){this.scene.traverse(e=>{e.layers.disableAll();const t=e instanceof Ue&&e.material&&!e.material.gtaoVisible,n=e instanceof Ue&&e.material&&e.material.isMeshNodeMaterial&&(e.material.alphaTest>0||e.material.alphaToCoverage);t?e.layers.enable(0):n?e.layers.enable(1):e.layers.enable(2)})}_restoreLayers(){this.scene.traverse(e=>e.layers.mask=this._layerMasks[e.id])}_setupNodeAlphaClipHashMaterials(){this.scene.traverse(e=>{e instanceof Ue&&e.material&&e.material.isMeshNodeMaterial&&(e.material.defines.NORMAL_OUTPUT=Number(e.material.alphaTest>0||e.material.alphaToCoverage),e.material.needsUpdate=!0)})}_restoreNodeAlphaClipHashMaterials(){this.scene.traverse(e=>{e instanceof Ue&&e.material&&e.material.isMeshNodeMaterial&&(e.material.defines.NORMAL_OUTPUT=0,e.material.needsUpdate=!0)})}render(e){this._saveLayers(),this._setupLayers(),this.camera.layers.disableAll(),this.camera.layers.enable(1),this._setupNodeAlphaClipHashMaterials(),this._renderOverride(e,null,this.renderTargetNormalDepth,8355839,1,!0),this._restoreNodeAlphaClipHashMaterials(),this.camera.layers.disableAll(),this.camera.layers.enable(2),this._renderOverride(e,this.materialNormal,this.renderTargetNormalDepth,null,null,!0),this._restoreLayers(),this.materialGTAO.defines.ORTHO_CAMERA=this.camera.isOrthographicCamera?1:0,this.materialGTAO.defines.CALC_BENT_NORMALS=this.bentNormals?1:0,this.materialGTAO.needsUpdate=!0,this.materialGTAO.uniforms.tNormal.value=this.renderTargetNormalDepth.texture,this.materialGTAO.uniforms.tDepth.value=this.renderTargetNormalDepth.depthTexture,this.materialGTAO.uniforms.tNoise.value=this.noiseTexture,this.materialGTAO.uniforms.occlDistance.value=this.distance,this.materialGTAO.uniforms.factor.value=this.factor,this.materialGTAO.uniforms.occlPrecision.value=this.precision,this.materialGTAO.uniforms.bounceApprox.value=this.bounceApprox,this.materialGTAO.uniforms.mainCameraProjMat.value.copy(this.camera.projectionMatrix),this.materialGTAO.uniforms.resolution.value.set(this.renderTargetGTAO.width,this.renderTargetGTAO.height),this._renderPass(e,this.materialGTAO,this.renderTargetGTAO),this.materialBlur.uniforms.tDiffuse.value=this.renderTargetGTAO.texture,this.materialBlur.map=this.renderTargetGTAO.texture,this.materialBlur.uniforms.tNormal.value=this.renderTargetNormalDepth.texture,this.materialBlur.uniforms.direction.value.set(1,0),this.materialBlur.uniforms.resolution.value.set(this.renderTargetGTAO.width,this.renderTargetGTAO.height),this._renderPass(e,this.materialBlur,this.renderTargetBlurX),this.materialBlur.uniforms.tDiffuse.value=this.renderTargetBlurX.texture,this.materialBlur.map=this.renderTargetBlurX.texture,this.materialBlur.uniforms.direction.value.set(0,1),this.materialBlur.uniforms.resolution.value.set(this.renderTargetBlurX.width,this.renderTargetBlurX.height),this._renderPass(e,this.materialBlur,this.renderTarget)}_renderOverride(e,t,n,i,o,r){const s=e.getRenderTarget(),l=e.getClearColor(B0),c=e.getClearAlpha(),d=e.autoClear,u=this.scene.background;e.setRenderTarget(n),i!=null&&(e.setClearColor(i),e.setClearAlpha(o??0),e.clear()),e.autoClear=!1,r&&(this.scene.background=null),t&&(this.scene.overrideMaterial=t),e.render(this.scene,this.camera),this.scene.overrideMaterial=null,e.setRenderTarget(s),e.setClearColor(l),e.setClearAlpha(c),e.autoClear=d,this.scene.background=u}_renderPass(e,t,n,i,o){const r=e.getRenderTarget(),s=e.getClearColor(B0),l=e.getClearAlpha(),c=e.autoClear;e.setRenderTarget(n),i!=null&&(e.setClearColor(i),e.setClearAlpha(o??0),e.clear()),e.autoClear=!1,this.fsQuad.material=t,this.fsQuad.render(e),e.setRenderTarget(r),e.setClearColor(s),e.setClearAlpha(l),e.autoClear=c}createNoiseTexture(){const e=new Uint8Array([101,192,145,80,53,136,86,207,229,131,240,6,58,41,171,13,199,63,175,128,113,55,246,66,115,213,157,59,243,114,68,169,255,60,216,5,200,37,250,65,170,48,153,108,125,211,137,29,120,82,38,213,25,198,15,150,33,131,173,16,140,180,9,206,134,20,117,176,99,222,124,190,95,33,198,221,86,68,241,157,227,142,253,96,72,135,169,102,204,253,89,195,50,233,94,38,185,86,235,72,149,163,25,2,146,75,254,14,164,189,0,100,49,187,162,8,181,222,240,52,7,73,41,109,210,123,76,150,226,161,44,11,242,51,107,232,212,116,177,54,141,37,207,77,115,19,59,235,110,42,83,122,160,184,224,148,2,164,248,24,203,109,129,192,208,138,83,182,61,132,28,229,96,121,224,173,248,197,88,127,147,29,193,210,139,96,237,30,63,191,102,54,69,178,32,93,63,170,36,247,17,201,80,155,245,18,60,133,151,32,219,206,165,67,230,20,57,12,171,128,84,221,139,13,236,146,220,252,20,120,222,150,99,166,43,108,196,183,89,45,9,107,74,49,4,100,175,117,246,71,198,113,241,39,174,119,46,82,1,157,105,195,72,9,127,239,217,6,69,145,211,166,230,181,240,136,190,251,87,155,35,219,143,50,22,159,213,92,191,127,212,41,135,237,50,206,88,58,176,118,36,234,27,114,64,93,157,119,21,214,45,129,187,105,92,208,182,66,6,249,27,167,62,185,78,172,29,160,188,25,139,249,161,84,130,254,203,14,37,226,59,143,77,238,0,166,18,254,79,133,103,153,205,113,94,246,12,216,100,116,227,76,209,48,97,186,1,53,144,192,82,169,108,179,28,198,65,228,42,151,122,197,233,53,74,222,24,146,123,56,141,255,3,151,106,20,200,220,73,174,104,216,131,248,7,209,156,86,112,136,177,58,223,11,36,140,241,8,195,178,232,85,200,43,65,180,240,133,61,149,120,231,22,46,71,30,92,230,121,52,242,215,97,26,110,186,89,172,158,102,50,70,34,156,15,189,126,91,34,168,10,245,39,91,163,243,152,202,140,42,188,17,163,8,203,77,156,237,63,118,32,130,251,165,112,208,98,235,161,213,228,81,110,194,178,14,125,185,111,61,173,103,253,71,144,39,125,250,45,207,15,217,177,202,88,1,226,132,75,26,56,12,119,203,46,137,66,209,77,220,3,238,19,80,129,218,179,90,193,168,132,98,146,81,19,235,142,59,183,44,250,174,104,144,69,155,251,97,230,145,33,99,49,159,212,196,31,56,110,225,22,62,2,183,245,55,123,40,106,215,17,150,116,218,194,238,31,186,0,23,55,162,241,194,135,87,118,147,236,4,158,244,75,117,228,35,109,194,67,155,78,168,199,91,64,8,135,47,88,169,212,129,181,111,11,65,170,227,40,68,176,95,201,46,142,209,154,90,165,218,255,188,232,27,121,244,35,163,79,206,124,242,103,72,223,83,204,123,25,247,10,191,111,136,26,85,187,18,236,51,134,7,144,13,99,48,138,227,190,101,223,24,153,60,41,149,30,255,45,152,184,103,78,162,51,252,217,128,171,104,70,197,30,84,114,57,176,205,70,4,148,54,253,181,113,6,231,191,134,172,95,220,56,211,141,233,205,16,66,40,224,5,122,243,179,211,226,127,247,158,85,111,174,126,15,73,202,167,87,215,17,116,3,71,130,19,35,90,124,154,182,98,248,148,57,156,96,43,73,196,34,16,218,237,42,208,94,143,38,247,122,67,52,201,234,164,249,177,199,61,1,108,76,167,31,204,80,231,22,170,0,147,93,120,183,64,28,161,239,57,185,105,28,159,139,184,106,40,81,114,145,242,219,190,239,53,138,112,11,187,133,107,204,239,168,54,141,102,193,81,221,134,9,216,78,229,244,90,23,153,225,10,95,160,43,132,23,214,195,89,47,215,252,62,38,82,228,21,214,251,2,151,109,21,175,197,149,44,5,173,64,210,52,196,69,29,172,83,118,13,154,236,175,119,26,159,137,112,189,44,131,75,171,121,49,232,92,126,62,101,205,130,117,250,138,180,125,207,254,58,225,97,67,37,142,74,98,182,210,7,68,152,202,94,34,243,200,70,39,252,166,16,224,188,32,84,21,100,231,12,106,148,199,178,249,164,5,229,55,245,87,165,234,105,14,225,60,184,140,158,214,27,115,143,74,51,162,147,238,47,76,167,36,137,3,48,126,104,201,189,128,18,47,124,31,244,180,160,115,23,10,101,79,179,193,233,93,246,107,217,4,192,154,221,91,186,234,79,24,219,85,33,152,223]),t=new Uint8Array([7,87,145,233,57,15,124,219,7,163,132,35,222,160,41,99,10,23,228,253,53,207,65,214,94,146,248,134,214,15,97,230,201,181,41,105,189,206,171,100,146,78,188,106,177,87,141,232,198,122,70,178,149,26,124,174,16,55,115,35,70,179,158,111,74,241,122,159,29,90,47,242,23,229,213,16,245,72,26,183,58,136,205,43,86,239,139,226,77,188,203,86,224,144,50,30,135,62,11,218,255,68,156,185,59,121,91,49,199,152,219,109,243,162,14,221,113,192,3,100,42,152,233,168,22,123,251,210,153,191,99,173,139,114,2,133,201,32,169,135,64,118,1,47,89,31,102,76,154,35,63,164,255,127,9,62,106,187,4,91,44,222,17,80,39,209,237,82,107,251,148,11,231,174,208,130,194,171,234,184,248,121,216,199,110,28,212,137,240,77,164,232,25,128,247,150,57,193,20,160,44,211,75,191,96,37,81,254,147,66,8,140,54,21,177,89,74,51,175,93,39,199,55,115,84,202,104,179,230,124,97,222,64,177,27,111,239,158,17,57,105,219,42,209,95,132,231,13,144,244,194,157,226,18,143,180,66,166,48,5,74,32,169,142,7,241,128,52,216,137,185,228,26,124,84,166,189,71,38,158,221,115,1,65,123,102,250,216,34,242,140,113,212,188,249,85,118,197,156,89,5,70,116,167,202,153,240,114,4,246,203,100,46,185,84,31,209,173,6,130,196,22,225,91,155,61,16,49,103,229,36,206,173,249,46,92,12,73,33,223,142,60,172,126,22,234,135,246,151,75,52,97,161,79,182,12,235,132,207,150,184,20,78,143,101,28,196,235,134,178,53,195,24,108,82,215,150,55,168,110,43,189,233,144,207,59,125,44,168,108,34,220,69,166,244,58,225,125,149,63,213,104,253,93,155,184,11,250,73,96,201,8,218,88,14,117,223,105,247,193,71,88,254,122,3,132,191,113,10,181,40,83,0,162,127,41,210,235,122,36,195,18,228,65,131,176,253,38,19,165,0,146,27,203,178,54,96,234,43,159,90,218,245,112,191,229,18,79,66,137,51,160,180,141,118,164,30,101,154,71,137,94,217,56,238,134,17,153,200,80,29,204,67,23,155,52,172,33,145,198,175,7,223,103,87,244,41,79,236,204,51,186,81,199,176,112,77,224,40,110,170,223,144,251,174,131,98,205,73,121,247,97,238,116,29,204,62,2,213,183,145,24,125,241,228,45,31,129,160,92,188,246,62,6,102,50,116,15,240,140,10,218,59,45,151,83,167,255,130,157,107,55,92,219,110,5,61,147,252,8,212,51,12,140,75,126,183,215,83,194,43,226,88,165,109,187,21,215,68,39,192,20,239,198,12,68,174,159,99,121,192,70,231,177,119,209,237,19,154,33,232,163,65,180,29,200,129,4,231,135,182,98,147,76,118,165,136,248,40,211,14,85,169,107,25,151,100,36,164,197,92,58,136,2,123,106,148,252,75,210,162,53,120,9,233,217,46,28,226,83,128,195,245,224,38,141,205,61,249,86,48,227,114,255,186,207,77,236,16,56,39,102,85,30,247,203,60,87,179,103,186,56,152,22,180,131,53,236,81,15,190,134,175,8,72,147,24,99,48,215,192,172,139,240,196,149,108,168,17,127,157,252,1,206,114,74,161,98,3,186,156,120,221,27,108,211,129,40,170,242,158,131,91,115,225,20,178,71,45,222,142,197,36,66,145,93,234,34,198,67,217,109,243,45,67,161,237,54,195,224,85,112,6,32,69,155,9,64,123,212,3,94,242,76,113,214,25,170,49,220,119,148,28,170,90,10,200,143,80,95,153,18,64,202,175,220,250,42,208,96,163,254,133,185,21,52,230,190,126,244,138,13,86,254,58,138,211,125,179,251,34,2,183,248,126,143,54,187,78,136,235,193,50,32,82,117,173,161,98,9,82,63,105,187,19,205,37,230,76,21,104,60,167,119,214,106,37,227,13,101,120,167,25,109,146,227,201,60,238,38,148,206,181,42,163,236,176,128,107,154,184,50,225,208,133,232,49,73,165,90,239,152,204,0,89,182,72,11,156,101,217,14,130,252,111,227,5,72,95,47,196,0,245,94,149,13,84,27,150,193,19,181,68,30,48,243,61,221,127,246,24,138,190,69,88,57,26,141,210,151,220,249,67,117,166,35,194,112,176,202,95,237,139,208,111,129,216,190,142,37,171,197,81,47,119,229,159,200,171,79,120,33,133,169,23,213,80,138,238,69,44,253,63,117,4,56,250,172,78,157,93,116,6,104,162,241,31,182,1,103,46,243,189,59]),n=new Uint8Array(4096);for(let o=0;o<1024;o++)n[4*o]=e[o],n[4*o+1]=t[o],n[4*o+2]=0,n[4*o+3]=0;const i=new Jn(n,32,32,Qe,Ft);return i.name="GTAONoiseTexture",i.wrapS=Qn,i.wrapT=Qn,i.needsUpdate=!0,i}}class hR{constructor(e=4){this.pool=e,this.queue=[],this.workers=[],this.workersResolve=[],this.workerStatus=0}_initWorker(e){if(!this.workers[e]){const t=this.workerCreator();t.addEventListener("message",this._onMessage.bind(this,e)),this.workers[e]=t}}_getIdleWorker(){for(let e=0;e<this.pool;e++)if(!(this.workerStatus&1<<e))return e;return-1}_onMessage(e,t){const n=this.workersResolve[e];if(n&&n(t),this.queue.length){const{resolve:i,msg:o,transfer:r}=this.queue.shift();this.workersResolve[e]=i,this.workers[e].postMessage(o,r)}else this.workerStatus^=1<<e}setWorkerCreator(e){this.workerCreator=e}setWorkerLimit(e){this.pool=e}postMessage(e,t){return new Promise(n=>{const i=this._getIdleWorker();i!==-1?(this._initWorker(i),this.workerStatus|=1<<i,this.workersResolve[i]=n,this.workers[i].postMessage(e,t)):this.queue.push({resolve:n,msg:e,transfer:t})})}dispose(){this.workers.forEach(e=>e.terminate()),this.workersResolve.length=0,this.workers.length=0,this.queue.length=0,this.workerStatus=0}}const Id=new WeakMap;let Rd=0;class Ii extends pn{constructor(e){super(e),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerPool=new hR,this.workerSourceURL="",this.workerConfig=null,typeof MSC_TRANSCODER<"u"&&console.warn('v3d.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(e){return this.transcoderPath=e,this}setWorkerLimit(e){return this.workerPool.setWorkerLimit(e),this}detectSupport(e){return this.workerConfig={astcSupported:e.extensions.has("WEBGL_compressed_texture_astc"),etc1Supported:e.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:e.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:e.extensions.has("WEBGL_compressed_texture_s3tc")&&e.extensions.has("WEBGL_compressed_texture_s3tc_srgb"),bptcSupported:e.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:e.extensions.has("WEBGL_compressed_texture_pvrtc")||e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},e.capabilities.isWebGL2&&(this.workerConfig.etc1Supported=!1),this}dispose(){return this.workerPool.dispose(),this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}init(){if(!this.transcoderPending){const e=new cn(this.manager);e.setPath(this.transcoderPath),e.setWithCredentials(this.withCredentials);const t=e.loadAsync("basis_transcoder.js"),n=new cn(this.manager);n.setPath(this.transcoderPath),n.setResponseType("arraybuffer"),n.setWithCredentials(this.withCredentials);const i=n.loadAsync("basis_transcoder.wasm");this.transcoderPending=Promise.all([t,i]).then(([o,r])=>{const s=Ii.BasisWorker.toString(),l=["/* constants */","let _EngineFormat = "+JSON.stringify(Ii.EngineFormat),"let _TranscoderFormat = "+JSON.stringify(Ii.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(Ii.BasisFormat),"/* basis_transcoder.js */",o,"/* worker */",s.substring(s.indexOf("{")+1,s.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([l])),this.transcoderBinary=r,this.workerPool.setWorkerCreator(()=>{const c=new Worker(this.workerSourceURL),d=this.transcoderBinary.slice(0);return c.postMessage({type:"init",config:this.workerConfig,transcoderBinary:d},[d]),c})}),Rd>0&&console.warn("v3d.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),Rd++}return this.transcoderPending}load(e,t,n,i){if(this.workerConfig===null)throw new Error("v3d.KTX2Loader: Missing initialization with `.detectSupport(renderer)`.");const o=new cn(this.manager);o.setResponseType("arraybuffer"),o.setWithCredentials(this.withCredentials);const r=new ys;return o.load(e,s=>{if(Id.has(s))return Id.get(s).promise.then(t).catch(i);this._createTexture([s]).then(function(l){r.copy(l),r.needsUpdate=!0,t&&t(r)}).catch(i)},n,i),r}_createTextureFrom(e){const{mipmaps:t,width:n,height:i,format:o,type:r,error:s,dfdTransferFn:l,dfdFlags:c}=e;if(r==="error")return Promise.reject(s);const d=new ys(t,n,i,o,Ft);return d.minFilter=t.length===1?Le:In,d.magFilter=Le,d.generateMipmaps=!1,d.needsUpdate=!0,d.encoding=l===2?Ke:_n,d.premultiplyAlpha=!!(1&c),d}_createTexture(e,t={}){const n=t,i=this.init().then(()=>this.workerPool.postMessage({type:"transcode",buffers:e,taskConfig:n},e)).then(o=>this._createTextureFrom(o.data));return Id.set(e[0],{promise:i}),i}dispose(){return URL.revokeObjectURL(this.workerSourceURL),this.workerPool.dispose(),Rd--,this}}Ii.BasisFormat={ETC1S:0,UASTC_4x4:1},Ii.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16},Ii.EngineFormat={RGBAFormat:Qe,RGBA_ASTC_4x4_Format:hs,RGBA_BPTC_Format:ps,RGBA_ETC2_EAC_Format:ds,RGBA_PVRTC_4BPPV1_Format:cs,RGBA_S3TC_DXT5_Format:oa,RGB_ETC1_Format:Wc,RGB_ETC2_Format:us,RGB_PVRTC_4BPPV1_Format:ls,RGB_S3TC_DXT1_Format:ia},Ii.BasisWorker=function(){let a,e,t;const n=_EngineFormat,i=_TranscoderFormat,o=_BasisFormat;self.addEventListener("message",function(d){const u=d.data;switch(u.type){case"init":a=u.config,h=u.transcoderBinary,e=new Promise(p=>{t={wasmBinary:h,onRuntimeInitialized:p},BASIS(t)}).then(()=>{t.initializeBasis(),t.KTX2File===void 0&&console.warn("v3d.KTX2Loader: Please update Basis Universal transcoder.")});break;case"transcode":e.then(()=>{try{const{width:p,height:m,hasAlpha:f,mipmaps:g,format:_,dfdTransferFn:A,dfdFlags:x}=function(M){const T=new t.KTX2File(new Uint8Array(M));function L(){T.close(),T.delete()}if(!T.isValid())throw L(),new Error("v3d.KTX2Loader:    Invalid or unsupported .ktx2 file");const z=T.isUASTC()?o.UASTC_4x4:o.ETC1S,W=T.getWidth(),V=T.getHeight(),N=T.getLevels(),j=T.getHasAlpha(),oe=T.getDFDTransferFunc(),H=T.getDFDFlags(),{transcoderFormat:ne,engineFormat:le}=function(ae,E,F,U){let B,Z;const k=ae===o.ETC1S?s:l;for(let X=0;X<k.length;X++){const P=k[X];if(a[P.if]&&P.basisFormat.includes(ae)&&!(U&&P.transcoderFormat.length<2)&&(!P.needsPowerOfTwo||c(E)&&c(F)))return B=P.transcoderFormat[U?1:0],Z=P.engineFormat[U?1:0],{transcoderFormat:B,engineFormat:Z}}return console.warn("v3d.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."),B=i.RGBA32,Z=n.RGBAFormat,{transcoderFormat:B,engineFormat:Z}}(z,W,V,j);if(!W||!V||!N)throw L(),new Error("v3d.KTX2Loader:    Invalid texture");if(!T.startTranscoding())throw L(),new Error("v3d.KTX2Loader: .startTranscoding failed");const re=[];for(let ae=0;ae<N;ae++){const E=T.getImageLevelInfo(ae,0,0),F=E.origWidth,U=E.origHeight,B=new Uint8Array(T.getImageTranscodedSizeInBytes(ae,0,0,ne));if(!T.transcodeImage(B,ae,0,0,ne,0,-1,-1))throw L(),new Error("v3d.KTX2Loader: .transcodeImage failed.");re.push({data:B,width:F,height:U})}return L(),{width:W,height:V,hasAlpha:j,mipmaps:re,format:le,dfdTransferFn:oe,dfdFlags:H}}(u.buffers[0]),S=[];for(let M=0;M<g.length;++M)S.push(g[M].data.buffer);self.postMessage({type:"transcode",id:u.id,width:p,height:m,hasAlpha:f,mipmaps:g,format:_,dfdTransferFn:A,dfdFlags:x},S)}catch(p){console.error(p),self.postMessage({type:"error",id:u.id,error:p.message})}})}var h});const r=[{if:"astcSupported",basisFormat:[o.UASTC_4x4],transcoderFormat:[i.ASTC_4x4,i.ASTC_4x4],engineFormat:[n.RGBA_ASTC_4x4_Format,n.RGBA_ASTC_4x4_Format],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[o.ETC1S,o.UASTC_4x4],transcoderFormat:[i.BC7_M5,i.BC7_M5],engineFormat:[n.RGBA_BPTC_Format,n.RGBA_BPTC_Format],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[o.ETC1S,o.UASTC_4x4],transcoderFormat:[i.BC1,i.BC3],engineFormat:[n.RGB_S3TC_DXT1_Format,n.RGBA_S3TC_DXT5_Format],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[o.ETC1S,o.UASTC_4x4],transcoderFormat:[i.ETC1,i.ETC2],engineFormat:[n.RGB_ETC2_Format,n.RGBA_ETC2_EAC_Format],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[o.ETC1S,o.UASTC_4x4],transcoderFormat:[i.ETC1],engineFormat:[n.RGB_ETC1_Format],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[o.ETC1S,o.UASTC_4x4],transcoderFormat:[i.PVRTC1_4_RGB,i.PVRTC1_4_RGBA],engineFormat:[n.RGB_PVRTC_4BPPV1_Format,n.RGBA_PVRTC_4BPPV1_Format],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0}],s=r.sort(function(d,u){return d.priorityETC1S-u.priorityETC1S}),l=r.sort(function(d,u){return d.priorityUASTC-u.priorityUASTC});function c(d){return d<=2||(d&d-1)==0&&d!==0}};class ov{static fromCubeTexture(e){let t=0;const n=new b,i=new b,o=new me,r=[0,0,0,0,0,0,0,0,0],s=new ea,l=s.coefficients;for(let d=0;d<6;d++){const u=e.image[d],h=u.width,p=u.height,m=document.createElement("canvas");m.width=h,m.height=p;const f=m.getContext("2d");f.drawImage(u,0,0,h,p);const g=f.getImageData(0,0,h,p),_=g.data,A=g.width,x=2/A;for(let S=0,M=_.length;S<M;S+=4){o.setRGB(_[S]/255,_[S+1]/255,_[S+2]/255),D0(o,e.encoding);const T=S/4,L=(T%A+.5)*x-1,z=1-(Math.floor(T/A)+.5)*x;switch(d){case 0:n.set(-1,z,-L);break;case 1:n.set(1,z,L);break;case 2:n.set(-L,1,-z);break;case 3:n.set(-L,-1,z);break;case 4:n.set(-L,z,1);break;case 5:n.set(L,z,-1)}const W=n.lengthSq(),V=4/(Math.sqrt(W)*W);t+=V,i.copy(n).normalize(),ea.getBasisAt(i,r);for(let N=0;N<9;N++)l[N].x+=r[N]*o.r*V,l[N].y+=r[N]*o.g*V,l[N].z+=r[N]*o.b*V}}const c=4*Math.PI/t;for(let d=0;d<9;d++)l[d].x*=c,l[d].y*=c,l[d].z*=c;return new ga(s)}static fromCubeRenderTarget(e,t){let n=0;const i=new b,o=new b,r=new me,s=[0,0,0,0,0,0,0,0,0],l=new ea,c=l.coefficients,d=t.texture.type;for(let h=0;h<6;h++){const p=t.width,m=new(d===_t?Uint16Array:d===Ct?Float32Array:Uint8Array)(p*p*4);e.readRenderTargetPixels(t,0,0,p,p,m,h);const f=2/p;for(let g=0,_=m.length;g<_;g+=4){d===_t?r.setRGB(_c(m[g]),_c(m[g+1]),_c(m[g+2])):d===Ct?r.setRGB(m[g],m[g+1],m[g+2]):r.setRGB(m[g]/255,m[g+1]/255,m[g+2]/255),D0(r,t.texture.encoding);const A=g/4,x=(A%p+.5)*f-1,S=1-(Math.floor(A/p)+.5)*f;switch(h){case 0:i.set(1,S,-x);break;case 1:i.set(-1,S,x);break;case 2:i.set(x,1,-S);break;case 3:i.set(x,-1,S);break;case 4:i.set(x,S,1);break;case 5:i.set(-x,S,-1)}const M=i.lengthSq(),T=4/(Math.sqrt(M)*M);n+=T,o.copy(i).normalize(),ea.getBasisAt(o,s);for(let L=0;L<9;L++)c[L].x+=s[L]*r.r*T,c[L].y+=s[L]*r.g*T,c[L].z+=s[L]*r.b*T}}const u=4*Math.PI/n;for(let h=0;h<9;h++)c[h].x*=u,c[h].y*=u,c[h].z*=u;return new ga(l)}}function D0(a,e){switch(e){case Ke:a.convertSRGBToLinear();break;case _n:break;default:console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.")}return a}function Ac(a,e,t,n,i){this._domElement=a,this._keyCode=e,this._callback=t,this._repeats=n,this._period=i,this._timer=0,this._counter=0,this._keydownCb=(function(o){o.keyCode==this._keyCode&&(this._timer||(this._timer=window.setTimeout((function(){this._counter=0,this._timer=null}).bind(this),1e3*i)),++this._counter>=n&&(this._timer&&(window.clearTimeout(this._timer),this._timer=null),this._counter=0,this._callback()))}).bind(this),this._domElement.addEventListener("keydown",this._keydownCb,!1)}function pR(){throw new Error("BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.")}function fR(a,e,t=!0){if(!e||!e.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!a.hasAttribute("position")||!a.hasAttribute("normal")||!a.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function n(r){if(r.normalized||r.isInterleavedBufferAttribute){const s=new Float32Array(r.getCount()*r.itemSize);for(let l=0,c=0;l<r.getCount();l++)s[c++]=r.getX(l),s[c++]=r.getY(l),r.itemSize>2&&(s[c++]=r.getZ(l));return s}return r.array instanceof Float32Array?r.array:new Float32Array(r.array)}const i=a.index?a.toNonIndexed():a,o=e.generateTangents(n(i.attributes.position),n(i.attributes.normal),n(i.attributes.uv));if(t)for(let r=3;r<o.length;r+=4)o[r]*=-1;return i.setAttribute("tangent",new Te(o,4)),a!==i&&a.copy(i),a}function mR(a,e=!1){const t=a[0].index!==null,n=new Set(Object.keys(a[0].attributes)),i=new Set(Object.keys(a[0].morphAttributes)),o={},r={},s=a[0].morphTargetsRelative,l=new Pe;let c=0;for(let d=0;d<a.length;++d){const u=a[d];let h=0;if(t!==(u.index!==null))return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+d+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const p in u.attributes){if(!n.has(p))return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+d+'. All geometries must have compatible attributes; make sure "'+p+'" attribute exists among all geometries, or in none of them.'),null;o[p]===void 0&&(o[p]=[]),o[p].push(u.attributes[p]),h++}if(h!==n.size)return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+d+". Make sure all geometries have the same number of attributes."),null;if(s!==u.morphTargetsRelative)return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+d+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const p in u.morphAttributes){if(!i.has(p))return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+d+".  .morphAttributes must be consistent throughout all geometries."),null;r[p]===void 0&&(r[p]=[]),r[p].push(u.morphAttributes[p])}if(e){let p;if(t)p=u.index.count;else{if(u.attributes.position===void 0)return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+d+". The geometry must have either an index or a position attribute"),null;p=u.attributes.position.count}l.addGroup(c,p,d),c+=p}}if(t){let d=0;const u=[];for(let h=0;h<a.length;++h){const p=a[h].index;for(let m=0;m<p.count;++m)u.push(p.getX(m)+d);d+=a[h].attributes.position.count}l.setIndex(u)}for(const d in o){const u=yh(o[d]);if(!u)return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+d+" attribute."),null;l.setAttribute(d,u)}for(const d in r){const u=r[d][0].length;if(u===0)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[d]=[];for(let h=0;h<u;++h){const p=[];for(let f=0;f<r[d].length;++f)p.push(r[d][f][h]);const m=yh(p);if(!m)return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+d+" morphAttribute."),null;l.morphAttributes[d].push(m)}}return l}function yh(a){let e,t,n,i=0;for(let s=0;s<a.length;++s){const l=a[s];if(l.isInterleavedBufferAttribute)return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(e===void 0&&(e=l.array.constructor),e!==l.array.constructor)return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(t===void 0&&(t=l.itemSize),t!==l.itemSize)return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(n===void 0&&(n=l.normalized),n!==l.normalized)return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;i+=l.array.length}const o=new e(i);let r=0;for(let s=0;s<a.length;++s)o.set(a[s].array,r),r+=a[s].array.length;return new Te(o,t,n)}function xc(a){return a.isInstancedInterleavedBufferAttribute||a.isInterleavedBufferAttribute?zc(a):a.isInstancedBufferAttribute?new InstancedBufferAttribute().copy(a):new Te().copy(a)}function gR(a){let e,t=0,n=0;for(let c=0,d=a.length;c<d;++c){const u=a[c];if(e===void 0&&(e=u.array.constructor),e!==u.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;t+=u.array.length,n+=u.itemSize}const i=new Ma(new e(t),n);let o=0;const r=[],s=["getX","getY","getZ","getW"],l=["setX","setY","setZ","setW"];for(let c=0,d=a.length;c<d;c++){const u=a[c],h=u.itemSize,p=u.count,m=new io(i,h,o,u.normalized);r.push(m),o+=h;for(let f=0;f<p;f++)for(let g=0;g<h;g++)m[l[g]](f,u[s[g]](f))}return r}function zc(a){const e=a.data.array.constructor,t=a.count,n=a.itemSize,i=a.normalized,o=new e(t*n);let r;r=a.isInstancedInterleavedBufferAttribute?new InstancedBufferAttribute(o,n,i,a.meshPerAttribute):new Te(o,n,i);for(let s=0;s<t;s++)r.setX(s,a.getX(s)),n>=2&&r.setY(s,a.getY(s)),n>=3&&r.setZ(s,a.getZ(s)),n>=4&&r.setW(s,a.getW(s));return r}function vR(a){const e=a.attributes,t=a.morphTargets,n=new Map;for(const i in e){const o=e[i];o.isInterleavedBufferAttribute&&(n.has(o)||n.set(o,zc(o)),e[i]=n.get(o))}for(const i in t){const o=t[i];o.isInterleavedBufferAttribute&&(n.has(o)||n.set(o,zc(o)),t[i]=n.get(o))}}function _R(a){let e=0;for(const n in a.attributes){const i=a.getAttribute(n);e+=i.count*i.itemSize*i.array.BYTES_PER_ELEMENT}const t=a.getIndex();return e+=t?t.count*t.itemSize*t.array.BYTES_PER_ELEMENT:0,e}function AR(a,e=1e-4){e=Math.max(e,Number.EPSILON);const t={},n=a.getIndex(),i=a.getAttribute("position"),o=n?n.count:i.count;let r=0;const s=Object.keys(a.attributes),l={},c={},d=[],u=["getX","getY","getZ","getW"],h=["setX","setY","setZ","setW"];for(let g=0,_=s.length;g<_;g++){const A=s[g],x=a.attributes[A];l[A]=new Te(new x.array.constructor(x.count*x.itemSize),x.itemSize,x.normalized);const S=a.morphAttributes[A];S&&(c[A]=new Te(new S.array.constructor(S.count*S.itemSize),S.itemSize,S.normalized))}const p=Math.log10(1/e),m=Math.pow(10,p);for(let g=0;g<o;g++){const _=n?n.getX(g):g;let A="";for(let x=0,S=s.length;x<S;x++){const M=s[x],T=a.getAttribute(M),L=T.itemSize;for(let z=0;z<L;z++)A+=~~(T[u[z]](_)*m)+","}if(A in t)d.push(t[A]);else{for(let x=0,S=s.length;x<S;x++){const M=s[x],T=a.getAttribute(M),L=a.morphAttributes[M],z=T.itemSize,W=l[M],V=c[M];for(let N=0;N<z;N++){const j=u[N],oe=h[N];if(W[oe](r,T[j](_)),L)for(let H=0,ne=L.length;H<ne;H++)V[H][oe](r,L[H][j](_))}}t[A]=r,d.push(r),r++}}const f=a.clone();for(const g in a.attributes){const _=l[g];if(f.setAttribute(g,new Te(_.array.slice(0,r*_.itemSize),_.itemSize,_.normalized)),g in c)for(let A=0;A<c[g].length;A++){const x=c[g][A];f.morphAttributes[g][A]=new Te(x.array.slice(0,r*x.itemSize),x.itemSize,x.normalized)}}return f.setIndex(d),f}function xR(a,e){if(e===wg)return console.warn("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),a;if(e===fs||e===Fh){let t=a.getIndex();if(t===null){const r=[],s=a.getAttribute("position");if(s===void 0)return console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),a;for(let l=0;l<s.count;l++)r.push(l);a.setIndex(r),t=a.getIndex()}const n=t.count-2,i=[];if(e===fs)for(let r=1;r<=n;r++)i.push(t.getX(0)),i.push(t.getX(r)),i.push(t.getX(r+1));else for(let r=0;r<n;r++)r%2==0?(i.push(t.getX(r)),i.push(t.getX(r+1)),i.push(t.getX(r+2))):(i.push(t.getX(r+2)),i.push(t.getX(r+1)),i.push(t.getX(r)));i.length/3!==n&&console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const o=a.clone();return o.setIndex(i),o.clearGroups(),o}return console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),a}function yR(a){if(a.geometry.isBufferGeometry!==!0)return console.error("v3d.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;const e=new b,t=new b,n=new b,i=new b,o=new b,r=new b,s=new b,l=new b,c=new b;function d(re,ae,E,F,U,B,Z,k){e.fromBufferAttribute(ae,U),t.fromBufferAttribute(ae,B),n.fromBufferAttribute(ae,Z);const X=re.morphTargetInfluences;if(E&&X){s.set(0,0,0),l.set(0,0,0),c.set(0,0,0);for(let P=0,v=E.length;P<v;P++){const y=X[P],R=E[P];y!==0&&(i.fromBufferAttribute(R,U),o.fromBufferAttribute(R,B),r.fromBufferAttribute(R,Z),F?(s.addScaledVector(i,y),l.addScaledVector(o,y),c.addScaledVector(r,y)):(s.addScaledVector(i.sub(e),y),l.addScaledVector(o.sub(t),y),c.addScaledVector(r.sub(n),y)))}e.add(s),t.add(l),n.add(c)}re.isSkinnedMesh&&(re.boneTransform(U,e),re.boneTransform(B,t),re.boneTransform(Z,n)),k[3*U+0]=e.x,k[3*U+1]=e.y,k[3*U+2]=e.z,k[3*B+0]=t.x,k[3*B+1]=t.y,k[3*B+2]=t.z,k[3*Z+0]=n.x,k[3*Z+1]=n.y,k[3*Z+2]=n.z}const u=a.geometry,h=a.material;let p,m,f;const g=u.index,_=u.attributes.position,A=u.morphAttributes.position,x=u.morphTargetsRelative,S=u.attributes.normal,M=u.morphAttributes.position,T=u.groups,L=u.drawRange;let z,W,V,N,j,oe,H;const ne=new Float32Array(_.count*_.itemSize),le=new Float32Array(S.count*S.itemSize);if(g!==null)if(Array.isArray(h))for(z=0,V=T.length;z<V;z++)for(j=T[z],oe=Math.max(j.start,L.start),H=Math.min(j.start+j.count,L.start+L.count),W=oe,N=H;W<N;W+=3)p=g.getX(W),m=g.getX(W+1),f=g.getX(W+2),d(a,_,A,x,p,m,f,ne),d(a,S,M,x,p,m,f,le);else for(oe=Math.max(0,L.start),H=Math.min(g.count,L.start+L.count),z=oe,V=H;z<V;z+=3)p=g.getX(z),m=g.getX(z+1),f=g.getX(z+2),d(a,_,A,x,p,m,f,ne),d(a,S,M,x,p,m,f,le);else if(Array.isArray(h))for(z=0,V=T.length;z<V;z++)for(j=T[z],oe=Math.max(j.start,L.start),H=Math.min(j.start+j.count,L.start+L.count),W=oe,N=H;W<N;W+=3)p=W,m=W+1,f=W+2,d(a,_,A,x,p,m,f,ne),d(a,S,M,x,p,m,f,le);else for(oe=Math.max(0,L.start),H=Math.min(_.count,L.start+L.count),z=oe,V=H;z<V;z+=3)p=z,m=z+1,f=z+2,d(a,_,A,x,p,m,f,ne),d(a,S,M,x,p,m,f,le);return{positionAttribute:_,normalAttribute:S,morphedPositionAttribute:new Ie(ne,3),morphedNormalAttribute:new Ie(le,3)}}function rv(a){if(a.groups.length===0)return console.warn("v3d.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),a;let e=a.groups;if(e=e.sort((r,s)=>r.materialIndex!==s.materialIndex?r.materialIndex-s.materialIndex:r.start-s.start),a.getIndex()===null){const r=a.getAttribute("position"),s=[];for(let l=0;l<r.count;l+=3)s.push(l,l+1,l+2);a.setIndex(s)}const t=a.getIndex(),n=[];for(let r=0;r<e.length;r++){const s=e[r],l=s.start,c=l+s.count;for(let d=l;d<c;d++)n.push(t.getX(d))}a.dispose(),a.setIndex(n);let i=0;for(let r=0;r<e.length;r++){const s=e[r];s.start=i,i+=s.count}let o=e[0];a.groups=[o];for(let r=1;r<e.length;r++){const s=e[r];o.materialIndex===s.materialIndex?o.count+=s.count:(o=s,a.groups.push(o))}return a}function bR(a,e=Math.PI/3){const t=Math.cos(e),n=100*(1+1e-10),i=[new b,new b,new b],o=new b,r=new b,s=new b,l=new b;function c(f){return`${~~(f.x*n)},${~~(f.y*n)},${~~(f.z*n)}`}const d=a.toNonIndexed(),u=d.attributes.position,h={};for(let f=0,g=u.count/3;f<g;f++){const _=3*f,A=i[0].fromBufferAttribute(u,_+0),x=i[1].fromBufferAttribute(u,_+1),S=i[2].fromBufferAttribute(u,_+2);o.subVectors(S,x),r.subVectors(A,x);const M=new b().crossVectors(o,r).normalize();for(let T=0;T<3;T++){const L=c(i[T]);L in h||(h[L]=[]),h[L].push(M)}}const p=new Float32Array(3*u.count),m=new Te(p,3,!1);for(let f=0,g=u.count/3;f<g;f++){const _=3*f,A=i[0].fromBufferAttribute(u,_+0),x=i[1].fromBufferAttribute(u,_+1),S=i[2].fromBufferAttribute(u,_+2);o.subVectors(S,x),r.subVectors(A,x),s.crossVectors(o,r).normalize();for(let M=0;M<3;M++){const T=h[c(i[M])];l.set(0,0,0);for(let L=0,z=T.length;L<z;L++){const W=T[L];s.dot(W)>t&&l.add(W)}l.normalize(),m.setXYZ(_+M,l.x,l.y,l.z)}}return d.setAttribute("normal",m),d}function CR(a,e){const t={};for(let n=0;n<a.length;n++){const i=a[n],o=i.geometry,r=i.material;let s=[];s.push(r.name),s.push(i.visible),s.push(i.disableChildRendering),s.push(i.castShadow),s.push(i.receiveShadow),s.push(i.renderOrder),s=s.concat(i.groupNames);const l=Object.keys(o.attributes);s=s.concat(l);const c=Object.keys(o.morphAttributes);s=s.concat(c),s=s.join(),t[s]=t[s]||[],t[s].indexOf(i)==-1&&t[s].push(i)}for(let n in t){const i=t[n];if(i.length<2)continue;const o=[];let r=!0;for(let u=0;u<i.length;u++){const h=i[u],p=h.geometry;h.updateMatrixWorld(),o.push(p.clone().applyMatrix4(h.matrixWorld)),p.boundsTree||(r=!1)}const s=i[0],l=s.material,c=`${l.name}_x${i.length}_batch`,d=this.mergeBufferGeometries(o);if(d){const u=new Ue(d,l);u.name=c,u.visible=s.visible,u.disableChildRendering=s.disableChildRendering,u.castShadow=s.castShadow,u.receiveShadow=s.receiveShadow,u.renderOrder=s.renderOrder,u.groupNames=s.groupNames;for(let h=0;h<i.length;h++){const p=i[h];p.parent.remove(p)}r&&d.computeBoundsTree({verbose:!1}),console.log("Adding batch object:",c),e.add(u)}else console.warn("Failed to create batch object:",c)}}Object.assign(Ac.prototype,{dispose:function(){this._domElement.removeEventListener("keydown",this._keydownCb,!1),this._timer&&window.clearTimeout(this._timer)}});var SR=Object.freeze({__proto__:null,batchMeshes:CR,computeMikkTSpaceTangents:fR,computeMorphedAttributes:yR,computeTangents:pR,deepCloneAttribute:xc,deinterleaveAttribute:zc,deinterleaveGeometry:vR,estimateBytesUsed:_R,interleaveAttributes:gR,mergeBufferAttributes:yh,mergeBufferGeometries:mR,mergeGroups:rv,mergeVertices:AR,toCreasedNormals:bR,toTrianglesDrawMode:xR});const N0=new me,O0=new Ae;function MR(a){const e=new Zn,t=a.count,n=a.geometry,i=a.material;for(let o=0;o<t;o++){const r=new Ue(n,i);a.getMatrixAt(o,r.matrix),r.matrix.decompose(r.position,r.quaternion,r.scale),e.add(r)}return e.copy(a),e.updateMatrixWorld(),e}function ER(a){if(Array.isArray(a.material)===!1)return console.warn("v3d.SceneUtils.createMeshesFromMultiMaterialMesh(): The given mesh has no multiple materials."),a;const e=new Zn;e.copy(a);const t=rv(a.geometry),n=t.index,i=t.groups,o=Object.keys(t.attributes);for(let r=0;r<i.length;r++){const s=i[r],l=s.start,c=l+s.count,d=new Pe,u=a.material[s.materialIndex];for(let p=0;p<o.length;p++){const m=o[p],f=t.attributes[m],g=f.itemSize,_=s.count*g,A=new f.array.constructor(_),x=new Te(A,g);for(let S=l,M=0;S<c;S++,M++){const T=n.getX(S);g>=1&&x.setX(M,f.getX(T)),g>=2&&x.setY(M,f.getY(T)),g>=3&&x.setZ(M,f.getZ(T)),g>=4&&x.setW(M,f.getW(T))}d.setAttribute(m,x)}const h=new Ue(d,u);e.add(h)}return e}function wR(a,e){const t=new Zn;for(let n=0,i=e.length;n<i;n++)t.add(new Ue(a,e[n]));return t}function TR(a,e,t){let n=t;const i=new b;return a.updateWorldMatrix(!0,!0),a.traverseVisible(o=>{const{geometry:r}=o;if(r!==void 0){const{position:s}=r.attributes;if(s!==void 0)for(let l=0,c=s.count;l<c;l++)o.isMesh?o.getVertexPosition(l,i):i.fromBufferAttribute(s,l),o.isSkinnedMesh||i.applyMatrix4(o.matrixWorld),n=e(n,i)}}),n}function IR(a,e){const t=xc(a.instanceMatrix),n=a.instanceColor?xc(a.instanceColor):null,i=new Map;for(const r in a.geometry.attributes){const s=a.geometry.attributes[r];s.isInstancedBufferAttribute&&i.set(s,xc(s))}const o=[];for(let r=0;r<a.count;r++)o.push(r);o.sort(e);for(let r=0;r<o.length;r++){const s=o[r];O0.fromArray(t.array,s*a.instanceMatrix.itemSize),O0.toArray(a.instanceMatrix.array,r*a.instanceMatrix.itemSize),a.instanceColor&&(N0.fromArray(n.array,s*a.instanceColor.itemSize),N0.toArray(a.instanceColor.array,r*a.instanceColor.itemSize));for(const l in a.geometry.attributes){const c=a.geometry.attributes[l];if(c.isInstancedBufferAttribute){const d=i.get(c);c.setX(r,d.getX(s)),c.itemSize>1&&c.setY(r,d.getY(s)),c.itemSize>2&&c.setZ(r,d.getZ(s)),c.itemSize>3&&c.setW(r,d.getW(s))}}}}function RR(a,e){const t=this.getMaterialsByName(a,e);return t.length?t[0]:null}function LR(a,e){const t=[];if(a.scene!==null){a.scene.traverse(function(i){i.material&&i.material.name===e&&t.indexOf(i.material)===-1&&t.push(i.material)});const n=a.scene.worldMaterial;n!==null&&n.name===e&&t.indexOf(n)===-1&&t.push(n)}return t}function PR(a,e){for(let t=0;t<a.actions.length;t++){const n=a.actions[t];if(n.getClip().name==e)return n}return null}function av(a,e){return!!e._propertyBindings.find(function(t){const n=t.binding.node;return n&&n.findRoot()===a})}function BR(a,e,t){const n=new xt(6),i={};if(n.node(0).originData={name:"Light Path",type:"LIGHT_PATH_BL",inputs:[],outputs:[0,0,0,0,0,0,0,0,0,0,0,0,0],is_active_output:!1},n.node(1).originData={name:"Lighting Texture",type:"TEX_ENVIRONMENT_BL",projection:"EQUIRECTANGULAR",inputs:[[0,0,0]],outputs:[[0,0,0,0]],texture:0,is_active_output:!1},i[wt.nodeTexUniName("TEX_ENVIRONMENT_BL",0)]=e,t instanceof me){const o=[0,0,0,0];o[0]=t.r,o[1]=t.g,o[2]=t.b,o[3]=1,n.node(2).originData={name:"Background Color",type:"RGB_BL",inputs:[],outputs:[o],is_active_output:!1}}else n.node(2).originData={name:"Background Texture",type:"TEX_ENVIRONMENT_BL",projection:"EQUIRECTANGULAR",inputs:[[0,0,0]],outputs:[[0,0,0,0]],texture:1,is_active_output:!1},i[wt.nodeTexUniName("TEX_ENVIRONMENT_BL",1)]=t;return n.node(3).originData={name:"Mix",type:"MIX_RGB_BL",blendType:"MIX",inputs:[0,[0,0,0,0],[0,0,0,0]],outputs:[[0,0,0,0]],is_active_output:!1},n.node(4).originData={name:"Background",type:"BACKGROUND_BL",inputs:[[0,0,0,0],1],outputs:[[0,0,0,0]],is_active_output:!1},n.node(5).originData={name:"Output",type:"OUTPUT_WORLD_BL",inputs:[[0,0,0,0],[0,0,0,0]],outputs:[],is_active_output:!0},Xe(n,0,0,3,0),Xe(n,1,0,3,1),Xe(n,2,0,3,2),Xe(n,3,0,4,0),Xe(n,4,0,5,0),new wt({name:a,nodeGraph:n,nodeTextures:i})}function yc(a){const e=new At;return e.expandByObject(a),e}function sv(a,e){const t=new b,n=2*a.getSize(t).length(),i=new Qt(45,e,n/1e4,n);return i.position.copy(a.max).multiplyScalar(2),i.lookAt(a.getCenter(t)),i}function lv(a,e){const t=new ze;e.getCenter(t.position),a.controls=new X1,a.controls.orbitMinDistance=a.near,a.controls.orbitMaxDistance=a.far,a.controls.orbitTarget=t}var DR=Object.freeze({__proto__:null,assignDefaultControls:lv,calcSceneBox:yc,checkActionIsUsed:av,createDefaultCamera:sv,createEnvironmentMaterial:BR,createMeshesFromInstancedMesh:MR,createMeshesFromMultiMaterialMesh:ER,createMultiMaterialObject:wR,getAnimationActionByName:PR,getMaterialByName:RR,getMaterialsByName:LR,reduceVertices:TR,sortInstancedMesh:IR}),la=function(){var a=0,e=document.createElement("div");function t(d){return e.appendChild(d.dom),d}function n(d){for(var u=0;u<e.children.length;u++)e.children[u].style.display=u===d?"block":"none";a=d}e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",function(d){d.preventDefault(),n(++a%e.children.length)},!1);var i=(performance||Date).now(),o=i,r=0,s=t(new la.Panel("FPS","#0ff","#002")),l=t(new la.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=t(new la.Panel("MB","#f08","#201"));return n(0),{REVISION:16,dom:e,addPanel:t,showPanel:n,begin:function(){i=(performance||Date).now()},end:function(){r++;var d=(performance||Date).now();if(l.update(d-i,200),d>=o+1e3&&(s.update(1e3*r/(d-o),100),o=d,r=0,c)){var u=performance.memory;c.update(u.usedJSHeapSize/1048576,u.jsHeapSizeLimit/1048576)}return d},update:function(){i=this.end()},domElement:e,setMode:n}};la.Panel=function(a,e,t){var n=1/0,i=0,o=Math.round,r=o(window.devicePixelRatio||1),s=80*r,l=48*r,c=3*r,d=2*r,u=3*r,h=15*r,p=74*r,m=30*r,f=document.createElement("canvas");f.width=s,f.height=l,f.style.cssText="width:80px;height:48px";var g=f.getContext("2d");return g.font="bold "+9*r+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=t,g.fillRect(0,0,s,l),g.fillStyle=e,g.fillText(a,c,d),g.fillRect(u,h,p,m),g.fillStyle=t,g.globalAlpha=.9,g.fillRect(u,h,p,m),{dom:f,update:function(_,A){n=Math.min(n,_),i=Math.max(i,_),g.fillStyle=t,g.globalAlpha=1,g.fillRect(0,0,s,h),g.fillStyle=e,g.fillText(o(_)+" "+a+" ("+o(n)+"-"+o(i)+")",c,d),g.drawImage(f,u+r,h,p-r,m,u,h,p-r,m),g.fillRect(u+p-r,h,r,m),g.fillStyle=t,g.globalAlpha=.9,g.fillRect(u+p-r,h,r,o((1-_/A)*m))}}};const NR="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIQXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHja7ZhZltw2DEX/uYosQSQ4LofjOdlBlp8LSqquHt12nD+X3JIKYpEg3sMDZDP/+XuZv/iIOGd8SDmWGA8+vvjiKjf5OD91n+3h93l//PWI76/s5vHAYRKucn7N8bJP7I7x7rL3a56KPTxNVOb1oL1+UK+JXL4WuOz3QmLPBY5rYlOvicRdK18utnNbRyw5PW+hX+PX9XyHgT+jJy/JxRBt8py9O1KKhfvsDp+I21BHV3dFfxfaNdGb7+Ye6vDJTbFycM7qoeC+FKmi93rGaSzCvUjY53J6ClrOHIn7csf1689Xnpvb9QvyV5A+7uwn9iekzQ7o/UDeIBQf1w/tNrzYzTOkG7enlWN8rPzKnufRXu35Rk3/1hp5rXnurvrIluO1qXsr+45xTaO1fxU5En/hyBpsPQpHJiU6PBqQrHF0W6wDxmW9HbbaZee+dttx0bvpElfnuhPbDcYMGMX1DbfXwy6XAH5IBvgOHQSre/hi97JlL9dtZuFhs4E9lsksP/lPh/nOoLU0oaw98iNW+OU00/BCkbPWHJZhIGLXFdSwA3wfbz+Kq4Bg2GHObLAeTWcA/hbsC7lkAy0MDFzPBLZpXBMQIjwIOGMFBI5oJdhoj4SwJWsJZAagiutOvGvAYkNwAyedF4mAQxawNr9Jdg91wZ1mhBAggkQjCWxITcDyPsCf5DMcqkGCDyHEkEIOJdQoUTMsxhRVUWuS5FNIMaWUU0nVZMk+hxxzyjmXXIsrguKGQj6WXEqplUUrM1d+XRlQa3NNmm+hxZZabqXV7kyX7nvosaeee+l1uCGDPB5xpJFHGXXaCZWmn2HGmWaeZdYF1ZYsv8KKK628iln1gdoF67vjJ1CzF2puI6UD0wM1rCndU1iVk6CYgZjzFsCTImDFOKeYHdl67xQ5xewoTkXQ4WRQcIZVxEDQT+vCsg/sXpALRuLvwc0AhPsdyBmF7hvIvcftI9RG3YVONkKahhrUQ8i+VdbM1eWqlfLLq/nRgO9e/0z0Z6LfNtEKlJIcBGEJdi4Y3YtQv/vMn9hbb2uO2qngQp1HkExeIqtF6sbqOjSLnimwjeScNfUo89iTZO/b7GHNot9iXc1v+ypRmpg4x9DZbZ/owSyht5CoP3X52YZQTUprFa0ItmIdx22xPvAvogdcVPyXdoNjrZpJ4+lZTtdDaj62hxnWigOhXduzQx+mQvaPZrNbk99ZfVDsDIMlgtBQLro75kMVI3Xb63P8HRXr6s2O0hI7YuI8TZLWlq8z1NZmxkfWRLdoCMcQIVAj5kCbeFkOhcg11PO8o7M6r+Z4Y/iJq4KdFVJt3w261qI9nXagWtvw6cKp96g4ZMIw/NZERidb2NYSDUzpabXiF3EzpaKqdZNqZSuTXqnN0CtBntdNmZYJStprx7kgxZCka/XWsc9qwzRVdkRnFEWjy8mRQDknXhkExoYgj6QNm96PWsKsM8EoejmdKOblTRMIQOt3ucsgJUigEUldCH5vJRCMcd1I1wWdMmKMNfyqcepalKOCefgzY9iGzOJ/Jd3Mhw9aLbrhTCyntQ44IOYBgdocpAPBbbGP1siF1bRxHYNyFKjJcD0EaAQs0EU0zcCEBBDNiuQn3CFPANTv3epZWd+CRs2zU7Og7coEZKcArFQGA8BOU5faUL/I3J0OuVAw2xqHzAHbywZiudFiNEM9XIMa3edcw7USP5WUzT5RLsA6JZ9SD/K07JoZAFUiPmdQak0CPlGYa/MptVDJT20yYguxkIT0DXQKexSrkjpz8QhlimYmdYF13enoS7Lj9CkCxcXzCa7Esl8AQBq6rDabFASNxDfMWcgaRzTRgIFeBRmje5n4GAJmnGIHE2qUtOBqhOpzOhnrHtCJiJnTPoAA9FmVwgzCETw7yqmHPwbBfIbCOxC6jSogCHVjYzWhLEk1KTQonoYhUIEbIQd4p42Wliu5ngJtT8Le6LXS6CdV5xIA+p3l6GY+dKCrHMp8mK0bSBPGK/WJ/d4U1PdiM3WhDiU9dQCRH6o4sxerpKcUyJGASZrjLVvTQ/XiJ0sAAj9ayPYW+8IbpLzW/3KkLUIvEnQKEG6FLW3OF3aksFMFtoZp+I0+giNUtd4xUutm3LTnZxLXmFQ5el3WkFEIPtPMorRGG2sfslIJ8NIaqxnbBKp7ckpOgDThLLn1kBGbnmRkvcgIlH+WkbLIoOC1LCAksc5RuviYqfE0yZeFd/2vomk+DSfceh1PLZ5k35uI3vXUvC+oKlTrUVBJ56eSyhJ5flhTzS8U1Q+v5ptF9aXK7ZuWNaXDJshY1S4xofutu27qtutxVSPSrffPqhGj39Ujan+5K9IXxXq+FPp3UhsAdw3TwQG5G3aWmEBohrt4qthpkCbBz4ntlcQXXreum5R1sbAXHs2QldBo9LOroE+gIaj52mBwabjzC2+lX17NjwbodeuhtFsPof1Q0UMOyTI0EO45g2lqG8k2i809EsB4quEkUrK1cKgW8mZb+UkcIAdcUXKyI9scHR1MY6I3jzUIZ2ODum6EgoaiEIrp9/YJmYP0QbMBnHLaCW2meqzsfm6AyYtX7S+id3W/vKle3e/OPRojdI/oDyOdRFVlrAORRx/igFKtQDte/oV654VGuvIKzMM2eCFuVB4SbD3CppXcXFE7i8guPY8i0l5XcpVqGsNjp1bjzGyCNLRgySyT5TY9R2fu2joo2cRhR6bsdCYa8P8MEJnzEqJpHiH6KEA6wXcCRHzMrwRovzykVEY/b/U/r81981+vfyb6M9H/MBF5RKaafwEjmLcIrlR0mgAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+MCAwojJyJFeN4AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAd0lEQVR42u3YUQqAIBAFwLUDdf9zdCH7lwwEI2VnPkWQfWCvigAAAAAAgDTK1wecNWq7dpX+uaP7lw7gaZi3oUb3z3BkvwICEIAW+KcFRte3DWBGO7gCAhCAAHZ9FY6IpC3QG963gGeAAASgBRb6IwQAAAAAQCY34QUtIL9dJTwAAAAASUVORK5CYII=";class OR{constructor(e,t,n,i,o,r=0){this.a=e,this.b=t,this.c=n,this.normal=i&&i.isVector3?i:new b,this.vertexNormals=Array.isArray(i)?i:[],this.color=o&&o.isColor?o:new me,this.vertexColors=Array.isArray(o)?o:[],this.materialIndex=r}clone(){return new this.constructor().copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,n=e.vertexNormals.length;t<n;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,n=e.vertexColors.length;t<n;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}var ic=new b,oc=new b,rc=new b,F0=new te,U0=new te,z0=new te,V0=new b,ac=new b;function FR(a,e,t,n,i,o,r,s){if((e.side===nn?n.intersectTriangle(r,o,i,!0,s):n.intersectTriangle(i,o,r,e.side!==Tn,s))===null)return null;ac.copy(s),ac.applyMatrix4(a.matrixWorld);var l=t.ray.origin.distanceTo(ac);return l<t.near||l>t.far?null:{distance:l,point:ac.clone(),object:a}}function UR(a,e,t,n,i,o,r,s){ic.fromBufferAttribute(n,o),oc.fromBufferAttribute(n,r),rc.fromBufferAttribute(n,s);var l=FR(a,a.material,e,t,ic,oc,rc,V0);if(l){i&&(F0.fromBufferAttribute(i,o),U0.fromBufferAttribute(i,r),z0.fromBufferAttribute(i,s),l.uv=gn.getUV(V0,ic,oc,rc,F0,U0,z0,new te));var c=new b;l.face=new OR(o,r,s,gn.getNormal(ic,oc,rc,c)),l.faceIndex=o}return l}function cv(a,e,t,n,i,o){var r=3*i,s=e.index.getX(r),l=e.index.getX(r+1),c=e.index.getX(r+2),d=UR(a,t,n,e.attributes.position,e.attributes.uv,s,l,c);return d?(d.faceIndex=i,o&&o.push(d),d):null}function zR(a,e,t,n,i,o,r){for(var s=i,l=i+o;s<l;s++)cv(a,e,t,n,s,r)}function VR(a,e,t,n,i,o){for(var r=1/0,s=null,l=i,c=i+o;l<c;l++){var d=cv(a,e,t,n,l);d&&d.distance<r&&(s=d,r=d.distance)}return s}function GR(a){var e=new Float32Array(6);return e[0]=a.min.x,e[1]=a.min.y,e[2]=a.min.z,e[3]=a.max.x,e[4]=a.max.y,e[5]=a.max.z,e}function li(a,e){return e.min.x=a[0],e.min.y=a[1],e.min.z=a[2],e.max.x=a[3],e.max.y=a[4],e.max.z=a[5],e}function G0(a){for(var e=-1,t=-1/0,n=0;n<3;n++){var i=a[n+3]-a[n];i>t&&(t=i,e=n)}return e}class to{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){for(var n=1/0,i=-1/0,o=0,r=e.length;o<r;o++){var s=e[o][t];n=Math.min(s,n),i=Math.max(s,i)}this.min=n,this.max=i}setFromPoints(e,t){for(var n=1/0,i=-1/0,o=0,r=t.length;o<r;o++){var s=t[o],l=e.dot(s);n=Math.min(l,n),i=Math.max(l,i)}this.min=n,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}to.prototype.setFromBox=function(){var a=new b;return function(e,t){for(var n=t.min,i=t.max,o=1/0,r=-1/0,s=0;s<=1;s++)for(var l=0;l<=1;l++)for(var c=0;c<=1;c++){a.x=n.x*s+i.x*(1-s),a.y=n.y*l+i.y*(1-l),a.z=n.z*c+i.z*(1-c);var d=e.dot(a);o=Math.min(d,o),r=Math.max(d,r)}this.min=o,this.max=r}}();var kR=function(){var a=new b,e=new b,t=new b;return function(n,i,o){var r=n.start,s=a,l=i.start,c=e;t.subVectors(r,l),a.subVectors(n.end,i.start),e.subVectors(i.end,i.start);var d,u,h=t.dot(c),p=c.dot(s),m=c.dot(c),f=t.dot(s),g=s.dot(s)*m-p*p;u=(h+(d=g!==0?(h*p-f*m)/g:0)*p)/m,o.x=d,o.y=u}}(),uv=function(){var a=new te,e=new b,t=new b;return function(n,i,o,r){kR(n,i,a);var s,l,c=a.x,d=a.y;if(c>=0&&c<=1&&d>=0&&d<=1)return n.at(c,o),void i.at(d,r);if(c>=0&&c<=1)return d<0?i.at(0,r):i.at(1,r),void n.closestPointToPoint(r,!0,o);if(d>=0&&d<=1)return c<0?n.at(0,o):n.at(1,o),void i.closestPointToPoint(o,!0,r);s=c<0?n.start:n.end,l=d<0?i.start:i.end;var u=e,h=t;return n.closestPointToPoint(l,!0,e),i.closestPointToPoint(s,!0,t),u.distanceToSquared(l)<=h.distanceToSquared(s)?(o.copy(u),void r.copy(l)):(o.copy(s),void r.copy(h))}}(),QR=function(){var a=new b,e=new b,t=new Gn,n=new va;return function(i,o){var r=i.radius,s=i.center,l=o.a,c=o.b,d=o.c;if(n.start=l,n.end=c,n.closestPointToPoint(s,!0,a).distanceTo(s)<=r||(n.start=l,n.end=d,n.closestPointToPoint(s,!0,a).distanceTo(s)<=r)||(n.start=c,n.end=d,n.closestPointToPoint(s,!0,a).distanceTo(s)<=r))return!0;var u=o.getPlane(t);if(Math.abs(u.distanceToPoint(s))<=r){var h=u.projectPoint(s,e);if(o.containsPoint(h))return!0}return!1}}();class Ei extends gn{constructor(...e){super(...e),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map(function(){return new b}),this.satBounds=new Array(4).fill().map(function(){return new to}),this.points=[this.a,this.b,this.c],this.sphere=new Rn}}Ei.prototype.update=function(){var a=new Array(3);return function(){var e=this.a,t=this.b,n=this.c;a[0]=this.a,a[1]=this.b,a[2]=this.c;var i=this.satAxes,o=this.satBounds,r=i[0],s=o[0];this.getNormal(r),s.setFromPoints(r,a);var l=i[1],c=o[1];l.subVectors(e,t),c.setFromPoints(l,a);var d=i[2],u=o[2];d.subVectors(t,n),u.setFromPoints(d,a);var h=i[3],p=o[3];h.subVectors(n,e),p.setFromPoints(h,a),this.sphere.setFromPoints(this.points)}}(),Ei.prototype.intersectsTriangle=function(){var a=new Ei,e=new Array(3),t=new Array(3),n=new to,i=new to,o=new b;return function(r){r.isSeparatingAxisTriangle||(a.copy(r),a.update(),r=a);var s=this.satBounds,l=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(var c=0;c<4;c++){var d=s[c],u=l[c];if(n.setFromPoints(u,t),d.isSeparated(n))return!1}var h=r.satBounds,p=r.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(var m=0;m<4;m++){var f=h[m],g=p[m];if(n.setFromPoints(g,e),f.isSeparated(n))return!1}for(var _=0;_<4;_++)for(var A=l[_],x=0;x<4;x++){var S=p[x];if(o.crossVectors(A,S),n.setFromPoints(o,e),i.setFromPoints(o,t),n.isSeparated(i))return!1}return!0}}(),Ei.prototype.distanceToPoint=function(){var a=new b;return function(e){return this.closestPointToPoint(e,a),e.distanceTo(a)}}(),Ei.prototype.distanceToTriangle=function(){var a=new b,e=new b,t=["a","b","c"],n=new va,i=new va;return function(o,r=null,s=null){if(this.intersectsTriangle(o))return(r||s)&&(this.getMidpoint(a),o.closestPointToPoint(a,e),this.closestPointToPoint(e,a),r&&r.copy(a),s&&s.copy(e)),0;for(var l=1/0,c=0;c<3;c++){var d=void 0,u=t[c],h=o[u];this.closestPointToPoint(h,a),(d=h.distanceToSquared(a))<l&&(l=d,r&&r.copy(a),s&&s.copy(h));var p=this[u];o.closestPointToPoint(p,a),(d=p.distanceToSquared(a))<l&&(l=d,r&&r.copy(p),s&&s.copy(a))}for(var m=0;m<3;m++){var f=t[m],g=t[(m+1)%3];n.set(this[f],this[g]);for(var _=0;_<3;_++){var A=t[_],x=t[(_+1)%3];i.set(o[A],o[x]),uv(n,i,a,e);var S=a.distanceToSquared(e);S<l&&(l=S,r&&r.copy(a),s&&s.copy(e))}}return Math.sqrt(l)}}();class Si extends At{constructor(...e){super(...e),this.isOrientedBox=!0,this.matrix=new Ae,this.invMatrix=new Ae,this.points=new Array(8).fill().map(function(){return new b}),this.satAxes=new Array(3).fill().map(function(){return new b}),this.satBounds=new Array(3).fill().map(function(){return new to}),this.alignedSatBounds=new Array(3).fill().map(function(){return new to}),this.sphere=new Rn}set(e,t,n){super.set(e,t),this.matrix=n}copy(e){super.copy(e),this.matrix.copy(e.matrix)}}Si.prototype.update=function(){for(var a=this.matrix,e=this.min,t=this.max,n=this.points,i=0;i<=1;i++)for(var o=0;o<=1;o++)for(var r=0;r<=1;r++){var s=n[1*i|2*o|4*r];s.x=i?t.x:e.x,s.y=o?t.y:e.y,s.z=r?t.z:e.z,s.applyMatrix4(a)}this.sphere.setFromPoints(this.points);for(var l=this.satBounds,c=this.satAxes,d=n[0],u=0;u<3;u++){var h=c[u],p=l[u],m=n[1<<u];h.subVectors(d,m),p.setFromPoints(h,n)}var f=this.alignedSatBounds;f[0].setFromPointsField(n,"x"),f[1].setFromPointsField(n,"y"),f[2].setFromPointsField(n,"z"),this.invMatrix.copy(this.matrix).invert()},Si.prototype.intersectsBox=function(){var a=new to;return function(e){if(!e.intersectsSphere(this.sphere))return!1;var t=e.min,n=e.max,i=this.satBounds,o=this.satAxes,r=this.alignedSatBounds;if(a.min=t.x,a.max=n.x,r[0].isSeparated(a)||(a.min=t.y,a.max=n.y,r[1].isSeparated(a))||(a.min=t.z,a.max=n.z,r[2].isSeparated(a)))return!1;for(var s=0;s<3;s++){var l=o[s],c=i[s];if(a.setFromBox(l,e),c.isSeparated(a))return!1}return!0}}(),Si.prototype.intersectsTriangle=function(){var a=new Ei,e=new Array(3),t=new to,n=new to,i=new b;return function(o){o.isSeparatingAxisTriangle||(a.copy(o),a.update(),o=a);var r=this.satBounds,s=this.satAxes;e[0]=o.a,e[1]=o.b,e[2]=o.c;for(var l=0;l<3;l++){var c=r[l],d=s[l];if(t.setFromPoints(d,e),c.isSeparated(t))return!1}for(var u=o.satBounds,h=o.satAxes,p=this.points,m=0;m<3;m++){var f=u[m],g=h[m];if(t.setFromPoints(g,p),f.isSeparated(t))return!1}for(var _=0;_<3;_++)for(var A=s[_],x=0;x<4;x++){var S=h[x];if(i.crossVectors(A,S),t.setFromPoints(i,e),n.setFromPoints(i,p),t.isSeparated(n))return!1}return!0}}(),Si.prototype.closestPointToPoint=function(a,e){return e.copy(a).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},Si.prototype.distanceToPoint=function(){var a=new b;return function(e){return this.closestPointToPoint(e,a),e.distanceTo(a)}}(),Si.prototype.distanceToBox=function(){var a=["x","y","z"],e=new Array(12).fill().map(function(){return new va}),t=new Array(12).fill().map(function(){return new va}),n=new b,i=new b;return function(o,r=0,s=null,l=null){if(this.intersectsBox(o))return(s||l)&&(o.getCenter(i),this.closestPointToPoint(i,n),o.closestPointToPoint(n,i),s&&s.copy(n),l&&l.copy(i)),0;for(var c=r*r,d=o.min,u=o.max,h=this.points,p=1/0,m=0;m<8;m++){var f=h[m];i.copy(f).clamp(d,u);var g=f.distanceToSquared(i);if(g<p&&(p=g,s&&s.copy(f),l&&l.copy(i),g<c))return Math.sqrt(g)}for(var _=0,A=0;A<3;A++)for(var x=0;x<=1;x++)for(var S=0;S<=1;S++){var M=(A+1)%3,T=(A+2)%3,L=1<<A|x<<M|S<<T,z=h[x<<M|S<<T],W=h[L];e[_].set(z,W);var V=a[A],N=a[M],j=a[T],oe=t[_],H=oe.start,ne=oe.end;H[V]=d[V],H[N]=x?d[N]:u[N],H[j]=S?d[j]:u[N],ne[V]=u[V],ne[N]=x?d[N]:u[N],ne[j]=S?d[j]:u[N],_++}for(var le=0;le<=1;le++)for(var re=0;re<=1;re++)for(var ae=0;ae<=1;ae++){i.x=le?u.x:d.x,i.y=re?u.y:d.y,i.z=ae?u.z:d.z,this.closestPointToPoint(i,n);var E=i.distanceToSquared(n);if(E<p&&(p=E,s&&s.copy(n),l&&l.copy(i),E<c))return Math.sqrt(E)}for(var F=0;F<12;F++)for(var U=e[F],B=0;B<12;B++){var Z=t[B];uv(U,Z,n,i);var k=n.distanceToSquared(i);if(k<p&&(p=k,s&&s.copy(n),l&&l.copy(i),k<c))return Math.sqrt(k)}return Math.sqrt(p)}}();var ta=new At,sc=new b,WR=["x","y","z"];function Ya(a,e,t,n){var i=a.a,o=a.b,r=a.c,s=t.getX(e);i.x=n.getX(s),i.y=n.getY(s),i.z=n.getZ(s),s=t.getX(e+1),o.x=n.getX(s),o.y=n.getY(s),o.z=n.getZ(s),s=t.getX(e+2),r.x=n.getX(s),r.y=n.getY(s),r.z=n.getZ(s)}class Mi{constructor(){}intersectRay(e,t){return li(this.boundingData,ta),e.intersectBox(ta,t)}raycast(e,t,n,i){this.count?zR(e,e.geometry,t,n,this.offset,this.count,i):(this.left.intersectRay(n,sc)&&this.left.raycast(e,t,n,i),this.right.intersectRay(n,sc)&&this.right.raycast(e,t,n,i))}raycastFirst(e,t,n){if(this.count)return VR(e,e.geometry,t,n,this.offset,this.count);var i,o,r=this.splitAxis,s=WR[r];n.direction[s]>=0?(i=this.left,o=this.right):(i=this.right,o=this.left);var l=i.intersectRay(n,sc)?i.raycastFirst(e,t,n):null;if(l){var c=n.origin[s],d=c-l.point[s],u=c-o.boundingData[r],h=c-o.boundingData[r+3],p=d*d;if(p<=u*u&&p<=h*h)return l}var m=o.intersectRay(n,sc)?o.raycastFirst(e,t,n):null;return l&&m?l.distance<=m.distance?l:m:l||m||null}}Mi.prototype.shapecast=function(){var a=new Ei,e=new At,t=new At;return function(n,i,o=null,r=null){if(this.count&&o){for(var s=n.geometry,l=s.index,c=s.attributes.position,d=this.offset,u=3*d,h=3*(this.count+d);u<h;u+=3)if(Ya(a,u,l,c),a.update(),o(a,u,u+1,u+2))return!0;return!1}var p,m,f,g,_=this.left,A=this.right,x=_,S=A;if(r&&(f=e,g=t,li(x.boundingData,f),li(S.boundingData,g),p=r(f),(m=r(g))<p)){x=A,S=_;var M=p;p=m,m=M;var T=f;f=g,g=T}return f||(f=e,li(x.boundingData,f)),!(!i(f,!!x.count,p,x)||!x.shapecast(n,i,o,r))||(g||(g=t,li(S.boundingData,g)),!(!i(g,!!S.count,m,S)||!S.shapecast(n,i,o,r)))}}(),Mi.prototype.intersectsGeometry=function(){var a=new Ei,e=new Ei,t=new Ue,n=new Ae,i=new Si,o=new Si;return function(r,s,l,c=null){if(c===null&&(s.boundingBox||s.computeBoundingBox(),i.set(s.boundingBox.min,s.boundingBox.max,l),i.update(),c=i),!this.count){var d=this.left,u=this.right;return li(d.boundingData,ta),c.intersectsBox(ta)&&d.intersectsGeometry(r,s,l,c)?!0:(li(u.boundingData,ta),!(!c.intersectsBox(ta)||!u.intersectsGeometry(r,s,l,c)))}var h=r.geometry,p=h.index,m=h.attributes.position,f=s.index,g=s.attributes.position,_=this.offset,A=this.count;if(n.copy(l).invert(),s.boundsTree){li(this.boundingData,o),o.matrix.copy(n),o.update(),t.geometry=s;var x=s.boundsTree.shapecast(t,function(z){return o.intersectsBox(z)},function(z){z.a.applyMatrix4(l),z.b.applyMatrix4(l),z.c.applyMatrix4(l),z.update();for(var W=3*_,V=3*(A+_);W<V;W+=3)if(Ya(e,W,p,m),e.update(),z.intersectsTriangle(e))return!0;return!1});return t.geometry=null,x}for(var S=3*_,M=A+3*_;S<M;S+=3){Ya(a,S,p,m),a.a.applyMatrix4(n),a.b.applyMatrix4(n),a.c.applyMatrix4(n),a.update();for(var T=0,L=f.count;T<L;T+=3)if(Ya(e,T,f,g),e.update(),a.intersectsTriangle(e))return!0}}}(),Mi.prototype.intersectsBox=function(){var a=new Si;return function(e,t,n){return a.set(t.min,t.max,n),a.update(),this.shapecast(e,function(i){return a.intersectsBox(i)},function(i){return a.intersectsTriangle(i)})}}(),Mi.prototype.intersectsSphere=function(a,e){return this.shapecast(a,function(t){return e.intersectsBox(t)},function(t){return QR(e,t)})},Mi.prototype.closestPointToPoint=function(){var a=new b;return function(e,t,n=null,i=0,o=1/0){var r=1/0;return this.shapecast(e,function(s,l,c){return c<r&&c<o},function(s){s.closestPointToPoint(t,a);var l=t.distanceTo(a);return l<r&&(n&&n.copy(a),r=l),l<i},function(s){return s.distanceToPoint(t)}),r}}(),Mi.prototype.closestPointToGeometry=function(){var a=new Ei,e=new Si,t=new b,n=new b;return function(i,o,r,s=null,l=null,c=0,d=1/0){o.boundingBox||o.computeBoundingBox(),e.set(o.boundingBox.min,o.boundingBox.max,r),e.update();var u,h,p=o.attributes.position,m=o.index;s&&(u=t),l&&(h=n);var f=1/0;return this.shapecast(i,function(g,_,A){return A<f&&A<d},function(g){for(var _=g.sphere,A=0,x=m.count;A<x;A+=3){Ya(a,A,m,p),a.a.applyMatrix4(r),a.b.applyMatrix4(r),a.c.applyMatrix4(r),a.sphere.setFromPoints(a.points);var S=a.sphere;if(!(S.center.distanceTo(_.center)-S.radius-_.radius>f)){a.update();var M=g.distanceToTriangle(a,u,h);if(M<f&&(s&&s.copy(u),l&&l.copy(h),f=M),M<c)return!0}}return!1},function(g){return e.distanceToBox(g,Math.min(f,d))}),f}}();var Xp=0,dv=1,bh=2,k0=["x","y","z"];function HR(a){for(var e=a.attributes.position.array,t=a.index.array,n=t.length/3,i=new Float32Array(6*n),o=0;o<n;o++)for(var r=3*t[3*o+0],s=3*t[3*o+1],l=3*t[3*o+2],c=0;c<3;c++){var d=e[r+c],u=e[s+c],h=e[l+c],p=Math.min(d,u,h),m=(Math.max(d,u,h)-p)/2;i[6*o+2*c+0]=p+m,i[6*o+2*c+1]=m}return i}var XR=new At;class YR{constructor(e,t){if(this.geo=e,this.options=t,this.bounds=HR(e),this.sahplanes=null,t.strategy===bh){var n=e.index.count/3;this.sahplanes=[new Array(n),new Array(n),new Array(n)];for(var i=0;i<n;i++)for(var o=0;o<3;o++)this.sahplanes[o][i]={p:this.bounds[6*i+2*o],tri:i}}}getAverage(e,t,n){for(var i=0,o=this.bounds,r=e,s=e+t;r<s;r++)i+=o[6*r+2*n];return i/t}getBounds(e,t,n){for(var i=1/0,o=1/0,r=1/0,s=-1/0,l=-1/0,c=-1/0,d=this.bounds,u=e,h=e+t;u<h;u++){var p=d[6*u+0],m=d[6*u+1];i=Math.min(i,p-m),s=Math.max(s,p+m);var f=d[6*u+2],g=d[6*u+3];o=Math.min(o,f-g),l=Math.max(l,f+g);var _=d[6*u+4],A=d[6*u+5];r=Math.min(r,_-A),c=Math.max(c,_+A)}return n[0]=i,n[1]=o,n[2]=r,n[3]=s,n[4]=l,n[5]=c,n}partition(e,t,n){for(var i=e,o=e+t-1,r=n.pos,s=2*n.axis,l=this.geo.index.array,c=this.bounds,d=this.sahplanes;;){for(;i<=o&&c[6*i+s]<r;)i++;for(;i<=o&&c[6*o+s]>=r;)o--;if(!(i<o))return i;for(var u=0;u<3;u++){var h=l[3*i+u];l[3*i+u]=l[3*o+u],l[3*o+u]=h;var p=c[6*i+2*u+0];c[6*i+2*u+0]=c[6*o+2*u+0],c[6*o+2*u+0]=p;var m=c[6*i+2*u+1];c[6*i+2*u+1]=c[6*o+2*u+1],c[6*o+2*u+1]=m}if(d)for(var f=0;f<3;f++){var g=d[f][i];d[f][i]=d[f][o],d[f][o]=g}i++,o--}}getOptimalSplit(e,t,n,i){var o=-1,r=0;if(i===Xp)(o=G0(e))!==-1&&(r=(e[o+3]+e[o])/2);else if(i===dv)(o=G0(e))!==-1&&(r=this.getAverage(t,n,o));else if(i===bh){for(var s=li(e,XR),l=[s.max.x-s.min.x,s.max.y-s.min.y,s.max.z-s.min.z],c=2*(l[0]*l[1]+l[0]*l[2]+l[1]*l[2]),d=[[],[],[]],u=t,h=t+n;u<h;u++)for(var p=0;p<3;p++)d[p].push(this.sahplanes[p][u]);d.forEach(function(re){return re.sort(function(ae,E){return ae.p-E.p})});var m=function(re,ae,E,F,U){return 3+1*(ae/re*E+F/re*U)};o=-1;for(var f=1*n,g=0;g<3;g++)for(var _=(g+1)%3,A=(g+2)%3,x=s.min[k0[g]],S=s.max[k0[g]],M=d[g],T=0,L=n,z=0;z<M.length;z++){var W=M[z];T++,L--;var V=W.p-x,N=S-W.p,j=l[_],oe=l[_],H=l[A],ne=l[A],le=m(c,2*(j*H+j*V+H*V),T,2*(oe*ne+oe*N+ne*N),L);le<f&&(o=g,r=W.p,f=le)}}return{axis:o,pos:r}}}class hv{constructor(e,t={}){if(!e.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e.attributes.position.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the position attribute.");if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");(t=Object.assign({strategy:Xp,maxDepth:40,maxLeafTris:10,verbose:!0},t)).strategy=Math.max(0,Math.min(2,t.strategy)),this._roots=this._buildTree(e,t)}_ensureIndex(e){if(!e.index){var t=e.attributes.position.count,n=new(t>65535?Uint32Array:Uint16Array)(t);e.setIndex(new Te(n,1));for(var i=0;i<t;i++)n[i]=i}}_getRootIndexRanges(e){if(!e.groups||!e.groups.length)return[{offset:0,count:e.index.count/3}];for(var t=[],n=new Set,i=0,o=e.groups;i<o.length;i++){var r=o[i];n.add(r.start),n.add(r.start+r.count)}for(var s=Array.from(n.values()).sort(function(u,h){return u-h}),l=0;l<s.length-1;l++){var c=s[l],d=s[l+1];t.push({offset:c/3,count:(d-c)/3})}return t}_buildTree(e,t){this._ensureIndex(e);var n=new YR(e,t),i=!1,o=function(g,_,A,x=0){if(x>=t.maxDepth&&(i=!0),A<=t.maxLeafTris||x>=t.maxDepth)return g.offset=_,g.count=A,g;var S=n.getOptimalSplit(g.boundingData,_,A,t.strategy);if(S.axis===-1)return g.offset=_,g.count=A,g;var M=n.partition(_,A,S);if(M===_||M===_+A)g.offset=_,g.count=A;else{g.splitAxis=S.axis;var T=g.left=new Mi,L=_,z=M-_;T.boundingData=n.getBounds(L,z,new Float32Array(6)),o(T,L,z,x+1);var W=g.right=new Mi,V=M,N=A-z;W.boundingData=n.getBounds(V,N,new Float32Array(6)),o(W,V,N,x+1)}return g},r=[],s=this._getRootIndexRanges(e);if(s.length===1){var l=new Mi,c=s[0];e.boundingBox!=null?l.boundingData=GR(e.boundingBox):l.boundingData=n.getBounds(c.offset,c.count,new Float32Array(6)),o(l,c.offset,c.count),r.push(l)}else for(var d=0;d<s.length;d++){var u=s[d],h=new Mi;h.boundingData=n.getBounds(u.offset,u.count,new Float32Array(6)),o(h,u.offset,u.count),r.push(h)}if(i&&t.verbose&&(console.warn(`MeshBVH: Max depth of ${t.maxDepth} reached when generating BVH. Consider increasing maxDepth.`),console.warn(this,e)),e.boundingBox==null){var p=new At;e.boundingBox=new At;for(var m=0;m<r.length;m++){var f=r[m];e.boundingBox.union(li(f.boundingData,p))}}return r}raycast(e,t,n,i){for(var o=0,r=this._roots;o<r.length;o++)r[o].raycast(e,t,n,i)}raycastFirst(e,t,n){for(var i=null,o=0,r=this._roots;o<r.length;o++){var s=r[o].raycastFirst(e,t,n);s!=null&&(i==null||s.distance<i.distance)&&(i=s)}return i}intersectsGeometry(e,t,n){for(var i=0,o=this._roots;i<o.length;i++)if(o[i].intersectsGeometry(e,t,n))return!0;return!1}shapecast(e,t,n=null,i=null){for(var o=0,r=this._roots;o<r.length;o++)if(r[o].shapecast(e,t,n,i))return!0;return!1}intersectsBox(e,t,n){for(var i=0,o=this._roots;i<o.length;i++)if(o[i].intersectsBox(e,t,n))return!0;return!1}intersectsSphere(e,t){for(var n=0,i=this._roots;n<i.length;n++)if(i[n].intersectsSphere(e,t))return!0;return!1}closestPointToGeometry(e,t,n,i,o,r,s){for(var l=1/0,c=0,d=this._roots;c<d.length;c++){var u=d[c].closestPointToGeometry(e,t,n,i,o,r,s);if(u<l&&(l=u),u<r)return u}return l}distanceToGeometry(e,t,n,i,o){return this.closestPointToGeometry(e,t,n,null,null,i,o)}closestPointToPoint(e,t,n,i,o){for(var r=1/0,s=0,l=this._roots;s<l.length;s++){var c=l[s].closestPointToPoint(e,t,n,i,o);if(c<r&&(r=c),c<i)return c}return r}distanceToPoint(e,t,n,i){return this.closestPointToPoint(e,t,null,n,i)}}var jR=new un({color:65416,transparent:!0,opacity:.3}),KR=new Dc().geometry,lc=new At;class qR extends ze{constructor(e,t=10,n=0){super("MeshBVHRootVisualizer"),this.depth=t,this._oldDepth=-1,this._mesh=e,this._boundsTree=null,this._group=n,this.update()}update(){var e=this;if(this._mesh.geometry.boundsTree!==this._boundsTree||this._oldDepth!==this.depth){this._oldDepth=this.depth,this._boundsTree=this._mesh.geometry.boundsTree;var t=0;if(this._boundsTree){var n=function(i,o){var r="count"in i;if(o!==e.depth){if(o===e.depth-1||r){var s=t<e.children.length?e.children[t]:null;s||((s=new Wn(KR,jR)).raycast=function(){return[]},e.add(s)),t++,li(i.boundingData,lc),lc.getCenter(s.position),s.scale.subVectors(lc.max,lc.min).multiplyScalar(.5),s.scale.x===0&&(s.scale.x=Number.EPSILON),s.scale.y===0&&(s.scale.y=Number.EPSILON),s.scale.z===0&&(s.scale.z=Number.EPSILON)}r||(n(i.left,o+1),n(i.right,o+1))}};n(this._boundsTree._roots[this._group],0)}for(;this.children.length>t;)this.remove(this.children.pop())}}}class ZR extends ze{constructor(e,t=10){super("MeshBVHVisualizer"),this.depth=t,this._mesh=e,this._roots=[],this.update()}update(){for(var e=this._mesh.geometry.boundsTree,t=e?e._roots.length:0;this._roots.length>t;)this._roots.pop();for(var n=0;n<t;n++)if(n>=this._roots.length){var i=new qR(this._mesh,this.depth,n);this.add(i),this._roots.push(i)}else{var o=this._roots[n];o.depth=this.depth,o.update()}this.position.copy(this._mesh.position),this.rotation.copy(this._mesh.rotation),this.scale.copy(this._mesh.scale)}}var Ld=new ya,Q0=new Ae,JR=Ue.prototype.raycast;function pv(a,e){if(this.geometry.boundsTree){if(this.isAuxClippingMesh||this.material===void 0)return;try{Q0.copy(this.matrixWorld).invert()}catch{return}if(Ld.copy(a.ray).applyMatrix4(Q0),a.firstHitOnly===!0){var t=this.geometry.boundsTree.raycastFirst(this,a,Ld);t&&e.push(t)}else this.geometry.boundsTree.raycast(this,a,Ld,e)}else JR.call(this,a,e)}function fv(a){return this.boundsTree=new hv(this,a),this.boundsTree}function mv(){this.boundsTree=null}const W0=["toneMapping","toneMappingLook","toneMappingMidTones","toneMappingPhysicalScale","toneMappingBrightness","toneMappingContrast","toneMappingChromaticAdaptation","toneMappingWhiteColor","toneMappingColorDifferentiation","toneMappingExteriorDaylight","toneMappingWhiteBalance","toneMappingHighlights","toneMappingShadows","toneMappingSaturation","toneMappingAperture","toneMappingShutter","toneMappingISO","toneMappingVignetting"],$R={type:"afterFirstRender"},e5={type:"afterRender"},t5={type:"beforeRender"},n5={type:"dispose"},i5={type:"pause"},o5={type:"resume"},r5={type:"sceneLoad"};function Ci(a,e,t){return 2*ua*Math.atan(Math.tan(eo*a/2)*e/t)}class is extends An{constructor(e,t={},n=null){if(super(),this.container=e instanceof HTMLElement?e:document.getElementById(e),this.scene=null,this.camera=null,this.clock=new Di,this.mixer=null,this.renderCallbacks=[],this.compileCallbacks=[],this.elapsed=0,this.frame=0,this.preloader=n,this.worldCubemapRes=1024,this._pmremMaxTileSize=256,this._lightProbeCubemapRes=64,this.xrSession=null,this.xrCameraParent=null,this.xrControllers=[],t=t||{},!Lt.checkWebGL()){const r=t.webglErrorMsg||'Ouch! Your device does not support WebGL.<br>Find out how to fix this <a href="https://www.soft8soft.com/webgl-supported-browsers-and-troubleshooting/" target="_top" class="v3d-webgl-error-link">here</a>.';return void Lt.showWebGLErrorMessage(this.container,r)}rn.legacyMode=!1;const i={};i.alpha=!!q(t.alpha)&&t.alpha,i.depth=!q(t.depth)||t.depth,i.stencil=!q(t.stencil)||t.stencil,i.antialias=!q(t.antialias)||t.antialias,i.premultipliedAlpha=!q(t.premultipliedAlpha)||t.premultipliedAlpha,i.preserveDrawingBuffer=!!q(t.preserveDrawingBuffer)&&t.preserveDrawingBuffer,Lt.isSafariWithMultisamplingBug()&&(console.warn("v3d.App: disabling buggy context AA on Safari 15.4"),i.antialias=!1),this.renderer=new Yh(i),z1.prepareRenderer(this.renderer),this.clearBkgOnLoad=!1,this.frameRateDivider=1,this.enableRender=!0,this.disableRenderTrigger=0,this.ssaaOnPause=!1,this.renderer.setSize(this.container.offsetWidth,this.container.offsetHeight),this.renderer.outputEncoding=Ke,this.container.appendChild(this.renderer.domElement),this.container.classList.add("v3d-container"),this.renderer.domElement.classList.add("v3d-canvas"),this.container.setAttribute("translate","no"),this._onContextRestoreCb=()=>{this._onContextRestore()},this.renderer.domElement.addEventListener("webglcontextrestored",this._onContextRestoreCb),this.loader=new j1;const o=new Ii().setTranscoderPath(Yc()).detectSupport(this.renderer);this.loader.setKTX2Loader(o),Pe.prototype.computeBoundsTree=fv,Pe.prototype.disposeBoundsTree=mv,Ue.prototype.raycast=pv,this.actions=[],this.materials={push:function(){}},this.updateMaterials=function(){},this._envIBLMode=0,this._envLightProbe=null,this._resizeCb=null,this._loadSceneURL="",this._loadingTime=0,this._backgroundSave=null,this._postprocessingSave=null,this.stats=null,To.drawWatermark(this),To.addToAppList(this),this.worldMaterial=null}_updateRendererFromGLTF(e){const t=this,n=Lt.checkHalfFloatTex(this.renderer,!0);if(e.renderer.shadowMap&&(this.renderer.shadowMap.enabled=e.renderer.shadowMap.enabled,this.renderer.shadowMap.type=e.renderer.shadowMap.type,n||this.renderer.shadowMap.type!==Vn||(this.renderer.shadowMap.type=Po,e.scene.traverse(function(i){i.isLight&&i.castShadow&&i.shadow&&(i.shadow.bias/=100)}))),e.renderer.physicallyCorrectLights&&(this.renderer.physicallyCorrectLights=!0),this.aaMethod=e.renderer.aaMethod||"AUTO",this.useHDR=!!(e.renderer.useHDR&&n),this.renderer.useOIT=e.renderer.useOIT??!1,this.renderer.unitsScaleFactor=e.renderer.unitsScaleFactor??1,e.renderer.toneMapping)for(let i=0;i<W0.length;i++){const o=W0[i];q(e.renderer[o])&&(this.renderer[o]=e.renderer[o])}e.renderer.pmremMaxTileSize!==void 0&&(this._pmremMaxTileSize=e.renderer.pmremMaxTileSize),e.renderer.iblEnvironmentMode!==void 0&&(this._envIBLMode=e.renderer.iblEnvironmentMode),e.renderer.esmDistanceScale!==void 0&&(this.renderer.shadowMap.esmDistanceScale=e.renderer.esmDistanceScale),e.scene.traverse(function(i){i.hidpiCompositing&&(i.traverse(o=>{i.isMesh&&(o.layers.set(7),o.isMaterialGeneratedMesh&&i.parent.layers.set(7))}),t.useHiDPIRenderPass=!0,t.renderer.setPixelRatio(window.devicePixelRatio))}),t.useHiDPIRenderPass&&e.scene.traverse(function(i){i.isLight&&i.layers.enable(7)})}_updateMeshesRaycastFromGLTF(e){e.scene&&e.scene.traverse(function(t){const n=t.geometry;t.isMesh&&(!n.computeBoundsTree||Object.keys(n.morphAttributes).length!==0||n.attributes.position.isInterleavedBufferAttribute||n.index&&n.index.isInterleavedBufferAttribute||n.computeBoundsTree({verbose:!1}))})}_prepareReflProbesFromGLTF(e){e.scene&&e.scene.traverse(t=>{if(t.isCubeReflectionProbe)this._prepareEnvMapProbe(t);else if(t.isPlaneReflectionProbe){let n=this._checkMSAA(this.renderer,4);n>0&&t.makeMultisampleRenderTarget(n)}})}_prepareEnvMapProbe(e){switch(e.setSize(this._pmremMaxTileSize),this._envIBLMode){case 0:e.onUpdate=t=>this.generateRTargetPMREM(t);break;case 2:case 3:e.onUpdate=()=>null}}_prepareReflProbesEncoding(e,t){e.traverse(n=>{(n.isCubeReflectionProbe||n.isPlaneReflectionProbe)&&n.setEncoding(t)})}_prepareEnvMapProbeWorld(){if(this._envIBLMode==3)return;const e=new vn;e.worldMaterial=this.scene.worldMaterial,this.scene.worldEnvMapProbe===null&&(this.scene.worldEnvMapProbe=new pu(this._pmremMaxTileSize),this.scene.worldEnvMapProbe.influenceType=0,this.scene.worldEnvMapProbe.parallaxType=0);const t=this.scene.worldEnvMapProbe;switch(this._envIBLMode){case 0:t.onUpdate=n=>this.generateRTargetPMREM(n);break;case 2:t.onUpdate=n=>{const i=n.clone();i.setSize(this._lightProbeCubemapRes,this._lightProbeCubemapRes),Lt.checkHalfFloatReadPixels(this.renderer)?i.texture.type=_t:Lt.checkFloatReadPixels(this.renderer)?i.texture.type=Ct:(console.warn("v3d.App: Target platform does not support reading pixels in float format, expect quality loss."),i.texture.type=Ft),i.texture.format=Qe,i.texture.encoding=_n;const o=new Ts(n.texture);return o.render(this.renderer,i),o.dispose(),this._disposeEnvLightProbe(),this._envLightProbe=ov.fromCubeRenderTarget(this.renderer,i),this.scene.add(this._envLightProbe),i.dispose(),null}}t.update(e,this.renderer),this.renderer.compatSettings.useSpecEnvBlenderApprox=this._envIBLMode===0}_updateMaterialsFromGLTF(e){const t=this;e.scene&&e.scene.traverse(function(n){const i=n.material;if(i&&t.useHDR&&(i.toneMapped=!1,i.useFloatTex=Lt.checkFloatTex(t.renderer,!0),i.isMeshNodeMaterial)){const o=i.nodeTexCoordObject;i.updateNodeGraph(),i.nodeTexCoordObject=o}})}_updateAnimationsFromGLTF(e,t){const n=this;!n.mixer&&e.animations&&e.animations.length&&(n.mixer=new B1(n.scene)),(e.animations||[]).forEach(function(i){const o=t.getObjectById(i.nodeId);if(o){let r;r=o.id==t.id||o.name!==""&&o.name!=="root"&&o.name!=="."&&o.name!==t.name&&o.name!==t.uuid?n.mixer.clipAction(i.clip,t):n.mixer.clipAction(i.clip,o),r.setLoop(i.loop,i.repetitions),r.startAt(i.startAt+n.mixer.time),r.clampWhenFinished=!0,i.auto?r.play():(r.stop(),r.paused=!0),n.actions.push(r)}})}_traverseSceneForTexUniforms(e,t){e.traverse(function(n){n.material&&(Array.isArray(n.material)?n.material:[n.material]).forEach(function(i){i.program!==void 0&&t(n,i,i.program.getTexUniformCount())})})}_checkMSAA(e,t){return Math.min(t,e.capabilities.maxSamples)}_precompileSceneAsync(e,t,n,i){const o=this,r=o.compileCallbacks;for(let l=0;l<r.length;l++)r[l](o);const s=o.renderer.getRenderTarget();o.renderer.setRenderTarget(n),o.renderer.compileAsync(e,t,function(l){l>=1&&o.renderer.setRenderTarget(s),i&&i(100*l)})}_handleAlphaToCoverage(e){this.scene.traverse(function(t){const n=t.material;n&&n.alphaToCoverage&&(e>0?(n.transparent=!1,n.premultipliedAlpha=!1,n.blending=En):n.alphaToCoverage=!1)})}_onContextRestore(e){this.scene&&this.scene.worldMaterial&&(this.updateEnvironment(this.scene.worldMaterial),this.updateReflectionProbes(this.scene))}assignClippingPlanes(e){const t=this;let n=[],i=[],o=[],r=-1e3;e.traverse(function(s){s.isClippingPlaneObject&&(n.push(s),i.push(s.plane),e.traverse(function(l){s.needsClippingPlane(l)&&s.assignToObject(l,r++)}),o.push(r++))});for(let s=0;s<n.length;s++){const l=n[s];l.crossSection&&l.createCrossSectionPlane(i,o[s])}n.length&&(t.renderer.localClippingEnabled=!0,t.postprocessing&&t.postprocessing.composer.setStencil(!0))}updateConstraints(e){const t=this;e.traverse(function(n){for(let i=0;i<n.constraints.length;i++){const o=n.constraints[i];o.isCanvasBreakpointsConstraint&&(o.appInstance=t),o.isCanvasFitConstraint&&(o.xr=t.renderer.xr)}})}loadScene(e,t,n,i){const o=this;o.renderer?(o._loadSceneURL=e,o._loadingTime=performance.now(),o.preloader&&o.preloader.onUpdate(0),this.loader.load(e,function(r){o.scene=r.scene||new vn;let s=null;r.cameras&&r.cameras.length?o.camera=r.cameras[0]:(s=yc(o.scene),o.camera=sv(s,o.container.offsetWidth/o.container.offsetHeight),o.scene.add(o.camera)),o.camera.controls||(s=s||yc(o.scene),lv(o.camera,yc(o.scene)),o.camera.viewportFit.type=1),o._updateRendererFromGLTF(r),o._prepareReflProbesFromGLTF(r),o._updateMaterialsFromGLTF(r),o._updateAnimationsFromGLTF(r,o.scene);const l=r.world.material;l&&(o.scene.background=new me,o.scene.worldMaterial=l,o.updateEnvironment(l),o.worldMaterial=l),o.initPostprocessing(),o.assignClippingPlanes(o.scene),o.updateConstraints(o.scene),o.onResize&&o.onResize(),o.scene.updateMatrixWorld(),o.scene.visible=!1,o.scene.disableChildRendering=!0;const c=function(){o.scene&&o._traverseSceneForTexUniforms(o.scene,function(u,h,p){p>8&&console.warn(`v3d.App: Material "${h.name}" on object "${u.name}" exceeds iOS limit of 8 textures (has ${p}).`)}),o.removeEventListener("afterFirstRender",c)},d=o.postprocessing?o.postprocessing.composer.renderTarget1:null;o._precompileSceneAsync(o.scene,o.camera,d,function(u){const h=(60+.4*u)/1;n&&n(h),o.preloader&&o.preloader.onUpdate(h),h>=100&&(o._updateMeshesRaycastFromGLTF(r),o.addEventListener("afterFirstRender",c),t&&setTimeout(function(){o.scene.visible=!0,o.scene.disableChildRendering=!1,o.updateReflectionProbes(o.scene),o._loadingTime=performance.now()-o._loadingTime,o.dispatchEvent({...r5}),t(o.scene)},16),r=null)}),o.clearBkgOnLoad&&(o.scene.background=null),o._tripleP=new Ac(window,Ee.P,function(){To.printPerformanceInfo(o,1)},3,1),o._tripleF=new Ac(window,Ee.F,function(){o.stats?o.hideFPS():o.showFPS()},3,1),o._tripleH=new Ac(window,Ee.H,function(){o.enableRender?o.disableRendering():o.enableRendering()},3,1)},function(r){const s=.6*r/1;n&&n(s),o.preloader&&o.preloader.onUpdate(s)},function(r){console.error(r),i&&i(r)}),window.removeEventListener("resize",this._resizeCb,!1),this._resizeCb=function(){o.onResize&&o.onResize()},window.addEventListener("resize",this._resizeCb,!1)):i&&i("WebGL not found")}appendScene(e,t,n,i,o,r){const s=this;s.renderer?(o===void 0&&(o=!0),r===void 0&&(r=!0),s.preloader&&s.preloader.onUpdate(0),this.loader.load(e,function(l){const c=l.scene||new vn,d=[];c.traverse(function(p){(p.isCamera&&!o||p.isLight&&!r)&&d.push(p)}),d.forEach(function(p){s.unload(p)}),s.scene&&(s.scene.add(c),s._prepareReflProbesFromGLTF(l),s._updateMaterialsFromGLTF(l),s._updateAnimationsFromGLTF(l,c),s.scene.updateMatrixWorld());const u=s.postprocessing?s.postprocessing.composer.renderTarget1:null,h=s.scene||c;s.assignClippingPlanes(h),s.updateConstraints(h),c.visible=!1,c.disableChildRendering=!0,s._precompileSceneAsync(h,s.camera||new Os,u,function(p){const m=(60+.4*p)/1;n&&n(m),s.preloader&&s.preloader.onUpdate(m),m>=100&&(s._updateMeshesRaycastFromGLTF(l),s._traverseSceneForTexUniforms(c,function(f,g,_){_>8&&console.warn(`v3d.App: Material "${g.name}" on object "${f.name}" exceeds iOS limit of 8 textures (has ${_}).`)}),t&&setTimeout(function(){c.visible=!0,c.disableChildRendering=!1,s.updateReflectionProbes(s.scene),t(c)},16),l=null)})},function(l){const c=.6*l/1;n&&n(c),s.preloader&&s.preloader.onUpdate(c)},function(l){console.error(l),i&&i(l)})):i&&i("WebGL not found")}unload(e){const t=this;function n(i){if(i.isAnnotation)i.dispose();else if(i.isLight&&i.shadow&&i.shadow.isLightShadow)i.shadow.dispose();else if(i.isCamera&&i.controls&&i.controls.orbitTarget)n(i.controls.orbitTarget);else if(i.isScene){const o=i.worldMaterial;o!==null&&(ph.disposeTextures(o),o.dispose()),i.worldEnvMapProbe!==null&&(i.worldEnvMapProbe.dispose(),i.worldEnvMapProbe=null)}else if(i.isMesh){i.geometry.dispose(),i.geometry.disposeBoundsTree&&i.geometry.disposeBoundsTree();const o=i.material;ph.disposeTextures(o),o.dispose()}}if(e||(e=t.scene),e===t.scene){if(t.scene&&(t.scene.traverse(n),t.disposeEnvironment(),t.worldMaterial=null),t.scene=null,t.controls&&t.controls.dispose&&t.controls.dispose(),t.controls=null,t.camera=null,t.mixer&&(t.mixer.stopAllAction(),t.actions.forEach(function(i){t.mixer.uncacheAction(i.getClip(),i.getRoot())})),t.mixer=null,t.actions=[],t.postprocessing){if(t.postprocessing.composer)for(let i in t.postprocessing){const o=t.postprocessing[i];(o instanceof ii||o instanceof fh)&&o.dispose()}t.disablePostprocessing()}t.postprocessing=null,hi.dispose(),t.renderer&&t.renderer.disposeInternalCaches(),t._tripleP&&t._tripleP.dispose(),t._tripleF&&t._tripleF.dispose(),t._tripleH&&t._tripleH.dispose(),t.useHiDPIRenderPass=!1,t.renderer.setPixelRatio(1)}else if(t.scene&&(e.traverse(n),e.parent&&e.parent.remove(e)),t.mixer)for(let i=t.actions.length-1;i>=0;i--){const o=t.actions[i];av(t.scene,o)||(o.stop(),t.mixer.uncacheAction(o.getClip(),o.getRoot()),t.actions.splice(i,1))}}dispose(){this.scene&&this.unload(),this.renderer&&(this.renderer.forceContextLoss(),this.renderer.dispose(),this.renderer.domElement.removeEventListener("webglcontextrestored",this._onContextRestoreCb),this._onContextRestoreCb=null,this.renderer.domElement.parentElement===this.container&&this.container.removeChild(this.renderer.domElement)),this.renderer=null,this.loader=null,window.removeEventListener("resize",this._resizeCb,!1),this._resizeCb=null,this.renderCallbacks.length=0,this.compileCallbacks.length=0,To.removeFromAppList(this),pi.clear(),this.dispatchEvent({...n5}),delete this._listeners}getWidth(){return this.container.offsetWidth}getHeight(){return this.container.offsetHeight}onResize(){if(!this.renderer)return;this.enableRender&&!this.ssaaOnPause||(this.enableRendering(),this.disableRendering(1));const e=this.getWidth(),t=this.getHeight();if(this.renderer.setSize(e,t),this.postprocessing&&(this.postprocessing.gtaoGenerator&&this.postprocessing.gtaoGenerator.setSize(e,t),this.postprocessing.composer.setSize(e,t)),this.scene){this.scene.traverse(o=>{o.isPlaneReflectionProbe&&o.setSize(e,t)});const n=e/t,i=this.camera;if(i.isPerspectiveCamera){const o=i.aspect<i.viewportFit.initialAspect,r=n<i.viewportFit.initialAspect;switch(i.viewportFit.type){case 1:i.aspect=n;break;case 2:i.fov=Ci(i.fov,i.aspect,n),i.aspect=n;break;case 3:o&&r?i.fov=Ci(i.fov,i.aspect,n):o&&!r?i.fov=Ci(i.fov,i.aspect,i.viewportFit.initialAspect):!o&&r&&(i.fov=Ci(i.fov,i.viewportFit.initialAspect,n)),i.aspect=n;break;case 5:o&&r?i.fov=Ci(i.fov,i.aspect,n):o&&!r?i.fov=Ci(i.fov,i.viewportFit.initialAspect,n):!o&&r&&(i.fov=Ci(i.fov,i.aspect,n)),i.aspect=n;break;case 4:o||r?o&&!r?i.fov=Ci(i.fov,i.viewportFit.initialAspect,n):!o&&r&&(i.fov=Ci(i.fov,i.aspect,i.viewportFit.initialAspect)):i.fov=Ci(i.fov,i.aspect,n),i.aspect=n}}else if(i.isOrthographicCamera){let o,r;switch(i.viewportFit.type){case 1:case 5:o=i.top*n,i.left=-o,i.right=o;break;case 2:case 4:r=i.right/n,i.bottom=-r,i.top=r;break;case 3:const s=(i.right-i.left)/(i.top-i.bottom)<i.viewportFit.initialAspect,l=n<i.viewportFit.initialAspect;o=s&&l?i.right:s&&!l?i.right*n/i.viewportFit.initialAspect:!s&&l?i.top*i.viewportFit.initialAspect:i.top*n,i.left=-o,i.right=o,i.bottom=-o/n,i.top=o/n}}i.updateProjectionMatrix()}}run(){this.preloader&&(this.preloader.onFinish(),this.preloader=null),this.animate()}animate(){const e=this;e.renderer.setAnimationLoop(function(){e.stats&&e.stats.begin();const t=e.clock.getDelta();e.elapsed=t,e.mixer&&e.mixer.update(t),e.controls&&!e.xrSession&&e.controls.update(t);const n=e.renderCallbacks;for(let i=0;i<n.length;i++)n[i](t,e.clock.elapsedTime);e.frame%e.frameRateDivider==0&&e.enableRender&&(e.render(),e.frame===0&&e.dispatchEvent({...$R})),e.frame++,e.disableRenderTrigger&&--e.disableRenderTrigger==0&&(e.enableRender=!1),e.stats&&e.stats.end()})}enableRendering(){this.disableRenderTrigger=0,this.enableRender=!0,this.ssaaOnPause&&this.enableSSAA(0,!0)}disableRendering(e){((e=e||0)||this.ssaaOnPause)&&this.enableRender&&this.disableRenderTrigger==0?(this.disableRenderTrigger=this.ssaaOnPause?32:e,this.ssaaOnPause&&this.enableSSAA(4,!0)):e==0&&(this.enableRender=!1)}pause(){this.renderer.setAnimationLoop(null),this.clock.stop(),this.dispatchEvent({...i5})}resume(){this.animate(),this.clock.start(),this.dispatchEvent({...o5})}setFrameRateDivider(e){this.frameRateDivider=e}render(){this.dispatchEvent({...t5});const e=!!this.scene&&!!this.camera;if(e&&this.scene.traverse(t=>{t.isPlaneReflectionProbe&&t.update(this.scene,this.camera,this.renderer)}),this.renderer.gtaoMapEnabled=!0,this.postprocessing){const t=this.postprocessing.gtaoGenerator;t&&t.render(this.renderer),this.postprocessing.composer.render(this.elapsed)}else e&&this.renderer.render(this.scene,this.camera);if(e&&this.useHiDPIRenderPass){const t=this.camera.layers.mask,n=this.scene.background,i=this.renderer.autoClear,o=this.renderer.useOIT;this.camera.layers.set(7),this.scene.background=null,this.renderer.autoClear=!1,this.renderer.useOIT=!1,this.renderer.clearDepth(),this.renderer.render(this.scene,this.camera),this.camera.layers.mask=t,this.scene.background=n,this.renderer.autoClear=i,this.renderer.useOIT=o}this.renderer.gtaoMapEnabled=!1,this.dispatchEvent({...e5})}enableControls(e){const t=this.camera;if(t.controls){if(!(this.controls&&t===this.controls.object&&(this.controls instanceof Fc&&t.controls.type==="ORBIT"||this.controls instanceof gh&&t.controls.type==="FLYING"||this.controls instanceof mh&&t.controls.type==="FIRST_PERSON")))switch(this.controls&&this.controls.dispose(),t.controls.type){case"ORBIT":this.controls=new Fc(t,e||this.renderer.domElement);break;case"FLYING":this.controls=new gh(t,this.renderer.domElement);break;case"FIRST_PERSON":this.controls=new mh(t,this.renderer.domElement);break;default:this.controls=null}this.controls&&(t.controls.assignToControls(this.controls,this.scene),this.controls.update())}}setCamera(e){if(this.camera=e,this.postprocessing){const t=this.postprocessing.composer.passes;for(let n=0;n<t.length;n++)t[n].setCamera(e);this.postprocessing.renderPass&&this.postprocessing.renderPass.setCamera(e),this.postprocessing.ssaaRenderPass&&this.postprocessing.ssaaRenderPass.setCamera(e),this.postprocessing.gtaoGenerator&&this.postprocessing.gtaoGenerator.setCamera(e)}this.enableControls(),this.onResize()}getCamera(e=!1){return e&&this.camera&&this.renderer&&this.renderer.xr.enabled&&this.renderer.xr.isPresenting?this.renderer.xr.getCamera():this.camera}initPostprocessing(){(this.scene.postprocessing&&this.scene.postprocessing.length||this.useHDR||this.useHiDPIRenderPass||this.aaMethod!="AUTO"||this.renderer.useOIT)&&this.enablePostprocessing(this.scene.postprocessing||[]),this.renderer.useOIT&&(this.useHiDPIRenderPass?console.warn("v3d.App: Order-Independent Transparency is not compatible with HiDPI Compositing, disabling OIT"):this.renderer.setOIT(1,this.postprocessing.composer.writeBuffer.samples)),this.postprocessing||this._handleAlphaToCoverage(this.renderer.getContextAttributes().antialias?4:0)}enablePostprocessing(e){const t={format:Qe,stencilBuffer:!1};let n;if(this.useHDR?(t.type=_t,t.encoding=_n):(t.type=Ft,t.encoding=Ke),this._prepareReflProbesEncoding(this.scene,t.encoding),this.postprocessing)n=this.postprocessing.composer;else{this.postprocessing={};const i=new Oc(this.scene,this.camera);this.postprocessing.renderPass=i;let o=0;switch(this.aaMethod){case"AUTO":case"MSAA4":o=this._checkMSAA(this.renderer,4);break;case"MSAA8":o=this._checkMSAA(this.renderer,8);break;case"MSAA16":o=this._checkMSAA(this.renderer,16)}Lt.checkSwiftShader(this.renderer)&&(console.warn("v3d.App: disabling buggy multisampling on SwiftShader renderer"),o=0),Lt.isSafariWithMultisamplingBug()&&(console.warn("v3d.App: disabling buggy multisampling on Safari 15.4"),o=0);const r=new et(this.getWidth(),this.getHeight(),t);r.texture.name="EffectComposer.rt1",r.samples=o,n=new fh(this.renderer,r),n.addPass(i),this.postprocessing.composer=n;const s=this.renderer.getContextAttributes().alpha,l=o==0&&this.aaMethod!="NONE",c=new Cp;if(l&&!s&&(c.material.defines.ALPHA_AS_LUMA=1),this.useHDR||(c.material.toneMapped=!1),n.addPass(c),this.postprocessing.toneMapPass=c,l){const d=new Nc(this.scene,this.camera);this.useHDR&&!s&&(d.material.defines.FXAA_GREEN_AS_LUMA=0),n.addPass(d),this.postprocessing.fxaaPass=d}this._handleAlphaToCoverage(o)}e.length&&this.postprocessing.copyPass&&(n.passes.splice(n.passes.indexOf(this.postprocessing.copyPass),1),this.postprocessing.copyPass=null);for(let i=0;i<e.length;i++){const o=e[i];let r=n.passes.length-1;switch(n.passes[r]instanceof Nc&&r--,o.type){case"afterimage":const s=o.damp;let l;this.postprocessing.afterimagePass?(l=this.postprocessing.afterimagePass,l.damp=s):(l=new O1(new te(this.getWidth(),this.getHeight()),s,t),n.insertPass(l,r),this.postprocessing.afterimagePass=l);break;case"bloom":const c=o.strength,d=o.radius,u=o.threshold;let h;this.postprocessing.bloomPass?(h=this.postprocessing.bloomPass,h.strength=c,h.radius=d,h.threshold=u):(h=new Fo(new te(this.getWidth(),this.getHeight()),c,d,u,t),n.insertPass(h,r),this.postprocessing.bloomPass=h);break;case"brightnessContrast":let p;this.postprocessing.brightnessContrastPass?p=this.postprocessing.brightnessContrastPass:(p=new Ap,n.insertPass(p,r),this.postprocessing.brightnessContrastPass=p),p.brightness=o.brightness,p.contrast=o.contrast;break;case"dof":let m;this.postprocessing.bokehPass?m=this.postprocessing.bokehPass:(m=new _p(this.scene,this.camera,{width:this.getWidth(),height:this.getHeight()}),n.insertPass(m,r),this.postprocessing.bokehPass=m),m.focus=o.focus,m.aperture=o.aperture,m.maxblur=o.maxblur,m.depthLeakThreshold=o.depthLeakThreshold;break;case"grayscale":if(!this.postprocessing.grayscalePass){const x=new xp;n.insertPass(x,r),this.postprocessing.grayscalePass=x}break;case"gtao":if(!Lt.checkDepthTex(this.renderer)){console.warn("v3d.App: disabling GTAO since your hardware does not support depth textures");break}if(Lt.getGPUVendor(this.renderer)==="ARM"&&Lt.getGPUModel(this.renderer).startsWith("Mali-")){console.warn("v3d.App: disabling buggy GTAO on Mali devices");break}let f=this.postprocessing.gtaoGenerator;if(!f){f=this.postprocessing.gtaoGenerator=new iv(this.scene,this.camera,this.getWidth(),this.getHeight());const x=S=>{f.removeEventListener("dispose",x),this.renderer.disposeGTAO()};f.addEventListener("dispose",x),this.renderer.gtaoMap=f.renderTarget.texture}f.distance=o.distance,f.factor=o.factor,f.precision=o.precision,f.bentNormals=o.bentNormals??!1,f.bounceApprox=o.bounceApprox;break;case"outline":let g;this.postprocessing.outlinePass?g=this.postprocessing.outlinePass:(g=new Ti(new te(this.getWidth(),this.getHeight()),this.scene,this.camera),n.insertPass(g,r),this.postprocessing.outlinePass=g),g.edgeStrength=o.edgeStrength,g.edgeGlow=o.edgeGlow,g.edgeThickness=o.edgeThickness,g.pulsePeriod=o.pulsePeriod,g.visibleEdgeColor.fromArray(o.visibleEdgeColor),g.hiddenEdgeColor.fromArray(o.hiddenEdgeColor),g.hiddenEdgeColor.setW(Number(o.renderHiddenEdge));break;case"ssr":if(!Lt.checkHalfFloatTex(this.renderer,!1)){console.warn("v3d.App: disabling SSR since your hardware does not support half float textures");break}let _,A=!1;q(o.useRefract)&&(A=o.useRefract),(A?this.postprocessing.ssrPassRefract:this.postprocessing.ssrPassReflect)?_=A?this.postprocessing.ssrPassRefract:this.postprocessing.ssrPassReflect:(_=new U1(this.scene,this.camera),n.insertPassAfter(_,[this.postprocessing.renderPass,this.postprocessing.ssrPassRefract,this.postprocessing.ssrPassReflect]),A?this.postprocessing.ssrPassRefract=_:this.postprocessing.ssrPassReflect=_),_.useRefract=A,q(o.objects)&&(_.objects=o.objects),q(o.intensity)&&(_.intensity=o.intensity),q(o.steps)&&(_.steps=o.steps),q(o.stride)&&(_.stride=o.stride),q(o.binarySearchSteps)&&(_.binarySearchSteps=o.binarySearchSteps),q(o.renderTargetScale)&&(_.renderTargetScale=o.renderTargetScale),q(o.thickness)&&(_.thickness=o.thickness),q(o.maxDistance)&&(_.maxDistance=o.maxDistance),q(o.jitter)&&(_.jitter=o.jitter),q(o.renderAfter)&&(_.renderAfter=o.renderAfter),q(o.simpleRefraction)&&(_.simpleRefraction=o.simpleRefraction),this.onResize&&this.onResize();break;default:console.error(`v3d.App: wrong postprocessing effect "${o.type}"`)}}if(n.passes.length==1){const i=new oo(De.copy);n.passes.push(i),this.postprocessing.copyPass=i}}disablePostprocessing(e,t){if(!this.postprocessing)return;const n=this.postprocessing.gtaoGenerator;!t&&n&&(n.dispose(),this.postprocessing.gtaoGenerator=null);const i=["afterimagePass","bloomPass","brightnessContrastPass","bokehPass","grayscalePass","ssrPassReflect","ssrPassRefract"];e||i.push("outlinePass");const o=this.postprocessing.composer;for(let r=0;r<i.length;r++){const s=i[r];this.postprocessing[s]&&(o.passes.splice(o.passes.indexOf(this.postprocessing[s]),1),this.postprocessing[s].dispose(),this.postprocessing[s]=null)}if(this.aaMethod!="AUTO"||o.passes.length!=1||this.postprocessing.gtaoGenerator){if(o.passes.length==1){const r=new oo(De.copy);o.passes.push(r),this.postprocessing.copyPass=r}}else this.postprocessing.renderPass.dispose(),this.postprocessing.composer.dispose(),this.postprocessing=null}enableSSAA(e,t){if(this.postprocessing||this.enablePostprocessing([]),!this.postprocessing||e>0&&(this.postprocessing.ssrPassRefract||this.postprocessing.ssrPassReflect))return;const n=this;this.scene.traverse(function(o){o.isAnnotationControl&&(o.update(n.camera),o.doUpdate=!e)});const i=this.postprocessing.composer;if(e>0&&i.passes[0]instanceof Oc){let o;this.postprocessing.ssaaRenderPass?o=this.postprocessing.ssaaRenderPass:(o=new ws(this.scene,this.camera),this.postprocessing.ssaaRenderPass=o,t&&o.addEventListener("iteration",function(r){r.frame==e*e-1&&(i.enableAllPasses(),i.renderToScreen=!0,i.passes[i.passes.length-1].renderToScreen=!0,n.disableRenderTrigger=1)})),o.sampleLevel=e||4,i.passes[0]=o,this.postprocessing.fxaaPass&&i.passes.splice(i.passes.length-1,1),t&&(o.iterative=!0,o.iterativeFrame=0,i.disableAllPasses(),i.renderToScreen=!1,o.enabled=!0)}else e>0?(i.passes[0].sampleLevel=e||4,t&&(ssaaRenderPass.iterative=!0,ssaaRenderPass.iterativeFrame=0,i.disableAllPasses(),i.renderToScreen=!1,ssaaRenderPass.enabled=!0)):e==0&&i.passes[0]instanceof ws&&(i.passes[0]=this.postprocessing.renderPass,this.postprocessing.fxaaPass&&i.passes.push(this.postprocessing.fxaaPass),i.enableAllPasses(),i.renderToScreen=!0)}updateEnvironment(e){const t=this.renderer.xr.enabled;if(this.renderer.xr.enabled=!1,this.disposeEnvironment(),e.toneMapped=!1,this.scene.background!==null){const n=this.renderer.toneMapping===ci?e.worldMaterialColor():null;n!==null?this.scene.background=n:(this.scene.background=V1(this.renderer,e,this.worldCubemapRes,{encoding:Ke,format:Qe,generateMipmaps:!0,minFilter:In,type:_t}).texture,this.scene.backgroundToneMapped=!this.useHDR)}this._envIBLMode===0&&new As(this.renderer,this._pmremMaxTileSize,!0).compileCubemapShader(),this._prepareEnvMapProbeWorld(),this.renderer.xr.enabled=t}disposeEnvironment(){this._disposeEnvLightProbe();let e=this.scene.background;e&&e&&(e.isTexture||e.isCubeTexture)&&e.dispose()}_disposeEnvLightProbe(){this._envLightProbe!==null&&(this.scene.remove(this._envLightProbe),this._envLightProbe=null)}updateReflectionProbes(e){e.traverse(t=>{t.isCubeReflectionProbe&&t.update(this.scene,this.renderer)})}generateRTargetPMREM(e){if(!e.isWebGLCubeRenderTarget)return null;const t=new As(this.renderer,this._pmremMaxTileSize,!0);t.flipCubemapX=!1;const n=t.fromCubemap(e.texture);return t.dispose(),n}initWebXR(e,t,n,i,o,r){n=n||function(){},i=i||function(){},o=o||function(){},r=r||{};const s=this;function l(h){s.xrSession.removeEventListener("end",l),o();for(let p=0;p<s.xrControllers.length;p++){const m=s.xrControllers[p];m.removeEventListener("connected",c),s.scene.remove(m)}if(s.xrControllers=[],s.xrCameraParent){const p=s.camera;p.removeFromParent(),s.scene.add(p),s.scene.remove(s.xrCameraParent),s.xrCameraParent=null}if(s.xrSession=null,s._backgroundSave&&(s.scene.background=s._backgroundSave,s._backgroundSave=null),s.postprocessing=s._postprocessingSave,s._postprocessingSave=null,s.postprocessing){const p=s.postprocessing.gtaoGenerator;p&&(s.renderer.gtaoMap=p.renderTarget.texture)}s.onResize()}function c(h){const p=h.data,m=h.target;if(p.targetRayMode=="tracked-pointer"){const f=new Pe().setFromPoints([new b(0,0,0),new b(0,0,-1)]),g=new Pi(f);g.name=m.name+"_RAY",g.scale.z=5,m.add(g)}else if(p.targetRayMode=="gaze"){const f=new dp().load(NR),g=new tu({map:f,sizeAttenuation:!1}),_=new jh(g);_.name=m.name+"_RETICLE",_.scale.multiplyScalar(.1),_.position.z=-5,m.add(_)}m.userData.inputSource=p}function d(h){const p=h.target;s.xrSession||p.removeEventListener("disconnected",d);for(let m=p.children.length-1;m>=0;m--){const f=p.children[m];f.name.indexOf(p.name)>-1&&(f.geometry.dispose(),f.material.dispose(),p.remove(f))}}const u={optionalFeatures:[t]};e=="immersive-ar"&&(u.optionalFeatures.push("hit-test"),r.domOverlay&&(u.optionalFeatures.push("dom-overlay"),u.domOverlay={root:s.container})),navigator.xr.requestSession(e,u).then(function(h){s._postprocessingSave=s.postprocessing,s.postprocessing=null,s.renderer.xr.setReferenceSpaceType(t),s.xrSession=h,h.addEventListener("end",l);const p=e=="immersive-vr"?2:1;for(let m=0;m<p;m++){const f=s.renderer.xr.getController(m);s.scene.add(f),s.xrControllers.push(f),f.addEventListener("connected",c),f.addEventListener("disconnected",d)}if(e=="immersive-vr"){const m=s.camera;m.parent&&m.parent.isScene&&(s.xrCameraParent=new ze,s.xrCameraParent.name="XR_CAMERA_CONTROL_OBJECT",s.scene.add(s.xrCameraParent),m.removeFromParent(),s.xrCameraParent.add(m))}else s._backgroundSave=s.scene.background,s.scene.background=null;s.renderer.xr.enabled=!0,s.renderer.xr.setSession(h),r.domOverlay&&s.renderer.xr.addEventListener("sessionstart",function(){setTimeout(function(){s.renderer.domElement.style.width=s.getWidth()+"px",s.renderer.domElement.style.height=s.getHeight()+"px"},300)}),n()}).catch(i)}endWebXR(){this.xrSession&&this.xrSession.end()}printPerformanceInfo(e){To.printPerformanceInfo(this,e)}showFPS(){if(this.container){this.hideFPS();const e=new la;e.showPanel(0),this.container.appendChild(e.dom),this.stats=e}}hideFPS(){this.container&&this.stats&&(this.container.removeChild(this.stats.dom),this.stats=null)}}function a5(){console.error("v3d.ImmediateRenderObject has been removed.")}class s5 extends et{constructor(e,t,n){console.error('v3d.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),super(e,t,n),this.samples=4}}class l5 extends Ns{constructor(e,t,n,i){console.warn("v3d.DataTexture2DArray has been renamed to DataArrayTexture."),super(e,t,n,i)}}class c5 extends jc{constructor(e,t,n,i){console.warn("v3d.DataTexture3D has been renamed to Data3DTexture."),super(e,t,n,i)}}class u5 extends ao{constructor(e,t,n,i,o,r){console.warn("v3d.BoxBufferGeometry has been renamed to v3d.BoxGeometry."),super(e,t,n,i,o,r)}}class d5 extends Vs{constructor(e,t,n,i){console.warn("v3d.CapsuleBufferGeometry has been renamed to v3d.CapsuleGeometry."),super(e,t,n,i)}}class h5 extends Gs{constructor(e,t,n,i){console.warn("v3d.CircleBufferGeometry has been renamed to v3d.CircleGeometry."),super(e,t,n,i)}}class p5 extends ks{constructor(e,t,n,i,o,r,s){console.warn("v3d.ConeBufferGeometry has been renamed to v3d.ConeGeometry."),super(e,t,n,i,o,r,s)}}class f5 extends yr{constructor(e,t,n,i,o,r,s,l){console.warn("v3d.CylinderBufferGeometry has been renamed to v3d.CylinderGeometry."),super(e,t,n,i,o,r,s,l)}}class m5 extends Qs{constructor(e,t){console.warn("v3d.DodecahedronBufferGeometry has been renamed to v3d.DodecahedronGeometry."),super(e,t)}}class g5 extends wa{constructor(e,t){console.warn("v3d.ExtrudeBufferGeometry has been renamed to v3d.ExtrudeGeometry."),super(e,t)}}class v5 extends Ws{constructor(e,t){console.warn("v3d.IcosahedronBufferGeometry has been renamed to v3d.IcosahedronGeometry."),super(e,t)}}class _5 extends Ea{constructor(e,t,n,i){console.warn("v3d.LatheBufferGeometry has been renamed to v3d.LatheGeometry."),super(e,t,n,i)}}class A5 extends Ta{constructor(e,t){console.warn("v3d.OctahedronBufferGeometry has been renamed to v3d.OctahedronGeometry."),super(e,t)}}class x5 extends ni{constructor(e,t,n,i){console.warn("v3d.PlaneBufferGeometry has been renamed to v3d.PlaneGeometry."),super(e,t,n,i)}}class y5 extends so{constructor(e,t,n,i){console.warn("v3d.PolyhedronBufferGeometry has been renamed to v3d.PolyhedronGeometry."),super(e,t,n,i)}}class b5 extends Hs{constructor(e,t,n,i,o,r){console.warn("v3d.RingBufferGeometry has been renamed to v3d.RingGeometry."),super(e,t,n,i,o,r)}}class C5 extends Xs{constructor(e,t){console.warn("v3d.ShapeBufferGeometry has been renamed to v3d.ShapeGeometry."),super(e,t)}}class S5 extends Ia{constructor(e,t,n,i,o,r,s){console.warn("v3d.SphereBufferGeometry has been renamed to v3d.SphereGeometry."),super(e,t,n,i,o,r,s)}}class M5 extends Ys{constructor(e,t){console.warn("v3d.TetrahedronBufferGeometry has been renamed to v3d.TetrahedronGeometry."),super(e,t)}}class E5 extends js{constructor(e,t,n,i,o){console.warn("v3d.TorusBufferGeometry has been renamed to v3d.TorusGeometry."),super(e,t,n,i,o)}}class w5 extends Ks{constructor(e,t,n,i,o,r){console.warn("v3d.TorusKnotBufferGeometry has been renamed to v3d.TorusKnotGeometry."),super(e,t,n,i,o,r)}}class T5 extends qs{constructor(e,t,n,i,o){console.warn("v3d.TubeBufferGeometry has been renamed to v3d.TubeGeometry."),super(e,t,n,i,o)}}function I5(){console.error("v3d.SSAOPass has been removed, use v3d.GTAOMapGenerator instead")}is.prototype.updateObjectMaterialEnv=function(){console.error("v3d.App.updateObjectMaterialEnv has been deprecated: not needed anymore")},is.prototype.load=function(){console.error("v3d.App.load has been deprecated. Use v3d.App.loadScene instead.")},is.prototype.cleanup=function(){console.error("v3d.App.cleanup has been deprecated. Use v3d.App.unload or v3d.App.dispose instead.")},To.createLineObjectHTML=function(){console.error("v3d.AppUtils.createLineObjectHTML has been deprecated. Use v3d.LineHTML instead.")};var gv={calcCameraZoomToObjectsParams:function(){var a=new At,e=new Rn;return function(t,n,i,o,r){var s=a.makeEmpty();n.forEach(function(c){s.expandByObject(c)});var l=s.getBoundingSphere(e);gv.calcCameraZoomToSphereParams(t,l,i,o,r)}}(),calcCameraZoomToSphereParams:function(){const a=new b;return function(e,t,n,i,o){if(e.isOrthographicCamera){let r=Math.min(e.top,e.right);o[0]=r/t.radius,n.setFromMatrixPosition(e.matrixWorld),i.copy(t.center)}else{let r=Ds(e.fov/2);e.aspect<1&&(r=Math.atan(e.aspect*Math.tan(r)));let s=t.radius/Math.sin(r);const l=e.getWorldDirection(a);n.copy(t.center).addScaledVector(l,-s),i.copy(t.center)}}}()},bc={normalizeDialectOptions:function(a){var e={delimiter:",",doublequote:!0,lineterminator:`
`,quotechar:'"',skipinitialspace:!0,skipinitialrows:0};for(var t in a)e[t.toLowerCase()]=a[t];return e},parse:function(a,e){(!e||e&&!e.lineterminator)&&(a=bc.normalizeLineTerminator(a,e));var t=bc.normalizeDialectOptions(e);a=bc.chomp(a,t.lineterminator);var n,i,o="",r=!1,s=!1,l="",c=[],d=[];for(i=function(u){var h=String.prototype.trim?function(p){return p.trim()}:function(p){return p.replace(/^\s*/,"").replace(/\s*$/,"")};return s!==!0&&(u===""?u=null:t.skipinitialspace===!0&&(u=h(u)),/^\d+$/.test(u)?u=parseInt(u,10):/^\d*\.\d+$|^\d+\.\d*$/.test(u)&&(u=parseFloat(u,10))),u},n=0;n<a.length;n+=1)o=a.charAt(n),r!==!1||o!==t.delimiter&&o!==t.lineterminator?o!==t.quotechar?l+=o:r?a.charAt(n+1)===t.quotechar?(l+=t.quotechar,n+=1):r=!1:(r=!0,s=!0):(l=i(l),c.push(l),o===t.lineterminator&&(d.push(c),c=[]),l="",s=!1);return l=i(l),c.push(l),d.push(c),t.skipinitialrows&&(d=d.slice(t.skipinitialrows)),d},normalizeLineTerminator:function(a,e){return(e=e||{}).lineterminator?a:a.replace(/(\r\n|\n|\r)/gm,`
`)},chomp:function(a,e){return a.charAt(a.length-e.length)!==e?a:a.substring(0,a.length-e.length)}};const cc=new b(1,0,0),R5=new b,L5=new b,P5=new Ge;class vv extends Ue{constructor(e,t){e=e!==void 0?e:new me(1,0,0),t=t!==void 0?t:2;const n=new ai;n.setGeometry([0,0,0,cc.x,cc.y,cc.z]);const i=new hu({color:e,lineWidth:t,sizeAttenuation:0});super(n.geometry,i),this.elemHTML=null,this.offset=5}onBeforeRender(e,t,n,i,o,r){if(super.onBeforeRender(),!this.elemHTML)return;const s=e.domElement.offsetHeight,l=e.domElement.offsetWidth,c=this.elemHTML.getBoundingClientRect(),d=(c.left+c.right)/2,u=(c.top+c.bottom)/2,h=this.getWorldPosition(R5).project(n),p=(h.x+1)/2*l,m=(1-h.y)/2*s,f=(u-m)/(d-p),g=(c.height+2*this.offset)/(c.width+2*this.offset);let _,A;Math.abs(f)>g?(A=m>u?Math.min(c.bottom+this.offset,m):Math.max(c.top-this.offset,m),_=(A-m)/f+p):(_=p<d?Math.max(c.left-this.offset,p):Math.min(c.right+this.offset,p),A=(_-p)*f+m);const x=2*_/l-1,S=1-2*A/s,M=L5.set(x,S,-1);M.unproject(n),this.parent&&this.parent.worldToLocal(M);const T=M.length();this.scale.setScalar(T),M.normalize();const L=P5.setFromUnitVectors(cc,M);this.setRotationFromQuaternion(L),this.updateMatrixWorld()}}function Lo(){}function Vc(a){Lo.call(this);for(let e in a){const t=a[e];e==="container"&&(t===void 0?this.container=document.body:t instanceof HTMLElement?this.container=t:this.container=document.getElementById(t))}this.bar=document.createElement("div"),this.bar.setAttribute("class","v3d-simple-preloader-bar"),this.logo=document.createElement("div"),this.logo.setAttribute("class","v3d-simple-preloader-logo"),this.logoCont=document.createElement("div"),this.logoCont.setAttribute("id","v3d_preloader_container"),this.logoCont.setAttribute("class","v3d-simple-preloader-container"),this.background=document.createElement("div"),this.background.setAttribute("class","v3d-simple-preloader-background"),this.background.appendChild(this.logoCont),this.logoCont.appendChild(this.logo),this.logoCont.appendChild(this.bar),this.container.appendChild(this.background),this.clock=new Di}vv.prototype.isLineHTML=!0,Object.assign(Lo.prototype,{onUpdate:function(a){},onFinish:function(){}}),Vc.prototype=Object.assign(Object.create(Lo.prototype),{constructor:Vc,onUpdate:function(a){a=Math.round(a),this.bar.style.width=a+"%"},onFinish:function(){this.container.removeChild(this.background)}});const B5="puzzles.min.js";function _v(){}function Cc(a){Ue.call(this),this.type="CubeTextureHelper",this.geometry=new ao(2,2,2,1,1,1),this.geometry.computeBoundingSphere(),this.material=new Xt,this.material.envMap=a}Object.assign(_v.prototype,{_logicFileLoadError:function(a){const e=new Error(a);return e.name="LogicFileLoadError",e},_editorLoadError:function(a){const e=new Error(a);return e.name="EditorLoadError",e},_getLogicPromise:async function(a){var n,i,o;const e=_s(),t=new URL(a,document.baseURI).href;try{const r=(i=(n=await rf(()=>import(t),__vite__mapDeps([]))).createPL)==null?void 0:i.call(n);return await((o=r==null?void 0:r.loadPhysics)==null?void 0:o.call(r)),r??e.v3d.PL??null}catch{throw this._logicFileLoadError(`Unable to load the logic file: '${t}'.`)}},_getEditorPromise:function(a,e){const t=this;return new Promise(function(n,i){To.loadScript(a,document.body,function(){n()},function(){i(t._editorLoadError("Unable to load the Puzzles Editor: '"+a+"'."))})})},_getLogicViaEditorPromise:async function(a,e){const t=_s();if(!t.v3d||!t.v3d.PE)throw this._editorLoadError("Unable to load Puzzles' logic. The Puzzles Editor isn't loaded.");const n=e.split(".");n[n.length-1]="xml";const i=n.join("."),{PL:o,logicXMLLoaded:r}=await t.v3d.PE.init(a,i);if(!r)throw this._logicFileLoadError(`Unable to load the Puzzles Editor's XML logic file: '${i}'.`);return o},_getAmmoJSPromise:function(){const a=document.getElementsByTagName("script");let e=!1;for(let t=a.length-1;t>=0;--t)if(a[t].src.search(/ammo.wasm.js/)>-1){e=!0;break}return new Promise(function(t,n){if(e&&window.Ammo)console.warn("You have ammo.wasm.js assigned in app html, please remove it"),t();else if(e&&!window.Ammo){console.warn("You have ammo.wasm.js assigned in app html, please remove it and resave Puzzles");const i=Yc("ammo.wasm.js");rf(()=>import(i),__vite__mapDeps([])).then(o=>{let r=o.default;r?new r().then(s=>{window.Ammo=s,t()}):n(new Error("Failed to load physics module"))})}else t()})},loadLogic:async function(a,e,t){try{const n=await this._getLogicPromise(a);return await this._getAmmoJSPromise(),e&&e(),n}catch(n){console.error(n),t&&t(n)}},loadEditorWithLogic:async function(a,e,t,n){try{let i=null;await this._getEditorPromise(a+B5);try{i=await this._getLogicViaEditorPromise(a,e)}catch(o){if(o.name!=="LogicFileLoadError")throw o}return await this._getAmmoJSPromise(),t&&t(),i}catch(i){console.error(i),n&&n(i)}}}),Cc.prototype=Object.create(Ue.prototype),Cc.prototype.constructor=Cc;class Yp extends ze{constructor(e){super(),this.doUpdate=!0,this.projected=new b,this.container=e,this.updatedCallback=null}clone(){return new this.constructor(this.container).copy(this)}update(e){if(this.doUpdate){var t=this.projected;this.getWorldPosition(t).project(e);var n=this.container.offsetWidth,i=this.container.offsetHeight,o=(.5+t.x/2)*n,r=(.5-t.y/2)*i;t.x=o,t.y=r;var s=t.z<=1&&o>=0&&o<=n&&r>=0&&r<=i;this.visible=s,this.updatedCallback&&this.updatedCallback(t.x,t.y,s)}}}Yp.prototype.isAnnotationControl=!0;var Pd=new Jc,uc=new b,Bd=new b,H0=new b;class Av extends Yp{constructor(e,t,n){super(e),this.type="Annotation",this.character=t,this.dialogContents=n,this.annotation=document.createElement("div"),this.annotation.innerHTML=t,this.annotation.className="v3d-annotation",this.container.appendChild(this.annotation),this.annotationDialogVisible=!1,this.annotationDialog=document.createElement("div"),this.annotationDialog.innerHTML=n,this.annotationDialog.className="v3d-annotation-dialog",this.annotation.appendChild(this.annotationDialog),this.fadeObscured=!0,this.obscured=!1;var i=!1,o=this;function r(s){s.target==o.annotation?o.annotationDialog.innerHTML.length==0||o.obscured||(o.annotationDialogVisible=!o.annotationDialogVisible,o.annotationDialog.style.visibility=o.annotationDialogVisible?"visible":"hidden",o.annotationDialogVisible?o.annotation.style.zIndex="2":o.annotation.style.zIndex="1"):s.target.className.indexOf("v3d-annotation")>-1&&(o.annotationDialogVisible=!1,o.annotationDialog.style.visibility="hidden",o.annotation.style.zIndex=o.obscured?"auto":"1")}this._touchstartCb=function(s){r(s),i=!0},document.body.addEventListener("touchstart",this._touchstartCb,!1),this._mousedownCb=function(s){i||r(s),i=!1},document.body.addEventListener("mousedown",this._mousedownCb,!1)}raycast(){}clone(){return new this.constructor(this.container,this.character,this.dialogContents).copy(this)}update(e){if(super.update(e),this.doUpdate){var t=this.projected,n=this.annotation;if(n.style.transform="translate("+t.x+"px, "+t.y+"px)",n.style.visibility=this.visible?"visible":"hidden",this.annotationDialog.style.visibility=this.visible&&this.annotationDialogVisible?"visible":"hidden",this.fadeObscured){e.getWorldPositionNU(uc),this.getWorldPositionNU(Bd),H0.copy(Bd).sub(uc).normalize(),Pd.set(uc,H0),Pd.far=uc.distanceTo(Bd);var i=Pd.intersectObject(this.findRoot(),!0);i.length>1||i.length==1&&i[0].object!=this.parent?(n.classList.add("v3d-annotation-transparent"),this.obscured=!0,n.style.zIndex="auto",this.annotationDialog.style.visibility="hidden"):(n.classList.remove("v3d-annotation-transparent"),n.style.zIndex=this.annotationDialog.style.visibility=="visible"?"2":"1",this.obscured=!1)}}}setDialogVisibility(e){e?(this.annotationDialogVisible=!0,this.annotationDialog.style.visibility="visible",this.annotation.style.zIndex="2"):(this.annotationDialogVisible=!1,this.annotationDialog.style.visibility="hidden",this.annotation.style.zIndex="1")}dispose(){var e=this.annotation.parentElement;e&&e.removeChild(this.annotation),document.body.removeEventListener("touchstart",this._touchstartCb,!1),document.body.removeEventListener("mousedown",this._mousedownCb,!1)}}Av.prototype.isAnnotation=!0;const X0=new b,dc=new Ge,D5=new Ge;function N5(a,e,t){const n=a.parent;n&&!n.isScene&&(X0.copy(e).applyQuaternion(a.quaternion).applyQuaternion(n.quaternion),n.position.add(X0.multiplyScalar(t)))}function O5(a,e,t){const n=a.parent;n&&!n.isScene&&(dc.setFromAxisAngle(e,t),dc.premultiply(a.quaternion),dc.premultiply(n.quaternion),n.quaternion.multiplyQuaternions(dc,D5.copy(a.quaternion).invert()))}var F5=Object.freeze({__proto__:null,rotateVRCamera:O5,translateVRCamera:N5});class jp{constructor(){this.pluginCallbacks=[],this.register(function(e){return new k5(e)}),this.register(function(e){return new Q5(e)}),this.register(function(e){return new X5(e)}),this.register(function(e){return new Y5(e)}),this.register(function(e){return new W5(e)}),this.register(function(e){return new H5(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,i){const o=new G5,r=[];for(let s=0,l=this.pluginCallbacks.length;s<l;s++)r.push(this.pluginCallbacks[s](o));o.setPlugins(r),o.write(e,t,i).catch(n)}parseAsync(e,t){const n=this;return new Promise(function(i,o){n.parse(e,i,o,t)})}}const ft={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,FLOAT:5126,UNSIGNED_INT:5125,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},zn={};zn[st]=ft.NEAREST,zn[ca]=ft.NEAREST_MIPMAP_NEAREST,zn[cr]=ft.NEAREST_MIPMAP_LINEAR,zn[Le]=ft.LINEAR,zn[Bs]=ft.LINEAR_MIPMAP_NEAREST,zn[In]=ft.LINEAR_MIPMAP_LINEAR,zn[mt]=ft.CLAMP_TO_EDGE,zn[Qn]=ft.REPEAT,zn[fr]=ft.MIRRORED_REPEAT;const Y0={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"};function Za(a,e){return a.length===e.length&&a.every(function(t,n){return t===e[n]})}function U5(a){return new TextEncoder().encode(a).buffer}function z5(a){return Za(a.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function V5(a,e,t){const n={min:new Array(a.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(a.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let i=e;i<e+t;i++)for(let o=0;o<a.itemSize;o++){let r;a.itemSize>4?r=a.array[i*a.itemSize+o]:(o===0?r=a.getX(i):o===1?r=a.getY(i):o===2?r=a.getZ(i):o===3&&(r=a.getW(i)),a.normalized===!0&&(r=ut(r,a.array))),n.min[o]=Math.min(n.min[o],r),n.max[o]=Math.max(n.max[o],r)}return n}function xv(a){return 4*Math.ceil(a/4)}function Dd(a,e=0){const t=xv(a.byteLength);if(t!==a.byteLength){const n=new Uint8Array(t);if(n.set(new Uint8Array(a)),e!==0)for(let i=a.byteLength;i<t;i++)n[i]=e;return n.buffer}return a}function j0(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function K0(a,e){if(a.toBlob!==void 0)return new Promise(n=>a.toBlob(n,e));let t;return e==="image/jpeg"?t=.92:e==="image/webp"&&(t=.8),a.convertToBlob({type:e,quality:t})}class G5{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"v3d.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,t,n={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const i=this,o=i.buffers,r=i.json;n=i.options;const s=i.extensionsUsed,l=new Blob(o,{type:"application/octet-stream"}),c=Object.keys(s);if(c.length>0&&(r.extensionsUsed=c),r.buffers&&r.buffers.length>0&&(r.buffers[0].byteLength=l.size),n.binary===!0){const d=new FileReader;d.readAsArrayBuffer(l),d.onloadend=function(){const u=Dd(d.result),h=new DataView(new ArrayBuffer(8));h.setUint32(0,u.byteLength,!0),h.setUint32(4,5130562,!0);const p=Dd(U5(JSON.stringify(r)),32),m=new DataView(new ArrayBuffer(8));m.setUint32(0,p.byteLength,!0),m.setUint32(4,1313821514,!0);const f=new ArrayBuffer(12),g=new DataView(f);g.setUint32(0,1179937895,!0),g.setUint32(4,2,!0);const _=12+m.byteLength+p.byteLength+h.byteLength+u.byteLength;g.setUint32(8,_,!0);const A=new Blob([f,m,p,h,u],{type:"application/octet-stream"}),x=new FileReader;x.readAsArrayBuffer(A),x.onloadend=function(){t(x.result)}}}else if(r.buffers&&r.buffers.length>0){const d=new FileReader;d.readAsDataURL(l),d.onloadend=function(){const u=d.result;r.buffers[0].uri=u,t(r)}}else t(r)}serializeUserData(e,t){if(Object.keys(e.userData).length===0)return;const n=this.options,i=this.extensionsUsed;try{const o=JSON.parse(JSON.stringify(e.userData));if(n.includeCustomExtensions&&o.gltfExtensions){t.extensions===void 0&&(t.extensions={});for(const r in o.gltfExtensions)t.extensions[r]=o.gltfExtensions[r],i[r]=!0;delete o.gltfExtensions}Object.keys(o).length>0&&(t.extras=o)}catch(o){console.warn("v3d.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+o.message)}}getUID(e,t=!1){if(this.uids.has(e)===!1){const n=new Map;n.set(!0,this.uid++),n.set(!1,this.uid++),this.uids.set(e,n)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const t=new b;for(let n=0,i=e.count;n<i;n++)if(Math.abs(t.fromBufferAttribute(e,n).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const n=e.clone(),i=new b;for(let o=0,r=n.count;o<r;o++)i.fromBufferAttribute(n,o),i.x===0&&i.y===0&&i.z===0?i.setX(1):i.normalize(),n.setXYZ(o,i.x,i.y,i.z);return t.attributesNormalized.set(e,n),n}applyTextureTransform(e,t){let n=!1;const i={};t.offset.x===0&&t.offset.y===0||(i.offset=t.offset.toArray(),n=!0),t.rotation!==0&&(i.rotation=t.rotation,n=!0),t.repeat.x===1&&t.repeat.y===1||(i.scale=t.repeat.toArray(),n=!0),n&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=i,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,t){if(e===t)return e;function n(h){return h.encoding===sRGBEncoding?function(p){return p<.04045?.0773993808*p:Math.pow(.9478672986*p+.0521327014,2.4)}:function(p){return p}}console.warn("v3d.GLTFExporter: Merged metalnessMap and roughnessMap textures.");const i=e==null?void 0:e.image,o=t==null?void 0:t.image,r=Math.max((i==null?void 0:i.width)||0,(o==null?void 0:o.width)||0),s=Math.max((i==null?void 0:i.height)||0,(o==null?void 0:o.height)||0),l=j0();l.width=r,l.height=s;const c=l.getContext("2d");c.fillStyle="#00ffff",c.fillRect(0,0,r,s);const d=c.getImageData(0,0,r,s);if(i){c.drawImage(i,0,0,r,s);const h=n(e),p=c.getImageData(0,0,r,s).data;for(let m=2;m<p.length;m+=4)d.data[m]=256*h(p[m]/256)}if(o){c.drawImage(o,0,0,r,s);const h=n(t),p=c.getImageData(0,0,r,s).data;for(let m=1;m<p.length;m+=4)d.data[m]=256*h(p[m]/256)}c.putImageData(d,0,0);const u=(e||t).clone();return u.source=new Source(l),u.encoding=LinearEncoding,u}processBuffer(e){const t=this.json,n=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),n.push(e),0}processBufferView(e,t,n,i,o){const r=this.json;let s;r.bufferViews||(r.bufferViews=[]),s=t===ft.UNSIGNED_BYTE?1:t===ft.UNSIGNED_SHORT?2:4;const l=xv(i*e.itemSize*s),c=new DataView(new ArrayBuffer(l));let d=0;for(let h=n;h<n+i;h++)for(let p=0;p<e.itemSize;p++){let m;e.itemSize>4?m=e.array[h*e.itemSize+p]:(p===0?m=e.getX(h):p===1?m=e.getY(h):p===2?m=e.getZ(h):p===3&&(m=e.getW(h)),e.normalized===!0&&(m=ut(m,e.array))),t===ft.FLOAT?c.setFloat32(d,m,!0):t===ft.UNSIGNED_INT?c.setUint32(d,m,!0):t===ft.UNSIGNED_SHORT?c.setUint16(d,m,!0):t===ft.UNSIGNED_BYTE&&c.setUint8(d,m),d+=s}const u={buffer:this.processBuffer(c.buffer),byteOffset:this.byteOffset,byteLength:l};return o!==void 0&&(u.target=o),o===ft.ARRAY_BUFFER&&(u.byteStride=e.itemSize*s),this.byteOffset+=l,r.bufferViews.push(u),{id:r.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,n=t.json;return n.bufferViews||(n.bufferViews=[]),new Promise(function(i){const o=new FileReader;o.readAsArrayBuffer(e),o.onloadend=function(){const r=Dd(o.result),s={buffer:t.processBuffer(r),byteOffset:t.byteOffset,byteLength:r.byteLength};t.byteOffset+=r.byteLength,i(n.bufferViews.push(s)-1)}})}processAccessor(e,t,n,i){const o=this.json;let r;if(e.array.constructor===Float32Array)r=ft.FLOAT;else if(e.array.constructor===Uint32Array)r=ft.UNSIGNED_INT;else if(e.array.constructor===Uint16Array)r=ft.UNSIGNED_SHORT;else{if(e.array.constructor!==Uint8Array)throw new Error("v3d.GLTFExporter: Unsupported bufferAttribute component type.");r=ft.UNSIGNED_BYTE}if(n===void 0&&(n=0),i===void 0&&(i=e.count),i===0)return null;const s=V5(e,n,i);let l;t!==void 0&&(l=e===t.index?ft.ELEMENT_ARRAY_BUFFER:ft.ARRAY_BUFFER);const c=this.processBufferView(e,r,n,i,l),d={bufferView:c.id,byteOffset:c.byteOffset,componentType:r,count:i,max:s.max,min:s.min,type:{1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"}[e.itemSize]};return e.normalized===!0&&(d.normalized=!0),o.accessors||(o.accessors=[]),o.accessors.push(d)-1}processImage(e,t,n,i="image/png"){if(e!==null){const o=this,r=o.cache,s=o.json,l=o.options,c=o.pending;r.images.has(e)||r.images.set(e,{});const d=r.images.get(e),u=i+":flipY/"+n.toString();if(d[u]!==void 0)return d[u];s.images||(s.images=[]);const h={mimeType:i},p=j0();p.width=Math.min(e.width,l.maxTextureSize),p.height=Math.min(e.height,l.maxTextureSize);const m=p.getContext("2d");if(n===!0&&(m.translate(0,p.height),m.scale(1,-1)),e.data!==void 0){t!==Qe&&console.error("GLTFExporter: Only RGBAFormat is supported."),(e.width>l.maxTextureSize||e.height>l.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const g=new Uint8ClampedArray(e.height*e.width*4);for(let _=0;_<g.length;_+=4)g[_+0]=e.data[_+0],g[_+1]=e.data[_+1],g[_+2]=e.data[_+2],g[_+3]=e.data[_+3];m.putImageData(new ImageData(g,e.width,e.height),0,0)}else m.drawImage(e,0,0,p.width,p.height);l.binary===!0?c.push(K0(p,i).then(g=>o.processBufferViewImage(g)).then(g=>{h.bufferView=g})):p.toDataURL!==void 0?h.uri=p.toDataURL(i):c.push(K0(p,i).then(g=>new FileReader().readAsDataURL(g)).then(g=>{h.uri=g}));const f=s.images.push(h)-1;return d[u]=f,f}throw new Error("v3d.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const n={magFilter:zn[e.magFilter],minFilter:zn[e.minFilter],wrapS:zn[e.wrapS],wrapT:zn[e.wrapT]};return t.samplers.push(n)-1}processTexture(e){const t=this.cache,n=this.json;if(t.textures.has(e))return t.textures.get(e);n.textures||(n.textures=[]);let i=e.userData.mimeType;i==="image/webp"&&(i="image/png");const o={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,i)};e.name&&(o.name=e.name),this._invokeAll(function(s){s.writeTexture&&s.writeTexture(e,o)});const r=n.textures.push(o)-1;return t.textures.set(e,r),r}processMaterial(e){const t=this.cache,n=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: v3d.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const i={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const o=e.color.toArray().concat([e.opacity]);if(Za(o,[1,1,1,1])||(i.pbrMetallicRoughness.baseColorFactor=o),e.isMeshStandardMaterial?(i.pbrMetallicRoughness.metallicFactor=e.metalness,i.pbrMetallicRoughness.roughnessFactor=e.roughness):(i.pbrMetallicRoughness.metallicFactor=.5,i.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const s=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),l={index:this.processTexture(s)};this.applyTextureTransform(l,s),i.pbrMetallicRoughness.metallicRoughnessTexture=l}if(e.map){const s={index:this.processTexture(e.map)};this.applyTextureTransform(s,e.map),i.pbrMetallicRoughness.baseColorTexture=s}if(e.emissive){const s=e.emissive.clone().multiplyScalar(e.emissiveIntensity),l=Math.max(s.r,s.g,s.b);if(l>1&&(s.multiplyScalar(1/l),console.warn("v3d.GLTFExporter: Some emissive components exceed 1; emissive has been limited")),l>0&&(i.emissiveFactor=s.toArray()),e.emissiveMap){const c={index:this.processTexture(e.emissiveMap)};this.applyTextureTransform(c,e.emissiveMap),i.emissiveTexture=c}}if(e.normalMap){const s={index:this.processTexture(e.normalMap)};e.normalScale&&e.normalScale.x!==1&&(s.scale=e.normalScale.x),this.applyTextureTransform(s,e.normalMap),i.normalTexture=s}if(e.aoMap){const s={index:this.processTexture(e.aoMap),texCoord:1};e.aoMapIntensity!==1&&(s.strength=e.aoMapIntensity),this.applyTextureTransform(s,e.aoMap),i.occlusionTexture=s}e.transparent?i.alphaMode="BLEND":e.alphaTest>0&&(i.alphaMode="MASK",i.alphaCutoff=e.alphaTest),e.side===Tn&&(i.doubleSided=!0),e.name!==""&&(i.name=e.name),this.serializeUserData(e,i),this._invokeAll(function(s){s.writeMaterial&&s.writeMaterial(e,i)});const r=n.materials.push(i)-1;return t.materials.set(e,r),r}processMesh(e){const t=this.cache,n=this.json,i=[e.geometry.uuid];if(Array.isArray(e.material))for(let x=0,S=e.material.length;x<S;x++)i.push(e.material[x].uuid);else i.push(e.material.uuid);const o=i.join(":");if(t.meshes.has(o))return t.meshes.get(o);const r=e.geometry;let s;s=e.isLineSegments?ft.LINES:e.isLineLoop?ft.LINE_LOOP:e.isLine?ft.LINE_STRIP:e.isPoints?ft.POINTS:e.material.wireframe?ft.LINES:ft.TRIANGLES;const l={},c={},d=[],u=[],h={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},p=r.getAttribute("normal");p===void 0||this.isNormalizedNormalAttribute(p)||(console.warn("v3d.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),r.setAttribute("normal",this.createNormalizedNormalAttribute(p)));let m=null;for(let x in r.attributes){if(x.slice(0,5)==="morph")continue;const S=r.attributes[x];if(x=h[x]||x.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(x)||(x="_"+x),t.attributes.has(this.getUID(S))){c[x]=t.attributes.get(this.getUID(S));continue}m=null;const M=S.array;x!=="JOINTS_0"||M instanceof Uint16Array||M instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),m=new Te(new Uint16Array(M),S.itemSize,S.normalized));const T=this.processAccessor(m||S,r);T!==null&&(c[x]=T,t.attributes.set(this.getUID(S),T))}if(p!==void 0&&r.setAttribute("normal",p),Object.keys(c).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const x=[],S=[],M={};if(e.morphTargetDictionary!==void 0)for(const T in e.morphTargetDictionary)M[e.morphTargetDictionary[T]]=T;for(let T=0;T<e.morphTargetInfluences.length;++T){const L={};let z=!1;for(const W in r.morphAttributes){if(W!=="position"&&W!=="normal"){z||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),z=!0);continue}const V=r.morphAttributes[W][T],N=W.toUpperCase(),j=r.attributes[W];if(t.attributes.has(this.getUID(V,!0))){L[N]=t.attributes.get(this.getUID(V,!0));continue}const oe=V.clone();if(!r.morphTargetsRelative)for(let H=0,ne=V.count;H<ne;H++)for(let le=0;le<V.itemSize;le++)le===0&&oe.setX(H,V.getX(H)-j.getX(H)),le===1&&oe.setY(H,V.getY(H)-j.getY(H)),le===2&&oe.setZ(H,V.getZ(H)-j.getZ(H)),le===3&&oe.setW(H,V.getW(H)-j.getW(H));L[N]=this.processAccessor(oe,r),t.attributes.set(this.getUID(j,!0),L[N])}u.push(L),x.push(e.morphTargetInfluences[T]),e.morphTargetDictionary!==void 0&&S.push(M[T])}l.weights=x,S.length>0&&(l.extras={},l.extras.targetNames=S)}const f=Array.isArray(e.material);if(f&&r.groups.length===0)return null;const g=f?e.material:[e.material],_=f?r.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let x=0,S=_.length;x<S;x++){const M={mode:s,attributes:c};if(this.serializeUserData(r,M),u.length>0&&(M.targets=u),r.index!==null){let L=this.getUID(r.index);_[x].start===void 0&&_[x].count===void 0||(L+=":"+_[x].start+":"+_[x].count),t.attributes.has(L)?M.indices=t.attributes.get(L):(M.indices=this.processAccessor(r.index,r,_[x].start,_[x].count),t.attributes.set(L,M.indices)),M.indices===null&&delete M.indices}const T=this.processMaterial(g[_[x].materialIndex]);T!==null&&(M.material=T),d.push(M)}l.primitives=d,n.meshes||(n.meshes=[]),this._invokeAll(function(x){x.writeMesh&&x.writeMesh(e,l)});const A=n.meshes.push(l)-1;return t.meshes.set(o,A),A}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const n=e.isOrthographicCamera,i={type:n?"orthographic":"perspective"};return n?i.orthographic={xmag:2*e.right,ymag:2*e.top,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:i.perspective={aspectRatio:e.aspect,yfov:Ds(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(i.name=e.type),t.cameras.push(i)-1}processAnimation(e,t){const n=this.json,i=this.nodeMap;n.animations||(n.animations=[]);const o=(e=jp.Utils.mergeMorphTargetTracks(e.clone(),t)).tracks,r=[],s=[];for(let l=0;l<o.length;++l){const c=o[l],d=$e.parseTrackName(c.name);let u=$e.findNode(t,d.nodeName);const h=Y0[d.propertyName];if(d.objectName==="bones"&&(u=u.isSkinnedMesh===!0?u.skeleton.getBoneByName(d.objectIndex):void 0),!u||!h)return console.warn('v3d.GLTFExporter: Could not export animation track "%s".',c.name),null;const p=1;let m,f=c.values.length/c.times.length;h===Y0.morphTargetInfluences&&(f/=u.morphTargetInfluences.length),c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(m="CUBICSPLINE",f/=3):m=c.getInterpolation()===2300?"STEP":"LINEAR",s.push({input:this.processAccessor(new Te(c.times,p)),output:this.processAccessor(new Te(c.values,f)),interpolation:m}),r.push({sampler:s.length-1,target:{node:i.get(u),path:h}})}return n.animations.push({name:e.name||"clip_"+n.animations.length,samplers:s,channels:r}),n.animations.length-1}processSkin(e){const t=this.json,n=this.nodeMap,i=t.nodes[n.get(e)],o=e.skeleton;if(o===void 0)return null;const r=e.skeleton.bones[0];if(r===void 0)return null;const s=[],l=new Float32Array(16*o.bones.length),c=new Ae;for(let d=0;d<o.bones.length;++d)s.push(n.get(o.bones[d])),c.copy(o.boneInverses[d]),c.multiply(e.bindMatrix).toArray(l,16*d);return t.skins===void 0&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new Te(l,16)),joints:s,skeleton:n.get(r)}),i.skin=t.skins.length-1}processNode(e){const t=this.json,n=this.options,i=this.nodeMap;if(e.isAuxClippingMesh)return null;let o=!1;if(n.onlyVisible&&!e.visible&&(e.traverse(function(l){l.visible&&(o=!0)}),!o))return null;t.nodes||(t.nodes=[]);const r={};if(n.trs){const l=e.quaternion.toArray(),c=e.position.toArray(),d=e.scale.toArray();Za(l,[0,0,0,1])||(r.rotation=l),Za(c,[0,0,0])||(r.translation=c),Za(d,[1,1,1])||(r.scale=d)}else e.matrixAutoUpdate&&e.updateMatrix(),z5(e.matrix)===!1&&(r.matrix=e.matrix.elements);if(e.name!==""&&(r.name=String(e.name)),this.serializeUserData(e,r),(e.isMesh||e.isLine||e.isPoints)&&!o){const l=this.processMesh(e);l!==null&&(r.mesh=l)}else e.isCamera&&!o&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&!o&&this.skins.push(e),e.children.length>0){const l=[];for(let c=0,d=e.children.length;c<d;c++){const u=e.children[c],h=this.processNode(u);h!==null&&l.push(h)}l.length>0&&(r.children=l)}this._invokeAll(function(l){l.writeNode&&l.writeNode(e,r)});const s=t.nodes.push(r)-1;return i.set(e,s),s}processScene(e){const t=this.json,n=this.options;t.scenes||(t.scenes=[],t.scene=0);const i={};e.name!==""&&(i.name=e.name),t.scenes.push(i);const o=[];for(let r=0,s=e.children.length;r<s;r++){const l=e.children[r];if(l.visible||n.onlyVisible===!1){const c=this.processNode(l);c!==null&&o.push(c)}}o.length>0&&(i.nodes=o),this.serializeUserData(e,i)}processObjects(e){const t=new vn;t.name="AuxScene";for(let n=0;n<e.length;n++)t.children.push(e[n]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll(function(i){i.beforeParse&&i.beforeParse(e)});const n=[];for(let i=0;i<e.length;i++)e[i]instanceof vn?this.processScene(e[i]):n.push(e[i]);n.length>0&&this.processObjects(n);for(let i=0;i<this.skins.length;++i)this.processSkin(this.skins[i]);for(let i=0;i<t.animations.length;++i)this.processAnimation(t.animations[i],e[0]);this._invokeAll(function(i){i.afterParse&&i.afterParse(e)})}_invokeAll(e){for(let t=0,n=this.plugins.length;t<n;t++)e(this.plugins[t])}}class k5{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight)return void console.warn("v3d.GLTFExporter: Only directional, point, and spot lights are supported.",e);const n=this.writer,i=n.json,o=n.extensionsUsed,r={};e.name&&(r.name=e.name),r.color=e.color.toArray(),r.intensity=e.intensity,e.isDirectionalLight?r.type="directional":e.isPointLight?(r.type="point",e.distance>0&&(r.range=e.distance)):e.isSpotLight&&(r.type="spot",e.distance>0&&(r.range=e.distance),r.spot={},r.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,r.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("v3d.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),!e.target||e.target.parent===e&&e.target.position.x===0&&e.target.position.y===0&&e.target.position.z===-1||console.warn("v3d.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),o[this.name]||(i.extensions=i.extensions||{},i.extensions[this.name]={lights:[]},o[this.name]=!0);const s=i.extensions[this.name].lights;s.push(r),t.extensions=t.extensions||{},t.extensions[this.name]={light:s.length-1}}}class Q5{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const n=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},n[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}}class W5{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial)return;const n=this.writer,i=n.extensionsUsed,o={};if(o.clearcoatFactor=e.clearcoat,e.clearcoatMap){const r={index:n.processTexture(e.clearcoatMap)};n.applyTextureTransform(r,e.clearcoatMap),o.clearcoatTexture=r}if(o.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const r={index:n.processTexture(e.clearcoatRoughnessMap)};n.applyTextureTransform(r,e.clearcoatRoughnessMap),o.clearcoatRoughnessTexture=r}if(e.clearcoatNormalMap){const r={index:n.processTexture(e.clearcoatNormalMap)};n.applyTextureTransform(r,e.clearcoatNormalMap),o.clearcoatNormalTexture=r}t.extensions=t.extensions||{},t.extensions[this.name]=o,i[this.name]=!0}}class H5{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial)return;const n=this.writer,i=n.extensionsUsed,o={};if(o.iridescenceFactor=e.iridescence,e.iridescenceMap){const r={index:n.processTexture(e.iridescenceMap)};n.applyTextureTransform(r,e.iridescenceMap),o.iridescenceTexture=r}if(o.iridescenceIor=e.iridescenceIOR,o.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],o.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const r={index:n.processTexture(e.iridescenceThicknessMap)};n.applyTextureTransform(r,e.iridescenceThicknessMap),o.iridescenceThicknessTexture=r}t.extensions=t.extensions||{},t.extensions[this.name]=o,i[this.name]=!0}}class X5{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,i=n.extensionsUsed,o={};if(o.transmissionFactor=e.transmission,e.transmissionMap){const r={index:n.processTexture(e.transmissionMap)};n.applyTextureTransform(r,e.transmissionMap),o.transmissionTexture=r}t.extensions=t.extensions||{},t.extensions[this.name]=o,i[this.name]=!0}}class Y5{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,i=n.extensionsUsed,o={};if(o.thicknessFactor=e.thickness,e.thicknessMap){const r={index:n.processTexture(e.thicknessMap)};n.applyTextureTransform(r,e.thicknessMap),o.thicknessTexture=r}o.attenuationDistance=e.attenuationDistance,o.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=o,i[this.name]=!0}}jp.Utils={insertKeyframe:function(a,e){const n=a.getValueSize(),i=new a.TimeBufferType(a.times.length+1),o=new a.ValueBufferType(a.values.length+n),r=a.createInterpolant(new a.ValueBufferType(n));let s;if(a.times.length===0){i[0]=e;for(let l=0;l<n;l++)o[l]=0;s=0}else if(e<a.times[0]){if(Math.abs(a.times[0]-e)<.001)return 0;i[0]=e,i.set(a.times,1),o.set(r.evaluate(e),0),o.set(a.values,n),s=0}else if(e>a.times[a.times.length-1]){if(Math.abs(a.times[a.times.length-1]-e)<.001)return a.times.length-1;i[i.length-1]=e,i.set(a.times,0),o.set(a.values,0),o.set(r.evaluate(e),a.values.length),s=i.length-1}else for(let l=0;l<a.times.length;l++){if(Math.abs(a.times[l]-e)<.001)return l;if(a.times[l]<e&&a.times[l+1]>e){i.set(a.times.slice(0,l+1),0),i[l+1]=e,i.set(a.times.slice(l+1),l+2),o.set(a.values.slice(0,(l+1)*n),0),o.set(r.evaluate(e),(l+1)*n),o.set(a.values.slice((l+1)*n),(l+2)*n),s=l+1;break}}return a.times=i,a.values=o,s},mergeMorphTargetTracks:function(a,e){const t=[],n={},i=a.tracks;for(let o=0;o<i.length;++o){let r=i[o];const s=$e.parseTrackName(r.name),l=$e.findNode(e,s.nodeName);if(s.propertyName!=="morphTargetInfluences"||s.propertyIndex===void 0){t.push(r);continue}if(r.createInterpolant!==r.InterpolantFactoryMethodDiscrete&&r.createInterpolant!==r.InterpolantFactoryMethodLinear){if(r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("v3d.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("v3d.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),r=r.clone(),r.setInterpolation(2301)}const c=l.morphTargetInfluences.length,d=l.morphTargetDictionary[s.propertyIndex];if(d===void 0)throw new Error("v3d.GLTFExporter: Morph target name not found: "+s.propertyIndex);let u;if(n[l.uuid]===void 0){u=r.clone();const p=new u.ValueBufferType(c*u.times.length);for(let m=0;m<u.times.length;m++)p[m*c+d]=u.values[m];u.name=(s.nodeName||"")+".morphTargetInfluences",u.values=p,n[l.uuid]=u,t.push(u);continue}const h=r.createInterpolant(new r.ValueBufferType(1));u=n[l.uuid];for(let p=0;p<u.times.length;p++)u.values[p*c+d]=h.evaluate(u.times[p]);for(let p=0;p<r.times.length;p++){const m=this.insertKeyframe(u,r.times[p]);u.values[m*c+d]=r.values[p]}}return a.tracks=t,a}};var j5=`.v3d-container {
    
    overflow: hidden;
    z-index: 0;
}
.v3d-canvas {
    
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    
    z-index: -1;
}
.v3d-simple-preloader-background {
    background-color: #fff;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1;
    height: 100%;
    width: 100%;
}
.v3d-simple-preloader-container {
    --v3d-preloader-img-width: 120px;
    --v3d-preloader-img-height: 120px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: calc(var(--v3d-preloader-img-width) + 60px);
    height: calc(var(--v3d-preloader-img-height) + 60px);
}
.v3d-simple-preloader-bar {
    background: linear-gradient(90deg, #1458ae, #4388e0);
    width: 0%;
    height: 3px;
    margin: 15px -1px;
    border: 1px solid;
    border-radius: 50px;
    border-color: #2b70c7;
}
.v3d-simple-preloader-logo {
    width: var(--v3d-preloader-img-width);
    height: var(--v3d-preloader-img-height);
    background-image: url('data:image/svg+xml,%3C%3Fxml version="1.0" encoding="UTF-8" standalone="no"%3F%3E%3Csvg width="120" height="120" viewBox="0 0 31.75 31.75" version="1.1" id="svg5409" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns%23" xmlns:cc="http://creativecommons.org/ns%23" xmlns:dc="http://purl.org/dc/elements/1.1/"%3E%3Cdefs id="defs5403"%3E%3ClinearGradient xlink:href="%23linearGradient3077" id="linearGradient4375" gradientUnits="userSpaceOnUse" x1="172.91336" y1="78.689407" x2="193.7847" y2="53.806618" gradientTransform="matrix(1.1562901,0,0,1.1583991,-194.29093,208.80811)" /%3E%3ClinearGradient id="linearGradient3077"%3E%3Cstop style="stop-color:%230048a5;stop-opacity:1" offset="0" id="stop3073" /%3E%3Cstop style="stop-color:%234b86d1;stop-opacity:1" offset="1" id="stop3075" /%3E%3C/linearGradient%3E%3C/defs%3E%3Cmetadata id="metadata5406"%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=""%3E%3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E%3Cdc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cg id="layer1" transform="translate(0,-270.54167)"%3E%3Cpath style="display:inline;fill:url(%23linearGradient4375);fill-opacity:1;stroke:none;stroke-width:0.9171;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" d="m 15.945207,270.5417 c -1.669933,-0.007 -3.344811,1.1051 -7.2273169,3.32785 -7.76503612,4.4455 -7.2281318,3.52338 -7.2677439,12.48309 -0.03948,8.95973 -0.56829626,8.03286 7.1571159,12.5471 7.7254249,4.51422 6.6598479,4.50948 14.4248479,0.064 7.765036,-4.4455 7.228132,-3.52338 7.267744,-12.48309 0.03948,-8.95973 0.568296,-8.03287 -7.157116,-12.5471 -3.862718,-2.25711 -5.527635,-3.38445 -7.197531,-3.39185 z m -0.0132,2.85167 c 1.6836,0.007 3.363685,0.8128 6.115359,2.4207 5.503323,3.21577 6.107199,4.27438 6.078963,10.65695 -0.02832,6.3826 -0.641388,7.43578 -6.172923,10.60259 -5.531523,3.16682 -6.748576,3.16139 -12.2518993,-0.0544 -5.503299,-3.21578 -6.1071633,-4.27439 -6.0789633,-10.65697 0.02844,-6.38259 0.6413884,-7.43577 6.1729353,-10.6026 2.7657613,-1.5834 4.4529153,-2.37377 6.1365283,-2.3663 z m -0.154249,1.6177 c -2.694169,0.0343 -5.683359,3.07006 -7.236352,6.07548 -1.5776528,3.05311 -2.4803533,5.94456 -2.1086051,9.65753 0.1618801,1.61652 1.6983849,3.67982 3.5378539,4.71425 -0.3909602,-3.2062 -0.1707481,-6.34306 0.5400002,-8.94693 0.71076,-2.60387 2.83223,-6.82883 5.337159,-6.82316 2.504954,0.006 4.626375,4.22704 5.337123,6.83091 0.710725,2.60386 0.930961,5.74073 0.539989,8.94693 1.839481,-1.03442 3.375985,-3.09779 3.537853,-4.71432 0.371749,-3.71296 -0.53082,-6.60428 -2.108485,-9.6574 -1.547604,-2.99499 -4.52153,-6.01988 -7.24846,-6.08267 -0.0426,-9.5e-4 -0.08532,-10e-4 -0.128028,-6.2e-4 z m 0.131713,8.9184 a 2.4731483,2.4776591 0 0 0 -1.188637,0.29153 2.4731483,2.4776591 0 0 0 -1.017889,3.35228 2.4731483,2.4776591 0 0 0 3.34619,1.01974 2.4731483,2.4776591 0 0 0 1.017877,-3.35231 2.4731483,2.4776591 0 0 0 -2.157541,-1.31124 z" id="path4130" /%3E%3C/g%3E%3C/svg%3E');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    margin: 20px auto;
}
.v3d-annotation {
    position: absolute;
    top: -0.7em;
    left: -0.5em;
    width: auto;
    min-width: 1em;
    height: 1.4em;
    padding: 0.3em 0.5em;
    border: 1px solid #fff;
    border-radius: 2em;
    font-size: 16px;
    font-family: sans-serif;
    line-height: 1.4em;
    color: #fff;
    text-align: center;
    user-select: none;
    background: rgba(0, 0, 0, 0.8);
}
.v3d-annotation-transparent {
    opacity: 0.5;
}
.v3d-annotation-dialog {
    position: absolute;
    top: 85%;
    left: 85%;
    font-family: sans-serif;
    user-select: none;
    padding: 1em;
    min-width: 200px;
    color: #fff;
    background: rgba(0, 0, 0, 0.8);
    border-radius: 1em;
    font-size: 12px;
    line-height: 1.2;
    transition: opacity .5s;
    visibility: hidden;
}
.v3d-mobile-forward {
    position: absolute;
    width: 62px;
    height: 62px;
    bottom: 31px;
    left: 50%;
    margin-left: -31px;
    background-image: url('data:image/svg+xml,%3C%3Fxml version="1.0" encoding="UTF-8" standalone="no"%3F%3E%3Csvg width="62" height="62" viewBox="0 0 16.404167 16.404167" version="1.1" id="svg2719" sodipodi:docname="move_forward.svg" inkscape:version="1.1.2 (b8e25be833, 2022-02-05)" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns%23" xmlns:cc="http://creativecommons.org/ns%23" xmlns:dc="http://purl.org/dc/elements/1.1/"%3E%3Csodipodi:namedview id="namedview7548" pagecolor="%23505050" bordercolor="%23eeeeee" borderopacity="1" inkscape:pageshadow="0" inkscape:pageopacity="0" inkscape:pagecheckerboard="0" showgrid="false" inkscape:snap-global="false" inkscape:zoom="7.1451613" inkscape:cx="42.266366" inkscape:cy="15.814898" inkscape:window-width="1920" inkscape:window-height="1137" inkscape:window-x="-8" inkscape:window-y="-8" inkscape:window-maximized="1" inkscape:current-layer="svg2719" /%3E%3Cdefs id="defs2713"%3E%3ClinearGradient gradientTransform="translate(-524.2581,-935.78503)" xlink:href="%23linearGradient2768" id="linearGradient2673" x1="501.88306" y1="942.95502" x2="508.08038" y2="935.61182" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient id="linearGradient2768"%3E%3Cstop style="stop-color:%23414141;stop-opacity:1" offset="0" id="stop2764" /%3E%3Cstop style="stop-color:%23767676;stop-opacity:1" offset="1" id="stop2766" /%3E%3C/linearGradient%3E%3ClinearGradient gradientTransform="translate(-521.96226,-941.8579)" xlink:href="%23linearGradient2648" id="linearGradient2665" x1="495.62714" y1="948.00964" x2="508.85629" y2="934.78046" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient id="linearGradient2648"%3E%3Cstop style="stop-color:%23ebebeb;stop-opacity:1" offset="0" id="stop2644" /%3E%3Cstop style="stop-color:%23ffffff;stop-opacity:1" offset="1" id="stop2646" /%3E%3C/linearGradient%3E%3Cfilter style="color-interpolation-filters:sRGB" id="filter2688" x="-0.12" width="1.24" y="-0.12" height="1.24"%3E%3CfeGaussianBlur stdDeviation="0.66145835" id="feGaussianBlur2690" /%3E%3C/filter%3E%3ClinearGradient inkscape:collect="always" xlink:href="%23linearGradient2768" id="linearGradient7749" x1="6.0107598" y1="11.942085" x2="11.430239" y2="4.0917845" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient inkscape:collect="always" xlink:href="%23linearGradient2648" id="linearGradient8251" x1="4.2536402" y1="13.238126" x2="12.150527" y2="2.9068334" gradientUnits="userSpaceOnUse" /%3E%3Cfilter inkscape:collect="always" style="color-interpolation-filters:sRGB" id="filter8772" x="-0.10840111" y="-0.10840111" width="1.2168022" height="1.2168022"%3E%3CfeGaussianBlur inkscape:collect="always" stdDeviation="0.59752352" id="feGaussianBlur8774" /%3E%3C/filter%3E%3C/defs%3E%3Cmetadata id="metadata2716"%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=""%3E%3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E%3Cdc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Ccircle style="fill:%23000000;stroke-width:0.230841;stroke-linecap:round;stroke-linejoin:round;fill-opacity:0.5;filter:url(%23filter8772)" id="circle8626" cx="8.2020836" cy="8.2020836" r="6.6145835" /%3E%3Ccircle style="fill:url(%23linearGradient8251);stroke-width:0.230841;stroke-linecap:round;stroke-linejoin:round;fill-opacity:1" id="path7652" cx="8.2020836" cy="8.2020836" r="6.6145835" /%3E%3Cpath d="m 4.2333333,6.7138018 c 0,0.9875367 0.4960933,2.4804692 0.4960933,2.4804692 h 1.984375 c 0,-0.7441408 0.2480473,-1.1782225 0.496094,-1.612305 0.2480467,-0.4340817 0.4960942,-0.8681642 0.4960942,-1.6123037 0,-0.8743657 -0.2480475,-2.7285166 -1.4882817,-2.7285166 -1.240234,0 -1.9843749,1.9843749 -1.9843748,3.4726561 z m 1.4882816,4.4648442 c 0.5472533,0 0.9921867,-0.444934 0.9921867,-0.992188 V 9.6903643 h -1.984375 v 0.4960937 c 0,0.547254 0.4449341,0.992188 0.9921883,0.992188 z M 12.170834,8.6981768 c 0,-1.4882808 -0.744141,-3.4726553 -1.984376,-3.4726553 -1.240234,0 -1.4882807,1.8541503 -1.4882807,2.7285153 0,0.74414 0.2480467,1.1782226 0.4960933,1.6123041 0.2480467,0.4340821 0.4960934,0.8681641 0.4960934,1.6123051 h 1.984376 c 0,0 0.496094,-1.4929325 0.496094,-2.4804692 z m -1.488281,4.4648442 c 0.547253,0 0.992187,-0.444935 0.992187,-0.992188 V 11.674739 H 9.690364 v 0.496094 c 0,0.547253 0.444935,0.992188 0.992189,0.992188 z" id="path7734" style="stroke-width:0.0155029;fill-opacity:1;fill:url(%23linearGradient7749)" /%3E%3C/svg%3E');
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
}
.v3d-webgl-error-container {
    position: absolute;
    top: 50%;
    left: 50%;
    margin-top: -80px;
    margin-left: -200px;
    width: 400px;
    height: 160px;
    text-align: center;
    z-index: 10;
}
.v3d-webgl-error-image {
    width: 160px;
    height: 160px;
    background-repeat: no-repeat;
    margin: 0px auto;
    background-image: url('data:image/svg+xml,%3C%3Fxml version="1.0" encoding="UTF-8" standalone="no"%3F%3E%3Csvg width="160" height="160" viewBox="0 0 42.333332 42.333333" version="1.1" id="svg1" inkscape:version="1.3 (0e150ed6c4, 2023-07-21)" sodipodi:docname="webgl-error.svg" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"%3E%3Csodipodi:namedview id="namedview1" pagecolor="%23ffffff" bordercolor="%23eeeeee" borderopacity="1" inkscape:showpageshadow="false" inkscape:pageopacity="0" inkscape:pagecheckerboard="false" inkscape:deskcolor="%23d1d1d1" inkscape:document-units="px" labelstyle="default" shape-rendering="auto" inkscape:clip-to-page="false" inkscape:zoom="1.6017536" inkscape:cx="-5.3066837" inkscape:cy="78.97594" inkscape:window-width="1920" inkscape:window-height="1137" inkscape:window-x="-8" inkscape:window-y="-8" inkscape:window-maximized="1" inkscape:current-layer="layer1" /%3E%3Cdefs id="defs1"%3E%3Cfilter inkscape:collect="always" style="color-interpolation-filters:sRGB" id="filter1" x="-0.18167429" y="-0.16562716" width="1.3633486" height="1.3312543"%3E%3CfeGaussianBlur inkscape:collect="always" stdDeviation="2.1910722" id="feGaussianBlur1" /%3E%3C/filter%3E%3ClinearGradient inkscape:collect="always" xlink:href="%23linearGradient3259" id="linearGradient10" x1="863.9444" y1="1424.3892" x2="892.88947" y2="1424.3892" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient inkscape:collect="always" id="linearGradient3259"%3E%3Cstop style="stop-color:%23c90000;stop-opacity:1" offset="0" id="stop3255" /%3E%3Cstop style="stop-color:%23ff0a0a;stop-opacity:1" offset="1" id="stop3257" /%3E%3C/linearGradient%3E%3C/defs%3E%3Cg inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1"%3E%3Cg id="g2" style="display:inline" transform="translate(-857.25025,-1403.2226)"%3E%3Cpath id="path10" style="fill:%23e40505;fill-opacity:0.4;stroke-width:0.0581876;filter:url(%23filter1)" d="m 878.41691,1413.9426 c 1.49459,-0.033 2.34009,1.1428 2.29362,2.1957 l -0.39169,8.8754 c -0.0465,1.0529 -0.84799,1.9018 -1.90193,1.9018 -1.05394,0 -1.8516,-0.8491 -1.90193,-1.9018 l -0.42433,-8.8754 c -0.0503,-1.0527 0.83167,-2.163 2.32626,-2.1957 z m -0.18948,15.5145 c 1.4715,-0.1102 2.72596,1.0544 2.72522,2.53 0.0257,3.4066 -5.09721,3.4066 -5.07148,0 -6.7e-4,-1.3275 1.02252,-2.4308 2.34626,-2.53 z m 0.26002,-20.9425 c -1.67293,-0.01 -3.35083,1.1046 -7.24038,3.3274 -7.77912,4.4454 -7.24153,3.5234 -7.28121,12.483 -0.0397,8.9596 -0.56935,8.0329 7.17011,12.547 7.73941,4.5142 6.67221,4.5096 14.45131,0.064 7.77911,-4.4455 7.241,-3.5233 7.28069,-12.483 0.0397,-8.9596 0.56933,-8.0328 -7.1701,-12.547 -3.86972,-2.257 -5.53749,-3.384 -7.21042,-3.3915 z m -0.0134,2.8509 v 6e-4 c 1.68666,0.01 3.37009,0.8126 6.12676,2.4205 5.51329,3.2157 6.11834,4.2746 6.09006,10.6572 -0.0283,6.3825 -0.64255,7.4357 -6.18411,10.6025 -5.54155,3.1668 -6.76089,3.161 -12.27419,-0.055 -5.51329,-3.2158 -6.11831,-4.2742 -6.09007,-10.6567 0.0284,-6.3825 0.64255,-7.4357 6.18412,-10.6025 2.77079,-1.5834 4.46077,-2.3737 6.14743,-2.3663 z" sodipodi:nodetypes="zssssszsccssssssssssccsssssssc" /%3E%3Cpath id="path3" style="fill:url(%23linearGradient10);stroke-width:0.0581876" d="m 878.41691,1413.9426 c 1.49459,-0.033 2.34009,1.1428 2.29362,2.1957 l -0.39169,8.8754 c -0.0465,1.0529 -0.84799,1.9018 -1.90193,1.9018 -1.05394,0 -1.8516,-0.8491 -1.90193,-1.9018 l -0.42433,-8.8754 c -0.0503,-1.0527 0.83167,-2.163 2.32626,-2.1957 z m -0.18948,15.5145 c 1.4715,-0.1102 2.72596,1.0544 2.72522,2.53 0.0257,3.4066 -5.09721,3.4066 -5.07148,0 -6.7e-4,-1.3275 1.02252,-2.4308 2.34626,-2.53 z m 0.26002,-20.9425 c -1.67293,-0.01 -3.35083,1.1046 -7.24038,3.3274 -7.77912,4.4454 -7.24153,3.5234 -7.28121,12.483 -0.0397,8.9596 -0.56935,8.0329 7.17011,12.547 7.73941,4.5142 6.67221,4.5096 14.45131,0.064 7.77911,-4.4455 7.241,-3.5233 7.28069,-12.483 0.0397,-8.9596 0.56933,-8.0328 -7.1701,-12.547 -3.86972,-2.257 -5.53749,-3.384 -7.21042,-3.3915 z m -0.0134,2.8509 v 6e-4 c 1.68666,0.01 3.37009,0.8126 6.12676,2.4205 5.51329,3.2157 6.11834,4.2746 6.09006,10.6572 -0.0283,6.3825 -0.64255,7.4357 -6.18411,10.6025 -5.54155,3.1668 -6.76089,3.161 -12.27419,-0.055 -5.51329,-3.2158 -6.11831,-4.2742 -6.09007,-10.6567 0.0284,-6.3825 0.64255,-7.4357 6.18412,-10.6025 2.77079,-1.5834 4.46077,-2.3737 6.14743,-2.3663 z" sodipodi:nodetypes="zssssszsccssssssssssccsssssssc" /%3E%3C/g%3E%3C/g%3E%3C/svg%3E');
    background-size: 100% 100%;
}
.v3d-webgl-error {
    font-family: Arial;
    font-size: 16px;
}
.v3d-webgl-error-link {
    font-style: italic;
    font-weight: bolder;
}
.v3d-webgl-error-link {
    color: #015fb1;
}
.v3d-device-motion-permissions-dialog {
    z-index: 1;
    position: absolute;
    width: 100%;
    background-color: #f00;
    color: #000;
    text-align: center;
    padding: 10px;
}
`;if(typeof __V3D_DEVTOOLS__<"u"&&__V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:pr}})),typeof window<"u"&&(window.__V3D__?console.warn("WARNING: Multiple instances of Verge3D being imported."):window.__V3D__=pr),typeof document<"u"){const a=document.createElement("style");a.appendChild(document.createTextNode(j5)),document.head.insertBefore(a,document.head.firstChild)}const K5=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:hg,AVERAGE:dv,AddEquation:tn,AddOperation:cg,AdditiveAnimationBlendMode:Oh,AdditiveBlending:os,AgXBlenderToneMapping:Bh,AlphaFormat:Ag,AlwaysDepth:ng,AlwaysStencilFunc:b_,AmbientLight:pp,AmbientLightProbe:KT,AnimationClip:ma,AnimationLoader:UT,AnimationMixer:B1,AnimationObjectGroup:u4,AnimationUtils:DT,Annotation:Av,AnnotationControl:Yp,App:is,AppUtils:To,ArcCurve:e1,ArrayCamera:Xg,ArrowHelper:L4,Audio:L1,AudioAnalyser:t4,AudioContext:mp,AudioListener:JT,AudioLoader:YT,AxesHelper:P4,BackSide:nn,BasicDepthPacking:o_,BasicShadowMap:na,BilinearShadowMap:sr,BlenderTextBufferGeometry:fa,BlenderTextGeometry:fa,BloomPass:Fo,BokehPass:_p,Bone:nu,BooleanKeyframeTrack:er,Box2:_4,Box3:At,Box3Helper:Dc,BoxBufferGeometry:u5,BoxGeometry:ao,BoxHelper:I4,BrightnessContrastPass:Ap,BufferAttribute:Te,BufferGeometry:Pe,BufferGeometryLoader:I1,BufferGeometryUtils:SR,ByteType:fg,CENTER:Xp,CSVParser:bc,Cache:pi,Camera:Os,CameraHelper:T4,CameraUtils:gv,CanvasBreakpointsConstraint:kp,CanvasFitConstraint:Gp,CanvasTexture:Fw,CapsuleBufferGeometry:d5,CapsuleGeometry:Vs,CatmullRomCurve3:t1,ChildOfConstraint:wp,CineonToneMapping:dg,CircleBufferGeometry:h5,CircleGeometry:Gs,ClampToEdgeWrapping:mt,ClearMaskPass:F1,Clock:Di,Color:me,ColorKeyframeTrack:lp,ColorManagement:rn,Compat:z1,CompressedArrayTexture:Ow,CompressedTexture:ys,CompressedTextureLoader:zT,ConeBufferGeometry:p5,ConeGeometry:ks,Constraint:br,ConstraintSpaceCustom:K_,ConstraintSpaceLocal:q_,ConstraintSpaceWorld:j_,CopyLocationConstraint:Tp,CopyRotationConstraint:Ip,CopyScaleConstraint:Rp,CopyTransformsConstraint:Lp,CubeCamera:Ic,CubeCopy:Ts,CubeReflectionMapping:_a,CubeReflectionProbe:pu,CubeRefractionMapping:Aa,CubeTexture:Fs,CubeTextureHelper:Cc,CubeTextureLoader:VT,CubeUVReflectionMapping:xa,CubicBezierCurve:$h,CubicBezierCurve3:n1,CubicInterpolant:y1,CullFaceBack:Nd,CullFaceFront:eg,CullFaceFrontBack:kv,CullFaceNone:$0,Curve:mi,CurvePath:o1,CustomBlending:no,CustomToneMapping:pg,CylinderBufferGeometry:f5,CylinderGeometry:yr,Cylindrical:v4,DampedTrackConstraint:Pp,Data3DTexture:jc,DataArrayTexture:Ns,DataTexture:Jn,DataTexture2DArray:l5,DataTexture3D:c5,DataTextureLoader:C1,DataUtils:D4,DecrementStencilOp:d_,DecrementWrapStencilOp:p_,DefaultLoadingManager:up,DepthFormat:Bo,DepthStencilFormat:mr,DepthTexture:Xh,Detector:Lt,DirectionalLight:uu,DirectionalLightCSMHelper:w4,DirectionalLightHelper:E4,DiscreteInterpolant:ap,DodecahedronBufferGeometry:m5,DodecahedronGeometry:Qs,DoubleSide:Tn,DstAlphaFactor:wh,DstColorFactor:Ih,DynamicCopyUsage:R_,DynamicDrawUsage:S_,DynamicReadUsage:w_,ESMDistancePacking:Tg,ESMShadowMap:Vn,EdgesGeometry:r1,EffectComposer:fh,EllipseCurve:iu,EqualDepth:og,EqualStencilFunc:v_,EquirectangularReflectionMapping:as,EquirectangularRefractionMapping:ss,Euler:gr,EventDispatcher:An,ExtrudeBufferGeometry:g5,ExtrudeGeometry:wa,FXAAPass:Nc,FileLoader:cn,FilmicBlenderToneMapping:Ph,FirstPersonControls:mh,FixOrthoZoomConstraint:Vp,Float16BufferAttribute:wA,Float32BufferAttribute:Ie,Float64BufferAttribute:TA,FloatType:Ct,FloorConstraint:Bp,FlyingControls:gh,Fog:eu,FogExp2:$c,Font:Ep,FramebufferTexture:Nw,FrontSide:kn,Frustum:Kc,GLBufferAttribute:g4,GLSL1:P_,GLSL3:nh,GLTFExporter:jp,GLTFLoader:j1,GTAOMapGenerator:iv,GraphUtils:hT,GrayscalePass:xp,GreaterDepth:ag,GreaterEqualDepth:rg,GreaterEqualStencilFunc:y_,GreaterStencilFunc:A_,GridHelper:S4,Group:Zn,HalfFloatType:_t,HemisphereLight:hp,HemisphereLightHelper:C4,HemisphereLightProbe:jT,IBLEnvironmentNone:k_,IBLEnvironmentPMREM:z_,IBLEnvironmentProbe:G_,IBLEnvironmentProbeCubemap:V_,IcosahedronBufferGeometry:v5,IcosahedronGeometry:Ws,ImageBitmapLoader:R1,ImageLoader:Es,ImageUtils:Gh,ImmediateRenderObject:a5,IncrementStencilOp:u_,IncrementWrapStencilOp:h_,InstancedBufferAttribute:pa,InstancedBufferGeometry:T1,InstancedInterleavedBuffer:m4,InstancedMesh:$g,Int16BufferAttribute:MA,Int32BufferAttribute:EA,Int8BufferAttribute:bA,IntType:gg,InterleavedBuffer:Ma,InterleavedBufferAttribute:io,Interpolant:La,InterpolateDiscrete:Zv,InterpolateLinear:Jv,InterpolateSmooth:$v,InvertStencilOp:f_,KeepStencilOp:l_,KeyframeTrack:di,Keys:Ee,LOD:Jg,LatheBufferGeometry:_5,LatheGeometry:Ea,Layers:ba,LessDepth:ig,LessEqualDepth:Sc,LessEqualStencilFunc:__,LessStencilFunc:g_,Light:zo,LightProbe:ga,LightProbeGenerator:ov,LimitDistanceConstraint:Dp,LimitLocationConstraint:Np,LimitRotationConstraint:Op,LimitScaleConstraint:Fp,Line:Pi,Line3:va,LineBasicMaterial:un,LineCurve:ou,LineCurve3:i1,LineDashedMaterial:g1,LineHTML:vv,LineLoop:Kh,LineSegments:Wn,LinearDepthPacking:r_,LinearEncoding:_n,LinearFilter:Le,LinearInterpolant:au,LinearMipMapLinearFilter:Yv,LinearMipMapNearestFilter:Xv,LinearMipmapLinearFilter:In,LinearMipmapNearestFilter:Bs,LinearSRGBColorSpace:ms,LinearToneMapping:Gc,Loader:pn,LoaderUtils:ti,LoadingManager:cp,LockedTrackConstraint:Up,LogarithmicMaxToneMapping:kc,LoopOnce:jv,LoopPingPong:qv,LoopRepeat:Kv,LuminanceAlphaFormat:bg,LuminanceFormat:yg,MOD_SUITE:Rg,MOUSE:rr,MaskPass:yp,Material:Ut,MaterialLoader:du,MaterialUtils:ph,MathUtils:sA,Matrix3:ln,Matrix4:Ae,MaxEquation:Vd,Mesh:Ue,MeshBVH:hv,MeshBasicMaterial:Xt,MeshDepthMaterial:vr,MeshDistanceMaterial:Hh,MeshLambertMaterial:f1,MeshLine:ai,MeshLineIndexed:bp,MeshLineMaterial:hu,MeshMaskMaterial:rp,MeshMatcapMaterial:m1,MeshNodeMaterial:wt,MeshNormalMaterial:op,MeshPhongMaterial:h1,MeshPhysicalMaterial:lo,MeshStandardMaterial:Zs,MeshToonMaterial:p1,MinEquation:zd,MirroredRepeatWrapping:fr,MixOperation:lg,MotionPathConstraint:Hp,MultiplyBlending:Ud,MultiplyOperation:Ps,NearestFilter:st,NearestMipMapLinearFilter:Hv,NearestMipMapNearestFilter:Wv,NearestMipmapLinearFilter:cr,NearestMipmapNearestFilter:ca,NeverDepth:tg,NeverStencilFunc:m_,NoBlending:En,NoColorSpace:a_,NoOIT:qr,NoToneMapping:ci,NormalAnimationBlendMode:i_,NormalBlending:lr,NotEqualDepth:sg,NotEqualStencilFunc:x_,NumberKeyframeTrack:No,OITWeighted:Y_,Object3D:ze,ObjectLoader:HT,ObjectSpaceNormalMap:Ig,OctahedronBufferGeometry:A5,OctahedronGeometry:Ta,OneFactor:ei,OneMinusDstAlphaFactor:Th,OneMinusDstColorFactor:Rh,OneMinusSrcAlphaFactor:Ri,OneMinusSrcColorFactor:Eh,OrbitControls:Fc,OrthographicCamera:fi,OutlinePass:Ti,PCFShadowMap:Io,PCFShadowMapPoissonDisk:ar,PCFSoftShadowMap:Po,PMREMGenerator:As,Pass:ii,Path:bs,PerspectiveCamera:Qt,PhysicalMaxToneMapping:Qc,Plane:Gn,PlaneBufferGeometry:x5,PlaneGeometry:ni,PlaneHelper:R4,PointLight:lu,PointLightHelper:y4,Points:Zh,PointsMaterial:qh,PolarGridHelper:M4,PolyhedronBufferGeometry:y5,PolyhedronGeometry:so,PositionalAudio:e4,Preloader:Lo,PropertyBinding:$e,PropertyMixer:P1,PuzzlesLoader:_v,QuadraticBezierCurve:ep,QuadraticBezierCurve3:tp,Quaternion:Ge,QuaternionKeyframeTrack:Oo,QuaternionLinearInterpolant:b1,REVISION:pr,RGBADepthPacking:Hc,RGBADistancePacking:Uh,RGBAFormat:Qe,RGBAIntegerFormat:Eg,RGBA_ASTC_10x10_Format:$d,RGBA_ASTC_10x5_Format:qd,RGBA_ASTC_10x6_Format:Zd,RGBA_ASTC_10x8_Format:Jd,RGBA_ASTC_12x10_Format:eh,RGBA_ASTC_12x12_Format:th,RGBA_ASTC_4x4_Format:hs,RGBA_ASTC_5x4_Format:Qd,RGBA_ASTC_5x5_Format:Wd,RGBA_ASTC_6x5_Format:Hd,RGBA_ASTC_6x6_Format:Xd,RGBA_ASTC_8x5_Format:Yd,RGBA_ASTC_8x6_Format:jd,RGBA_ASTC_8x8_Format:Kd,RGBA_BPTC_Format:ps,RGBA_ETC2_EAC_Format:ds,RGBA_PVRTC_2BPPV1_Format:kd,RGBA_PVRTC_4BPPV1_Format:cs,RGBA_S3TC_DXT1_Format:pc,RGBA_S3TC_DXT3_Format:fc,RGBA_S3TC_DXT5_Format:oa,RGBELoader:vh,RGBFormat:xg,RGB_ETC1_Format:Wc,RGB_ETC2_Format:us,RGB_PVRTC_2BPPV1_Format:Gd,RGB_PVRTC_4BPPV1_Format:ls,RGB_S3TC_DXT1_Format:ia,RGFormat:Sg,RGIntegerFormat:Mg,RawShaderMaterial:Ca,Ray:ya,Raycaster:Jc,RectAreaLight:fp,RectAreaLightUniformsLib:W1,RedFormat:Ki,RedIntegerFormat:Cg,ReflectionProbeTypeBox:X_,ReflectionProbeTypeInfinite:W_,ReflectionProbeTypeSphere:H_,ReinhardToneMapping:ug,RenderPass:Oc,RenderUtils:G4,RepeatWrapping:Qn,ReplaceStencilOp:c_,ReverseSubtractEquation:Sh,RingBufferGeometry:b5,RingGeometry:Hs,SAH:bh,SRGBColorSpace:si,SSAARenderPass:ws,SSAOPass:I5,Scene:vn,SceneBackground:me,SceneUtils:DR,ShaderChunk:Me,ShaderLib:De,ShaderMaterial:vt,ShaderPass:oo,ShadowMaterial:d1,Shape:hr,ShapeBufferGeometry:C5,ShapeGeometry:Xs,ShapePath:N1,ShapeUtils:Li,ShortType:mg,SimplePreloader:Vc,Skeleton:zs,SkeletonHelper:x4,SkinnedMesh:xs,Source:nr,Sphere:Rn,SphereBufferGeometry:S5,SphereGeometry:Ia,Spherical:Bi,SphericalHarmonics3:ea,SplineCurve:np,SpotLight:su,SpotLightHelper:A4,Sprite:jh,SpriteMaterial:tu,SrcAlphaFactor:xr,SrcAlphaSaturateFactor:Lh,SrcColorFactor:Mh,StaticCopyUsage:I_,StaticDrawUsage:C_,StaticReadUsage:E_,Stats:la,StereoCamera:qT,StreamCopyUsage:L_,StreamDrawUsage:M_,StreamReadUsage:T_,StringKeyframeTrack:tr,SubtractEquation:Ch,SubtractiveBlending:Fd,TOUCH:Gv,TTFLoader:k1,TangentSpaceNormalMap:Uo,TargetConstraint:xn,TeapotGeometry:u1,TetrahedronBufferGeometry:M5,TetrahedronGeometry:Ys,TextGeometry:Ra,Texture:yt,TextureLoader:dp,ToneMapPass:Cp,ToneMappingLookAgXPunchy:Dh,ToneMappingLookNone:rs,TorusBufferGeometry:E5,TorusGeometry:js,TorusKnotBufferGeometry:w5,TorusKnotGeometry:Ks,TrackToConstraint:zp,Triangle:gn,TriangleFanDrawMode:fs,TriangleStripDrawMode:Fh,TrianglesDrawMode:wg,TubeBufferGeometry:T5,TubeGeometry:qs,TweenCameraController:Js,TweenLinear:wc,TweenSpherical:Q_,TwoPassDoubleSide:Od,UVMapping:Qv,Uint16BufferAttribute:kh,Uint32BufferAttribute:Qh,Uint8BufferAttribute:CA,Uint8ClampedBufferAttribute:SA,Uniform:vp,UniformsGroup:f4,UniformsLib:xe,UniformsUtils:hn,UnsignedByteType:Ft,UnsignedInt248Type:ur,UnsignedIntType:Zi,UnsignedShort4444Type:vg,UnsignedShort5551Type:_g,UnsignedShortType:Nh,V3DL:Ec,Vector2:te,Vector3:b,Vector4:Re,VectorKeyframeTrack:Ar,VideoTexture:Dw,ViewportFitAuto:O_,ViewportFitFill:F_,ViewportFitHorizontal:N_,ViewportFitNone:B_,ViewportFitOverscan:U_,ViewportFitVertical:D_,Visualizer:ZR,WebGL1Renderer:qg,WebGL3DRenderTarget:fA,WebGLArrayRenderTarget:pA,WebGLCubeRenderTarget:Us,WebGLMultipleRenderTargets:rh,WebGLMultisampleRenderTarget:s5,WebGLRenderTarget:et,WebGLRenderer:Yh,WebGLUtils:Hg,WebXRUtils:F5,WireframeGeometry:c1,WrapAroundEnding:n_,XZ:G1,XZLoader:Is,ZeroCurvatureEnding:e_,ZeroFactor:Ls,ZeroSlopeEnding:t_,ZeroStencilOp:s_,_SRGBAFormat:Mc,acceleratedRaycast:pv,arrayMax:Bg,arrayMin:lA,clampArray:Ng,computeBoundsTree:fv,disposeBoundsTree:mv,engineVersionCmp:Og,findModulePath:Yc,getGlobalScope:_s,isDef:q,loadModule:Fg,sRGBEncoding:Ke,shaderFloatStr:Do},Symbol.toStringTag,{value:"Module"})),q5=(a=window.v3d)=>null;async function Kp({containerId:a,fsButtonId:e=null,sceneURL:t}){var c;pi.enabled=!0;const n=null;let i=null;i=q5(K5),await((c=i==null?void 0:i.loadPhysics)==null?void 0:c.call(i));let o={useFullscreen:!0};i&&(o=i.execInitPuzzles({container:a}).initOptions),t=o.useCompAssets?`${t}.xz`:t;const r=tL(a,e,o.useFullscreen),s=Z5(a,o,n),l=eL(a,o,s,n);return l.addEventListener("dispose",()=>r==null?void 0:r()),o.preloaderStartCb&&o.preloaderStartCb(),l.loadScene(t,()=>{l.enableControls(),l.run(),i&&i.init(l,o)},null,()=>{console.log(`Can't load the scene ${t}`)}),{app:l,PL:i}}function Z5(a,e,t){const n=e.useCustomPreloader?J5(e.preloaderProgressCb,e.preloaderEndCb):new Vc({container:a});return t&&$5(n,t),n}function J5(a,e){function t(){Lo.call(this)}return t.prototype=Object.assign(Object.create(Lo.prototype),{onUpdate:function(n){Lo.prototype.onUpdate.call(this,n),a&&a(n)},onFinish:function(){Lo.prototype.onFinish.call(this),e&&e()}}),new t}function $5(a,e){const t=a.onUpdate.bind(a);a.onUpdate=function(i){t(i),e.loadingUpdateCb(i)};const n=a.onFinish.bind(a);a.onFinish=function(){n(),e.loadingFinishCb()}}function eL(a,e,t,n){const i={};e.useBkgTransp&&(i.alpha=!0),e.preserveDrawBuf&&(i.preserveDrawingBuffer=!0);const o=new is(a,i,t);return e.useBkgTransp&&(o.clearBkgOnLoad=!0,o.renderer&&o.renderer.setClearColor(0,0)),o.ExternalInterface={},n&&n.viewportUseAppInstance(o),o}function tL(a,e,t){const n=document.getElementById(a),i=document.getElementById(e);if(!i)return null;if(!t)return i&&(i.style.display="none"),null;const o=()=>document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled,r=()=>document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement,s=h=>(h.requestFullscreen||h.mozRequestFullScreen||h.webkitRequestFullscreen||h.msRequestFullscreen).call(h),l=()=>(document.exitFullscreen||document.mozCancelFullScreen||document.webkitExitFullscreen||document.msExitFullscreen).call(document),c=()=>{const h=r();i.classList.add(h?"fullscreen-close":"fullscreen-open"),i.classList.remove(h?"fullscreen-open":"fullscreen-close")};function d(h){h.stopPropagation(),r()?l():s(n)}return o()&&(i.style.display="inline"),i.addEventListener("click",d),document.addEventListener("webkitfullscreenchange",c),document.addEventListener("mozfullscreenchange",c),document.addEventListener("msfullscreenchange",c),document.addEventListener("fullscreenchange",c),()=>{i.removeEventListener("click",d),document.removeEventListener("webkitfullscreenchange",c),document.removeEventListener("mozfullscreenchange",c),document.removeEventListener("msfullscreenchange",c),document.removeEventListener("fullscreenchange",c)}}let hc;const nL=new Uint8Array(16);function iL(){if(!hc&&(hc=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!hc))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return hc(nL)}const on=[];for(let a=0;a<256;++a)on.push((a+256).toString(16).slice(1));function oL(a,e=0){return on[a[e+0]]+on[a[e+1]]+on[a[e+2]]+on[a[e+3]]+"-"+on[a[e+4]]+on[a[e+5]]+"-"+on[a[e+6]]+on[a[e+7]]+"-"+on[a[e+8]]+on[a[e+9]]+"-"+on[a[e+10]]+on[a[e+11]]+on[a[e+12]]+on[a[e+13]]+on[a[e+14]]+on[a[e+15]]}const rL=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),q0={randomUUID:rL};function qp(a,e,t){if(q0.randomUUID&&!e&&!a)return q0.randomUUID();a=a||{};const n=a.random||(a.rng||iL)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(let i=0;i<16;++i)e[t+i]=n[i];return e}return oL(n)}const aL={name:"Nissan240",created(){this.app=null,this.PL=null,this.uuid=qp(),this.containerId=`v3d-container-${this.uuid}`,this.fsButtonId=`fullscreen-button-${this.uuid}`,this.sceneURL="240SX/240SX.gltf",this.loadApp=async function(){({app:this.app,PL:this.PL}=await Kp({containerId:this.containerId,fsButtonId:this.fsButtonId,sceneURL:this.sceneURL}))},this.disposeApp=function(){var a,e;(a=this.app)==null||a.dispose(),this.app=null,(e=this.PL)==null||e.dispose(),this.PL=null},this.reloadApp=function(){this.disposeApp(),this.loadApp()}},mounted(){this.loadApp()},beforeUnmount(){this.disposeApp()}},sL=["id"],lL=["id"];function cL(a,e,t,n,i,o){return $n(),ui("div",{id:a.containerId},[Rs("div",{id:a.fsButtonId,class:"fullscreen-button fullscreen-open",title:"Toggle fullscreen mode"},null,8,lL)],8,sL)}const uL=ro(aL,[["render",cL]]),dL={name:"NissanSkyline",created(){this.app=null,this.PL=null,this.uuid=qp(),this.containerId=`v3d-container-${this.uuid}`,this.fsButtonId=`fullscreen-button-${this.uuid}`,this.sceneURL="skyline/skyline.gltf",this.loadApp=async function(){({app:this.app,PL:this.PL}=await Kp({containerId:this.containerId,fsButtonId:this.fsButtonId,sceneURL:this.sceneURL}))},this.disposeApp=function(){var a,e;(a=this.app)==null||a.dispose(),this.app=null,(e=this.PL)==null||e.dispose(),this.PL=null},this.reloadApp=function(){this.disposeApp(),this.loadApp()}},mounted(){this.loadApp()},beforeUnmount(){this.disposeApp()}},hL=["id"],pL=["id"];function fL(a,e,t,n,i,o){return $n(),ui("div",{id:a.containerId},[Rs("div",{id:a.fsButtonId,class:"fullscreen-button fullscreen-open",title:"Toggle fullscreen mode"},null,8,pL)],8,hL)}const mL=ro(dL,[["render",fL]]),gL={name:"Nissan370Z",created(){this.app=null,this.PL=null,this.uuid=qp(),this.containerId=`v3d-container-${this.uuid}`,this.fsButtonId=`fullscreen-button-${this.uuid}`,this.sceneURL="370Z/370Z.gltf",this.loadApp=async function(){({app:this.app,PL:this.PL}=await Kp({containerId:this.containerId,fsButtonId:this.fsButtonId,sceneURL:this.sceneURL}))},this.disposeApp=function(){var a,e;(a=this.app)==null||a.dispose(),this.app=null,(e=this.PL)==null||e.dispose(),this.PL=null},this.reloadApp=function(){this.disposeApp(),this.loadApp()}},mounted(){this.loadApp()},beforeUnmount(){this.disposeApp()}},vL=["id"],_L=["id"];function AL(a,e,t,n,i,o){return $n(),ui("div",{id:a.containerId},[Rs("div",{id:a.fsButtonId,class:"fullscreen-button fullscreen-open",title:"Toggle fullscreen mode"},null,8,_L)],8,vL)}const xL=ro(gL,[["render",AL]]),yL={name:"VideoBlock"},bL=a=>(Ov("data-v-b5db726b"),a=a(),Fv(),a),CL={class:"VideoContaiter"},SL=bL(()=>Rs("iframe",{width:"80%",height:"75%",src:"https://www.youtube.com/embed/Gz5YgrbzABI?si=PnpW6XpLHKMQml3U",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:""},null,-1)),ML=[SL];function EL(a,e,t,n,i,o){return $n(),ui("div",CL,ML)}const wL=ro(yL,[["render",EL],["__scopeId","data-v-b5db726b"]]),TL={class:"TextContaiterForVideo"},IL={name:"TextBlockForVideo",data(){return{markdownContent:"# Hello World"}},mounted(){fetch("/VideoText.md").then(a=>a.text()).then(a=>{this.markdownContent=a})}},RL=Object.assign(IL,{setup(a){return(e,t)=>($n(),ui("div",TL,[Rs("div",null,[$i(Z0,{source:e.markdownContent},null,8,["source"])])]))}}),LL=ro(RL,[["__scopeId","data-v-4e542f11"]]),PL={class:"VideoTextContaiter"},BL={name:"VieoTextBlock"},DL=Object.assign(BL,{setup(a){return(e,t)=>($n(),ui("div",PL,[$i(wL),$i(LL)]))}}),NL=ro(DL,[["__scopeId","data-v-ef1cf775"]]),OL={class:"MainTextContaiter"},FL={name:"MainTextBlock",data(){return{markdownContent:"# Hello World"}},mounted(){fetch("/MainText.md").then(a=>a.text()).then(a=>{this.markdownContent=a})}},UL=Object.assign(FL,{setup(a){return(e,t)=>($n(),ui("div",OL,[$i(Z0,{source:e.markdownContent},null,8,["source"])]))}}),zL=ro(UL,[["__scopeId","data-v-df0925a7"]]),VL={__name:"DescriptionBlock",setup(a){const e=Uv(!1),t=()=>{e.value=!e.value},n=()=>{e.value=!1};return(i,o)=>($n(),ui("div",{class:J0(["DescriptionBlock",{expanded:e.value}])},[e.value?($n(),ui("div",{key:1,class:"BottomResizeButton",onClick:n},"Свернуть")):($n(),ui("div",{key:0,class:"TopResizeButton",onClick:t},"Развернуть")),$i(NL),$i(zL)],2))}},GL=ro(VL,[["__scopeId","data-v-6e2fb8bb"]]),kL={data(){return{currentComponent:"Nissan240"}},components:{Nissan240:uL,NissanSkyline:mL,Nissan370Z:xL},methods:{changeComponent(a){this.currentComponent=a}}},QL=Object.assign(kL,{__name:"HomeView",setup(a){return(e,t)=>($n(),ui("div",{class:J0(["HomeView",{expanded:e.isExpanded}])},[$i(Dv,{onComponentChange:e.changeComponent},null,8,["onComponentChange"]),($n(),zv(Vv(e.currentComponent))),$i(GL),$i(Nv)],2))}}),YL=ro(QL,[["__scopeId","data-v-5150c945"]]);export{YL as default};
